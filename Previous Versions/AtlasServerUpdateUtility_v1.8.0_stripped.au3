#Region
#AutoIt3Wrapper_Icon=Resources\phoenix.ico
#AutoIt3Wrapper_Outfile=Builds\AtlasServerUpdateUtility_v1.8.0.exe
#AutoIt3Wrapper_Outfile_x64=Builds\AtlasServerUpdateUtility_v1.8.0_64-bit(x64).exe
#AutoIt3Wrapper_Compile_Both=y
#AutoIt3Wrapper_UseX64=y
#AutoIt3Wrapper_Res_Comment=By Phoenix125 based on Dateranoth's ConanServerUtility v3.3.0-Beta.3
#AutoIt3Wrapper_Res_Description=Atlas Dedicated Server Update Utility
#AutoIt3Wrapper_Res_Fileversion=1.8.0.0
#AutoIt3Wrapper_Res_ProductName=AtlasServerUpdateUtility
#AutoIt3Wrapper_Res_ProductVersion=v1.8.0
#AutoIt3Wrapper_Res_CompanyName=http://www.Phoenix125.com
#AutoIt3Wrapper_Res_LegalCopyright=http://www.Phoenix125.com
#AutoIt3Wrapper_Res_Icon_Add=Resources\phoenixfaded.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\check1.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\no.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\check2.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\refresh.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\pause.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\info.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\forum.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\discord.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\about.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\configuration.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\manual.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\help.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\toggle_on.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\toggle_off.ico
#AutoIt3Wrapper_Res_Icon_Add=Resources\refreshnotice.ico
#AutoIt3Wrapper_Run_AU3Check=n
#AutoIt3Wrapper_AU3Check_Parameters=-d -w 1 -w 2 -w 3 -w 4 -w 5 -w 6
#AutoIt3Wrapper_Run_Tidy=y
#AutoIt3Wrapper_Run_Au3Stripper=y
#Au3Stripper_Parameters=/mo
#EndRegion
Global Const $OPT_COORDSRELATIVE = 0
Global Const $OPT_COORDSABSOLUTE = 1
Global Const $OPT_COORDSCLIENT = 2
Global Const $OPT_ERRORSILENT = 0
Global Const $OPT_ERRORFATAL = 1
Global Const $OPT_CAPSNOSTORE = 0
Global Const $OPT_CAPSSTORE = 1
Global Const $OPT_MATCHSTART = 1
Global Const $OPT_MATCHANY = 2
Global Const $OPT_MATCHEXACT = 3
Global Const $OPT_MATCHADVANCED = 4
Global Const $CCS_TOP = 0x01
Global Const $CCS_NOMOVEY = 0x02
Global Const $CCS_BOTTOM = 0x03
Global Const $CCS_NORESIZE = 0x04
Global Const $CCS_NOPARENTALIGN = 0x08
Global Const $CCS_NOHILITE = 0x10
Global Const $CCS_ADJUSTABLE = 0x20
Global Const $CCS_NODIVIDER = 0x40
Global Const $CCS_VERT = 0x0080
Global Const $CCS_LEFT = 0x0081
Global Const $CCS_NOMOVEX = 0x0082
Global Const $CCS_RIGHT = 0x0083
Global Const $DT_DRIVETYPE = 1
Global Const $DT_SSDSTATUS = 2
Global Const $DT_BUSTYPE = 3
Global Const $PROXY_IE = 0
Global Const $PROXY_NONE = 1
Global Const $PROXY_SPECIFIED = 2
Global Const $OBJID_WINDOW = 0x00000000
Global Const $OBJID_TITLEBAR = 0xFFFFFFFE
Global Const $OBJID_SIZEGRIP = 0xFFFFFFF9
Global Const $OBJID_CARET = 0xFFFFFFF8
Global Const $OBJID_CURSOR = 0xFFFFFFF7
Global Const $OBJID_ALERT = 0xFFFFFFF6
Global Const $OBJID_SOUND = 0xFFFFFFF5
Global Const $DLG_CENTERONTOP = 0
Global Const $DLG_NOTITLE = 1
Global Const $DLG_NOTONTOP = 2
Global Const $DLG_TEXTLEFT = 4
Global Const $DLG_TEXTRIGHT = 8
Global Const $DLG_MOVEABLE = 16
Global Const $DLG_TEXTVCENTER = 32
Global Const $IDC_UNKNOWN = 0
Global Const $IDC_APPSTARTING = 1
Global Const $IDC_ARROW = 2
Global Const $IDC_CROSS = 3
Global Const $IDC_HAND = 32649
Global Const $IDC_HELP = 4
Global Const $IDC_IBEAM = 5
Global Const $IDC_ICON = 6
Global Const $IDC_NO = 7
Global Const $IDC_SIZE = 8
Global Const $IDC_SIZEALL = 9
Global Const $IDC_SIZENESW = 10
Global Const $IDC_SIZENS = 11
Global Const $IDC_SIZENWSE = 12
Global Const $IDC_SIZEWE = 13
Global Const $IDC_UPARROW = 14
Global Const $IDC_WAIT = 15
Global Const $IDI_APPLICATION = 32512
Global Const $IDI_ASTERISK = 32516
Global Const $IDI_EXCLAMATION = 32515
Global Const $IDI_HAND = 32513
Global Const $IDI_QUESTION = 32514
Global Const $IDI_WINLOGO = 32517
Global Const $IDI_SHIELD = 32518
Global Const $IDI_ERROR = $IDI_HAND
Global Const $IDI_INFORMATION = $IDI_ASTERISK
Global Const $IDI_WARNING = $IDI_EXCLAMATION
Global Const $SD_LOGOFF = 0
Global Const $SD_SHUTDOWN = 1
Global Const $SD_REBOOT = 2
Global Const $SD_FORCE = 4
Global Const $SD_POWERDOWN = 8
Global Const $SD_FORCEHUNG = 16
Global Const $SD_STANDBY = 32
Global Const $SD_HIBERNATE = 64
Global Const $STDIN_CHILD = 1
Global Const $STDOUT_CHILD = 2
Global Const $STDERR_CHILD = 4
Global Const $STDERR_MERGED = 8
Global Const $STDIO_INHERIT_PARENT = 0x10
Global Const $RUN_CREATE_NEW_CONSOLE = 0x00010000
Global Const $UBOUND_DIMENSIONS = 0
Global Const $UBOUND_ROWS = 1
Global Const $UBOUND_COLUMNS = 2
Global Const $MOUSEEVENTF_ABSOLUTE = 0x8000
Global Const $MOUSEEVENTF_MOVE = 0x0001
Global Const $MOUSEEVENTF_LEFTDOWN = 0x0002
Global Const $MOUSEEVENTF_LEFTUP = 0x0004
Global Const $MOUSEEVENTF_RIGHTDOWN = 0x0008
Global Const $MOUSEEVENTF_RIGHTUP = 0x0010
Global Const $MOUSEEVENTF_MIDDLEDOWN = 0x0020
Global Const $MOUSEEVENTF_MIDDLEUP = 0x0040
Global Const $MOUSEEVENTF_WHEEL = 0x0800
Global Const $MOUSEEVENTF_XDOWN = 0x0080
Global Const $MOUSEEVENTF_XUP = 0x0100
Global Const $REG_NONE = 0
Global Const $REG_SZ = 1
Global Const $REG_EXPAND_SZ = 2
Global Const $REG_BINARY = 3
Global Const $REG_DWORD = 4
Global Const $REG_DWORD_LITTLE_ENDIAN = 4
Global Const $REG_DWORD_BIG_ENDIAN = 5
Global Const $REG_LINK = 6
Global Const $REG_MULTI_SZ = 7
Global Const $REG_RESOURCE_LIST = 8
Global Const $REG_FULL_RESOURCE_DESCRIPTOR = 9
Global Const $REG_RESOURCE_REQUIREMENTS_LIST = 10
Global Const $REG_QWORD = 11
Global Const $REG_QWORD_LITTLE_ENDIAN = 11
Global Const $HWND_BOTTOM = 1
Global Const $HWND_NOTOPMOST = -2
Global Const $HWND_TOP = 0
Global Const $HWND_TOPMOST = -1
Global Const $SWP_NOSIZE = 0x0001
Global Const $SWP_NOMOVE = 0x0002
Global Const $SWP_NOZORDER = 0x0004
Global Const $SWP_NOREDRAW = 0x0008
Global Const $SWP_NOACTIVATE = 0x0010
Global Const $SWP_FRAMECHANGED = 0x0020
Global Const $SWP_DRAWFRAME = 0x0020
Global Const $SWP_SHOWWINDOW = 0x0040
Global Const $SWP_HIDEWINDOW = 0x0080
Global Const $SWP_NOCOPYBITS = 0x0100
Global Const $SWP_NOOWNERZORDER = 0x0200
Global Const $SWP_NOREPOSITION = 0x0200
Global Const $SWP_NOSENDCHANGING = 0x0400
Global Const $SWP_DEFERERASE = 0x2000
Global Const $SWP_ASYNCWINDOWPOS = 0x4000
Global Const $KEYWORD_DEFAULT = 1
Global Const $KEYWORD_NULL = 2
Global Const $DECLARED_LOCAL = -1
Global Const $DECLARED_UNKNOWN = 0
Global Const $DECLARED_GLOBAL = 1
Global Const $ASSIGN_CREATE = 0
Global Const $ASSIGN_FORCELOCAL = 1
Global Const $ASSIGN_FORCEGLOBAL = 2
Global Const $ASSIGN_EXISTFAIL = 4
Global Const $BI_ENABLE = 0
Global Const $BI_DISABLE = 1
Global Const $BREAK_ENABLE = 1
Global Const $BREAK_DISABLE = 0
Global Const $CDTRAY_OPEN = "open"
Global Const $CDTRAY_CLOSED = "closed"
Global Const $SEND_DEFAULT = 0
Global Const $SEND_RAW = 1
Global Const $DIR_DEFAULT = 0
Global Const $DIR_EXTENDED= 1
Global Const $DIR_NORECURSE = 2
Global Const $DIR_REMOVE= 1
Global Const $DT_ALL = "ALL"
Global Const $DT_CDROM = "CDROM"
Global Const $DT_REMOVABLE = "REMOVABLE"
Global Const $DT_FIXED = "FIXED"
Global Const $DT_NETWORK = "NETWORK"
Global Const $DT_RAMDISK = "RAMDISK"
Global Const $DT_UNKNOWN = "UNKNOWN"
Global Const $DT_UNDEFINED = 1
Global Const $DT_FAT = "FAT"
Global Const $DT_FAT32 = "FAT32"
Global Const $DT_EXFAT = "exFAT"
Global Const $DT_NTFS = "NTFS"
Global Const $DT_NWFS = "NWFS"
Global Const $DT_CDFS = "CDFS"
Global Const $DT_UDF = "UDF"
Global Const $DMA_DEFAULT = 0
Global Const $DMA_PERSISTENT = 1
Global Const $DMA_AUTHENTICATION = 8
Global Const $DS_UNKNOWN = "UNKNOWN"
Global Const $DS_READY = "READY"
Global Const $DS_NOTREADY = "NOTREADY"
Global Const $DS_INVALID = "INVALID"
Global Const $MOUSE_CLICK_LEFT = "left"
Global Const $MOUSE_CLICK_RIGHT = "right"
Global Const $MOUSE_CLICK_MIDDLE = "middle"
Global Const $MOUSE_CLICK_MAIN = "main"
Global Const $MOUSE_CLICK_MENU = "menu"
Global Const $MOUSE_CLICK_PRIMARY = "primary"
Global Const $MOUSE_CLICK_SECONDARY = "secondary"
Global Const $MOUSE_WHEEL_UP = "up"
Global Const $MOUSE_WHEEL_DOWN = "down"
Global Const $NUMBER_AUTO = 0
Global Const $NUMBER_32BIT = 1
Global Const $NUMBER_64BIT = 2
Global Const $NUMBER_DOUBLE = 3
Global Const $OBJ_NAME = 1
Global Const $OBJ_STRING = 2
Global Const $OBJ_PROGID = 3
Global Const $OBJ_FILE = 4
Global Const $OBJ_MODULE = 5
Global Const $OBJ_CLSID = 6
Global Const $OBJ_IID = 7
Global Const $EXITCLOSE_NORMAL = 0
Global Const $EXITCLOSE_BYEXIT = 1
Global Const $EXITCLOSE_BYCLICK = 2
Global Const $EXITCLOSE_BYLOGOFF = 3
Global Const $EXITCLOSE_BYSHUTDOWN = 4
Global Const $PROCESS_STATS_MEMORY = 0
Global Const $PROCESS_STATS_IO = 1
Global Const $PROCESS_LOW = 0
Global Const $PROCESS_BELOWNORMAL = 1
Global Const $PROCESS_NORMAL = 2
Global Const $PROCESS_ABOVENORMAL = 3
Global Const $PROCESS_HIGH = 4
Global Const $PROCESS_REALTIME = 5
Global Const $RUN_LOGON_NOPROFILE = 0
Global Const $RUN_LOGON_PROFILE = 1
Global Const $RUN_LOGON_NETWORK = 2
Global Const $RUN_LOGON_INHERIT = 4
Global Const $SOUND_NOWAIT = 0
Global Const $SOUND_WAIT = 1
Global Const $SHEX_OPEN = "open"
Global Const $SHEX_EDIT = "edit"
Global Const $SHEX_PRINT = "print"
Global Const $SHEX_PROPERTIES = "properties"
Global Const $TCP_DATA_DEFAULT = 0
Global Const $TCP_DATA_BINARY = 1
Global Const $UDP_OPEN_DEFAULT = 0
Global Const $UDP_OPEN_BROADCAST = 1
Global Const $UDP_DATA_DEFAULT = 0
Global Const $UDP_DATA_BINARY = 1
Global Const $UDP_DATA_ARRAY = 2
Global Const $TIP_NOICON = 0
Global Const $TIP_INFOICON = 1
Global Const $TIP_WARNINGICON = 2
Global Const $TIP_ERRORICON = 3
Global Const $TIP_BALLOON = 1
Global Const $TIP_CENTER = 2
Global Const $TIP_FORCEVISIBLE = 4
Global Const $WINDOWS_NOONTOP = 0
Global Const $WINDOWS_ONTOP = 1
Global Const $WIN_STATE_EXISTS = 1
Global Const $WIN_STATE_VISIBLE  = 2
Global Const $WIN_STATE_ENABLED = 4
Global Const $WIN_STATE_ACTIVE = 8
Global Const $WIN_STATE_MINIMIZED = 16
Global Const $WIN_STATE_MAXIMIZED = 32
Global Const $MB_OK = 0
Global Const $MB_OKCANCEL = 1
Global Const $MB_ABORTRETRYIGNORE = 2
Global Const $MB_YESNOCANCEL = 3
Global Const $MB_YESNO = 4
Global Const $MB_RETRYCANCEL = 5
Global Const $MB_CANCELTRYCONTINUE = 6
Global Const $MB_HELP = 0x4000
Global Const $MB_ICONSTOP = 16
Global Const $MB_ICONERROR = 16
Global Const $MB_ICONHAND = 16
Global Const $MB_ICONQUESTION = 32
Global Const $MB_ICONEXCLAMATION = 48
Global Const $MB_ICONWARNING = 48
Global Const $MB_ICONINFORMATION = 64
Global Const $MB_ICONASTERISK = 64
Global Const $MB_USERICON = 0x00000080
Global Const $MB_DEFBUTTON1 = 0
Global Const $MB_DEFBUTTON2 = 256
Global Const $MB_DEFBUTTON3 = 512
Global Const $MB_DEFBUTTON4 = 768
Global Const $MB_APPLMODAL = 0
Global Const $MB_SYSTEMMODAL = 4096
Global Const $MB_TASKMODAL = 8192
Global Const $MB_DEFAULT_DESKTOP_ONLY = 0x00020000
Global Const $MB_RIGHT = 0x00080000
Global Const $MB_RTLREADING = 0x00100000
Global Const $MB_SETFOREGROUND = 0x00010000
Global Const $MB_TOPMOST = 0x00040000
Global Const $MB_SERVICE_NOTIFICATION = 0x00200000
Global Const $MB_RIGHTJUSTIFIED = $MB_RIGHT
Global Const $IDTIMEOUT = -1
Global Const $IDOK = 1
Global Const $IDCANCEL = 2
Global Const $IDABORT = 3
Global Const $IDRETRY = 4
Global Const $IDIGNORE = 5
Global Const $IDYES = 6
Global Const $IDNO = 7
Global Const $IDCLOSE = 8
Global Const $IDHELP = 9
Global Const $IDTRYAGAIN = 10
Global Const $IDCONTINUE = 11
Global Const $STR_NOCASESENSE = 0
Global Const $STR_CASESENSE = 1
Global Const $STR_NOCASESENSEBASIC = 2
Global Const $STR_STRIPLEADING = 1
Global Const $STR_STRIPTRAILING = 2
Global Const $STR_STRIPSPACES = 4
Global Const $STR_STRIPALL = 8
Global Const $STR_CHRSPLIT = 0
Global Const $STR_ENTIRESPLIT = 1
Global Const $STR_NOCOUNT = 2
Global Const $STR_REGEXPMATCH = 0
Global Const $STR_REGEXPARRAYMATCH = 1
Global Const $STR_REGEXPARRAYFULLMATCH = 2
Global Const $STR_REGEXPARRAYGLOBALMATCH = 3
Global Const $STR_REGEXPARRAYGLOBALFULLMATCH = 4
Global Const $STR_ENDISSTART = 0
Global Const $STR_ENDNOTSTART = 1
Global Const $SB_ANSI = 1
Global Const $SB_UTF16LE = 2
Global Const $SB_UTF16BE = 3
Global Const $SB_UTF8 = 4
Global Const $SE_UTF16 = 0
Global Const $SE_ANSI = 1
Global Const $SE_UTF8 = 2
Global Const $STR_UTF16 = 0
Global Const $STR_UCS2 = 1
#Region Global Variables and Constants
Global Const $_ARRAYCONSTANT_SORTINFOSIZE = 11
Global $__g_aArrayDisplay_SortInfo[$_ARRAYCONSTANT_SORTINFOSIZE]
Global Const $ARRAYDISPLAY_COLALIGNLEFT = 0
Global Const $ARRAYDISPLAY_TRANSPOSE = 1
Global Const $ARRAYDISPLAY_COLALIGNRIGHT = 2
Global Const $ARRAYDISPLAY_COLALIGNCENTER = 4
Global Const $ARRAYDISPLAY_VERBOSE = 8
Global Const $ARRAYDISPLAY_NOROW = 64
Global Const $_ARRAYCONSTANT_tagHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $_ARRAYCONSTANT_tagLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" &  "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Func __ArrayDisplay_Share(Const ByRef $aArray, $sTitle = Default, $sArrayRange = Default, $iFlags = Default, $vUser_Separator = Default, $sHeader = Default, $iMax_ColWidth = Default, $hUser_Function = Default, $bDebug = True)
Local $vTmp, $sMsgBoxTitle = (($bDebug) ? ("DebugArray") : ("ArrayDisplay"))
If $sTitle = Default Then $sTitle = $sMsgBoxTitle
If $sArrayRange = Default Then $sArrayRange = ""
If $iFlags = Default Then $iFlags = 0
If $vUser_Separator = Default Then $vUser_Separator = ""
If $sHeader = Default Then $sHeader = ""
If $iMax_ColWidth = Default Then $iMax_ColWidth = 350
If $hUser_Function = Default Then $hUser_Function = 0
Local $iTranspose = BitAND($iFlags, $ARRAYDISPLAY_TRANSPOSE)
Local $iColAlign = BitAND($iFlags, 6)
Local $iVerbose = BitAND($iFlags, $ARRAYDISPLAY_VERBOSE)
Local $iNoRow = BitAND($iFlags, $ARRAYDISPLAY_NOROW)
Local $iButtonBorder = (($bDebug) ? (40) : (20))
Local $sMsg = "", $iRet = 1
If IsArray($aArray) Then
Local $iDimension = UBound($aArray, $UBOUND_DIMENSIONS), $iRowCount = UBound($aArray, $UBOUND_ROWS), $iColCount = UBound($aArray, $UBOUND_COLUMNS)
If $iDimension > 2 Then
$sMsg = "Larger than 2D array passed to function"
$iRet = 2
EndIf
If $iDimension = 1 Then
$iTranspose = 0
EndIf
Else
$sMsg = "No array variable passed to function"
EndIf
If $sMsg Then
If $iVerbose And MsgBox($MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO,  $sMsgBoxTitle & " Error: " & $sTitle, $sMsg & @CRLF & @CRLF & "Exit the script?") = $IDYES Then
Exit
Else
Return SetError($iRet, 0, 0)
EndIf
EndIf
Local $iCW_ColWidth = Number($vUser_Separator)
Local $sCurr_Separator = Opt("GUIDataSeparatorChar")
If $vUser_Separator = "" Then $vUser_Separator = $sCurr_Separator
Local $iItem_Start = 0, $iItem_End = $iRowCount - 1, $iSubItem_Start = 0, $iSubItem_End = (($iDimension = 2) ? ($iColCount - 1) : (0))
Local $bRange_Flag = False, $avRangeSplit
If $sArrayRange Then
Local $aArray_Range = StringRegExp($sArrayRange & "||", "(?U)(.*)\|", 3)
If $aArray_Range[0] Then
$avRangeSplit = StringSplit($aArray_Range[0], ":")
If @error Then
$iItem_End = Number($avRangeSplit[1])
Else
$iItem_Start = Number($avRangeSplit[1])
If $avRangeSplit[2] <> "" Then
$iItem_End = Number($avRangeSplit[2])
EndIf
EndIf
EndIf
If $iItem_Start < 0 Then $iItem_Start = 0
If $iItem_End > $iRowCount - 1 Then $iItem_End = $iRowCount - 1
If $iItem_Start > $iItem_End Then
$vTmp = $iItem_Start
$iItem_Start = $iItem_End
$iItem_End = $vTmp
EndIf
If $iItem_Start <> 0 Or $iItem_End <> $iRowCount - 1 Then $bRange_Flag = True
If $iDimension = 2 And $aArray_Range[1] Then
$avRangeSplit = StringSplit($aArray_Range[1], ":")
If @error Then
$iSubItem_End = Number($avRangeSplit[1])
Else
$iSubItem_Start = Number($avRangeSplit[1])
If $avRangeSplit[2] <> "" Then
$iSubItem_End = Number($avRangeSplit[2])
EndIf
EndIf
If $iSubItem_Start > $iSubItem_End Then
$vTmp = $iSubItem_Start
$iSubItem_Start = $iSubItem_End
$iSubItem_End = $vTmp
EndIf
If $iSubItem_Start < 0 Then $iSubItem_Start = 0
If $iSubItem_End > $iColCount - 1 Then $iSubItem_End = $iColCount - 1
If $iSubItem_Start <> 0 Or $iSubItem_End <> $iColCount - 1 Then $bRange_Flag = True
EndIf
EndIf
Local $sDisplayData = "[" & $iRowCount & "]"
If $iDimension = 2 Then
$sDisplayData &= " [" & $iColCount & "]"
EndIf
Local $sTipData = ""
If $bRange_Flag Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Range set"
EndIf
If $iTranspose Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Transposed"
EndIf
Local $asHeader = StringSplit($sHeader, $sCurr_Separator, $STR_NOCOUNT)
If UBound($asHeader) = 0 Then Local $asHeader[1] = [""]
$sHeader = "Row"
Local $iIndex = $iSubItem_Start
If $iTranspose Then
$sHeader = "Col"
For $j = $iItem_Start To $iItem_End
$sHeader &= $sCurr_Separator & "Row " & $j
Next
Else
If $asHeader[0] Then
For $iIndex = $iSubItem_Start To $iSubItem_End
If $iIndex >= UBound($asHeader) Then ExitLoop
$sHeader &= $sCurr_Separator & $asHeader[$iIndex]
Next
EndIf
For $j = $iIndex To $iSubItem_End
$sHeader &= $sCurr_Separator & "Col " & $j
Next
EndIf
If $iNoRow Then $sHeader = StringTrimLeft($sHeader, 4)
If $iVerbose And ($iItem_End - $iItem_Start + 1) * ($iSubItem_End - $iSubItem_Start + 1) > 10000 Then
SplashTextOn($sMsgBoxTitle, "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local Const $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 64
Local Const $_ARRAYCONSTANT_GUI_DOCKBORDERS = 102
Local Const $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 512
Local Const $_ARRAYCONSTANT_GUI_DOCKLEFT = 2
Local Const $_ARRAYCONSTANT_GUI_DOCKRIGHT = 4
Local Const $_ARRAYCONSTANT_GUI_DOCKHCENTER = 8
Local Const $_ARRAYCONSTANT_GUI_EVENT_CLOSE = -3
Local Const $_ARRAYCONSTANT_GUI_FOCUS = 256
Local Const $_ARRAYCONSTANT_SS_CENTER = 0x1
Local Const $_ARRAYCONSTANT_SS_CENTERIMAGE = 0x0200
Local Const $_ARRAYCONSTANT_LVM_GETITEMCOUNT = (0x1000 + 4)
Local Const $_ARRAYCONSTANT_LVM_GETITEMRECT = (0x1000 + 14)
Local Const $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH = (0x1000 + 29)
Local Const $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH = (0x1000 + 30)
Local Const $_ARRAYCONSTANT_LVM_GETITEMSTATE = (0x1000 + 44)
Local Const $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT = (0x1000 + 50)
Local Const $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000 + 54)
Local Const $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 0x1
Local Const $_ARRAYCONSTANT_LVIS_SELECTED = 0x0002
Local Const $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 0x8
Local Const $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 0x20
Local Const $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 0x0200
Local Const $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 0x00010000
Local Const $_ARRAYCONSTANT_WS_MINIMIZEBOX = 0x00020000
Local Const $_ARRAYCONSTANT_WS_SIZEBOX = 0x00040000
Local Const $_ARRAYCONSTANT_WM_SETREDRAW = 11
Local Const $_ARRAYCONSTANT_LVSCW_AUTOSIZE = -1
Local Const $_ARRAYCONSTANT_LVSCW_AUTOSIZE_USEHEADER = -2
Local $iCoordMode = Opt("GUICoordMode", 1)
Local $iOrgWidth = 210, $iHeight = 200, $iMinSize = 250
Local $hGUI = GUICreate($sTitle, $iOrgWidth, $iHeight, Default, Default, BitOR($_ARRAYCONSTANT_WS_SIZEBOX, $_ARRAYCONSTANT_WS_MINIMIZEBOX, $_ARRAYCONSTANT_WS_MAXIMIZEBOX))
Local $aiGUISize = WinGetClientSize($hGUI)
Local $iButtonWidth_1 = $aiGUISize[0] / 2
Local $iButtonWidth_2 = $aiGUISize[0] / 3
Local $idListView = GUICtrlCreateListView($sHeader, 0, 0, $aiGUISize[0], $aiGUISize[1] - $iButtonBorder, $_ARRAYCONSTANT_LVS_SHOWSELALWAYS)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_GRIDLINES, $_ARRAYCONSTANT_LVS_EX_GRIDLINES)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
Local $idCopy_ID = 9999, $idCopy_Data = 99999, $idData_Label = 99999, $idUser_Func = 99999, $idExit_Script = 99999
If $bDebug Then
$idCopy_ID = GUICtrlCreateButton("Copy Data && Hdr/Row", 0, $aiGUISize[1] - $iButtonBorder, $iButtonWidth_1, 20)
$idCopy_Data = GUICtrlCreateButton("Copy Data Only", $iButtonWidth_1, $aiGUISize[1] - $iButtonBorder, $iButtonWidth_1, 20)
Local $iButtonWidth_Var = $iButtonWidth_1
Local $iOffset = $iButtonWidth_1
If IsFunc($hUser_Function) Then
$idUser_Func = GUICtrlCreateButton("Run User Func", $iButtonWidth_2, $aiGUISize[1] - 20, $iButtonWidth_2, 20)
$iButtonWidth_Var = $iButtonWidth_2
$iOffset = $iButtonWidth_2 * 2
EndIf
$idExit_Script = GUICtrlCreateButton("Exit Script", $iOffset, $aiGUISize[1] - 20, $iButtonWidth_Var, 20)
$idData_Label = GUICtrlCreateLabel($sDisplayData, 0, $aiGUISize[1] - 20, $iButtonWidth_Var, 18, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
Else
$idData_Label = GUICtrlCreateLabel($sDisplayData, 0, $aiGUISize[1] - 20, $aiGUISize[0], 18, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
EndIf
Select
Case $iTranspose Or $bRange_Flag
GUICtrlSetColor($idData_Label, 0xFF0000)
GUICtrlSetTip($idData_Label, $sTipData)
EndSelect
GUICtrlSetResizing($idListView, $_ARRAYCONSTANT_GUI_DOCKBORDERS)
GUICtrlSetResizing($idCopy_ID, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idCopy_Data, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idData_Label, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idUser_Func, $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idExit_Script, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_WM_SETREDRAW, 0, 0)
Local $iRowIndex, $iColFill
If $iTranspose Then
For $i = $iSubItem_Start To $iSubItem_End
$iRowIndex = __ArrayDisplay_AddItem($idListView, "NULL")
If $iNoRow Then
$iColFill = 0
Else
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, "Col " & $i, 0)
$iColFill = 1
EndIf
For $j = $iItem_Start To $iItem_End
If $iDimension = 2 Then
$vTmp = $aArray[$j][$i]
Else
$vTmp = $aArray[$j]
EndIf
Switch VarGetType($vTmp)
Case "Array"
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, "{Array}", $iColFill)
Case Else
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, $vTmp, $iColFill)
EndSwitch
$iColFill += 1
Next
Next
Else
For $i = $iItem_Start To $iItem_End
$iRowIndex = __ArrayDisplay_AddItem($idListView, "NULL")
If $iNoRow Then
$iColFill = 0
Else
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, "Row " & $i, 0)
$iColFill = 1
EndIf
For $j = $iSubItem_Start To $iSubItem_End
If $iDimension = 2 Then
$vTmp = $aArray[$i][$j]
Else
$vTmp = $aArray[$i]
EndIf
Switch VarGetType($vTmp)
Case "Array"
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, "{Array}", $iColFill)
Case Else
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, $vTmp, $iColFill)
EndSwitch
$iColFill += 1
Next
Next
EndIf
If $iColAlign Then
For $i = 0 To $iColFill - 1
__ArrayDisplay_JustifyColumn($idListView, $i, $iColAlign / 2)
Next
EndIf
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_WM_SETREDRAW, 1, 0)
Local $iBorder = (($iRowIndex > 19) ? (65) : (45))
Local $iWidth = $iBorder, $iColWidth = 0, $aiColWidth[$iColFill], $iMin_ColWidth = 55
For $i = 0 To UBound($aiColWidth) - 1
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $_ARRAYCONSTANT_LVSCW_AUTOSIZE)
$iColWidth = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH, $i, 0)
If $sHeader <> "" Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $_ARRAYCONSTANT_LVSCW_AUTOSIZE_USEHEADER)
Local $iColWidthHeader = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH, $i, 0)
If $iColWidth < $iMin_ColWidth And $iColWidthHeader < $iMin_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMin_ColWidth)
$iColWidth = $iMin_ColWidth
ElseIf $iColWidthHeader < $iColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iColWidth)
Else
$iColWidth = $iColWidthHeader
EndIf
Else
If $iColWidth < $iMin_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMin_ColWidth)
$iColWidth = $iMin_ColWidth
EndIf
EndIf
$iWidth += $iColWidth
$aiColWidth[$i] = $iColWidth
Next
If $iWidth > @DesktopWidth - 100 Then
$iWidth = $iBorder
For $i = 0 To UBound($aiColWidth) - 1
If $aiColWidth[$i] > $iMax_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMax_ColWidth)
$iWidth += $iMax_ColWidth
Else
$iWidth += $aiColWidth[$i]
EndIf
Next
EndIf
If $iWidth > @DesktopWidth - 100 Then
$iWidth = @DesktopWidth - 100
ElseIf $iWidth < $iMinSize Then
$iWidth = $iMinSize
EndIf
Local $tRECT = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", GUICtrlGetHandle($idListView), "uint", $_ARRAYCONSTANT_LVM_GETITEMRECT, "wparam", 0, "struct*", $tRECT)
Local $aiWin_Pos = WinGetPos($hGUI)
Local $aiLV_Pos = ControlGetPos($hGUI, "", $idListView)
$iHeight = (($iRowIndex + 4) * (DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))) + $aiWin_Pos[3] - $aiLV_Pos[3]
If $iHeight > @DesktopHeight - 100 Then
$iHeight = @DesktopHeight - 100
ElseIf $iHeight < $iMinSize Then
$iHeight = $iMinSize
EndIf
If $iVerbose Then SplashOff()
GUISetState(@SW_HIDE, $hGUI)
WinMove($hGUI, "", (@DesktopWidth - $iWidth) / 2, (@DesktopHeight - $iHeight) / 2, $iWidth, $iHeight)
GUISetState(@SW_SHOW, $hGUI)
Local $iOnEventMode = Opt("GUIOnEventMode", 0), $iMsg
__ArrayDisplay_RegisterSortCallBack($idListView, 2, True, "__ArrayDisplay_SortCallBack")
While 1
$iMsg = GUIGetMsg()
Switch $iMsg
Case $_ARRAYCONSTANT_GUI_EVENT_CLOSE
ExitLoop
Case $idCopy_ID, $idCopy_Data
Local $iSel_Count = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT, 0, 0)
If $iVerbose And (Not $iSel_Count) And ($iItem_End - $iItem_Start) * ($iSubItem_End - $iSubItem_Start) > 10000 Then
SplashTextOn($sMsgBoxTitle, "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local $sClip = "", $sItem, $aSplit
For $i = 0 To GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMCOUNT, 0, 0) - 1
If $iSel_Count And Not (GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) Then
ContinueLoop
EndIf
$sItem = __ArrayDisplay_GetItemTextString($idListView, $i)
If $iMsg = $idCopy_ID And $iNoRow Then
$sItem = "Row " & ($i + (($iTranspose) ? ($iSubItem_Start) : ($iItem_Start))) & $sCurr_Separator & $sItem
EndIf
If $iMsg = $idCopy_Data And Not $iNoRow Then
$sItem = StringRegExpReplace($sItem, "^Row\s\d+\|(.*)$", "$1")
EndIf
If $iCW_ColWidth Then
$aSplit = StringSplit($sItem, $sCurr_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sItem, $sCurr_Separator, $vUser_Separator)
EndIf
$sClip &= $sItem & @CRLF
Next
$sItem = $sHeader
If $iMsg = $idCopy_ID Then
$sItem = $sHeader
If $iNoRow Then
$sItem = "Row|" & $sItem
EndIf
If $iCW_ColWidth Then
$aSplit = StringSplit($sItem, $sCurr_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sItem, $sCurr_Separator, $vUser_Separator)
EndIf
$sClip = $sItem & @CRLF & $sClip
EndIf
ClipPut($sClip)
SplashOff()
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idListView
__ArrayDisplay_SortItems($idListView, GUICtrlGetState($idListView))
Case $idUser_Func
Local $aiSelItems[1] = [0]
For $i = 0 To GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMCOUNT, 0, 0) - 1
If (GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) Then
$aiSelItems[0] += 1
ReDim $aiSelItems[$aiSelItems[0] + 1]
$aiSelItems[$aiSelItems[0]] = $i + $iItem_Start
EndIf
Next
$hUser_Function($aArray, $aiSelItems)
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idExit_Script
GUIDelete($hGUI)
Exit
EndSwitch
WEnd
GUIDelete($hGUI)
Opt("GUICoordMode", $iCoordMode)
Opt("GUIOnEventMode", $iOnEventMode)
Return 1
EndFunc
Func __ArrayDisplay_RegisterSortCallBack($hWnd, $vCompareType = 2, $bArrows = True, $sSort_Callback = "__ArrayDisplay_SortCallBack")
#Au3Stripper_Ignore_Funcs=$sSort_Callback
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $hHeader =  HWnd(GUICtrlSendMsg($hWnd, 0x101F, 0, 0))
$__g_aArrayDisplay_SortInfo[1] = $hWnd
$__g_aArrayDisplay_SortInfo[2] = DllCallbackRegister($sSort_Callback, "int", "int;int;hwnd")
$__g_aArrayDisplay_SortInfo[3] = -1
$__g_aArrayDisplay_SortInfo[4] = -1
$__g_aArrayDisplay_SortInfo[5] = 1
$__g_aArrayDisplay_SortInfo[6] = -1
$__g_aArrayDisplay_SortInfo[7] = 0
$__g_aArrayDisplay_SortInfo[8] = $vCompareType
$__g_aArrayDisplay_SortInfo[9] = $bArrows
$__g_aArrayDisplay_SortInfo[10] = $hHeader
Return $__g_aArrayDisplay_SortInfo[2] <> 0
EndFunc
#Au3Stripper_Ignore_Funcs=__ArrayDisplay_SortCallBack
Func __ArrayDisplay_SortCallBack($nItem1, $nItem2, $hWnd)
If $__g_aArrayDisplay_SortInfo[3] = $__g_aArrayDisplay_SortInfo[4] Then
If Not $__g_aArrayDisplay_SortInfo[7] Then
$__g_aArrayDisplay_SortInfo[5] *= -1
$__g_aArrayDisplay_SortInfo[7] = 1
EndIf
Else
$__g_aArrayDisplay_SortInfo[7] = 1
EndIf
$__g_aArrayDisplay_SortInfo[6] = $__g_aArrayDisplay_SortInfo[3]
Local $sVal1 = __ArrayDisplay_GetItemText($hWnd, $nItem1, $__g_aArrayDisplay_SortInfo[3])
Local $sVal2 = __ArrayDisplay_GetItemText($hWnd, $nItem2, $__g_aArrayDisplay_SortInfo[3])
If $__g_aArrayDisplay_SortInfo[8] = 1 Then
If (StringIsFloat($sVal1) Or StringIsInt($sVal1)) Then $sVal1 = Number($sVal1)
If (StringIsFloat($sVal2) Or StringIsInt($sVal2)) Then $sVal2 = Number($sVal2)
EndIf
Local $nResult
If $__g_aArrayDisplay_SortInfo[8] < 2 Then
$nResult = 0
If $sVal1 < $sVal2 Then
$nResult = -1
ElseIf $sVal1 > $sVal2 Then
$nResult = 1
EndIf
Else
$nResult = DllCall('shlwapi.dll', 'int', 'StrCmpLogicalW', 'wstr', $sVal1, 'wstr', $sVal2)[0]
EndIf
$nResult = $nResult * $__g_aArrayDisplay_SortInfo[5]
Return $nResult
EndFunc
Func __ArrayDisplay_SortItems($hWnd, $iCol)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $pFunction = DllCallbackGetPtr($__g_aArrayDisplay_SortInfo[2])
$__g_aArrayDisplay_SortInfo[3] = $iCol
$__g_aArrayDisplay_SortInfo[7] = 0
$__g_aArrayDisplay_SortInfo[4] = $__g_aArrayDisplay_SortInfo[6]
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x1051, "hwnd", $hWnd, "ptr", $pFunction)
If $aResult[0] <> 0 Then
If $__g_aArrayDisplay_SortInfo[9] Then
Local $hHeader = $__g_aArrayDisplay_SortInfo[10], $iFormat
For $x = 0 To __ArrayDisplay_GetItemCount($hHeader) - 1
$iFormat = __ArrayDisplay_GetItemFormat($hHeader, $x)
If BitAND($iFormat, 0x00000200) Then
__ArrayDisplay_SetItemFormat($hHeader, $x, BitXOR($iFormat, 0x00000200))
ElseIf BitAND($iFormat, 0x00000400) Then
__ArrayDisplay_SetItemFormat($hHeader, $x, BitXOR($iFormat, 0x00000400))
EndIf
Next
$iFormat = __ArrayDisplay_GetItemFormat($hHeader, $iCol)
If $__g_aArrayDisplay_SortInfo[5] = 1 Then
__ArrayDisplay_SetItemFormat($hHeader, $iCol, BitOR($iFormat, 0x00000400))
Else
__ArrayDisplay_SetItemFormat($hHeader, $iCol, BitOR($iFormat, 0x00000200))
EndIf
EndIf
Return True
EndIf
Return False
EndFunc
Func __ArrayDisplay_AddItem($hWnd, $sText)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagLVITEM)
DllStructSetData($tItem, "Param", 0)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iMask = 0x00000005
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", 999999999)
DllStructSetData($tItem, "Image", -1)
Local $pItem = DllStructGetPtr($tItem)
Local $iRet = GUICtrlSendMsg($hWnd, 0x104D, 0, $pItem)
Return $iRet
EndFunc
Func __ArrayDisplay_AddSubItem($hWnd, $iIndex, $sText, $iSubItem)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagLVITEM)
Local $iMask = 0x00000001
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", -1)
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
Local $iRet = GUICtrlSendMsg($hWnd, 0x104C, 0, $pItem)
Return $iRet <> 0
EndFunc
Func __ArrayDisplay_GetColumnCount($hWnd)
Local $hHeader = HWnd(GUICtrlSendMsg($hWnd, 0x101F, 0, 0))
Return __ArrayDisplay_GetItemCount($hHeader)
EndFunc
Func __ArrayDisplay_GetHeader($hWnd)
Return HWnd(GUICtrlSendMsg($hWnd, 0x101F, 0, 0))
EndFunc
Func __ArrayDisplay_GetItem($hWnd, $iIndex, ByRef $tItem)
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x120B, "wparam", $iIndex, "struct*", $tItem)
Return $aResult[0] <> 0
EndFunc
Func __ArrayDisplay_GetItemCount($hWnd)
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x1200, "wparam", 0, "lparam", 0)
Return $aResult[0]
EndFunc
Func __ArrayDisplay_GetItemFormat($hWnd, $iIndex)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagHDITEM)
DllStructSetData($tItem, "Mask", 0x00000004)
__ArrayDisplay_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Fmt")
EndFunc
Func __ArrayDisplay_GetItemText($hWnd, $iIndex, $iSubItem = 0)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagLVITEM)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "TextMax", 4096)
DllStructSetData($tItem, "Text", $pBuffer)
If IsHWnd($hWnd) Then
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x1073, "wparam", $iIndex, "struct*", $tItem)
Else
Local $pItem = DllStructGetPtr($tItem)
GUICtrlSendMsg($hWnd, 0x1073, $iIndex, $pItem)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func __ArrayDisplay_GetItemTextString($hWnd, $iItem)
Local $sRow = "", $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local $iSelected = $iItem
For $x = 0 To __ArrayDisplay_GetColumnCount($hWnd) - 1
$sRow &= __ArrayDisplay_GetItemText($hWnd, $iSelected, $x) & $sSeparatorChar
Next
Return StringTrimRight($sRow, 1)
EndFunc
Func __ArrayDisplay_JustifyColumn($idListView, $iIndex, $iAlign = -1)
Local $tColumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
DllStructSetData($tColumn, "Mask", 0x01)
DllStructSetData($tColumn, "Fmt", $iAlign)
Local $pColumn = DllStructGetPtr($tColumn)
Local $iRet = GUICtrlSendMsg($idListView, 0x1060 , $iIndex, $pColumn)
Return $iRet <> 0
EndFunc
Func __ArrayDisplay_SetItemFormat($hWnd, $iIndex, $iFormat)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagHDITEM)
DllStructSetData($tItem, "Mask", 0x00000004)
DllStructSetData($tItem, "Fmt", $iFormat)
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x120C, "wparam", $iIndex, "struct*", $tItem)
Return $aResult[0] <> 0
EndFunc
Global Enum $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER,  $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING, $ARRAYFILL_FORCE_BOOLEAN
Global Enum $ARRAYUNIQUE_NOCOUNT, $ARRAYUNIQUE_COUNT
Global Enum $ARRAYUNIQUE_AUTO, $ARRAYUNIQUE_FORCE32, $ARRAYUNIQUE_FORCE64, $ARRAYUNIQUE_MATCH, $ARRAYUNIQUE_DISTINCT
Func _ArrayAdd(ByRef $aArray, $vValue, $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
Case $ARRAYFILL_FORCE_BOOLEAN
$hDataType = "Boolean"
EndSwitch
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + 1]
$aArray[$iDim_1] = $vValue
Return $iDim_1
EndIf
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
EndIf
$vValue = $aTmp
EndIf
Local $iAdd = UBound($vValue, $UBOUND_ROWS)
ReDim $aArray[$iDim_1 + $iAdd]
For $i = 0 To $iAdd - 1
If String($hDataType) = "Boolean" Then
Switch $vValue[$i]
Case "True", "1"
$aArray[$iDim_1 + $i] = True
Case "False", "0", ""
$aArray[$iDim_1 + $i] = False
EndSwitch
ElseIf IsFunc($hDataType) Then
$aArray[$iDim_1 + $i] = $hDataType($vValue[$i])
Else
$aArray[$iDim_1 + $i] = $vValue[$i]
EndIf
Next
Return $iDim_1 + $iAdd - 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(4, 0, -1)
Local $iValDim_1, $iValDim_2 = 0, $iColCount
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(5, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
Local $aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
Local $aTmp[$iValDim_1][0], $aSplit_2
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iColCount = UBound($aSplit_2)
If $iColCount > $iValDim_2 Then
$iValDim_2 = $iColCount
ReDim $aTmp[$iValDim_1][$iValDim_2]
EndIf
For $j = 0 To $iColCount - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1 + $iValDim_1][$iDim_2]
For $iWriteTo_Index = 0 To $iValDim_1 - 1
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
Else
If String($hDataType) = "Boolean" Then
Switch $vValue[$iWriteTo_Index][$j - $iStart]
Case "True", "1"
$aArray[$iWriteTo_Index + $iDim_1][$j] = True
Case "False", "0", ""
$aArray[$iWriteTo_Index + $iDim_1][$j] = False
EndSwitch
ElseIf IsFunc($hDataType) Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = $hDataType($vValue[$iWriteTo_Index][$j - $iStart])
Else
$aArray[$iWriteTo_Index + $iDim_1][$j] = $vValue[$iWriteTo_Index][$j - $iStart]
EndIf
EndIf
Next
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS) - 1
EndFunc
Func _ArrayBinarySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iColumn = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iColumn = Default Then $iColumn = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iDim_1 = 0 Then Return SetError(6, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_1 - 1 Then $iEnd = $iDim_1 - 1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Local $iMid = Int(($iEnd + $iStart) / 2)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $aArray[$iStart] > $vValue Or $aArray[$iEnd] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid]
If $vValue < $aArray[$iMid] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(7, 0, -1)
If $aArray[$iStart][$iColumn] > $vValue Or $aArray[$iEnd][$iColumn] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid][$iColumn]
If $vValue < $aArray[$iMid][$iColumn] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case Else
Return SetError(5, 0, -1)
EndSwitch
Return $iMid
EndFunc
Func _ArrayColDelete(ByRef $aArray, $iColumn, $bConvert = False)
If $bConvert = Default Then $bConvert = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(2, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
Switch $iDim_2
Case 2
If $iColumn < 0 Or $iColumn > 1 Then Return SetError(3, 0, -1)
If $bConvert Then
Local $aTempArray[$iDim_1]
For $i = 0 To $iDim_1 - 1
$aTempArray[$i] = $aArray[$i][(Not $iColumn)]
Next
$aArray = $aTempArray
Else
ContinueCase
EndIf
Case Else
If $iColumn < 0 Or $iColumn > $iDim_2 - 1 Then Return SetError(3, 0, -1)
For $i = 0 To $iDim_1 - 1
For $j = $iColumn To $iDim_2 - 2
$aArray[$i][$j] = $aArray[$i][$j + 1]
Next
Next
ReDim $aArray[$iDim_1][$iDim_2 - 1]
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayColInsert(ByRef $aArray, $iColumn)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aTempArray[$iDim_1][2]
Switch $iColumn
Case 0, 1
For $i = 0 To $iDim_1 - 1
$aTempArray[$i][(Not $iColumn)] = $aArray[$i]
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
$aArray = $aTempArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1][$iDim_2 + 1]
For $i = 0 To $iDim_1 - 1
For $j = $iDim_2 To $iColumn + 1 Step -1
$aArray[$i][$j] = $aArray[$i][$j - 1]
Next
$aArray[$i][$iColumn] = ""
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayCombinations(Const ByRef $aArray, $iSet, $sDelimiter = "")
If $sDelimiter = Default Then $sDelimiter = ""
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, 0)
Local $iN = UBound($aArray)
Local $iR = $iSet
Local $aIdx[$iR]
For $i = 0 To $iR - 1
$aIdx[$i] = $i
Next
Local $iTotal = __Array_Combinations($iN, $iR)
Local $iLeft = $iTotal
Local $aResult[$iTotal + 1]
$aResult[0] = $iTotal
Local $iCount = 1
While $iLeft > 0
__Array_GetNext($iN, $iR, $iLeft, $iTotal, $aIdx)
For $i = 0 To $iSet - 1
$aResult[$iCount] &= $aArray[$aIdx[$i]] & $sDelimiter
Next
If $sDelimiter <> "" Then $aResult[$iCount] = StringTrimRight($aResult[$iCount], 1)
$iCount += 1
WEnd
Return $aResult
EndFunc
Func _ArrayConcatenate(ByRef $aArrayTarget, Const ByRef $aArraySource, $iStart = 0)
If $iStart = Default Then $iStart = 0
If Not IsArray($aArrayTarget) Then Return SetError(1, 0, -1)
If Not IsArray($aArraySource) Then Return SetError(2, 0, -1)
Local $iDim_Total_Tgt = UBound($aArrayTarget, $UBOUND_DIMENSIONS)
Local $iDim_Total_Src = UBound($aArraySource, $UBOUND_DIMENSIONS)
Local $iDim_1_Tgt = UBound($aArrayTarget, $UBOUND_ROWS)
Local $iDim_1_Src = UBound($aArraySource, $UBOUND_ROWS)
If $iStart < 0 Or $iStart > $iDim_1_Src - 1 Then Return SetError(6, 0, -1)
Switch $iDim_Total_Tgt
Case 1
If $iDim_Total_Src <> 1 Then Return SetError(4, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart]
For $i = $iStart To $iDim_1_Src - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart] = $aArraySource[$i]
Next
Case 2
If $iDim_Total_Src <> 2 Then Return SetError(4, 0, -1)
Local $iDim_2_Tgt = UBound($aArrayTarget, $UBOUND_COLUMNS)
If UBound($aArraySource, $UBOUND_COLUMNS) <> $iDim_2_Tgt Then Return SetError(5, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart][$iDim_2_Tgt]
For $i = $iStart To $iDim_1_Src - 1
For $j = 0 To $iDim_2_Tgt - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart][$j] = $aArraySource[$i][$j]
Next
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
Return UBound($aArrayTarget, $UBOUND_ROWS)
EndFunc
Func _ArrayDelete(ByRef $aArray, $vRange)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber, $aSplit_1, $aSplit_2
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
Local $iCopyTo_Index = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
$aArray[$iCopyTo_Index] = $aArray[$iReadFrom_Index]
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1]
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]][0] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index][0] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
For $j = 0 To $iDim_2
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFrom_Index][$j]
Next
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1][$iDim_2 + 1]
Case Else
Return SetError(2, 0, False)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayDisplay(Const ByRef $aArray, $sTitle = Default, $sArrayRange = Default, $iFlags = Default, $vUser_Separator = Default, $sHeader = Default, $iMax_ColWidth = Default)
#forceref $vUser_Separator
Local $iRet = __ArrayDisplay_Share($aArray, $sTitle, $sArrayRange, $iFlags, Default, $sHeader, $iMax_ColWidth, 0, False)
Return SetError(@error, @extended, $iRet)
EndFunc
Func _ArrayExtract(Const ByRef $aArray, $iStart_Row = -1, $iEnd_Row = -1, $iStart_Col = -1, $iEnd_Col = -1)
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
For $i = 0 To $iEnd_Row - $iStart_Row
$aRetArray[$i] = $aArray[$i + $iStart_Row]
Next
Return $aRetArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col = -1 Then $iStart_Col = 0
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
If $iStart_Col = $iEnd_Col Then
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
Else
Local $aRetArray[$iEnd_Row - $iStart_Row + 1][$iEnd_Col - $iStart_Col + 1]
EndIf
For $i = 0 To $iEnd_Row - $iStart_Row
For $j = 0 To $iEnd_Col - $iStart_Col
If $iStart_Col = $iEnd_Col Then
$aRetArray[$i] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
Else
$aRetArray[$i][$j] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
EndIf
Next
Next
Return $aRetArray
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayFindAll(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iSubItem = 0, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iSubItem = Default Then $iSubItem = 0
If $bRow = Default Then $bRow = False
$iStart = _ArraySearch($aArray, $vValue, $iStart, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
If @error Then Return SetError(@error, 0, -1)
Local $iIndex = 0, $avResult[UBound($aArray, ($bRow ? $UBOUND_COLUMNS : $UBOUND_ROWS))]
Do
$avResult[$iIndex] = $iStart
$iIndex += 1
$iStart = _ArraySearch($aArray, $vValue, $iStart + 1, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
Until @error
ReDim $avResult[$iIndex]
Return $avResult
EndFunc
Func _ArrayInsert(ByRef $aArray, $vRange, $vValue = "", $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $vValue = Default Then $vValue = ""
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
EndSwitch
Local $aSplit_1, $aSplit_2
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
For $i = 2 To $vRange[0]
If $vRange[$i] < $vRange[$i - 1] Then Return SetError(3, 0, -1)
Next
Local $iCopyTo_Index = $iDim_1 + $vRange[0]
Local $iInsertPoint_Index = $vRange[0]
Local $iInsert_Index = $vRange[$iInsertPoint_Index]
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + $vRange[0] + 1]
For $iReadFromIndex = $iDim_1 To 0 Step -1
$aArray[$iCopyTo_Index] = $aArray[$iReadFromIndex]
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
$aArray[$iCopyTo_Index] = $vValue
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index < 1 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Return $iDim_1 + $vRange[0] + 1
EndIf
ReDim $aArray[$iDim_1 + $vRange[0] + 1]
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
$hDataType = 0
EndIf
$vValue = $aTmp
EndIf
For $iReadFromIndex = $iDim_1 To 0 Step -1
$aArray[$iCopyTo_Index] = $aArray[$iReadFromIndex]
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
If $iInsertPoint_Index <= UBound($vValue, $UBOUND_ROWS) Then
If IsFunc($hDataType) Then
$aArray[$iCopyTo_Index] = $hDataType($vValue[$iInsertPoint_Index - 1])
Else
$aArray[$iCopyTo_Index] = $vValue[$iInsertPoint_Index - 1]
EndIf
Else
$aArray[$iCopyTo_Index] = ""
EndIf
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index = 0 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(6, 0, -1)
Local $iValDim_1, $iValDim_2
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(7, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
$aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
StringReplace($aSplit_1[0], $sDelim_Item, "")
$iValDim_2 = @extended + 1
Local $aTmp[$iValDim_1][$iValDim_2]
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
For $j = 0 To $iValDim_2 - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(8, 0, -1)
ReDim $aArray[$iDim_1 + $vRange[0] + 1][$iDim_2]
For $iReadFromIndex = $iDim_1 To 0 Step -1
For $j = 0 To $iDim_2 - 1
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFromIndex][$j]
Next
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iCopyTo_Index][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iCopyTo_Index][$j] = ""
Else
If $iInsertPoint_Index - 1 < $iValDim_1 Then
If IsFunc($hDataType) Then
$aArray[$iCopyTo_Index][$j] = $hDataType($vValue[$iInsertPoint_Index - 1][$j - $iStart])
Else
$aArray[$iCopyTo_Index][$j] = $vValue[$iInsertPoint_Index - 1][$j - $iStart]
EndIf
Else
$aArray[$iCopyTo_Index][$j] = ""
EndIf
EndIf
Next
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index = 0 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayMax(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMaxIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_GreaterThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayMin(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMinIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMinIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_LessThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayPermute(ByRef $aArray, $sDelimiter = "")
If $sDelimiter = Default Then $sDelimiter = ""
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, 0)
Local $iSize = UBound($aArray), $iFactorial = 1, $aIdx[$iSize], $aResult[1], $iCount = 1
If UBound($aArray) Then
For $i = 0 To $iSize - 1
$aIdx[$i] = $i
Next
For $i = $iSize To 1 Step -1
$iFactorial *= $i
Next
ReDim $aResult[$iFactorial + 1]
$aResult[0] = $iFactorial
__Array_ExeterInternal($aArray, 0, $iSize, $sDelimiter, $aIdx, $aResult, $iCount)
Else
$aResult[0] = 0
EndIf
Return $aResult
EndFunc
Func _ArrayPop(ByRef $aArray)
If (Not IsArray($aArray)) Then Return SetError(1, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, "")
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(3, 0, "")
Local $sLastVal = $aArray[$iUBound]
If $iUBound > -1 Then
ReDim $aArray[$iUBound]
EndIf
Return $sLastVal
EndFunc
Func _ArrayPush(ByRef $aArray, $vValue, $iDirection = 0)
If $iDirection = Default Then $iDirection = 0
If (Not IsArray($aArray)) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
Local $iUBound = UBound($aArray) - 1
If IsArray($vValue) Then
Local $iUBoundS = UBound($vValue)
If ($iUBoundS - 1) > $iUBound Then Return SetError(2, 0, 0)
If $iDirection Then
For $i = $iUBound To $iUBoundS Step -1
$aArray[$i] = $aArray[$i - $iUBoundS]
Next
For $i = 0 To $iUBoundS - 1
$aArray[$i] = $vValue[$i]
Next
Else
For $i = 0 To $iUBound - $iUBoundS
$aArray[$i] = $aArray[$i + $iUBoundS]
Next
For $i = 0 To $iUBoundS - 1
$aArray[$i + $iUBound - $iUBoundS + 1] = $vValue[$i]
Next
EndIf
Else
If $iUBound > -1 Then
If $iDirection Then
For $i = $iUBound To 1 Step -1
$aArray[$i] = $aArray[$i - 1]
Next
$aArray[0] = $vValue
Else
For $i = 0 To $iUBound - 1
$aArray[$i] = $aArray[$i + 1]
Next
$aArray[$iUBound] = $vValue
EndIf
EndIf
EndIf
Return 1
EndFunc
Func _ArrayReverse(ByRef $aArray, $iStart = 0, $iEnd = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
If Not UBound($aArray) Then Return SetError(4, 0, 0)
Local $vTmp, $iUBound = UBound($aArray) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
For $i = $iStart To Int(($iStart + $iEnd - 1) / 2)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iEnd]
$aArray[$iEnd] = $vTmp
$iEnd -= 1
Next
Return 1
EndFunc
Func _ArraySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iForward = 1, $iSubItem = -1, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iForward = Default Then $iForward = 1
If $iSubItem = Default Then $iSubItem = -1
If $bRow = Default Then $bRow = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray) - 1
If $iDim_1 = -1 Then Return SetError(3, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
Local $bCompType = False
If $iCompare = 2 Then
$iCompare = 0
$bCompType = True
EndIf
If $bRow Then
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then Return SetError(5, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_2 Then $iEnd = $iDim_2
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Else
If $iEnd < 1 Or $iEnd > $iDim_1 Then $iEnd = $iDim_1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
EndIf
Local $iStep = 1
If Not $iForward Then
Local $iTmp = $iStart
$iStart = $iEnd
$iEnd = $iTmp
$iStep = -1
EndIf
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] = $vValue Then Return $i
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] == $vValue Then Return $i
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If StringRegExp($aArray[$i], $vValue) Then Return $i
Else
If StringInStr($aArray[$i], $vValue, $iCase) > 0 Then Return $i
EndIf
Next
EndIf
Case 2
Local $iDim_Sub
If $bRow Then
$iDim_Sub = $iDim_1
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
Else
$iDim_Sub = $iDim_2
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
EndIf
For $j = $iSubItem To $iDim_Sub
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] = $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] = $vValue Then Return $i
EndIf
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] == $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] == $vValue Then Return $i
EndIf
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If $bRow Then
If StringRegExp($aArray[$j][$i], $vValue) Then Return $i
Else
If StringRegExp($aArray[$i][$j], $vValue) Then Return $i
EndIf
Else
If $bRow Then
If StringInStr($aArray[$j][$i], $vValue, $iCase) > 0 Then Return $i
Else
If StringInStr($aArray[$i][$j], $vValue, $iCase) > 0 Then Return $i
EndIf
EndIf
Next
EndIf
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return SetError(6, 0, -1)
EndFunc
Func _ArrayShuffle(ByRef $aArray, $iStart_Row = 0, $iEnd_Row = 0, $iCol = -1)
If $iStart_Row = Default Then $iStart_Row = 0
If $iEnd_Row = Default Then $iEnd_Row = 0
If $iCol = Default Then $iCol = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iEnd_Row = 0 Then $iEnd_Row = $iDim_1 - 1
If $iStart_Row < 0 Or $iStart_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iEnd_Row < 1 Or $iEnd_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $vTmp, $iRand
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iRand]
$aArray[$iRand] = $vTmp
Next
Return 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iCol < -1 Or $iCol > $iDim_2 - 1 Then Return SetError(5, 0, -1)
Local $iCol_Start, $iCol_End
If $iCol = -1 Then
$iCol_Start = 0
$iCol_End = $iDim_2 - 1
Else
$iCol_Start = $iCol
$iCol_End = $iCol
EndIf
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
For $j = $iCol_Start To $iCol_End
$vTmp = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$iRand][$j]
$aArray[$iRand][$j] = $vTmp
Next
Next
Return 1
Case Else
Return SetError(2, 0, -1)
EndSwitch
EndFunc
Func _ArraySort(ByRef $aArray, $iDescending = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0, $iPivot = 0)
If $iDescending = Default Then $iDescending = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If $iPivot = Default Then $iPivot = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(5, 0, 0)
If $iEnd = Default Then $iEnd = 0
If $iEnd < 1 Or $iEnd > $iUBound Or $iEnd = Default Then $iEnd = $iUBound
If $iStart < 0 Or $iStart = Default Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iPivot Then
__ArrayDualPivotSort($aArray, $iStart, $iEnd)
Else
__ArrayQuickSort1D($aArray, $iStart, $iEnd)
EndIf
If $iDescending Then _ArrayReverse($aArray, $iStart, $iEnd)
Case 2
If $iPivot Then Return SetError(6, 0, 0)
Local $iSubMax = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem > $iSubMax Then Return SetError(3, 0, 0)
If $iDescending Then
$iDescending = -1
Else
$iDescending = 1
EndIf
__ArrayQuickSort2D($aArray, $iDescending, $iStart, $iEnd, $iSubItem, $iSubMax)
Case Else
Return SetError(4, 0, 0)
EndSwitch
Return 1
EndFunc
Func __ArrayQuickSort1D(ByRef $aArray, Const ByRef $iStart, Const ByRef $iEnd)
If $iEnd <= $iStart Then Return
Local $vTmp
If ($iEnd - $iStart) < 15 Then
Local $vCur
For $i = $iStart + 1 To $iEnd
$vTmp = $aArray[$i]
If IsNumber($vTmp) Then
For $j = $i - 1 To $iStart Step -1
$vCur = $aArray[$j]
If ($vTmp >= $vCur And IsNumber($vCur)) Or (Not IsNumber($vCur) And StringCompare($vTmp, $vCur) >= 0) Then ExitLoop
$aArray[$j + 1] = $vCur
Next
Else
For $j = $i - 1 To $iStart Step -1
If (StringCompare($vTmp, $aArray[$j]) >= 0) Then ExitLoop
$aArray[$j + 1] = $aArray[$j]
Next
EndIf
$aArray[$j + 1] = $vTmp
Next
Return
EndIf
Local $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While ($aArray[$L] < $vPivot And IsNumber($aArray[$L])) Or (Not IsNumber($aArray[$L]) And StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While ($aArray[$R] > $vPivot And IsNumber($aArray[$R])) Or (Not IsNumber($aArray[$R]) And StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
Else
While (StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While (StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
$vTmp = $aArray[$L]
$aArray[$L] = $aArray[$R]
$aArray[$R] = $vTmp
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort1D($aArray, $iStart, $R)
__ArrayQuickSort1D($aArray, $L, $iEnd)
EndFunc
Func __ArrayQuickSort2D(ByRef $aArray, Const ByRef $iStep, Const ByRef $iStart, Const ByRef $iEnd, Const ByRef $iSubItem, Const ByRef $iSubMax)
If $iEnd <= $iStart Then Return
Local $vTmp, $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)][$iSubItem], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While ($iStep * ($aArray[$L][$iSubItem] - $vPivot) < 0 And IsNumber($aArray[$L][$iSubItem])) Or (Not IsNumber($aArray[$L][$iSubItem]) And $iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While ($iStep * ($aArray[$R][$iSubItem] - $vPivot) > 0 And IsNumber($aArray[$R][$iSubItem])) Or (Not IsNumber($aArray[$R][$iSubItem]) And $iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
Else
While ($iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While ($iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
For $i = 0 To $iSubMax
$vTmp = $aArray[$L][$i]
$aArray[$L][$i] = $aArray[$R][$i]
$aArray[$R][$i] = $vTmp
Next
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort2D($aArray, $iStep, $iStart, $R, $iSubItem, $iSubMax)
__ArrayQuickSort2D($aArray, $iStep, $L, $iEnd, $iSubItem, $iSubMax)
EndFunc
Func __ArrayDualPivotSort(ByRef $aArray, $iPivot_Left, $iPivot_Right, $bLeftMost = True)
If $iPivot_Left > $iPivot_Right Then Return
Local $iLength = $iPivot_Right - $iPivot_Left + 1
Local $i, $j, $k, $iAi, $iAk, $iA1, $iA2, $iLast
If $iLength < 45 Then
If $bLeftMost Then
$i = $iPivot_Left
While $i < $iPivot_Right
$j = $i
$iAi = $aArray[$i + 1]
While $iAi < $aArray[$j]
$aArray[$j + 1] = $aArray[$j]
$j -= 1
If $j + 1 = $iPivot_Left Then ExitLoop
WEnd
$aArray[$j + 1] = $iAi
$i += 1
WEnd
Else
While 1
If $iPivot_Left >= $iPivot_Right Then Return 1
$iPivot_Left += 1
If $aArray[$iPivot_Left] < $aArray[$iPivot_Left - 1] Then ExitLoop
WEnd
While 1
$k = $iPivot_Left
$iPivot_Left += 1
If $iPivot_Left > $iPivot_Right Then ExitLoop
$iA1 = $aArray[$k]
$iA2 = $aArray[$iPivot_Left]
If $iA1 < $iA2 Then
$iA2 = $iA1
$iA1 = $aArray[$iPivot_Left]
EndIf
$k -= 1
While $iA1 < $aArray[$k]
$aArray[$k + 2] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 2] = $iA1
While $iA2 < $aArray[$k]
$aArray[$k + 1] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 1] = $iA2
$iPivot_Left += 1
WEnd
$iLast = $aArray[$iPivot_Right]
$iPivot_Right -= 1
While $iLast < $aArray[$iPivot_Right]
$aArray[$iPivot_Right + 1] = $aArray[$iPivot_Right]
$iPivot_Right -= 1
WEnd
$aArray[$iPivot_Right + 1] = $iLast
EndIf
Return 1
EndIf
Local $iSeventh = BitShift($iLength, 3) + BitShift($iLength, 6) + 1
Local $iE1, $iE2, $iE3, $iE4, $iE5, $t
$iE3 = Ceiling(($iPivot_Left + $iPivot_Right) / 2)
$iE2 = $iE3 - $iSeventh
$iE1 = $iE2 - $iSeventh
$iE4 = $iE3 + $iSeventh
$iE5 = $iE4 + $iSeventh
If $aArray[$iE2] < $aArray[$iE1] Then
$t = $aArray[$iE2]
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
If $aArray[$iE3] < $aArray[$iE2] Then
$t = $aArray[$iE3]
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
If $aArray[$iE4] < $aArray[$iE3] Then
$t = $aArray[$iE4]
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
If $aArray[$iE5] < $aArray[$iE4] Then
$t = $aArray[$iE5]
$aArray[$iE5] = $aArray[$iE4]
$aArray[$iE4] = $t
If $t < $aArray[$iE3] Then
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
EndIf
Local $iLess = $iPivot_Left
Local $iGreater = $iPivot_Right
If (($aArray[$iE1] <> $aArray[$iE2]) And ($aArray[$iE2] <> $aArray[$iE3]) And ($aArray[$iE3] <> $aArray[$iE4]) And ($aArray[$iE4] <> $aArray[$iE5])) Then
Local $iPivot_1 = $aArray[$iE2]
Local $iPivot_2 = $aArray[$iE4]
$aArray[$iE2] = $aArray[$iPivot_Left]
$aArray[$iE4] = $aArray[$iPivot_Right]
Do
$iLess += 1
Until $aArray[$iLess] >= $iPivot_1
Do
$iGreater -= 1
Until $aArray[$iGreater] <= $iPivot_2
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk > $iPivot_2 Then
While $aArray[$iGreater] > $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
$aArray[$iPivot_Left] = $aArray[$iLess - 1]
$aArray[$iLess - 1] = $iPivot_1
$aArray[$iPivot_Right] = $aArray[$iGreater + 1]
$aArray[$iGreater + 1] = $iPivot_2
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 2, True)
__ArrayDualPivotSort($aArray, $iGreater + 2, $iPivot_Right, False)
If ($iLess < $iE1) And ($iE5 < $iGreater) Then
While $aArray[$iLess] = $iPivot_1
$iLess += 1
WEnd
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
WEnd
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk = $iPivot_2 Then
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iPivot_1
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
EndIf
__ArrayDualPivotSort($aArray, $iLess, $iGreater, False)
Else
Local $iPivot = $aArray[$iE3]
$k = $iLess
While $k <= $iGreater
If $aArray[$k] = $iPivot Then
$k += 1
ContinueLoop
EndIf
$iAk = $aArray[$k]
If $iAk < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
Else
While $aArray[$iGreater] > $iPivot
$iGreater -= 1
WEnd
If $aArray[$iGreater] < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $iPivot
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 1, True)
__ArrayDualPivotSort($aArray, $iGreater + 1, $iPivot_Right, False)
EndIf
EndFunc
Func _ArraySwap(ByRef $aArray, $iIndex_1, $iIndex_2, $bCol = False, $iStart = -1, $iEnd = -1)
If $bCol = Default Then $bCol = False
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iDim_2 = -1 Then
$bCol = False
$iStart = -1
$iEnd = -1
EndIf
If $iStart > $iEnd Then Return SetError(5, 0, -1)
If $bCol Then
If $iIndex_1 < 0 Or $iIndex_2 > $iDim_2 Then Return SetError(3, 0, -1)
If $iStart = -1 Then $iStart = 0
If $iEnd = -1 Then $iEnd = $iDim_1
Else
If $iIndex_1 < 0 Or $iIndex_2 > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart = -1 Then $iStart = 0
If $iEnd = -1 Then $iEnd = $iDim_2
EndIf
Local $vTmp
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
$vTmp = $aArray[$iIndex_1]
$aArray[$iIndex_1] = $aArray[$iIndex_2]
$aArray[$iIndex_2] = $vTmp
Case 2
If $iStart < -1 Or $iEnd < -1 Then Return SetError(4, 0, -1)
If $bCol Then
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(4, 0, -1)
For $j = $iStart To $iEnd
$vTmp = $aArray[$j][$iIndex_1]
$aArray[$j][$iIndex_1] = $aArray[$j][$iIndex_2]
$aArray[$j][$iIndex_2] = $vTmp
Next
Else
If $iStart > $iDim_2 Or $iEnd > $iDim_2 Then Return SetError(4, 0, -1)
For $j = $iStart To $iEnd
$vTmp = $aArray[$iIndex_1][$j]
$aArray[$iIndex_1][$j] = $aArray[$iIndex_2][$j]
$aArray[$iIndex_2][$j] = $vTmp
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayToClip(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
Local $sResult = _ArrayToString($aArray, $sDelim_Col, $iStart_Row, $iEnd_Row, $sDelim_Row, $iStart_Col, $iEnd_Col)
If @error Then Return SetError(@error, 0, 0)
If ClipPut($sResult) Then Return 1
Return SetError(-1, 0, 0)
EndFunc
Func _ArrayToString(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
If $sDelim_Col = Default Then $sDelim_Col = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, "")
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $sRet = ""
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iStart_Row To $iEnd_Row
$sRet &= $aArray[$i] & $sDelim_Col
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iStart_Col = -1 Then $iStart_Col = 0
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
For $i = $iStart_Row To $iEnd_Row
For $j = $iStart_Col To $iEnd_Col
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, StringLen($sDelim_Col)) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayTranspose(ByRef $aArray)
Switch UBound($aArray, 0)
Case 0
Return SetError(2, 0, 0)
Case 1
Local $aTemp[1][UBound($aArray)]
For $i = 0 To UBound($aArray) - 1
$aTemp[0][$i] = $aArray[$i]
Next
$aArray = $aTemp
Case 2
Local $iDim_1 = UBound($aArray, 1), $iDim_2 = UBound($aArray, 2)
If $iDim_1 <> $iDim_2 Then
Local $aTemp[$iDim_2][$iDim_1]
For $i = 0 To $iDim_1 - 1
For $j = 0 To $iDim_2 - 1
$aTemp[$j][$i] = $aArray[$i][$j]
Next
Next
$aArray = $aTemp
Else
Local $vElement
For $i = 0 To $iDim_1 - 1
For $j = $i + 1 To $iDim_2 - 1
$vElement = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$j][$i]
$aArray[$j][$i] = $vElement
Next
Next
EndIf
Case Else
Return SetError(1, 0, 0)
EndSwitch
Return 1
EndFunc
Func _ArrayTrim(ByRef $aArray, $iTrimNum, $iDirection = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0)
If $iDirection = Default Then $iDirection = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd = 0 Then $iEnd = $iDim_1
If $iStart > $iEnd Then Return SetError(3, 0, -1)
If $iStart < 0 Or $iEnd < 0 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iDirection Then
For $i = $iStart To $iEnd
$aArray[$i] = StringTrimRight($aArray[$i], $iTrimNum)
Next
Else
For $i = $iStart To $iEnd
$aArray[$i] = StringTrimLeft($aArray[$i], $iTrimNum)
Next
EndIf
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem < 0 Or $iSubItem > $iDim_2 Then Return SetError(5, 0, -1)
If $iDirection Then
For $i = $iStart To $iEnd
$aArray[$i][$iSubItem] = StringTrimRight($aArray[$i][$iSubItem], $iTrimNum)
Next
Else
For $i = $iStart To $iEnd
$aArray[$i][$iSubItem] = StringTrimLeft($aArray[$i][$iSubItem], $iTrimNum)
Next
EndIf
Case Else
Return SetError(2, 0, 0)
EndSwitch
Return 1
EndFunc
Func _ArrayUnique(Const ByRef $aArray, $iColumn = 0, $iBase = 0, $iCase = 0, $iCount = $ARRAYUNIQUE_COUNT, $iIntType = $ARRAYUNIQUE_AUTO)
If $iColumn = Default Then $iColumn = 0
If $iBase = Default Then $iBase = 0
If $iCase = Default Then $iCase = 0
If $iCount = Default Then $iCount = $ARRAYUNIQUE_COUNT
If UBound($aArray, $UBOUND_ROWS) = 0 Then Return SetError(1, 0, 0)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS), $iNumColumns = UBound($aArray, $UBOUND_COLUMNS)
If $iDims > 2 Then Return SetError(2, 0, 0)
If $iBase < 0 Or $iBase > 1 Or (Not IsInt($iBase)) Then Return SetError(3, 0, 0)
If $iCase < 0 Or $iCase > 1 Or (Not IsInt($iCase)) Then Return SetError(3, 0, 0)
If $iCount < 0 Or $iCount > 1 Or (Not IsInt($iCount)) Then Return SetError(4, 0, 0)
If $iIntType < 0 Or $iIntType > 4 Or (Not IsInt($iIntType)) Then Return SetError(5, 0, 0)
If $iColumn < 0 Or ($iNumColumns = 0 And $iColumn > 0) Or ($iNumColumns > 0 And $iColumn >= $iNumColumns) Then Return SetError(6, 0, 0)
If $iIntType = $ARRAYUNIQUE_AUTO Then
Local $bInt, $sVarType
If $iDims = 1 Then
$bInt = IsInt($aArray[$iBase])
$sVarType = VarGetType($aArray[$iBase])
Else
$bInt = IsInt($aArray[$iBase][$iColumn])
$sVarType = VarGetType($aArray[$iBase][$iColumn])
EndIf
If $bInt And $sVarType = "Int64" Then
$iIntType = $ARRAYUNIQUE_FORCE64
Else
$iIntType = $ARRAYUNIQUE_FORCE32
EndIf
EndIf
ObjEvent("AutoIt.Error", __ArrayUnique_AutoErrFunc)
Local $oDictionary = ObjCreate("Scripting.Dictionary")
$oDictionary.CompareMode = Number(Not $iCase)
Local $vElem, $sType, $vKey, $bCOMError = False
For $i = $iBase To UBound($aArray) - 1
If $iDims = 1 Then
$vElem = $aArray[$i]
Else
$vElem = $aArray[$i][$iColumn]
EndIf
Switch $iIntType
Case $ARRAYUNIQUE_FORCE32
$oDictionary.Item($vElem)
If @error Then
$bCOMError = True
ExitLoop
EndIf
Case $ARRAYUNIQUE_FORCE64
$sType = VarGetType($vElem)
If $sType = "Int32" Then
$bCOMError = True
ExitLoop
EndIf
$vKey = "#" & $sType & "#" & String($vElem)
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
Case $ARRAYUNIQUE_MATCH
$sType = VarGetType($vElem)
If StringLeft($sType, 3) = "Int" Then
$vKey = "#Int#" & String($vElem)
Else
$vKey = "#" & $sType & "#" & String($vElem)
EndIf
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
Case $ARRAYUNIQUE_DISTINCT
$vKey = "#" & VarGetType($vElem) & "#" & String($vElem)
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
EndSwitch
Next
Local $aValues, $j = 0
If $bCOMError Then
Return SetError(7, 0, 0)
ElseIf $iIntType <> $ARRAYUNIQUE_FORCE32 Then
Local $aValues[$oDictionary.Count]
For $vKey In $oDictionary.Keys()
$aValues[$j] = $oDictionary($vKey)
If StringLeft($vKey, 5) = "#Ptr#" Then
$aValues[$j] = Ptr($aValues[$j])
EndIf
$j += 1
Next
Else
$aValues = $oDictionary.Keys()
EndIf
If $iCount Then
_ArrayInsert($aValues, 0, $oDictionary.Count)
EndIf
Return $aValues
EndFunc
Func _Array1DToHistogram($aArray, $iSizing = 100)
If UBound($aArray, 0) > 1 Then Return SetError(1, 0, "")
$iSizing = $iSizing * 8
Local $t, $n, $iMin = 0, $iMax = 0, $iOffset = 0
For $i = 0 To UBound($aArray) - 1
$t = $aArray[$i]
$t = IsNumber($t) ? Round($t) : 0
If $t < $iMin Then $iMin = $t
If $t > $iMax Then $iMax = $t
Next
Local $iRange = Int(Round(($iMax - $iMin) / 8)) * 8
Local $iSpaceRatio = 4
For $i = 0 To UBound($aArray) - 1
$t = $aArray[$i]
If $t Then
$n = Abs(Round(($iSizing * $t) / $iRange) / 8)
$aArray[$i] = ""
If $t > 0 Then
If $iMin Then
$iOffset = Int(Abs(Round(($iSizing * $iMin) / $iRange) / 8) / 8 * $iSpaceRatio)
$aArray[$i] = __Array_StringRepeat(ChrW(0x20), $iOffset)
EndIf
Else
If $iMin <> $t Then
$iOffset = Int(Abs(Round(($iSizing * ($t - $iMin)) / $iRange) / 8) / 8 * $iSpaceRatio)
$aArray[$i] = __Array_StringRepeat(ChrW(0x20), $iOffset)
EndIf
EndIf
$aArray[$i] &= __Array_StringRepeat(ChrW(0x2588), Int($n / 8))
$n = Mod($n, 8)
If $n > 0 Then $aArray[$i] &= ChrW(0x2588 + 8 - $n)
$aArray[$i] &= ' ' & $t
Else
$aArray[$i] = ""
EndIf
Next
Return $aArray
EndFunc
Func __Array_StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If StringLen($sString) < 1 Or $iRepeatCount <= 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Func __Array_ExeterInternal(ByRef $aArray, $iStart, $iSize, $sDelimiter, ByRef $aIdx, ByRef $aResult, ByRef $iCount)
If $iStart == $iSize - 1 Then
For $i = 0 To $iSize - 1
$aResult[$iCount] &= $aArray[$aIdx[$i]] & $sDelimiter
Next
If $sDelimiter <> "" Then $aResult[$iCount] = StringTrimRight($aResult[$iCount], StringLen($sDelimiter))
$iCount += 1
Else
Local $iTemp
For $i = $iStart To $iSize - 1
$iTemp = $aIdx[$i]
$aIdx[$i] = $aIdx[$iStart]
$aIdx[$iStart] = $iTemp
__Array_ExeterInternal($aArray, $iStart + 1, $iSize, $sDelimiter, $aIdx, $aResult, $iCount)
$aIdx[$iStart] = $aIdx[$i]
$aIdx[$i] = $iTemp
Next
EndIf
EndFunc
Func __Array_Combinations($iN, $iR)
Local $i_Total = 1
For $i = $iR To 1 Step -1
$i_Total *= ($iN / $i)
$iN -= 1
Next
Return Round($i_Total)
EndFunc
Func __Array_GetNext($iN, $iR, ByRef $iLeft, $iTotal, ByRef $aIdx)
If $iLeft == $iTotal Then
$iLeft -= 1
Return
EndIf
Local $i = $iR - 1
While $aIdx[$i] == $iN - $iR + $i
$i -= 1
WEnd
$aIdx[$i] += 1
For $j = $i + 1 To $iR - 1
$aIdx[$j] = $aIdx[$i] + $j - $i
Next
$iLeft -= 1
EndFunc
Func __Array_MinMaxIndex(Const ByRef $aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, $fuComparison)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iCompNumeric <> 1 Then $iCompNumeric = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iDim_1 < 0 Then Return SetError(1, 0, -1)
If $iEnd = -1 Then $iEnd = $iDim_1
If $iStart = -1 Then $iStart = 0
If $iStart < -1 Or $iEnd < -1 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
If $iDim_1 < 0 Then Return SetError(5, 0, -1)
Local $iMaxMinIndex = $iStart
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i]), Number($aArray[$iMaxMinIndex])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i], $aArray[$iMaxMinIndex]) Then $iMaxMinIndex = $i
Next
EndIf
Case 2
If $iSubItem < 0 Or $iSubItem > UBound($aArray, $UBOUND_COLUMNS) - 1 Then Return SetError(6, 0, -1)
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i][$iSubItem]), Number($aArray[$iMaxMinIndex][$iSubItem])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i][$iSubItem], $aArray[$iMaxMinIndex][$iSubItem]) Then $iMaxMinIndex = $i
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return $iMaxMinIndex
EndFunc
Func __Array_GreaterThan($vValue1, $vValue2)
Return $vValue1 > $vValue2
EndFunc
Func __Array_LessThan($vValue1, $vValue2)
Return $vValue1 < $vValue2
EndFunc
Func __ArrayUnique_AutoErrFunc()
EndFunc
Global Const $BS_GROUPBOX = 0x0007
Global Const $BS_BOTTOM = 0x0800
Global Const $BS_CENTER = 0x0300
Global Const $BS_DEFPUSHBUTTON = 0x0001
Global Const $BS_LEFT = 0x0100
Global Const $BS_MULTILINE = 0x2000
Global Const $BS_PUSHBOX = 0x000A
Global Const $BS_PUSHLIKE = 0x1000
Global Const $BS_RIGHT = 0x0200
Global Const $BS_RIGHTBUTTON = 0x0020
Global Const $BS_TOP = 0x0400
Global Const $BS_VCENTER = 0x0C00
Global Const $BS_FLAT = 0x8000
Global Const $BS_ICON = 0x0040
Global Const $BS_BITMAP = 0x0080
Global Const $BS_NOTIFY = 0x4000
Global Const $BS_SPLITBUTTON = 0x0000000C
Global Const $BS_DEFSPLITBUTTON = 0x0000000D
Global Const $BS_COMMANDLINK = 0x0000000E
Global Const $BS_DEFCOMMANDLINK = 0x0000000F
Global Const $BCSIF_GLYPH = 0x0001
Global Const $BCSIF_IMAGE = 0x0002
Global Const $BCSIF_STYLE = 0x0004
Global Const $BCSIF_SIZE = 0x0008
Global Const $BCSS_NOSPLIT = 0x0001
Global Const $BCSS_STRETCH = 0x0002
Global Const $BCSS_ALIGNLEFT = 0x0004
Global Const $BCSS_IMAGE = 0x0008
Global Const $BUTTON_IMAGELIST_ALIGN_LEFT = 0
Global Const $BUTTON_IMAGELIST_ALIGN_RIGHT = 1
Global Const $BUTTON_IMAGELIST_ALIGN_TOP = 2
Global Const $BUTTON_IMAGELIST_ALIGN_BOTTOM = 3
Global Const $BUTTON_IMAGELIST_ALIGN_CENTER = 4
Global Const $BS_3STATE = 0x0005
Global Const $BS_AUTO3STATE = 0x0006
Global Const $BS_AUTOCHECKBOX = 0x0003
Global Const $BS_CHECKBOX = 0x0002
Global Const $BS_RADIOBUTTON = 0x4
Global Const $BS_AUTORADIOBUTTON = 0x0009
Global Const $BS_OWNERDRAW = 0xB
Global Const $GUI_SS_DEFAULT_BUTTON = 0
Global Const $GUI_SS_DEFAULT_CHECKBOX = 0
Global Const $GUI_SS_DEFAULT_GROUP = 0
Global Const $GUI_SS_DEFAULT_RADIO = 0
Global Const $BCM_FIRST = 0x1600
Global Const $BCM_GETIDEALSIZE = ($BCM_FIRST + 0x0001)
Global Const $BCM_GETIMAGELIST = ($BCM_FIRST + 0x0003)
Global Const $BCM_GETNOTE = ($BCM_FIRST + 0x000A)
Global Const $BCM_GETNOTELENGTH = ($BCM_FIRST + 0x000B)
Global Const $BCM_GETSPLITINFO = ($BCM_FIRST + 0x0008)
Global Const $BCM_GETTEXTMARGIN = ($BCM_FIRST + 0x0005)
Global Const $BCM_SETDROPDOWNSTATE = ($BCM_FIRST + 0x0006)
Global Const $BCM_SETIMAGELIST = ($BCM_FIRST + 0x0002)
Global Const $BCM_SETNOTE = ($BCM_FIRST + 0x0009)
Global Const $BCM_SETSHIELD = ($BCM_FIRST + 0x000C)
Global Const $BCM_SETSPLITINFO = ($BCM_FIRST + 0x0007)
Global Const $BCM_SETTEXTMARGIN = ($BCM_FIRST + 0x0004)
Global Const $BM_CLICK = 0xF5
Global Const $BM_GETCHECK = 0xF0
Global Const $BM_GETIMAGE = 0xF6
Global Const $BM_GETSTATE = 0xF2
Global Const $BM_SETCHECK = 0xF1
Global Const $BM_SETDONTCLICK = 0xF8
Global Const $BM_SETIMAGE = 0xF7
Global Const $BM_SETSTATE = 0xF3
Global Const $BM_SETSTYLE = 0xF4
Global Const $BCN_FIRST = -1250
Global Const $BCN_DROPDOWN = ($BCN_FIRST + 0x0002)
Global Const $BCN_HOTITEMCHANGE = ($BCN_FIRST + 0x0001)
Global Const $BN_CLICKED = 0
Global Const $BN_PAINT = 1
Global Const $BN_HILITE = 2
Global Const $BN_UNHILITE = 3
Global Const $BN_DISABLE = 4
Global Const $BN_DOUBLECLICKED = 5
Global Const $BN_SETFOCUS = 6
Global Const $BN_KILLFOCUS = 7
Global Const $BN_PUSHED = $BN_HILITE
Global Const $BN_UNPUSHED = $BN_UNHILITE
Global Const $BN_DBLCLK = $BN_DOUBLECLICKED
Global Const $BST_CHECKED = 0x1
Global Const $BST_INDETERMINATE = 0x2
Global Const $BST_UNCHECKED = 0x0
Global Const $BST_FOCUS = 0x8
Global Const $BST_PUSHED = 0x4
Global Const $BST_DONTCLICK = 0x000080
Global Const $COLOR_AQUA = 0x00FFFF
Global Const $COLOR_BLACK = 0x000000
Global Const $COLOR_BLUE = 0x0000FF
Global Const $COLOR_CREAM = 0xFFFBF0
Global Const $COLOR_FUCHSIA = 0xFF00FF
Global Const $COLOR_GRAY = 0x808080
Global Const $COLOR_GREEN = 0x008000
Global Const $COLOR_LIME = 0x00FF00
Global Const $COLOR_MAROON = 0x8B1C62
Global Const $COLOR_MEDBLUE = 0x0002C4
Global Const $COLOR_MEDGRAY = 0xA0A0A4
Global Const $COLOR_MONEYGREEN = 0xC0DCC0
Global Const $COLOR_NAVY = 0x000080
Global Const $COLOR_OLIVE = 0x808000
Global Const $COLOR_PURPLE = 0x800080
Global Const $COLOR_RED = 0xFF0000
Global Const $COLOR_SILVER = 0xC0C0C0
Global Const $COLOR_SKYBLUE = 0xA6CAF0
Global Const $COLOR_TEAL = 0x008080
Global Const $COLOR_WHITE = 0xFFFFFF
Global Const $COLOR_YELLOW = 0xFFFF00
Global Const $CLR_NONE = 0xFFFFFFFF
Global Const $CLR_DEFAULT = 0xFF000000
Global Const $CLR_AQUA = 0xFFFF00
Global Const $CLR_BLACK = 0x000000
Global Const $CLR_BLUE = 0xFF0000
Global Const $CLR_CREAM = 0xF0FBFF
Global Const $CLR_FUCHSIA = 0xFF00FF
Global Const $CLR_GRAY = 0x808080
Global Const $CLR_GREEN = 0x008000
Global Const $CLR_LIME = 0x00FF00
Global Const $CLR_MAROON = 0x621C8B
Global Const $CLR_MEDBLUE = 0xC40200
Global Const $CLR_MEDGRAY = 0xA4A0A0
Global Const $CLR_MONEYGREEN = 0xC0DCC0
Global Const $CLR_NAVY = 0x800000
Global Const $CLR_OLIVE = 0x008080
Global Const $CLR_PURPLE = 0x800080
Global Const $CLR_RED = 0x0000FF
Global Const $CLR_SILVER = 0xC0C0C0
Global Const $CLR_SKYBLUE = 0xF0CAA6
Global Const $CLR_TEAL = 0x808000
Global Const $CLR_WHITE = 0xFFFFFF
Global Const $CLR_YELLOW = 0x00FFFF
Global Const $CC_ANYCOLOR = 0x0100
Global Const $CC_FULLOPEN = 0x0002
Global Const $CC_RGBINIT = 0x0001
Global Const $DTS_SHORTDATEFORMAT = 0
Global Const $DTS_UPDOWN = 1
Global Const $DTS_SHOWNONE = 2
Global Const $DTS_LONGDATEFORMAT = 4
Global Const $DTS_TIMEFORMAT = 9
Global Const $DTS_RIGHTALIGN = 32
Global Const $DTS_SHORTDATECENTURYFORMAT = 0x0000000C
Global Const $DTS_APPCANPARSE = 0x00000010
Global Const $DMW_LONGNAME = 0
Global Const $DMW_SHORTNAME = 1
Global Const $DMW_LOCALE_LONGNAME = 2
Global Const $DMW_LOCALE_SHORTNAME = 3
Global Const $GDT_ERROR = -1
Global Const $GDT_VALID = 0
Global Const $GDT_NONE = 1
Global Const $GDTR_MIN = 0x0001
Global Const $GDTR_MAX = 0x0002
Global Const $MCHT_NOWHERE = 0x00000000
Global Const $MCHT_TITLE = 0x00010000
Global Const $MCHT_CALENDAR = 0x00020000
Global Const $MCHT_TODAYLINK = 0x00030000
Global Const $MCHT_NEXT = 0x01000000
Global Const $MCHT_PREV = 0x02000000
Global Const $MCHT_TITLEBK = 0x00010000
Global Const $MCHT_TITLEMONTH = 0x00010001
Global Const $MCHT_TITLEYEAR = 0x00010002
Global Const $MCHT_TITLEBTNNEXT = 0x01010003
Global Const $MCHT_TITLEBTNPREV = 0x02010003
Global Const $MCHT_CALENDARBK = 0x00020000
Global Const $MCHT_CALENDARDATE = 0x00020001
Global Const $MCHT_CALENDARDAY = 0x00020002
Global Const $MCHT_CALENDARWEEKNUM = 0x00020003
Global Const $MCHT_CALENDARDATENEXT = 0x01020000
Global Const $MCHT_CALENDARDATEPREV = 0x02020000
Global Const $MCS_DAYSTATE = 0x0001
Global Const $MCS_MULTISELECT = 0x0002
Global Const $MCS_WEEKNUMBERS = 0x0004
Global Const $MCS_NOTODAYCIRCLE = 0x0008
Global Const $MCS_NOTODAY = 0x0010
Global Const $MCS_NOTRAILINGDATES = 0x0040
Global Const $MCS_SHORTDAYSOFWEEK = 0x0080
Global Const $MCS_NOSELCHANGEONNAV = 0x0100
Global Const $MCM_FIRST = 0x1000
Global Const $MCM_GETCALENDARBORDER = ($MCM_FIRST + 31)
Global Const $MCM_GETCALENDARCOUNT = ($MCM_FIRST + 23)
Global Const $MCM_GETCALENDARGRIDINFO = ($MCM_FIRST + 24)
Global Const $MCM_GETCALID = ($MCM_FIRST + 27)
Global Const $MCM_GETCOLOR = ($MCM_FIRST + 11)
Global Const $MCM_GETCURRENTVIEW = ($MCM_FIRST + 22)
Global Const $MCM_GETCURSEL = ($MCM_FIRST + 1)
Global Const $MCM_GETFIRSTDAYOFWEEK = ($MCM_FIRST + 16)
Global Const $MCM_GETMAXSELCOUNT = ($MCM_FIRST + 3)
Global Const $MCM_GETMAXTODAYWIDTH = ($MCM_FIRST + 21)
Global Const $MCM_GETMINREQRECT = ($MCM_FIRST + 9)
Global Const $MCM_GETMONTHDELTA = ($MCM_FIRST + 19)
Global Const $MCM_GETMONTHRANGE = ($MCM_FIRST + 7)
Global Const $MCM_GETRANGE = ($MCM_FIRST + 17)
Global Const $MCM_GETSELRANGE = ($MCM_FIRST + 5)
Global Const $MCM_GETTODAY = ($MCM_FIRST + 13)
Global Const $MCM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $MCM_HITTEST = ($MCM_FIRST + 14)
Global Const $MCM_SETCALENDARBORDER = ($MCM_FIRST + 30)
Global Const $MCM_SETCALID = ($MCM_FIRST + 28)
Global Const $MCM_SETCOLOR = ($MCM_FIRST + 10)
Global Const $MCM_SETCURRENTVIEW = ($MCM_FIRST + 32)
Global Const $MCM_SETCURSEL = ($MCM_FIRST + 2)
Global Const $MCM_SETDAYSTATE = ($MCM_FIRST + 8)
Global Const $MCM_SETFIRSTDAYOFWEEK = ($MCM_FIRST + 15)
Global Const $MCM_SETMAXSELCOUNT = ($MCM_FIRST + 4)
Global Const $MCM_SETMONTHDELTA = ($MCM_FIRST + 20)
Global Const $MCM_SETRANGE = ($MCM_FIRST + 18)
Global Const $MCM_SETSELRANGE = ($MCM_FIRST + 6)
Global Const $MCM_SETTODAY = ($MCM_FIRST + 12)
Global Const $MCM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $MCM_SIZERECTTOMIN = ($MCM_FIRST + 29)
Global Const $MCN_FIRST = -746
Global Const $MCN_SELCHANGE = ($MCN_FIRST - 3)
Global Const $MCN_GETDAYSTATE = ($MCN_FIRST - 1)
Global Const $MCN_SELECT = ($MCN_FIRST)
Global Const $MCN_VIEWCHANGE = ($MCN_FIRST - 4)
Global Const $MCSC_BACKGROUND = 0
Global Const $MCSC_MONTHBK = 4
Global Const $MCSC_TEXT = 1
Global Const $MCSC_TITLEBK = 2
Global Const $MCSC_TITLETEXT = 3
Global Const $MCSC_TRAILINGTEXT = 5
Global Const $DTM_FIRST = 0x1000
Global Const $DTM_GETSYSTEMTIME = $DTM_FIRST + 1
Global Const $DTM_SETSYSTEMTIME = $DTM_FIRST + 2
Global Const $DTM_GETRANGE = $DTM_FIRST + 3
Global Const $DTM_SETRANGE = $DTM_FIRST + 4
Global Const $DTM_SETFORMAT = $DTM_FIRST + 5
Global Const $DTM_SETMCCOLOR = $DTM_FIRST + 6
Global Const $DTM_GETMCCOLOR = $DTM_FIRST + 7
Global Const $DTM_GETMONTHCAL = $DTM_FIRST + 8
Global Const $DTM_SETMCFONT = $DTM_FIRST + 9
Global Const $DTM_GETMCFONT = $DTM_FIRST + 10
Global Const $DTM_SETFORMATW = $DTM_FIRST + 50
Global Const $DTN_FIRST = -740
Global Const $DTN_FIRST2 = -753
Global Const $DTN_DATETIMECHANGE = $DTN_FIRST2 - 6
Global Const $DTN_USERSTRING = $DTN_FIRST2 - 5
Global Const $DTN_WMKEYDOWN = $DTN_FIRST2 - 4
Global Const $DTN_FORMAT = $DTN_FIRST2 - 3
Global Const $DTN_FORMATQUERY = $DTN_FIRST2 - 2
Global Const $DTN_DROPDOWN = $DTN_FIRST2 - 1
Global Const $DTN_CLOSEUP = $DTN_FIRST2 - 0
Global Const $DTN_USERSTRINGW = $DTN_FIRST - 5
Global Const $DTN_WMKEYDOWNW = $DTN_FIRST - 4
Global Const $DTN_FORMATW = $DTN_FIRST - 3
Global Const $DTN_FORMATQUERYW = $DTN_FIRST - 2
Global Const $GUI_SS_DEFAULT_DATE = $DTS_LONGDATEFORMAT
Global Const $GUI_SS_DEFAULT_MONTHCAL = 0
Global Const $GMEM_FIXED = 0x0000
Global Const $GMEM_MOVEABLE = 0x0002
Global Const $GMEM_NOCOMPACT = 0x0010
Global Const $GMEM_NODISCARD = 0x0020
Global Const $GMEM_ZEROINIT = 0x0040
Global Const $GMEM_MODIFY = 0x0080
Global Const $GMEM_DISCARDABLE = 0x0100
Global Const $GMEM_NOT_BANKED = 0x1000
Global Const $GMEM_SHARE = 0x2000
Global Const $GMEM_DDESHARE = 0x2000
Global Const $GMEM_NOTIFY = 0x4000
Global Const $GMEM_LOWER = 0x1000
Global Const $GMEM_VALID_FLAGS = 0x7F72
Global Const $GMEM_INVALID_HANDLE = 0x8000
Global Const $GPTR = BitOR($GMEM_FIXED, $GMEM_ZEROINIT)
Global Const $GHND = BitOR($GMEM_MOVEABLE, $GMEM_ZEROINIT)
Global Const $MEM_COMMIT = 0x00001000
Global Const $MEM_RESERVE = 0x00002000
Global Const $MEM_TOP_DOWN = 0x00100000
Global Const $MEM_SHARED = 0x08000000
Global Const $PAGE_NOACCESS = 0x00000001
Global Const $PAGE_READONLY = 0x00000002
Global Const $PAGE_READWRITE = 0x00000004
Global Const $PAGE_EXECUTE = 0x00000010
Global Const $PAGE_EXECUTE_READ = 0x00000020
Global Const $PAGE_EXECUTE_READWRITE = 0x00000040
Global Const $PAGE_EXECUTE_WRITECOPY = 0x00000080
Global Const $PAGE_GUARD = 0x00000100
Global Const $PAGE_NOCACHE = 0x00000200
Global Const $PAGE_WRITECOMBINE = 0x00000400
Global Const $PAGE_WRITECOPY = 0x00000008
Global Const $MEM_DECOMMIT = 0x00004000
Global Const $MEM_RELEASE = 0x00008000
Global Enum $MEM_LOAD, $MEM_TOTALPHYSRAM, $MEM_AVAILPHYSRAM, $MEM_TOTALPAGEFILE, $MEM_AVAILPAGEFILE, $MEM_TOTALVIRTUAL, $MEM_AVAILVIRTUAL
Global Const $PROCESS_TERMINATE = 0x00000001
Global Const $PROCESS_CREATE_THREAD = 0x00000002
Global Const $PROCESS_SET_SESSIONID = 0x00000004
Global Const $PROCESS_VM_OPERATION = 0x00000008
Global Const $PROCESS_VM_READ = 0x00000010
Global Const $PROCESS_VM_WRITE = 0x00000020
Global Const $PROCESS_DUP_HANDLE = 0x00000040
Global Const $PROCESS_CREATE_PROCESS = 0x00000080
Global Const $PROCESS_SET_QUOTA = 0x00000100
Global Const $PROCESS_SET_INFORMATION = 0x00000200
Global Const $PROCESS_QUERY_INFORMATION = 0x00000400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
Global Const $PROCESS_SUSPEND_RESUME = 0x00000800
Global Const $PROCESS_ALL_ACCESS = 0x001F0FFF
Global Const $SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
Global Const $SE_AUDIT_NAME = "SeAuditPrivilege"
Global Const $SE_BACKUP_NAME = "SeBackupPrivilege"
Global Const $SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
Global Const $SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege"
Global Const $SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
Global Const $SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
Global Const $SE_CREATE_SYMBOLIC_LINK_NAME = 'SeCreateSymbolicLinkPrivilege'
Global Const $SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
Global Const $SE_DEBUG_NAME = "SeDebugPrivilege"
Global Const $SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege"
Global Const $SE_IMPERSONATE_NAME = "SeImpersonatePrivilege"
Global Const $SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
Global Const $SE_INC_WORKING_SET_NAME = 'SeIncreaseWorkingSetPrivilege'
Global Const $SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
Global Const $SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
Global Const $SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
Global Const $SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
Global Const $SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege"
Global Const $SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
Global Const $SE_RELABEL_NAME = 'SeRelabelPrivilege'
Global Const $SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"
Global Const $SE_RESTORE_NAME = "SeRestorePrivilege"
Global Const $SE_SECURITY_NAME = "SeSecurityPrivilege"
Global Const $SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
Global Const $SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege"
Global Const $SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
Global Const $SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
Global Const $SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
Global Const $SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
Global Const $SE_TCB_NAME = "SeTcbPrivilege"
Global Const $SE_TIME_ZONE_NAME = 'SeTimeZonePrivilege'
Global Const $SE_TRUSTED_CREDMAN_ACCESS_NAME = 'SeTrustedCredManAccessPrivilege'
Global Const $SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
Global Const $SE_UNDOCK_NAME = "SeUndockPrivilege"
Global Const $SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001
Global Const $SE_PRIVILEGE_ENABLED = 0x00000002
Global Const $SE_PRIVILEGE_REMOVED = 0x00000004
Global Const $SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000
Global Const $SE_GROUP_MANDATORY = 0x00000001
Global Const $SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002
Global Const $SE_GROUP_ENABLED = 0x00000004
Global Const $SE_GROUP_OWNER = 0x00000008
Global Const $SE_GROUP_USE_FOR_DENY_ONLY = 0x00000010
Global Const $SE_GROUP_INTEGRITY = 0x00000020
Global Const $SE_GROUP_INTEGRITY_ENABLED = 0x00000040
Global Const $SE_GROUP_RESOURCE = 0x20000000
Global Const $SE_GROUP_LOGON_ID = 0xC0000000
Global Enum $TOKENPRIMARY = 1, $TOKENIMPERSONATION
Global Enum $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
Global Enum $TOKENUSER = 1, $TOKENGROUPS, $TOKENPRIVILEGES, $TOKENOWNER, $TOKENPRIMARYGROUP, $TOKENDEFAULTDACL, $TOKENSOURCE, $TOKENTYPE, $TOKENIMPERSONATIONLEVEL, $TOKENSTATISTICS, $TOKENRESTRICTEDSIDS, $TOKENSESSIONID, $TOKENGROUPSANDPRIVILEGES, $TOKENSESSIONREFERENCE, $TOKENSANDBOXINERT, $TOKENAUDITPOLICY, $TOKENORIGIN, $TOKENELEVATIONTYPE, $TOKENLINKEDTOKEN, $TOKENELEVATION, $TOKENHASRESTRICTIONS, $TOKENACCESSINFORMATION, $TOKENVIRTUALIZATIONALLOWED, $TOKENVIRTUALIZATIONENABLED, $TOKENINTEGRITYLEVEL, $TOKENUIACCESS, $TOKENMANDATORYPOLICY, $TOKENLOGONSID
Global Const $TOKEN_ASSIGN_PRIMARY = 0x00000001
Global Const $TOKEN_DUPLICATE = 0x00000002
Global Const $TOKEN_IMPERSONATE = 0x00000004
Global Const $TOKEN_QUERY = 0x00000008
Global Const $TOKEN_QUERY_SOURCE = 0x00000010
Global Const $TOKEN_ADJUST_PRIVILEGES = 0x00000020
Global Const $TOKEN_ADJUST_GROUPS = 0x00000040
Global Const $TOKEN_ADJUST_DEFAULT = 0x00000080
Global Const $TOKEN_ADJUST_SESSIONID = 0x00000100
Global Const $TOKEN_ALL_ACCESS = 0x000F01FF
Global Const $TOKEN_READ = 0x00020008
Global Const $TOKEN_WRITE = 0x000200E0
Global Const $TOKEN_EXECUTE = 0x00020000
Global Const $TOKEN_HAS_TRAVERSE_PRIVILEGE = 0x00000001
Global Const $TOKEN_HAS_BACKUP_PRIVILEGE = 0x00000002
Global Const $TOKEN_HAS_RESTORE_PRIVILEGE = 0x00000004
Global Const $TOKEN_HAS_ADMIN_GROUP = 0x00000008
Global Const $TOKEN_IS_RESTRICTED = 0x00000010
Global Const $TOKEN_SESSION_NOT_REFERENCED = 0x00000020
Global Const $TOKEN_SANDBOX_INERT = 0x00000040
Global Const $TOKEN_HAS_IMPERSONATE_PRIVILEGE = 0x00000080
Global Const $RIGHTS_DELETE = 0x00010000
Global Const $READ_CONTROL = 0x00020000
Global Const $WRITE_DAC = 0x00040000
Global Const $WRITE_OWNER = 0x00080000
Global Const $SYNCHRONIZE = 0x00100000
Global Const $ACCESS_SYSTEM_SECURITY = 0x01000000
Global Const $STANDARD_RIGHTS_REQUIRED = 0x000f0000
Global Const $STANDARD_RIGHTS_READ = $READ_CONTROL
Global Const $STANDARD_RIGHTS_WRITE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_EXECUTE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_ALL = 0x001F0000
Global Const $SPECIFIC_RIGHTS_ALL = 0x0000FFFF
Global Enum $NOT_USED_ACCESS = 0, $GRANT_ACCESS, $SET_ACCESS, $DENY_ACCESS, $REVOKE_ACCESS, $SET_AUDIT_SUCCESS, $SET_AUDIT_FAILURE
Global Enum $TRUSTEE_IS_UNKNOWN = 0, $TRUSTEE_IS_USER, $TRUSTEE_IS_GROUP, $TRUSTEE_IS_DOMAIN, $TRUSTEE_IS_ALIAS, $TRUSTEE_IS_WELL_KNOWN_GROUP, $TRUSTEE_IS_DELETED, $TRUSTEE_IS_INVALID, $TRUSTEE_IS_COMPUTER
Global Const $LOGON_WITH_PROFILE = 0x00000001
Global Const $LOGON_NETCREDENTIALS_ONLY = 0x00000002
Global Enum $SIDTYPEUSER = 1, $SIDTYPEGROUP, $SIDTYPEDOMAIN, $SIDTYPEALIAS, $SIDTYPEWELLKNOWNGROUP, $SIDTYPEDELETEDACCOUNT, $SIDTYPEINVALID, $SIDTYPEUNKNOWN, $SIDTYPECOMPUTER, $SIDTYPELABEL
Global Const $SID_ADMINISTRATORS = "S-1-5-32-544"
Global Const $SID_USERS = "S-1-5-32-545"
Global Const $SID_GUESTS = "S-1-5-32-546"
Global Const $SID_ACCOUNT_OPERATORS = "S-1-5-32-548"
Global Const $SID_SERVER_OPERATORS = "S-1-5-32-549"
Global Const $SID_PRINT_OPERATORS = "S-1-5-32-550"
Global Const $SID_BACKUP_OPERATORS = "S-1-5-32-551"
Global Const $SID_REPLICATOR = "S-1-5-32-552"
Global Const $SID_OWNER = "S-1-3-0"
Global Const $SID_EVERYONE = "S-1-1-0"
Global Const $SID_NETWORK = "S-1-5-2"
Global Const $SID_INTERACTIVE = "S-1-5-4"
Global Const $SID_SYSTEM = "S-1-5-18"
Global Const $SID_AUTHENTICATED_USERS = "S-1-5-11"
Global Const $SID_SCHANNEL_AUTHENTICATION = "S-1-5-64-14"
Global Const $SID_DIGEST_AUTHENTICATION = "S-1-5-64-21"
Global Const $SID_NT_SERVICE = "S-1-5-80"
Global Const $SID_UNTRUSTED_MANDATORY_LEVEL = "S-1-16-0"
Global Const $SID_LOW_MANDATORY_LEVEL = "S-1-16-4096"
Global Const $SID_MEDIUM_MANDATORY_LEVEL = "S-1-16-8192"
Global Const $SID_MEDIUM_PLUS_MANDATORY_LEVEL = "S-1-16-8448"
Global Const $SID_HIGH_MANDATORY_LEVEL = "S-1-16-12288"
Global Const $SID_SYSTEM_MANDATORY_LEVEL = "S-1-16-16384"
Global Const $SID_PROTECTED_PROCESS_MANDATORY_LEVEL = "S-1-16-20480"
Global Const $SID_SECURE_PROCESS_MANDATORY_LEVEL = "S-1-16-28672"
Global Const $SID_ALL_SERVICES = "S-1-5-80-0"
#Region Global Variables and Constants
Global Const $FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100
Global Const $FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200
Global Const $FORMAT_MESSAGE_FROM_STRING = 0x00000400
Global Const $FORMAT_MESSAGE_FROM_HMODULE = 0x00000800
Global Const $FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
Global Const $FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000
#EndRegion Global Variables and Constants
Func _WinAPI_Beep($iFreq = 500, $iDuration = 1000)
Local $aResult = DllCall("kernel32.dll", "bool", "Beep", "dword", $iFreq, "dword", $iDuration)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FormatMessage($iFlags, $pSource, $iMessageID, $iLanguageID, ByRef $pBuffer, $iSize, $vArguments)
Local $sBufferType = "struct*"
If IsString($pBuffer) Then $sBufferType = "wstr"
Local $aResult = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $iFlags, "struct*", $pSource, "dword", $iMessageID,  "dword", $iLanguageID, $sBufferType, $pBuffer, "dword", $iSize, "ptr", $vArguments)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
If $sBufferType = "wstr" Then $pBuffer = $aResult[5]
Return $aResult[0]
EndFunc
Func _WinAPI_GetErrorMessage($iCode, $iLanguage = 0, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $aRet = DllCall('kernel32.dll', 'dword', 'FormatMessageW', 'dword', 0x1000, 'ptr', 0, 'dword', $iCode,  'dword', $iLanguage, 'wstr', '', 'dword', 4096, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return SetError($_iCurrentError, $_iCurrentExtended, StringRegExpReplace($aRet[5], '[' & @LF & ',' & @CR & ']*\Z', ''))
EndFunc
Func _WinAPI_GetLastError(Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $aResult = DllCall("kernel32.dll", "dword", "GetLastError")
Return SetError($_iCurrentError, $_iCurrentExtended, $aResult[0])
EndFunc
Func _WinAPI_GetLastErrorMessage(Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $iLastError = _WinAPI_GetLastError()
Local $tBufferPtr = DllStructCreate("ptr")
Local $nCount = _WinAPI_FormatMessage(BitOR($FORMAT_MESSAGE_ALLOCATE_BUFFER, $FORMAT_MESSAGE_FROM_SYSTEM),  0, $iLastError, 0, $tBufferPtr, 0, 0)
If @error Then Return SetError(-@error, @extended, "")
Local $sText = ""
Local $pBuffer = DllStructGetData($tBufferPtr, 1)
If $pBuffer Then
If $nCount > 0 Then
Local $tBuffer = DllStructCreate("wchar[" & ($nCount + 1) & "]", $pBuffer)
$sText = DllStructGetData($tBuffer, 1)
If StringRight($sText, 2) = @CRLF Then $sText = StringTrimRight($sText, 2)
EndIf
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pBuffer)
EndIf
Return SetError($_iCurrentError, $_iCurrentExtended, $sText)
EndFunc
Func _WinAPI_MessageBeep($iType = 1)
Local $iSound
Switch $iType
Case 1
$iSound = 0
Case 2
$iSound = 16
Case 3
$iSound = 32
Case 4
$iSound = 48
Case 5
$iSound = 64
Case Else
$iSound = -1
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "MessageBeep", "uint", $iSound)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MsgBox($iFlags, $sTitle, $sText)
BlockInput(0)
MsgBox($iFlags, $sTitle, $sText & "      ")
EndFunc
Func _WinAPI_SetLastError($iErrorCode, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
DllCall("kernel32.dll", "none", "SetLastError", "dword", $iErrorCode)
Return SetError($_iCurrentError, $_iCurrentExtended, Null)
EndFunc
Func _WinAPI_ShowError($sText, $bExit = True)
BlockInput(0)
MsgBox($MB_SYSTEMMODAL, "Error", $sText & "      ")
If $bExit Then Exit
EndFunc
Func _WinAPI_ShowLastError($sText = '', $bAbort = False, $iLanguage = 0, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $sError
Local $iLastError = _WinAPI_GetLastError()
While 1
$sError = _WinAPI_GetErrorMessage($iLastError, $iLanguage)
If @error And $iLanguage Then
$iLanguage = 0
Else
ExitLoop
EndIf
WEnd
If StringStripWS($sText, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sText &= @CRLF & @CRLF
Else
$sText = ''
EndIf
_WinAPI_MsgBox(BitOR(0x00040000, BitShift(0x00000010, -2 * (Not $iLastError))), $iLastError, $sText & $sError)
If $iLastError Then
_WinAPI_SetLastError($iLastError)
If $bAbort Then
Exit $iLastError
EndIf
EndIf
Return SetError($_iCurrentError, $_iCurrentExtended, 1)
EndFunc
Func _WinAPI_ShowMsg($sText)
_WinAPI_MsgBox($MB_SYSTEMMODAL, "Information", $sText)
EndFunc
Func __COMErrorFormating(ByRef $oCOMError, $sPrefix = @TAB)
Local Const $STR_STRIPTRAILING = 2
Local $sError = "COM Error encountered in " & @ScriptName & " (" & $oCOMError.Scriptline & ") :" & @CRLF &  $sPrefix & "Number        " & @TAB & "= 0x" & Hex($oCOMError.Number, 8) & " (" & $oCOMError.Number & ")" & @CRLF &  $sPrefix & "WinDescription" & @TAB & "= " & StringStripWS($oCOMError.WinDescription, $STR_STRIPTRAILING) & @CRLF &  $sPrefix & "Description   " & @TAB & "= " & StringStripWS($oCOMError.Description, $STR_STRIPTRAILING) & @CRLF &  $sPrefix & "Source        " & @TAB & "= " & $oCOMError.Source & @CRLF &  $sPrefix & "HelpFile      " & @TAB & "= " & $oCOMError.HelpFile & @CRLF &  $sPrefix & "HelpContext   " & @TAB & "= " & $oCOMError.HelpContext & @CRLF &  $sPrefix & "LastDllError  " & @TAB & "= " & $oCOMError.LastDllError & @CRLF &  $sPrefix & "Retcode       " & @TAB & "= 0x" & Hex($oCOMError.retcode)
Return $sError
EndFunc
Func _Security__AdjustTokenPrivileges($hToken, $bDisableAll, $tNewState, $iBufferLen, $tPrevState = 0, $pRequired = 0)
Local $aCall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $hToken, "bool", $bDisableAll, "struct*", $tNewState, "dword", $iBufferLen, "struct*", $tPrevState, "struct*", $pRequired)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__CreateProcessWithToken($hToken, $iLogonFlags, $sCommandLine, $iCreationFlags, $sCurDir, $tSTARTUPINFO, $tPROCESS_INFORMATION)
Local $aCall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $hToken, "dword", $iLogonFlags, "ptr", 0, "wstr", $sCommandLine, "dword", $iCreationFlags, "struct*", 0, "wstr", $sCurDir, "struct*", $tSTARTUPINFO, "struct*", $tPROCESS_INFORMATION)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _Security__DuplicateTokenEx($hExistingToken, $iDesiredAccess, $iImpersonationLevel, $iTokenType)
Local $aCall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $hExistingToken, "dword", $iDesiredAccess, "struct*", 0, "int", $iImpersonationLevel, "int", $iTokenType, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[6]
EndFunc
Func _Security__GetAccountSid($sAccount, $sSystem = "")
Local $aAcct = _Security__LookupAccountName($sAccount, $sSystem)
If @error Then Return SetError(@error, @extended, 0)
If IsArray($aAcct) Then Return _Security__StringSidToSid($aAcct[0])
Return ''
EndFunc
Func _Security__GetLengthSid($pSID)
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, @extended, 0)
Local $aCall = DllCall("advapi32.dll", "dword", "GetLengthSid", "struct*", $pSID)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _Security__GetTokenInformation($hToken, $iClass)
Local $aCall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $hToken, "int", $iClass, "struct*", 0, "dword", 0, "dword*", 0)
If @error Or Not $aCall[5] Then Return SetError(@error + 10, @extended, 0)
Local $iLen = $aCall[5]
Local $tBuffer = DllStructCreate("byte[" & $iLen & "]")
$aCall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $hToken, "int", $iClass, "struct*", $tBuffer, "dword", DllStructGetSize($tBuffer), "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $tBuffer
EndFunc
Func _Security__ImpersonateSelf($iLevel = $SECURITYIMPERSONATION)
Local $aCall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $iLevel)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__IsValidSid($pSID)
Local $aCall = DllCall("advapi32.dll", "bool", "IsValidSid", "struct*", $pSID)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__LookupAccountName($sAccount, $sSystem = "")
Local $tData = DllStructCreate("byte SID[256]")
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $sSystem, "wstr", $sAccount, "struct*", $tData, "dword*", DllStructGetSize($tData), "wstr", "", "dword*", DllStructGetSize($tData), "int*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $aAcct[3]
$aAcct[0] = _Security__SidToStringSid(DllStructGetPtr($tData, "SID"))
$aAcct[1] = $aCall[5]
$aAcct[2] = $aCall[7]
Return $aAcct
EndFunc
Func _Security__LookupAccountSid($vSID, $sSystem = "")
Local $pSID, $aAcct[3]
If IsString($vSID) Then
$pSID = _Security__StringSidToSid($vSID)
Else
$pSID = $vSID
EndIf
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, @extended, 0)
Local $sTypeSystem = "ptr"
If $sSystem Then $sTypeSystem = "wstr"
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", $sTypeSystem, $sSystem, "struct*", $pSID, "wstr", "", "dword*", 65536, "wstr", "", "dword*", 65536, "int*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $aAcct[3]
$aAcct[0] = $aCall[3]
$aAcct[1] = $aCall[5]
$aAcct[2] = $aCall[7]
Return $aAcct
EndFunc
Func _Security__LookupPrivilegeValue($sSystem, $sName)
Local $aCall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $sSystem, "wstr", $sName, "int64*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenProcessToken($hProcess, $iAccess)
Local $aCall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hProcess, "dword", $iAccess, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenThreadToken($iAccess, $hThread = 0, $bOpenAsSelf = False)
If $hThread = 0 Then
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error + 10, @extended, 0)
$hThread = $aResult[0]
EndIf
Local $aCall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hThread, "dword", $iAccess, "bool", $bOpenAsSelf, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[4]
EndFunc
Func _Security__OpenThreadTokenEx($iAccess, $hThread = 0, $bOpenAsSelf = False)
Local $hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then
Local Const $ERROR_NO_TOKEN = 1008
If _WinAPI_GetLastError() <> $ERROR_NO_TOKEN Then Return SetError(20, _WinAPI_GetLastError(), 0)
If Not _Security__ImpersonateSelf() Then Return SetError(@error + 10, _WinAPI_GetLastError(), 0)
$hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then Return SetError(@error, _WinAPI_GetLastError(), 0)
EndIf
Return $hToken
EndFunc
Func _Security__SetPrivilege($hToken, $sPrivilege, $bEnable)
Local $iLUID = _Security__LookupPrivilegeValue("", $sPrivilege)
If $iLUID = 0 Then Return SetError(@error + 10, @extended, False)
Local Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Local $tCurrState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iCurrState = DllStructGetSize($tCurrState)
Local $tPrevState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iPrevState = DllStructGetSize($tPrevState)
Local $tRequired = DllStructCreate("int Data")
DllStructSetData($tCurrState, "Count", 1)
DllStructSetData($tCurrState, "LUID", $iLUID)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tCurrState, $iCurrState, $tPrevState, $tRequired) Then Return SetError(2, @error, False)
DllStructSetData($tPrevState, "Count", 1)
DllStructSetData($tPrevState, "LUID", $iLUID)
Local $iAttributes = DllStructGetData($tPrevState, "Attributes")
If $bEnable Then
$iAttributes = BitOR($iAttributes, $SE_PRIVILEGE_ENABLED)
Else
$iAttributes = BitAND($iAttributes, BitNOT($SE_PRIVILEGE_ENABLED))
EndIf
DllStructSetData($tPrevState, "Attributes", $iAttributes)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tPrevState, $iPrevState, $tCurrState, $tRequired) Then  Return SetError(3, @error, False)
Return True
EndFunc
Func _Security__SetTokenInformation($hToken, $iTokenInformation, $vTokenInformation, $iTokenInformationLength)
Local $aCall = DllCall("advapi32.dll", "bool", "SetTokenInformation", "handle", $hToken, "int", $iTokenInformation, "struct*", $vTokenInformation, "dword", $iTokenInformationLength)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _Security__SidToStringSid($pSID)
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, 0, "")
Local $aCall = DllCall("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $pSID, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, "")
Local $pStringSid = $aCall[2]
Local $aLen = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $pStringSid)
Local $sSID = DllStructGetData(DllStructCreate("wchar Text[" & $aLen[0] + 1 & "]", $pStringSid), "Text")
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pStringSid)
Return $sSID
EndFunc
Func _Security__SidTypeStr($iType)
Switch $iType
Case $SIDTYPEUSER
Return "User"
Case $SIDTYPEGROUP
Return "Group"
Case $SIDTYPEDOMAIN
Return "Domain"
Case $SIDTYPEALIAS
Return "Alias"
Case $SIDTYPEWELLKNOWNGROUP
Return "Well Known Group"
Case $SIDTYPEDELETEDACCOUNT
Return "Deleted Account"
Case $SIDTYPEINVALID
Return "Invalid"
Case $SIDTYPEUNKNOWN
Return "Unknown Type"
Case $SIDTYPECOMPUTER
Return "Computer"
Case $SIDTYPELABEL
Return "A mandatory integrity label SID"
Case Else
Return "Unknown SID Type"
EndSwitch
EndFunc
Func _Security__StringSidToSid($sSID)
Local $aCall = DllCall("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $sSID, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $pSID = $aCall[2]
Local $tBuffer = DllStructCreate("byte Data[" & _Security__GetLengthSid($pSID) & "]", $pSID)
Local $tSID = DllStructCreate("byte Data[" & DllStructGetSize($tBuffer) & "]")
DllStructSetData($tSID, "Data", DllStructGetData($tBuffer, "Data"))
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pSID)
Return $tSID
EndFunc
Global Const $tagPOINT = "struct;long X;long Y;endstruct"
Global Const $tagRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagSIZE = "struct;long X;long Y;endstruct"
Global Const $tagMARGINS = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $tagFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagTIME_ZONE_INFORMATION = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $tagCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" &  "int Indent;lparam Param"
Global Const $tagNMCBEDRAGBEGIN = $tagNMHDR & ";int ItemID;wchar szText[260]"
Global Const $tagNMCBEENDEDIT = $tagNMHDR & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $tagNMCOMBOBOXEX = $tagNMHDR & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" &  "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $tagDTPRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" &  "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" &  "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $tagNMDATETIMECHANGE = $tagNMHDR & ";dword Flag;" & $tagSYSTEMTIME
Global Const $tagNMDATETIMEFORMAT = $tagNMHDR & ";ptr Format;" & $tagSYSTEMTIME & ";ptr pDisplay;wchar Display[64]"
Global Const $tagNMDATETIMEFORMATQUERY = $tagNMHDR & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $tagNMDATETIMEKEYDOWN = $tagNMHDR & ";int VirtKey;ptr Format;" & $tagSYSTEMTIME
Global Const $tagNMDATETIMESTRING = $tagNMHDR & ";ptr UserString;" & $tagSYSTEMTIME & ";dword Flags"
Global Const $tagEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" &  "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" &  "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $tagGDIP_EFFECTPARAMS_Blur = "float Radius; bool ExpandEdge"
Global Const $tagGDIP_EFFECTPARAMS_BrightnessContrast = "int BrightnessLevel; int ContrastLevel"
Global Const $tagGDIP_EFFECTPARAMS_ColorBalance = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $tagGDIP_EFFECTPARAMS_ColorCurve = "int Adjustment; int Channel; int AdjustValue"
Global Const $tagGDIP_EFFECTPARAMS_ColorLUT = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $tagGDIP_EFFECTPARAMS_HueSaturationLightness = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $tagGDIP_EFFECTPARAMS_Levels = "int Highlight; int Midtone; int Shadow"
Global Const $tagGDIP_EFFECTPARAMS_RedEyeCorrection = "uint NumberOfAreas; ptr Areas"
Global Const $tagGDIP_EFFECTPARAMS_Sharpen = "float Radius; float Amount"
Global Const $tagGDIP_EFFECTPARAMS_Tint = "int Hue; int Amount"
Global Const $tagGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $tagGDIPCOLORMATRIX = "float m[25]"
Global Const $tagGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $tagGDIPENCODERPARAMS = "uint Count;" & $tagGDIPENCODERPARAM
Global Const $tagGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $tagGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $tagGDIPSTARTUPOUTPUT = "ptr HookProc;ptr UnhookProc"
Global Const $tagGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" &  "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $tagGDIPPENCODERPARAMS = "uint Count;byte Params[1]"
Global Const $tagHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $tagNMHDDISPINFO = $tagNMHDR & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $tagNMHDFILTERBTNCLICK = $tagNMHDR & ";int Item;" & $tagRECT
Global Const $tagNMHEADER = $tagNMHDR & ";int Item;int Button;ptr pItem"
Global Const $tagGETIPAddress = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $tagNMIPADDRESS = $tagNMHDR & ";int Field;int Value"
Global Const $tagLVFINDINFO = "struct;uint Flags;ptr Text;lparam Param;" & $tagPOINT & ";uint Direction;endstruct"
Global Const $tagLVHITTESTINFO = $tagPOINT & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $tagLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" &  "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $tagNMLISTVIEW = $tagNMHDR & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" &  "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $tagNMLVCUSTOMDRAW = "struct;" & $tagNMHDR & ";dword dwDrawStage;handle hdc;" & $tagRECT &  ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" &  ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" &  "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagNMLVDISPINFO = $tagNMHDR & ";" & $tagLVITEM
Global Const $tagNMLVFINDITEM = $tagNMHDR & ";int Start;" & $tagLVFINDINFO
Global Const $tagNMLVGETINFOTIP = $tagNMHDR & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $tagNMITEMACTIVATE = $tagNMHDR & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" &  $tagPOINT & ";lparam lParam;uint KeyFlags"
Global Const $tagNMLVKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagNMLVSCROLL = $tagNMHDR & ";int DX;int DY"
Global Const $tagMCHITTESTINFO = "uint Size;" & $tagPOINT & ";uint Hit;" & $tagSYSTEMTIME &  ";" & $tagRECT & ";int iOffset;int iRow;int iCol"
Global Const $tagMCMONTHRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds;short Span"
Global Const $tagMCRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $tagMCSELRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds"
Global Const $tagNMDAYSTATE = $tagNMHDR & ";" & $tagSYSTEMTIME & ";int DayState;ptr pDayState"
Global Const $tagNMSELCHANGE = $tagNMHDR &  ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" &  "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $tagNMOBJECTNOTIFY = $tagNMHDR & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $tagNMTCKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" &  "int Children;lparam Param;endstruct"
Global Const $tagTVITEMEX = "struct;" & $tagTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $tagNMTREEVIEW = $tagNMHDR & ";uint Action;" &  "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" &  "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" &  "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" &  "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" &  "struct;long PointX;long PointY;endstruct"
Global Const $tagNMTVCUSTOMDRAW = "struct;" & $tagNMHDR & ";dword DrawStage;handle HDC;" & $tagRECT &  ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" &  ";dword ClrText;dword ClrTextBk;int Level"
Global Const $tagNMTVDISPINFO = $tagNMHDR & ";" & $tagTVITEM
Global Const $tagNMTVGETINFOTIP = $tagNMHDR & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $tagNMTVITEMCHANGE = $tagNMHDR & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $tagTVHITTESTINFO = $tagPOINT & ";uint Flags;handle Item"
Global Const $tagNMTVKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagNMMOUSE = $tagNMHDR & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $tagPOINT & ";lparam HitInfo"
Global Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $tagIMAGEINFO = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $tagRECT
Global Const $tagMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $tagMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" &  "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" &  "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" &  "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? "" : ";" & $tagRECT & ";uint uChevronState")
Global Const $tagNMREBARAUTOBREAK = $tagNMHDR & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $tagNMRBAUTOSIZE = $tagNMHDR & ";bool fChanged;" &  "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" &  "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $tagNMREBAR = $tagNMHDR & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $tagNMREBARCHEVRON = $tagNMHDR & ";uint uBand;uint wID;lparam lParam;" & $tagRECT & ";lparam lParamNM"
Global Const $tagNMREBARCHILDSIZE = $tagNMHDR & ";uint uBand;uint wID;" &  "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" &  "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $tagCOLORSCHEME = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $tagNMTOOLBAR = $tagNMHDR & ";int iItem;" &  "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" &  ";int cchText;ptr pszText;" & $tagRECT
Global Const $tagNMTBHOTITEM = $tagNMHDR & ";int idOld;int idNew;dword dwFlags"
Global Const $tagTBBUTTON = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $tagTBBUTTONINFO = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $tagNETRESOURCE = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $tagOVERLAPPED = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $tagOPENFILENAME = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" &  "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" &  "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" &  "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $tagBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" &  "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagBITMAPINFO = $tagBITMAPINFOHEADER & ";dword biRGBQuad[1]"
Global Const $tagBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagWINDOWPLACEMENT = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $tagWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagSCROLLINFO = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $tagSCROLLBARINFO = "dword cbSize;" & $tagRECT & ";int dxyLineButton;int xyThumbTop;" &  "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $tagLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" &  "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagKBDLLHOOKSTRUCT = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $tagPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" &  "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" &  "handle StdOutput;handle StdError"
Global Const $tagSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $tagTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" &  "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" &  "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" &  "byte tmPitchAndFamily;byte tmCharSet"
Global Const $tagMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
Func _MemFree(ByRef $tMemMap)
Local $pMemory = DllStructGetData($tMemMap, "Mem")
Local $hProcess = DllStructGetData($tMemMap, "hProc")
Local $bResult = _MemVirtualFreeEx($hProcess, $pMemory, 0, $MEM_RELEASE)
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $bResult
EndFunc
Func _MemGlobalAlloc($iBytes, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iFlags, "ulong_ptr", $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalFree($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemGlobalLock($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalSize($hMemory)
Local $aResult = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalUnlock($hMemory)
Local $aResult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemInit($hWnd, $iSize, ByRef $tMemMap)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $iProcessID = $aResult[2]
If $iProcessID = 0 Then Return SetError(1, 0, 0)
Local $iAccess = BitOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
Local $hProcess = __Mem_OpenProcess($iAccess, False, $iProcessID, True)
Local $iAlloc = BitOR($MEM_RESERVE, $MEM_COMMIT)
Local $pMemory = _MemVirtualAllocEx($hProcess, 0, $iSize, $iAlloc, $PAGE_READWRITE)
If $pMemory = 0 Then Return SetError(2, 0, 0)
$tMemMap = DllStructCreate($tagMEMMAP)
DllStructSetData($tMemMap, "hProc", $hProcess)
DllStructSetData($tMemMap, "Size", $iSize)
DllStructSetData($tMemMap, "Mem", $pMemory)
Return $pMemory
EndFunc
Func _MemMoveMemory($pSource, $pDest, $iLength)
DllCall("kernel32.dll", "none", "RtlMoveMemory", "struct*", $pDest, "struct*", $pSource, "ulong_ptr", $iLength)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _MemRead(ByRef $tMemMap, $pSrce, $pDest, $iSize)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"),  "ptr", $pSrce, "struct*", $pDest, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemWrite(ByRef $tMemMap, $pSrce, $pDest = 0, $iSize = 0, $sSrce = "struct*")
If $pDest = 0 Then $pDest = DllStructGetData($tMemMap, "Mem")
If $iSize = 0 Then $iSize = DllStructGetData($tMemMap, "Size")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"),  "ptr", $pDest, $sSrce, $pSrce, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualAlloc($pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualAllocEx($hProcess, $pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualFree($pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualFreeEx($hProcess, $pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __Mem_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Global Const $FC_NOOVERWRITE = 0
Global Const $FC_OVERWRITE = 1
Global Const $FC_CREATEPATH = 8
Global Const $FT_MODIFIED = 0
Global Const $FT_CREATED = 1
Global Const $FT_ACCESSED = 2
Global Const $FT_ARRAY = 0
Global Const $FT_STRING = 1
Global Const $FSF_CREATEBUTTON = 1
Global Const $FSF_NEWDIALOG = 2
Global Const $FSF_EDITCONTROL = 4
Global Const $FT_NONRECURSIVE = 0
Global Const $FT_RECURSIVE = 1
Global Const $FO_READ = 0
Global Const $FO_APPEND = 1
Global Const $FO_OVERWRITE = 2
Global Const $FO_CREATEPATH = 8
Global Const $FO_BINARY = 16
Global Const $FO_UNICODE = 32
Global Const $FO_UTF16_LE = 32
Global Const $FO_UTF16_BE = 64
Global Const $FO_UTF8 = 128
Global Const $FO_UTF8_NOBOM = 256
Global Const $FO_ANSI = 512
Global Const $FO_UTF16_LE_NOBOM = 1024
Global Const $FO_UTF16_BE_NOBOM = 2048
Global Const $FO_UTF8_FULL = 16384
Global Const $FO_FULLFILE_DETECT = 16384
Global Const $EOF = -1
Global Const $FD_FILEMUSTEXIST = 1
Global Const $FD_PATHMUSTEXIST = 2
Global Const $FD_MULTISELECT = 4
Global Const $FD_PROMPTCREATENEW = 8
Global Const $FD_PROMPTOVERWRITE = 16
Global Const $CREATE_NEW = 1
Global Const $CREATE_ALWAYS = 2
Global Const $OPEN_EXISTING = 3
Global Const $OPEN_ALWAYS = 4
Global Const $TRUNCATE_EXISTING = 5
Global Const $INVALID_SET_FILE_POINTER = -1
Global Const $FILE_BEGIN = 0
Global Const $FILE_CURRENT = 1
Global Const $FILE_END = 2
Global Const $FILE_ATTRIBUTE_READONLY = 0x00000001
Global Const $FILE_ATTRIBUTE_HIDDEN = 0x00000002
Global Const $FILE_ATTRIBUTE_SYSTEM = 0x00000004
Global Const $FILE_ATTRIBUTE_DIRECTORY = 0x00000010
Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x00000020
Global Const $FILE_ATTRIBUTE_DEVICE = 0x00000040
Global Const $FILE_ATTRIBUTE_NORMAL = 0x00000080
Global Const $FILE_ATTRIBUTE_TEMPORARY = 0x00000100
Global Const $FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200
Global Const $FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400
Global Const $FILE_ATTRIBUTE_COMPRESSED = 0x00000800
Global Const $FILE_ATTRIBUTE_OFFLINE = 0x00001000
Global Const $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000
Global Const $FILE_ATTRIBUTE_ENCRYPTED = 0x00004000
Global Const $FILE_SHARE_READ = 0x00000001
Global Const $FILE_SHARE_WRITE = 0x00000002
Global Const $FILE_SHARE_DELETE = 0x00000004
Global Const $FILE_SHARE_READWRITE = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE)
Global Const $FILE_SHARE_ANY = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE, $FILE_SHARE_DELETE)
Global Const $GENERIC_ALL = 0x10000000
Global Const $GENERIC_EXECUTE = 0x20000000
Global Const $GENERIC_WRITE = 0x40000000
Global Const $GENERIC_READ = 0x80000000
Global Const $GENERIC_READWRITE = BitOR($GENERIC_READ, $GENERIC_WRITE)
Global Const $FILE_ENCODING_UTF16LE = 32
Global Const $FE_ENTIRE_UTF8 = 1
Global Const $FE_PARTIALFIRST_UTF8 = 2
Global Const $FN_FULLPATH = 0
Global Const $FN_RELATIVEPATH = 1
Global Const $FV_COMMENTS = "Comments"
Global Const $FV_COMPANYNAME = "CompanyName"
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FV_FILEVERSION = "FileVersion"
Global Const $FV_INTERNALNAME = "InternalName"
Global Const $FV_LEGALCOPYRIGHT = "LegalCopyright"
Global Const $FV_LEGALTRADEMARKS = "LegalTrademarks"
Global Const $FV_ORIGINALFILENAME = "OriginalFilename"
Global Const $FV_PRODUCTNAME = "ProductName"
Global Const $FV_PRODUCTVERSION = "ProductVersion"
Global Const $FV_PRIVATEBUILD = "PrivateBuild"
Global Const $FV_SPECIALBUILD = "SpecialBuild"
Global Const $FRTA_NOCOUNT = 0
Global Const $FRTA_COUNT = 1
Global Const $FRTA_INTARRAYS = 2
Global Const $FRTA_ENTIRESPLIT = 4
Global Const $FLTA_FILESFOLDERS = 0
Global Const $FLTA_FILES = 1
Global Const $FLTA_FOLDERS = 2
Global Const $FLTAR_FILESFOLDERS = 0
Global Const $FLTAR_FILES = 1
Global Const $FLTAR_FOLDERS = 2
Global Const $FLTAR_NOHIDDEN = 4
Global Const $FLTAR_NOSYSTEM = 8
Global Const $FLTAR_NOLINK = 16
Global Const $FLTAR_NORECUR = 0
Global Const $FLTAR_RECUR = 1
Global Const $FLTAR_NOSORT = 0
Global Const $FLTAR_SORT = 1
Global Const $FLTAR_FASTSORT = 2
Global Const $FLTAR_NOPATH = 0
Global Const $FLTAR_RELPATH = 1
Global Const $FLTAR_FULLPATH = 2
Global Const $PATH_ORIGINAL = 0
Global Const $PATH_DRIVE = 1
Global Const $PATH_DIRECTORY = 2
Global Const $PATH_FILENAME = 3
Global Const $PATH_EXTENSION = 4
#Region Global Variables and Constants
Global $__g_vEnum, $__g_vExt = 0
Global $__g_iRGBMode = 1
Global Const $tagOSVERSIONINFO = 'struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct'
Global Const $IMAGE_BITMAP = 0
Global Const $IMAGE_ICON = 1
Global Const $IMAGE_CURSOR = 2
Global Const $IMAGE_ENHMETAFILE = 3
Global Const $LR_DEFAULTCOLOR = 0x0000
Global Const $LR_MONOCHROME = 0x0001
Global Const $LR_COLOR = 0x0002
Global Const $LR_COPYRETURNORG = 0x0004
Global Const $LR_COPYDELETEORG = 0x0008
Global Const $LR_LOADFROMFILE = 0x0010
Global Const $LR_LOADTRANSPARENT = 0x0020
Global Const $LR_DEFAULTSIZE = 0x0040
Global Const $LR_VGACOLOR = 0x0080
Global Const $LR_LOADMAP3DCOLORS = 0x1000
Global Const $LR_CREATEDIBSECTION = 0x2000
Global Const $LR_COPYFROMRESOURCE = 0x4000
Global Const $LR_SHARED = 0x8000
Global Const $__tagCURSORINFO = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
Global Const $__WINVER = __WINVER()
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateFile($sFileName, $iCreation, $iAccess = 4, $iShare = 0, $iAttributes = 0, $tSecurity = 0)
Local $iDA = 0, $iSM = 0, $iCD = 0, $iFA = 0
If BitAND($iAccess, 1) <> 0 Then $iDA = BitOR($iDA, $GENERIC_EXECUTE)
If BitAND($iAccess, 2) <> 0 Then $iDA = BitOR($iDA, $GENERIC_READ)
If BitAND($iAccess, 4) <> 0 Then $iDA = BitOR($iDA, $GENERIC_WRITE)
If BitAND($iShare, 1) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_DELETE)
If BitAND($iShare, 2) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_READ)
If BitAND($iShare, 4) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_WRITE)
Switch $iCreation
Case 0
$iCD = $CREATE_NEW
Case 1
$iCD = $CREATE_ALWAYS
Case 2
$iCD = $OPEN_EXISTING
Case 3
$iCD = $OPEN_ALWAYS
Case 4
$iCD = $TRUNCATE_EXISTING
EndSwitch
If BitAND($iAttributes, 1) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_ARCHIVE)
If BitAND($iAttributes, 2) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_HIDDEN)
If BitAND($iAttributes, 4) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_READONLY)
If BitAND($iAttributes, 8) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_SYSTEM)
Local $aResult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sFileName, "dword", $iDA, "dword", $iSM,  "struct*", $tSecurity, "dword", $iCD, "dword", $iFA, "ptr", 0)
If @error Or ($aResult[0] = Ptr(-1)) Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FreeLibrary($hModule)
Local $aResult = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hModule)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCursorInfo()
Local $tCursor = DllStructCreate($__tagCURSORINFO)
Local $iCursor = DllStructGetSize($tCursor)
DllStructSetData($tCursor, "Size", $iCursor)
Local $aRet = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tCursor)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aCursor[5]
$aCursor[0] = True
$aCursor[1] = DllStructGetData($tCursor, "Flags") <> 0
$aCursor[2] = DllStructGetData($tCursor, "hCursor")
$aCursor[3] = DllStructGetData($tCursor, "X")
$aCursor[4] = DllStructGetData($tCursor, "Y")
Return $aCursor
EndFunc
Func _WinAPI_GetDlgCtrlID($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetModuleHandle($sModuleName)
Local $sModuleNameType = "wstr"
If $sModuleName = "" Then
$sModuleName = 0
$sModuleNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $sModuleNameType, $sModuleName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetString($pString, $bUnicode = True)
Local $iLength = _WinAPI_StrLen($pString, $bUnicode)
If @error Or Not $iLength Then Return SetError(@error + 10, @extended, '')
Local $tString = DllStructCreate(($bUnicode ? 'wchar' : 'char') & '[' & ($iLength + 1) & ']', $pString)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($iLength, DllStructGetData($tString, 1))
EndFunc
Func _WinAPI_IsWow64Process($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ($__WINVER < 0x0600 ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsWow64Process', 'handle', $hProcess[0], 'bool*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, False)
Return $aRet[2]
EndFunc
Func _WinAPI_LoadImage($hInstance, $sImage, $iType, $iXDesired, $iYDesired, $iLoad)
Local $aResult, $sImageType = "int"
If IsString($sImage) Then $sImageType = "wstr"
$aResult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hInstance, $sImageType, $sImage, "uint", $iType,  "int", $iXDesired, "int", $iYDesired, "uint", $iLoad)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadLibrary($sFileName)
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sFileName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_PathIsDirectory($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsDirectoryW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ReadFile($hFile, $pBuffer, $iToRead, ByRef $iRead, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToRead,  "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[4]
Return $aResult[0]
EndFunc
Func _WinAPI_StrLen($pString, $bUnicode = True)
Local $W = ''
If $bUnicode Then $W = 'W'
Local $aRet = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'struct*', $pString)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SwitchColor($iColor)
If $iColor = -1 Then Return $iColor
Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc
Func _WinAPI_WriteFile($hFile, $pBuffer, $iToWrite, ByRef $iWritten, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToWrite,  "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[4]
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __CheckErrorArrayBounds(Const ByRef $aData, ByRef $iStart, ByRef $iEnd, $nDim = 1, $iDim = $UBOUND_DIMENSIONS)
If Not IsArray($aData) Then Return SetError(1, 0, 1)
If UBound($aData, $iDim) <> $nDim Then Return SetError(2, 0, 1)
If $iStart < 0 Then $iStart = 0
Local $iUBound = UBound($aData) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart > $iEnd Then Return SetError(4, 0, 1)
Return 0
EndFunc
Func __CheckErrorCloseHandle($aRet, $hFile, $bLastError = False, $iCurErr = @error, $iCurExt = @extended)
If Not $iCurErr And Not $aRet[0] Then $iCurErr = 10
Local $aLastError = DllCall("kernel32.dll", "dword", "GetLastError")
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iCurErr Then DllCall("kernel32.dll", "none", "SetLastError", "dword", $aLastError[0])
If $bLastError Then $iCurExt = $aLastError[0]
Return SetError($iCurErr, $iCurExt, $iCurErr)
EndFunc
Func __DLL($sPath, $bPin = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetModuleHandleExW', 'dword', ($bPin ? 0x0001 : 0x0002), "wstr", $sPath, 'ptr*', 0)
If Not $aRet[3] Then
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sPath)
If Not $aResult[0] Then Return 0
EndIf
Return 1
EndFunc
Func __EnumWindowsProc($hWnd, $bVisible)
Local $aResult
If $bVisible Then
$aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If Not $aResult[0] Then
Return 1
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hWnd
$aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
$__g_vEnum[$__g_vEnum[0][0]][1] = $aResult[2]
Return 1
EndFunc
Func __FatalExit($iCode, $sText = '')
If $sText Then MsgBox($MB_SYSTEMMODAL, 'AutoIt', $sText)
DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
EndFunc
Func __Inc(ByRef $aData, $iIncrement = 100)
Select
Case UBound($aData, $UBOUND_COLUMNS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0][0] + 1][UBound($aData, $UBOUND_COLUMNS)]
Else
$aData[0][0] += 1
If $aData[0][0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, $UBOUND_COLUMNS)]
EndIf
EndIf
Case UBound($aData, $UBOUND_ROWS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0] + 1]
Else
$aData[0] += 1
If $aData[0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0] + $iIncrement]
EndIf
EndIf
Case Else
Return 0
EndSelect
Return 1
EndFunc
Func __RGB($iColor)
If $__g_iRGBMode Then
$iColor = _WinAPI_SwitchColor($iColor)
EndIf
Return $iColor
EndFunc
Func __WINVER()
Local $tOSVI = DllStructCreate($tagOSVERSIONINFO)
DllStructSetData($tOSVI, 1, DllStructGetSize($tOSVI))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVI)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return BitOR(BitShift(DllStructGetData($tOSVI, 2), -8), DllStructGetData($tOSVI, 3))
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $DUPLICATE_CLOSE_SOURCE = 0x00000001
Global Const $DUPLICATE_SAME_ACCESS = 0x00000002
Global Const $OBJ_BITMAP = 7
Global Const $OBJ_BRUSH = 2
Global Const $OBJ_COLORSPACE = 14
Global Const $OBJ_DC = 3
Global Const $OBJ_ENHMETADC = 12
Global Const $OBJ_ENHMETAFILE = 13
Global Const $OBJ_EXTPEN = 11
Global Const $OBJ_FONT = 6
Global Const $OBJ_MEMDC = 10
Global Const $OBJ_METADC = 4
Global Const $OBJ_METAFILE = 9
Global Const $OBJ_PAL = 5
Global Const $OBJ_PEN = 1
Global Const $OBJ_REGION = 8
Global Const $NULL_BRUSH = 5
Global Const $NULL_PEN = 8
Global Const $BLACK_BRUSH = 4
Global Const $DKGRAY_BRUSH = 3
Global Const $DC_BRUSH = 18
Global Const $GRAY_BRUSH = 2
Global Const $HOLLOW_BRUSH = $NULL_BRUSH
Global Const $LTGRAY_BRUSH = 1
Global Const $WHITE_BRUSH = 0
Global Const $BLACK_PEN = 7
Global Const $DC_PEN = 19
Global Const $WHITE_PEN = 6
Global Const $ANSI_FIXED_FONT = 11
Global Const $ANSI_VAR_FONT = 12
Global Const $DEVICE_DEFAULT_FONT = 14
Global Const $DEFAULT_GUI_FONT = 17
Global Const $OEM_FIXED_FONT = 10
Global Const $SYSTEM_FONT = 13
Global Const $SYSTEM_FIXED_FONT = 16
Global Const $DEFAULT_PALETTE = 15
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CloseHandle($hObject)
Local $aResult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteObject($hObject)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DuplicateHandle($hSourceProcessHandle, $hSourceHandle, $hTargetProcessHandle, $iDesiredAccess, $iInheritHandle, $iOptions)
Local $aResult = DllCall("kernel32.dll", "bool", "DuplicateHandle",  "handle", $hSourceProcessHandle,  "handle", $hSourceHandle,  "handle", $hTargetProcessHandle,  "handle*", 0,  "dword", $iDesiredAccess,  "bool", $iInheritHandle,  "dword", $iOptions)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
Return $aResult[4]
EndFunc
Func _WinAPI_GetCurrentObject($hDC, $iType)
Local $aRet = DllCall('gdi32.dll', 'handle', 'GetCurrentObject', 'handle', $hDC, 'uint', $iType)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetObject($hObject, $iSize, $pObject)
Local $aResult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hObject, "int", $iSize, "struct*", $pObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetObjectInfoByHandle($hObject)
Local $tagPUBLIC_OBJECT_BASIC_INFORMATION = 'ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]'
Local $tPOBI = DllStructCreate($tagPUBLIC_OBJECT_BASIC_INFORMATION)
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryObject', 'handle', $hObject, 'uint', 0, 'struct*', $tPOBI,  'ulong', DllStructGetSize($tPOBI), 'ptr', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $aResult[4]
For $i = 0 To 3
$aResult[$i] = DllStructGetData($tPOBI, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetObjectNameByHandle($hObject)
Local $tagUNICODE_STRING = 'struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct'
Local $tagPUBLIC_OBJECT_TYPE_INFORMATION = 'struct;' & $tagUNICODE_STRING & ';ulong Reserved[22];endstruct'
Local $tPOTI = DllStructCreate($tagPUBLIC_OBJECT_TYPE_INFORMATION & ';byte[32]')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryObject', 'handle', $hObject, 'uint', 2, 'struct*', $tPOTI,  'ulong', DllStructGetSize($tPOTI), 'ulong*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $pData = DllStructGetData($tPOTI, 3)
If Not $pData Then Return SetError(11, 0, '')
Return _WinAPI_GetString($pData)
EndFunc
Func _WinAPI_GetObjectType($hObject)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetObjectType', 'handle', $hObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetStdHandle($iStdHandle)
If $iStdHandle < 0 Or $iStdHandle > 2 Then Return SetError(2, 0, -1)
Local Const $aHandle[3] = [-10, -11, -12]
Local $aResult = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $aHandle[$iStdHandle])
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_GetStockObject($iObject)
Local $aResult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SelectObject($hDC, $hGDIObj)
Local $aResult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hGDIObj)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetHandleInformation($hObject, $iMask, $iFlags)
Local $aResult = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hObject, "dword", $iMask, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
Global Const $LINGUISTIC_IGNORECASE = 0x00000010
Global Const $LINGUISTIC_IGNOREDIACRITIC = 0x00000020
Global Const $NORM_IGNORECASE = 0x00000001
Global Const $NORM_IGNOREKANATYPE = 0x00010000
Global Const $NORM_IGNORENONSPACE = 0x00000002
Global Const $NORM_IGNORESYMBOLS = 0x00000004
Global Const $NORM_IGNOREWIDTH = 0x00020000
Global Const $NORM_LINGUISTIC_CASING = 0x08000000
Global Const $SORT_DIGITSASNUMBERS = 0x00000008
Global Const $SORT_STRINGSORT = 0x00001000
Global Const $CSTR_LESS_THAN = 1
Global Const $CSTR_EQUAL = 2
Global Const $CSTR_GREATER_THAN = 3
Global Const $MUI_LANGUAGE_ID = 0x0004
Global Const $MUI_LANGUAGE_NAME = 0x0008
Global Const $DATE_AUTOLAYOUT = 0x40
Global Const $DATE_LONGDATE = 0x02
Global Const $DATE_LTRREADING = 0x10
Global Const $DATE_SHORTDATE = 0x01
Global Const $DATE_RTLREADING = 0x20
Global Const $DATE_USE_ALT_CALENDAR = 0x04
Global Const $DATE_YEARMONTH = 0x08
Global Const $GEO_NATION = 1
Global Const $GEO_LATITUDE = 2
Global Const $GEO_LONGITUDE = 3
Global Const $GEO_ISO2 = 4
Global Const $GEO_ISO3 = 5
Global Const $GEO_RFC1766 = 6
Global Const $GEO_LCID = 7
Global Const $GEO_FRIENDLYNAME = 8
Global Const $GEO_OFFICIALNAME = 9
Global Const $GEO_TIMEZONES = 10
Global Const $GEO_OFFICIALLANGUAGES = 11
Global Const $GEO_ISO_UN_NUMBER = 12
Global Const $GEO_PARENT = 13
Global Const $LOCALE_ILANGUAGE = 0x0001
Global Const $LOCALE_SLANGUAGE = 0x0002
Global Const $LOCALE_SENGLANGUAGE = 0x1001
Global Const $LOCALE_SABBREVLANGNAME = 0x0003
Global Const $LOCALE_SNATIVELANGNAME = 0x0004
Global Const $LOCALE_ICOUNTRY = 0x0005
Global Const $LOCALE_SCOUNTRY = 0x0006
Global Const $LOCALE_SENGCOUNTRY = 0x1002
Global Const $LOCALE_SABBREVCTRYNAME = 0x0007
Global Const $LOCALE_SNATIVECTRYNAME = 0x0008
Global Const $LOCALE_IDEFAULTLANGUAGE = 0x0009
Global Const $LOCALE_IDEFAULTCOUNTRY = 0x000A
Global Const $LOCALE_IDEFAULTCODEPAGE = 0x000B
Global Const $LOCALE_IDEFAULTANSICODEPAGE = 0x1004
Global Const $LOCALE_IDEFAULTMACCODEPAGE = 0x1011
Global Const $LOCALE_SLIST = 0x000C
Global Const $LOCALE_IMEASURE = 0x000D
Global Const $LOCALE_SDECIMAL = 0x000E
Global Const $LOCALE_STHOUSAND = 0x000F
Global Const $LOCALE_SGROUPING = 0x0010
Global Const $LOCALE_IDIGITS = 0x0011
Global Const $LOCALE_ILZERO = 0x0012
Global Const $LOCALE_INEGNUMBER = 0x1010
Global Const $LOCALE_SNATIVEDIGITS = 0x0013
Global Const $LOCALE_SCURRENCY = 0x0014
Global Const $LOCALE_SINTLSYMBOL = 0x0015
Global Const $LOCALE_SMONDECIMALSEP = 0x0016
Global Const $LOCALE_SMONTHOUSANDSEP = 0x0017
Global Const $LOCALE_SMONGROUPING = 0x0018
Global Const $LOCALE_ICURRDIGITS = 0x0019
Global Const $LOCALE_IINTLCURRDIGITS = 0x001A
Global Const $LOCALE_ICURRENCY = 0x001B
Global Const $LOCALE_INEGCURR = 0x001C
Global Const $LOCALE_SDATE = 0x001D
Global Const $LOCALE_STIME = 0x001E
Global Const $LOCALE_SSHORTDATE = 0x001F
Global Const $LOCALE_SLONGDATE = 0x0020
Global Const $LOCALE_STIMEFORMAT = 0x1003
Global Const $LOCALE_IDATE = 0x0021
Global Const $LOCALE_ILDATE = 0x0022
Global Const $LOCALE_ITIME = 0x0023
Global Const $LOCALE_ITIMEMARKPOSN = 0x1005
Global Const $LOCALE_ICENTURY = 0x0024
Global Const $LOCALE_ITLZERO = 0x0025
Global Const $LOCALE_IDAYLZERO = 0x0026
Global Const $LOCALE_IMONLZERO = 0x0027
Global Const $LOCALE_S1159 = 0x0028
Global Const $LOCALE_S2359 = 0x0029
Global Const $LOCALE_ICALENDARTYPE = 0x1009
Global Const $LOCALE_IOPTIONALCALENDAR = 0x100B
Global Const $LOCALE_IFIRSTDAYOFWEEK = 0x100C
Global Const $LOCALE_IFIRSTWEEKOFYEAR = 0x100D
Global Const $LOCALE_SDAYNAME1 = 0x002A
Global Const $LOCALE_SDAYNAME2 = 0x002B
Global Const $LOCALE_SDAYNAME3 = 0x002C
Global Const $LOCALE_SDAYNAME4 = 0x002D
Global Const $LOCALE_SDAYNAME5 = 0x002E
Global Const $LOCALE_SDAYNAME6 = 0x002F
Global Const $LOCALE_SDAYNAME7 = 0x0030
Global Const $LOCALE_SABBREVDAYNAME1 = 0x0031
Global Const $LOCALE_SABBREVDAYNAME2 = 0x0032
Global Const $LOCALE_SABBREVDAYNAME3 = 0x0033
Global Const $LOCALE_SABBREVDAYNAME4 = 0x0034
Global Const $LOCALE_SABBREVDAYNAME5 = 0x0035
Global Const $LOCALE_SABBREVDAYNAME6 = 0x0036
Global Const $LOCALE_SABBREVDAYNAME7 = 0x0037
Global Const $LOCALE_SMONTHNAME1 = 0x0038
Global Const $LOCALE_SMONTHNAME2 = 0x0039
Global Const $LOCALE_SMONTHNAME3 = 0x003A
Global Const $LOCALE_SMONTHNAME4 = 0x003B
Global Const $LOCALE_SMONTHNAME5 = 0x003C
Global Const $LOCALE_SMONTHNAME6 = 0x003D
Global Const $LOCALE_SMONTHNAME7 = 0x003E
Global Const $LOCALE_SMONTHNAME8 = 0x003F
Global Const $LOCALE_SMONTHNAME9 = 0x0040
Global Const $LOCALE_SMONTHNAME10 = 0x0041
Global Const $LOCALE_SMONTHNAME11 = 0x0042
Global Const $LOCALE_SMONTHNAME12 = 0x0043
Global Const $LOCALE_SMONTHNAME13 = 0x100E
Global Const $LOCALE_SABBREVMONTHNAME1 = 0x0044
Global Const $LOCALE_SABBREVMONTHNAME2 = 0x0045
Global Const $LOCALE_SABBREVMONTHNAME3 = 0x0046
Global Const $LOCALE_SABBREVMONTHNAME4 = 0x0047
Global Const $LOCALE_SABBREVMONTHNAME5 = 0x0048
Global Const $LOCALE_SABBREVMONTHNAME6 = 0x0049
Global Const $LOCALE_SABBREVMONTHNAME7 = 0x004A
Global Const $LOCALE_SABBREVMONTHNAME8 = 0x004B
Global Const $LOCALE_SABBREVMONTHNAME9 = 0x004C
Global Const $LOCALE_SABBREVMONTHNAME10 = 0x004D
Global Const $LOCALE_SABBREVMONTHNAME11 = 0x004E
Global Const $LOCALE_SABBREVMONTHNAME12 = 0x004F
Global Const $LOCALE_SABBREVMONTHNAME13 = 0x100F
Global Const $LOCALE_SPOSITIVESIGN = 0x0050
Global Const $LOCALE_SNEGATIVESIGN = 0x0051
Global Const $LOCALE_IPOSSIGNPOSN = 0x0052
Global Const $LOCALE_INEGSIGNPOSN = 0x0053
Global Const $LOCALE_IPOSSYMPRECEDES = 0x0054
Global Const $LOCALE_IPOSSEPBYSPACE = 0x0055
Global Const $LOCALE_INEGSYMPRECEDES = 0x0056
Global Const $LOCALE_INEGSEPBYSPACE = 0x0057
Global Const $LOCALE_FONTSIGNATURE = 0x0058
Global Const $LOCALE_SISO639LANGNAME = 0x0059
Global Const $LOCALE_SISO3166CTRYNAME = 0x005A
Global Const $LOCALE_IDEFAULTEBCDICCODEPAGE = 0x1012
Global Const $LOCALE_IPAPERSIZE = 0x100A
Global Const $LOCALE_SENGCURRNAME = 0x1007
Global Const $LOCALE_SNATIVECURRNAME = 0x1008
Global Const $LOCALE_SYEARMONTH = 0x1006
Global Const $LOCALE_SSORTNAME = 0x1013
Global Const $LOCALE_IDIGITSUBSTITUTION = 0x1014
Global Const $LOCALE_CUSTOM_DEFAULT = 0x0C00
Global Const $LOCALE_CUSTOM_UI_DEFAULT = 0x1400
Global Const $LOCALE_CUSTOM_UNSPECIFIED = 0x1000
Global Const $LOCALE_INVARIANT = 0x007F
Global Const $LOCALE_SYSTEM_DEFAULT = 0x0800
Global Const $LOCALE_USER_DEFAULT = 0x0400
Global Const $TIME_FORCE24HOURFORMAT = 0x08
Global Const $TIME_NOMINUTESORSECONDS = 0x01
Global Const $TIME_NOSECONDS = 0x02
Global Const $TIME_NOTIMEMARKER = 0x04
Global Const $LCID_INSTALLED = 1
Global Const $LCID_SUPPORTED = 2
#Region Global Variables and Constants
Global Const $tagNUMBERFMT = 'uint NumDigits;uint LeadingZero;uint Grouping;ptr DecimalSep;ptr ThousandSep;uint NegativeOrder'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CompareString($iLCID, $sString1, $sString2, $iFlags = 0)
Local $aRet = DllCall('kernel32.dll', 'int', 'CompareStringW', 'dword', $iLCID, 'dword', $iFlags, 'wstr', $sString1,  'int', -1, 'wstr', $sString2, 'int', -1)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateNumberFormatInfo($iNumDigits, $iLeadingZero, $iGrouping, $sDecimalSep, $sThousandSep, $iNegativeOrder)
Local $tFMT = DllStructCreate($tagNUMBERFMT & ';wchar[' & (StringLen($sDecimalSep) + 1) & '];wchar[' & (StringLen($sThousandSep) + 1) & ']')
DllStructSetData($tFMT, 1, $iNumDigits)
DllStructSetData($tFMT, 2, $iLeadingZero)
DllStructSetData($tFMT, 3, $iGrouping)
DllStructSetData($tFMT, 4, DllStructGetPtr($tFMT, 7))
DllStructSetData($tFMT, 5, DllStructGetPtr($tFMT, 8))
DllStructSetData($tFMT, 6, $iNegativeOrder)
DllStructSetData($tFMT, 7, $sDecimalSep)
DllStructSetData($tFMT, 8, $sThousandSep)
Return $tFMT
EndFunc
Func _WinAPI_EnumSystemGeoID()
Local $hEnumProc = DllCallbackRegister('__EnumGeoIDProc', 'bool', 'long')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumSystemGeoID', 'dword', 16, 'long', 0, 'ptr', DllCallbackGetPtr($hEnumProc))
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumSystemLocales($iFlag)
Local $hEnumProc = DllCallbackRegister('__EnumLocalesProc', 'bool', 'ptr')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumSystemLocalesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'dword', $iFlag)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumUILanguages($iFlag = 0)
Local $hEnumProc = DllCallbackRegister('__EnumUILanguagesProc', 'bool', 'ptr;long_ptr')
Local $iID = 1
If $__WINVER >= 0x0600 Then
If BitAND($iFlag, 0x0008) Then
$iID = 0
EndIf
Else
$iFlag = 0
EndIf
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumUILanguagesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'dword', $iFlag,  'long_ptr', $iID)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_GetDateFormat($iLCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetDateFormatW', 'dword', $iLCID, 'dword', $iFlags, 'struct*', $tSYSTEMTIME,  $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetDurationFormat($iLCID, $iDuration, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $pST, $iVal
If IsDllStruct($iDuration) Then
$pST = DllStructGetPtr($iDuration)
$iVal = 0
Else
$pST = 0
$iVal = $iDuration
EndIf
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetDurationFormat', 'dword', $iLCID, 'dword', 0, 'ptr', $pST, 'uint64', $iVal,  $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[6]
EndFunc
Func _WinAPI_GetGeoInfo($iGEOID, $iType, $iLanguage = 0)
Local $aRet = DllCall('kernel32.dll', 'int', 'GetGeoInfoW', 'long', $iGEOID, 'dword', $iType, 'wstr', '', 'int', 4096,  'word', $iLanguage)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_GetLocaleInfo($iLCID, $iType)
Local $aRet = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'dword', $iLCID, 'dword', $iType, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetNumberFormat($iLCID, $sNumber, $tNUMBERFMT = 0)
If Not $iLCID Then $iLCID = 0x0400
Local $aRet = DllCall('kernel32.dll', 'int', 'GetNumberFormatW', 'dword', $iLCID, 'dword', 0, 'wstr', $sNumber,  'struct*', $tNUMBERFMT, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetSystemDefaultLangID()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetSystemDefaultLangID')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetSystemDefaultLCID()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetSystemDefaultLCID')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetSystemDefaultUILanguage()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetSystemDefaultUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetThreadLocale()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetThreadLocale')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetThreadUILanguage()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetThreadUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTimeFormat($iLCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetTimeFormatW', 'dword', $iLCID, 'dword', $iFlags, 'struct*', $tSYSTEMTIME,  $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetUserDefaultLangID()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetUserDefaultLangID')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserDefaultLCID()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetUserDefaultLCID')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserDefaultUILanguage()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetUserDefaultUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserGeoID()
Local $aRet = DllCall('kernel32.dll', 'long', 'GetUserGeoID', 'uint', 16)
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_IsValidLocale($iLCID, $iFlag = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsValidLocale', 'dword', $iLCID, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetLocaleInfo($iLCID, $iType, $sData)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetLocaleInfoW', 'dword', $iLCID, 'dword', $iType, 'wstr', $sData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetThreadLocale($iLCID)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetThreadLocale', 'dword', $iLCID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetThreadUILanguage($iLanguage)
Local $aRet = DllCall('kernel32.dll', 'word', 'SetThreadUILanguage', 'word', $iLanguage)
If @error Then Return SetError(@error, @extended, False)
Return ($aRet[0] = $aRet[1])
EndFunc
Func _WinAPI_SetUserGeoID($iGEOID)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetUserGeoID', 'long', $iGEOID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __EnumGeoIDProc($iID)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = $iID
Return 1
EndFunc
Func __EnumLocalesProc($pLocale)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = Dec(DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pLocale) + 1) & ']', $pLocale), 1))
Return 1
EndFunc
Func __EnumUILanguagesProc($pLanguage, $iID)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pLanguage) + 1) & ']', $pLanguage), 1)
If $iID Then
$__g_vEnum[$__g_vEnum[0]] = Dec($__g_vEnum[$__g_vEnum[0]])
EndIf
Return 1
EndFunc
#EndRegion Internal Functions
Func _DateAdd($sType, $iNumber, $sDate)
Local $asTimePart[4]
Local $asDatePart[4]
Local $iJulianDate
$sType = StringLeft($sType, 1)
If StringInStr("D,M,Y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not StringIsInt($iNumber) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sDate) Then
Return SetError(3, 0, 0)
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If $sType = "d" Or $sType = "w" Then
If $sType = "w" Then $iNumber = $iNumber * 7
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iNumber
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
EndIf
If $sType = "m" Then
$asDatePart[2] = $asDatePart[2] + $iNumber
While $asDatePart[2] > 12
$asDatePart[2] = $asDatePart[2] - 12
$asDatePart[1] = $asDatePart[1] + 1
WEnd
While $asDatePart[2] < 1
$asDatePart[2] = $asDatePart[2] + 12
$asDatePart[1] = $asDatePart[1] - 1
WEnd
EndIf
If $sType = "y" Then
$asDatePart[1] = $asDatePart[1] + $iNumber
EndIf
If $sType = "h" Or $sType = "n" Or $sType = "s" Then
Local $iTimeVal = _TimeToTicks($asTimePart[1], $asTimePart[2], $asTimePart[3]) / 1000
If $sType = "h" Then $iTimeVal = $iTimeVal + $iNumber * 3600
If $sType = "n" Then $iTimeVal = $iTimeVal + $iNumber * 60
If $sType = "s" Then $iTimeVal = $iTimeVal + $iNumber
Local $iDay2Add = Int($iTimeVal / (24 * 60 * 60))
$iTimeVal = $iTimeVal - $iDay2Add * 24 * 60 * 60
If $iTimeVal < 0 Then
$iDay2Add = $iDay2Add - 1
$iTimeVal = $iTimeVal + 24 * 60 * 60
EndIf
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iDay2Add
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
_TicksToTime($iTimeVal * 1000, $asTimePart[1], $asTimePart[2], $asTimePart[3])
EndIf
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $iNumDays[$asDatePart[2]] < $asDatePart[3] Then $asDatePart[3] = $iNumDays[$asDatePart[2]]
$sDate = $asDatePart[1] & '/' & StringRight("0" & $asDatePart[2], 2) & '/' & StringRight("0" & $asDatePart[3], 2)
If $asTimePart[0] > 0 Then
If $asTimePart[0] > 2 Then
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2) & ':' & StringRight("0" & $asTimePart[3], 2)
Else
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2)
EndIf
EndIf
Return $sDate
EndFunc
Func _DateDayOfWeek($iDayNum, $iFormat = Default)
Local Const $MONDAY_IS_NO1 = 128
If $iFormat = Default Then $iFormat = 0
$iDayNum = Int($iDayNum)
If $iDayNum < 1 Or $iDayNum > 7 Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", BitAND($iFormat, $MONDAY_IS_NO1) ? 2007 : 2006)
DllStructSetData($tSYSTEMTIME, "Month", 1)
DllStructSetData($tSYSTEMTIME, "Day", $iDayNum)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "ddd" : "dddd")
EndFunc
Func _DateDaysInMonth($iYear, $iMonthNum)
$iMonthNum = Int($iMonthNum)
$iYear = Int($iYear)
Return __DateIsMonth($iMonthNum) And __DateIsYear($iYear) ? _DaysInMonth($iYear)[$iMonthNum] : SetError(1, 0, 0)
EndFunc
Func _DateDiff($sType, $sStartDate, $sEndDate)
$sType = StringLeft($sType, 1)
If StringInStr("d,m,y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not _DateIsValid($sStartDate) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sEndDate) Then
Return SetError(3, 0, 0)
EndIf
Local $asStartDatePart[4], $asStartTimePart[4], $asEndDatePart[4], $asEndTimePart[4]
_DateTimeSplit($sStartDate, $asStartDatePart, $asStartTimePart)
_DateTimeSplit($sEndDate, $asEndDatePart, $asEndTimePart)
Local $aDaysDiff = _DateToDayValue($asEndDatePart[1], $asEndDatePart[2], $asEndDatePart[3]) - _DateToDayValue($asStartDatePart[1], $asStartDatePart[2], $asStartDatePart[3])
Local $iTimeDiff, $iYearDiff, $iStartTimeInSecs, $iEndTimeInSecs
If $asStartTimePart[0] > 1 And $asEndTimePart[0] > 1 Then
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $iTimeDiff < 0 Then
$aDaysDiff = $aDaysDiff - 1
$iTimeDiff = $iTimeDiff + 24 * 60 * 60
EndIf
Else
$iTimeDiff = 0
EndIf
Select
Case $sType = "d"
Return $aDaysDiff
Case $sType = "m"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
Local $iMonthDiff = $asEndDatePart[2] - $asStartDatePart[2] + $iYearDiff * 12
If $asEndDatePart[3] < $asStartDatePart[3] Then $iMonthDiff = $iMonthDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iMonthDiff = $iMonthDiff - 1
Return $iMonthDiff
Case $sType = "y"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
If $asEndDatePart[2] < $asStartDatePart[2] Then $iYearDiff = $iYearDiff - 1
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] < $asStartDatePart[3] Then $iYearDiff = $iYearDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iYearDiff = $iYearDiff - 1
Return $iYearDiff
Case $sType = "w"
Return Int($aDaysDiff / 7)
Case $sType = "h"
Return $aDaysDiff * 24 + Int($iTimeDiff / 3600)
Case $sType = "n"
Return $aDaysDiff * 24 * 60 + Int($iTimeDiff / 60)
Case $sType = "s"
Return $aDaysDiff * 24 * 60 * 60 + $iTimeDiff
EndSelect
EndFunc
Func _DateIsLeapYear($iYear)
If StringIsInt($iYear) Then
Select
Case Mod($iYear, 4) = 0 And Mod($iYear, 100) <> 0
Return 1
Case Mod($iYear, 400) = 0
Return 1
Case Else
Return 0
EndSelect
EndIf
Return SetError(1, 0, 0)
EndFunc
Func __DateIsMonth($iNumber)
$iNumber = Int($iNumber)
Return $iNumber >= 1 And $iNumber <= 12
EndFunc
Func _DateIsValid($sDate)
Local $asDatePart[4], $asTimePart[4]
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If Not StringIsInt($asDatePart[1]) Then Return 0
If Not StringIsInt($asDatePart[2]) Then Return 0
If Not StringIsInt($asDatePart[3]) Then Return 0
$asDatePart[1] = Int($asDatePart[1])
$asDatePart[2] = Int($asDatePart[2])
$asDatePart[3] = Int($asDatePart[3])
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $asDatePart[1] < 1000 Or $asDatePart[1] > 2999 Then Return 0
If $asDatePart[2] < 1 Or $asDatePart[2] > 12 Then Return 0
If $asDatePart[3] < 1 Or $asDatePart[3] > $iNumDays[$asDatePart[2]] Then Return 0
If $asTimePart[0] < 1 Then Return 1
If $asTimePart[0] < 2 Then Return 0
If $asTimePart[0] = 2 Then $asTimePart[3] = "00"
If Not StringIsInt($asTimePart[1]) Then Return 0
If Not StringIsInt($asTimePart[2]) Then Return 0
If Not StringIsInt($asTimePart[3]) Then Return 0
$asTimePart[1] = Int($asTimePart[1])
$asTimePart[2] = Int($asTimePart[2])
$asTimePart[3] = Int($asTimePart[3])
If $asTimePart[1] < 0 Or $asTimePart[1] > 23 Then Return 0
If $asTimePart[2] < 0 Or $asTimePart[2] > 59 Then Return 0
If $asTimePart[3] < 0 Or $asTimePart[3] > 59 Then Return 0
Return 1
EndFunc
Func __DateIsYear($iNumber)
Return StringLen($iNumber) = 4
EndFunc
Func _DateLastWeekdayNum($iWeekdayNum)
Select
Case Not StringIsInt($iWeekdayNum)
Return SetError(1, 0, 0)
Case $iWeekdayNum < 1 Or $iWeekdayNum > 7
Return SetError(2, 0, 0)
Case Else
Local $iLastWeekdayNum
If $iWeekdayNum = 1 Then
$iLastWeekdayNum = 7
Else
$iLastWeekdayNum = $iWeekdayNum - 1
EndIf
Return $iLastWeekdayNum
EndSelect
EndFunc
Func _DateLastMonthNum($iMonthNum)
Select
Case Not StringIsInt($iMonthNum)
Return SetError(1, 0, 0)
Case Not __DateIsMonth($iMonthNum)
Return SetError(2, 0, 0)
Case Else
Local $iLastMonthNum
If $iMonthNum = 1 Then
$iLastMonthNum = 12
Else
$iLastMonthNum = $iMonthNum - 1
EndIf
$iLastMonthNum = StringFormat("%02d", $iLastMonthNum)
Return $iLastMonthNum
EndSelect
EndFunc
Func _DateLastMonthYear($iMonthNum, $iYear)
Select
Case Not StringIsInt($iMonthNum) Or Not StringIsInt($iYear)
Return SetError(1, 0, 0)
Case Not __DateIsMonth($iMonthNum)
Return SetError(2, 0, 0)
Case Else
Local $iLastYear
If $iMonthNum = 1 Then
$iLastYear = $iYear - 1
Else
$iLastYear = $iYear
EndIf
$iLastYear = StringFormat("%04d", $iLastYear)
Return $iLastYear
EndSelect
EndFunc
Func _DateNextWeekdayNum($iWeekdayNum)
Select
Case Not StringIsInt($iWeekdayNum)
Return SetError(1, 0, 0)
Case $iWeekdayNum < 1 Or $iWeekdayNum > 7
Return SetError(2, 0, 0)
Case Else
Local $iNextWeekdayNum
If $iWeekdayNum = 7 Then
$iNextWeekdayNum = 1
Else
$iNextWeekdayNum = $iWeekdayNum + 1
EndIf
Return $iNextWeekdayNum
EndSelect
EndFunc
Func _DateNextMonthNum($iMonthNum)
Select
Case Not StringIsInt($iMonthNum)
Return SetError(1, 0, 0)
Case Not __DateIsMonth($iMonthNum)
Return SetError(2, 0, 0)
Case Else
Local $iNextMonthNum
If $iMonthNum = 12 Then
$iNextMonthNum = 1
Else
$iNextMonthNum = $iMonthNum + 1
EndIf
$iNextMonthNum = StringFormat("%02d", $iNextMonthNum)
Return $iNextMonthNum
EndSelect
EndFunc
Func _DateNextMonthYear($iMonthNum, $iYear)
Select
Case Not StringIsInt($iMonthNum) Or Not StringIsInt($iYear)
Return SetError(1, 0, 0)
Case Not __DateIsMonth($iMonthNum)
Return SetError(2, 0, 0)
Case Else
Local $iNextYear
If $iMonthNum = 12 Then
$iNextYear = $iYear + 1
Else
$iNextYear = $iYear
EndIf
$iNextYear = StringFormat("%04d", $iNextYear)
Return $iNextYear
EndSelect
EndFunc
Func _DateTimeFormat($sDate, $sType)
Local $asDatePart[4], $asTimePart[4]
Local $sTempDate = "", $sTempTime = ""
Local $sAM, $sPM, $sTempString = ""
If Not _DateIsValid($sDate) Then
Return SetError(1, 0, "")
EndIf
If $sType < 0 Or $sType > 5 Or Not IsInt($sType) Then
Return SetError(2, 0, "")
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
Switch $sType
Case 0
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not ($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not ($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 1
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SLONGDATE)
If Not @error And Not ($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "dddd, MMMM dd, yyyy"
EndIf
Case 2
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not ($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
Case 3
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not ($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 4
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm"
EndIf
Case 5
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm:ss"
EndIf
EndSwitch
If $sTempDate <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SDATE)
If Not @error And Not ($sTempString = '') Then
$sTempDate = StringReplace($sTempDate, "/", $sTempString)
EndIf
Local $iWday = _DateToDayOfWeek($asDatePart[1], $asDatePart[2], $asDatePart[3])
$asDatePart[3] = StringRight("0" & $asDatePart[3], 2)
$asDatePart[2] = StringRight("0" & $asDatePart[2], 2)
$sTempDate = StringReplace($sTempDate, "d", "@")
$sTempDate = StringReplace($sTempDate, "m", "#")
$sTempDate = StringReplace($sTempDate, "y", "&")
$sTempDate = StringReplace($sTempDate, "@@@@", _DateDayOfWeek($iWday, 0))
$sTempDate = StringReplace($sTempDate, "@@@", _DateDayOfWeek($iWday, 1))
$sTempDate = StringReplace($sTempDate, "@@", $asDatePart[3])
$sTempDate = StringReplace($sTempDate, "@", StringReplace(StringLeft($asDatePart[3], 1), "0", "") & StringRight($asDatePart[3], 1))
$sTempDate = StringReplace($sTempDate, "####", _DateToMonth($asDatePart[2], 0))
$sTempDate = StringReplace($sTempDate, "###", _DateToMonth($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "##", $asDatePart[2])
$sTempDate = StringReplace($sTempDate, "#", StringReplace(StringLeft($asDatePart[2], 1), "0", "") & StringRight($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "&&&&", $asDatePart[1])
$sTempDate = StringReplace($sTempDate, "&&", StringRight($asDatePart[1], 2))
EndIf
If $sTempTime <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S1159)
If Not @error And Not ($sTempString = '') Then
$sAM = $sTempString
Else
$sAM = "AM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S2359)
If Not @error And Not ($sTempString = '') Then
$sPM = $sTempString
Else
$sPM = "PM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIME)
If Not @error And Not ($sTempString = '') Then
$sTempTime = StringReplace($sTempTime, ":", $sTempString)
EndIf
If StringInStr($sTempTime, "tt") Then
If $asTimePart[1] < 12 Then
$sTempTime = StringReplace($sTempTime, "tt", $sAM)
If $asTimePart[1] = 0 Then $asTimePart[1] = 12
Else
$sTempTime = StringReplace($sTempTime, "tt", $sPM)
If $asTimePart[1] > 12 Then $asTimePart[1] = $asTimePart[1] - 12
EndIf
EndIf
$asTimePart[1] = StringRight("0" & $asTimePart[1], 2)
$asTimePart[2] = StringRight("0" & $asTimePart[2], 2)
$asTimePart[3] = StringRight("0" & $asTimePart[3], 2)
$sTempTime = StringReplace($sTempTime, "hh", StringFormat("%02d", $asTimePart[1]))
$sTempTime = StringReplace($sTempTime, "h", StringReplace(StringLeft($asTimePart[1], 1), "0", "") & StringRight($asTimePart[1], 1))
$sTempTime = StringReplace($sTempTime, "mm", StringFormat("%02d", $asTimePart[2]))
$sTempTime = StringReplace($sTempTime, "ss", StringFormat("%02d", $asTimePart[3]))
$sTempDate = StringStripWS($sTempDate & " " & $sTempTime, $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndIf
Return $sTempDate
EndFunc
Func _DateTimeSplit($sDate, ByRef $aDatePart, ByRef $iTimePart)
Local $sDateTime = StringSplit($sDate, " T")
If $sDateTime[0] > 0 Then $aDatePart = StringSplit($sDateTime[1], "/-.")
If $sDateTime[0] > 1 Then
$iTimePart = StringSplit($sDateTime[2], ":")
If UBound($iTimePart) < 4 Then ReDim $iTimePart[4]
Else
Dim $iTimePart[4]
EndIf
If UBound($aDatePart) < 4 Then ReDim $aDatePart[4]
For $x = 1 To 3
If StringIsInt($aDatePart[$x]) Then
$aDatePart[$x] = Int($aDatePart[$x])
Else
$aDatePart[$x] = -1
EndIf
If StringIsInt($iTimePart[$x]) Then
$iTimePart[$x] = Int($iTimePart[$x])
Else
$iTimePart[$x] = 0
EndIf
Next
Return 1
EndFunc
Func _DateToDayOfWeek($iYear, $iMonth, $iDay)
If Not _DateIsValid($iYear & "/" & $iMonth & "/" & $iDay) Then
Return SetError(1, 0, "")
EndIf
Local $i_FactorA = Int((14 - $iMonth) / 12)
Local $i_FactorY = $iYear - $i_FactorA
Local $i_FactorM = $iMonth + (12 * $i_FactorA) - 2
Local $i_FactorD = Mod($iDay + $i_FactorY + Int($i_FactorY / 4) - Int($i_FactorY / 100) + Int($i_FactorY / 400) + Int((31 * $i_FactorM) / 12), 7)
Return $i_FactorD + 1
EndFunc
Func _DateToDayOfWeekISO($iYear, $iMonth, $iDay)
Local $iDow = _DateToDayOfWeek($iYear, $iMonth, $iDay)
If @error Then
Return SetError(1, 0, "")
EndIf
If $iDow >= 2 Then Return $iDow - 1
Return 7
EndFunc
Func _DateToDayValue($iYear, $iMonth, $iDay)
If Not _DateIsValid(StringFormat("%04d/%02d/%02d", $iYear, $iMonth, $iDay)) Then
Return SetError(1, 0, "")
EndIf
If $iMonth < 3 Then
$iMonth = $iMonth + 12
$iYear = $iYear - 1
EndIf
Local $i_FactorA = Int($iYear / 100)
Local $i_FactorB = Int($i_FactorA / 4)
Local $i_FactorC = 2 - $i_FactorA + $i_FactorB
Local $i_FactorE = Int(1461 * ($iYear + 4716) / 4)
Local $i_FactorF = Int(153 * ($iMonth + 1) / 5)
Local $iJulianDate = $i_FactorC + $iDay + $i_FactorE + $i_FactorF - 1524.5
Return $iJulianDate
EndFunc
Func _DateToMonth($iMonNum, $iFormat = Default)
If $iFormat = Default Then $iFormat = 0
$iMonNum = Int($iMonNum)
If Not __DateIsMonth($iMonNum) Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", @YEAR)
DllStructSetData($tSYSTEMTIME, "Month", $iMonNum)
DllStructSetData($tSYSTEMTIME, "Day", 1)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "MMM" : "MMMM")
EndFunc
Func _DayValueToDate($iJulianDate, ByRef $iYear, ByRef $iMonth, ByRef $iDay)
If $iJulianDate < 0 Or Not IsNumber($iJulianDate) Then
Return SetError(1, 0, 0)
EndIf
Local $i_FactorZ = Int($iJulianDate + 0.5)
Local $i_FactorW = Int(($i_FactorZ - 1867216.25) / 36524.25)
Local $i_FactorX = Int($i_FactorW / 4)
Local $i_FactorA = $i_FactorZ + 1 + $i_FactorW - $i_FactorX
Local $i_FactorB = $i_FactorA + 1524
Local $i_FactorC = Int(($i_FactorB - 122.1) / 365.25)
Local $i_FactorD = Int(365.25 * $i_FactorC)
Local $i_FactorE = Int(($i_FactorB - $i_FactorD) / 30.6001)
Local $i_FactorF = Int(30.6001 * $i_FactorE)
$iDay = $i_FactorB - $i_FactorD - $i_FactorF
If $i_FactorE - 1 < 13 Then
$iMonth = $i_FactorE - 1
Else
$iMonth = $i_FactorE - 13
EndIf
If $iMonth < 3 Then
$iYear = $i_FactorC - 4715
Else
$iYear = $i_FactorC - 4716
EndIf
$iYear = StringFormat("%04d", $iYear)
$iMonth = StringFormat("%02d", $iMonth)
$iDay = StringFormat("%02d", $iDay)
Return $iYear & "/" & $iMonth & "/" & $iDay
EndFunc
Func _Date_JulianDayNo($iYear, $iMonth, $iDay)
Local $sFullDate = StringFormat("%04d/%02d/%02d", $iYear, $iMonth, $iDay)
If Not _DateIsValid($sFullDate) Then
Return SetError(1, 0, "")
EndIf
Local $iJDay = 0
Local $aiDaysInMonth = _DaysInMonth($iYear)
For $iCntr = 1 To $iMonth - 1
$iJDay = $iJDay + $aiDaysInMonth[$iCntr]
Next
$iJDay = ($iYear * 1000) + ($iJDay + $iDay)
Return $iJDay
EndFunc
Func _JulianToDate($iJDay, $sSep = "/")
Local $iYear = Int($iJDay / 1000)
Local $iDays = Mod($iJDay, 1000)
Local $iMaxDays = 365
If _DateIsLeapYear($iYear) Then $iMaxDays = 366
If $iDays > $iMaxDays Then
Return SetError(1, 0, "")
EndIf
Local $aiDaysInMonth = _DaysInMonth($iYear)
Local $iMonth = 1
While $iDays > $aiDaysInMonth[$iMonth]
$iDays = $iDays - $aiDaysInMonth[$iMonth]
$iMonth = $iMonth + 1
WEnd
Return StringFormat("%04d%s%02d%s%02d", $iYear, $sSep, $iMonth, $sSep, $iDays)
EndFunc
Func _Now()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, 0)
EndFunc
Func _NowCalc()
Return @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC
EndFunc
Func _NowCalcDate()
Return @YEAR & "/" & @MON & "/" & @MDAY
EndFunc
Func _NowDate()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY, 0)
EndFunc
Func _NowTime($sType = 3)
If $sType < 3 Or $sType > 5 Then $sType = 3
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, $sType)
EndFunc
Func _SetDate($iDay, $iMonth = 0, $iYear = 0)
If $iYear = 0 Then $iYear = @YEAR
If $iMonth = 0 Then $iMonth = @MON
If Not _DateIsValid($iYear & "/" & $iMonth & "/" & $iDay) Then Return 1
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, 0)
DllStructSetData($tSYSTEMTIME, "Day", $iDay)
If $iMonth > 0 Then DllStructSetData($tSYSTEMTIME, "Month", $iMonth)
If $iYear > 0 Then DllStructSetData($tSYSTEMTIME, "Year", $iYear)
Local $iReturn = _Date_Time_SetLocalTime($tSYSTEMTIME)
If @error Then Return SetError(@error + 10, @extended, 0)
Return Int($iReturn)
EndFunc
Func _SetTime($iHour, $iMinute, $iSecond = 0, $iMSeconds = 0)
If $iHour < 0 Or $iHour > 23 Then Return 1
If $iMinute < 0 Or $iMinute > 59 Then Return 1
If $iSecond < 0 Or $iSecond > 59 Then Return 1
If $iMSeconds < 0 Or $iMSeconds > 999 Then Return 1
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, 0)
DllStructSetData($tSYSTEMTIME, "Hour", $iHour)
DllStructSetData($tSYSTEMTIME, "Minute", $iMinute)
If $iSecond > 0 Then DllStructSetData($tSYSTEMTIME, "Second", $iSecond)
If $iMSeconds > 0 Then DllStructSetData($tSYSTEMTIME, "MSeconds", $iMSeconds)
Local $iReturn = _Date_Time_SetLocalTime($tSYSTEMTIME)
If @error Then Return SetError(@error + 10, @extended, 0)
Return Int($iReturn)
EndFunc
Func _TicksToTime($iTicks, ByRef $iHours, ByRef $iMins, ByRef $iSecs)
If Number($iTicks) > 0 Then
$iTicks = Int($iTicks / 1000)
$iHours = Int($iTicks / 3600)
$iTicks = Mod($iTicks, 3600)
$iMins = Int($iTicks / 60)
$iSecs = Mod($iTicks, 60)
Return 1
ElseIf Number($iTicks) = 0 Then
$iHours = 0
$iTicks = 0
$iMins = 0
$iSecs = 0
Return 1
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _TimeToTicks($iHours = @HOUR, $iMins = @MIN, $iSecs = @SEC)
If StringIsInt($iHours) And StringIsInt($iMins) And StringIsInt($iSecs) Then
Local $iTicks = 1000 * ((3600 * $iHours) + (60 * $iMins) + $iSecs)
Return $iTicks
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _WeekNumberISO($iYear = @YEAR, $iMonth = @MON, $iDay = @MDAY)
If $iDay > 31 Or $iDay < 1 Then
Return SetError(1, 0, -1)
ElseIf Not __DateIsMonth($iMonth) Then
Return SetError(2, 0, -1)
ElseIf $iYear < 1 Or $iYear > 2999 Then
Return SetError(3, 0, -1)
EndIf
Local $iDow = _DateToDayOfWeekISO($iYear, $iMonth, $iDay) - 1
Local $iDow0101 = _DateToDayOfWeekISO($iYear, 1, 1) - 1
If ($iMonth = 1 And 3 < $iDow0101 And $iDow0101 < 7 - ($iDay - 1)) Then
$iDow = $iDow0101 - 1
$iDow0101 = _DateToDayOfWeekISO($iYear - 1, 1, 1) - 1
$iMonth = 12
$iDay = 31
$iYear = $iYear - 1
ElseIf ($iMonth = 12 And 30 - ($iDay - 1) < _DateToDayOfWeekISO($iYear + 1, 1, 1) - 1 And _DateToDayOfWeekISO($iYear + 1, 1, 1) - 1 < 4) Then
Return 1
EndIf
Return Int((_DateToDayOfWeekISO($iYear, 1, 1) - 1 < 4) + 4 * ($iMonth - 1) + (2 * ($iMonth - 1) + ($iDay - 1) + $iDow0101 - $iDow + 6) * 36 / 256)
EndFunc
Func _WeekNumber($iYear = @YEAR, $iMonth = @MON, $iDay = @MDAY, $iWeekStart = 1)
If $iDay > 31 Or $iDay < 1 Then
Return SetError(1, 0, -1)
ElseIf Not __DateIsMonth($iMonth) Then
Return SetError(3, 0, -1)
ElseIf $iYear < 1 Or $iYear > 2999 Then
Return SetError(4, 0, -1)
ElseIf $iWeekStart < 1 Or $iWeekStart > 2 Then
Return SetError(2, 0, -1)
EndIf
Local $iStartWeek1, $iEndWeek1
Local $iDow0101 = _DateToDayOfWeekISO($iYear, 1, 1)
Local $iDate = $iYear & '/' & $iMonth & '/' & $iDay
If $iWeekStart = 1 Then
If $iDow0101 = 6 Then
$iStartWeek1 = 0
Else
$iStartWeek1 = -1 * $iDow0101 - 1
EndIf
$iEndWeek1 = $iStartWeek1 + 6
Else
$iStartWeek1 = $iDow0101 * -1
$iEndWeek1 = $iStartWeek1 + 6
EndIf
Local $iStartWeek1ny
Local $iEndWeek1Date = _DateAdd('d', $iEndWeek1, $iYear & '/01/01')
Local $iDow0101ny = _DateToDayOfWeekISO($iYear + 1, 1, 1)
If $iWeekStart = 1 Then
If $iDow0101ny = 6 Then
$iStartWeek1ny = 0
Else
$iStartWeek1ny = -1 * $iDow0101ny - 1
EndIf
Else
$iStartWeek1ny = $iDow0101ny * -1
EndIf
Local $iStartWeek1Dateny = _DateAdd('d', $iStartWeek1ny, $iYear + 1 & '/01/01')
Local $iCurrDateDiff = _DateDiff('d', $iEndWeek1Date, $iDate) - 1
Local $iCurrDateDiffny = _DateDiff('d', $iStartWeek1Dateny, $iDate)
If $iCurrDateDiff >= 0 And $iCurrDateDiffny < 0 Then Return 2 + Int($iCurrDateDiff / 7)
If $iCurrDateDiff < 0 Or $iCurrDateDiffny >= 0 Then Return 1
EndFunc
Func _DaysInMonth($iYear)
Local $aDays = [12, 31, (_DateIsLeapYear($iYear) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
Return $aDays
EndFunc
Func __Date_Time_CloneSystemTime($pSystemTime)
Local $tSystemTime1 = DllStructCreate($tagSYSTEMTIME, $pSystemTime)
Local $tSystemTime2 = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSystemTime2, "Month", DllStructGetData($tSystemTime1, "Month"))
DllStructSetData($tSystemTime2, "Day", DllStructGetData($tSystemTime1, "Day"))
DllStructSetData($tSystemTime2, "Year", DllStructGetData($tSystemTime1, "Year"))
DllStructSetData($tSystemTime2, "Hour", DllStructGetData($tSystemTime1, "Hour"))
DllStructSetData($tSystemTime2, "Minute", DllStructGetData($tSystemTime1, "Minute"))
DllStructSetData($tSystemTime2, "Second", DllStructGetData($tSystemTime1, "Second"))
DllStructSetData($tSystemTime2, "MSeconds", DllStructGetData($tSystemTime1, "MSeconds"))
DllStructSetData($tSystemTime2, "DOW", DllStructGetData($tSystemTime1, "DOW"))
Return $tSystemTime2
EndFunc
Func _Date_Time_CompareFileTime($tFileTime1, $tFileTime2)
Local $aResult = DllCall("kernel32.dll", "long", "CompareFileTime", "struct*", $tFileTime1, "struct*", $tFileTime2)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _Date_Time_DOSDateTimeToFileTime($iFatDate, $iFatTime)
Local $tTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "DosDateTimeToFileTime", "word", $iFatDate, "word", $iFatTime, "struct*", $tTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tTime)
EndFunc
Func _Date_Time_DOSDateToArray($iDosDate)
Local $aDate[3]
$aDate[0] = BitAND($iDosDate, 0x1F)
$aDate[1] = BitAND(BitShift($iDosDate, 5), 0x0F)
$aDate[2] = BitAND(BitShift($iDosDate, 9), 0x3F) + 1980
Return $aDate
EndFunc
Func _Date_Time_DOSDateTimeToArray($iDosDate, $iDosTime)
Local $aDate[6]
$aDate[0] = BitAND($iDosDate, 0x1F)
$aDate[1] = BitAND(BitShift($iDosDate, 5), 0x0F)
$aDate[2] = BitAND(BitShift($iDosDate, 9), 0x3F) + 1980
$aDate[5] = BitAND($iDosTime, 0x1F) * 2
$aDate[4] = BitAND(BitShift($iDosTime, 5), 0x3F)
$aDate[3] = BitAND(BitShift($iDosTime, 11), 0x1F)
Return $aDate
EndFunc
Func _Date_Time_DOSDateTimeToStr($iDosDate, $iDosTime)
Local $aDate = _Date_Time_DOSDateTimeToArray($iDosDate, $iDosTime)
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aDate[0], $aDate[1], $aDate[2], $aDate[3], $aDate[4], $aDate[5])
EndFunc
Func _Date_Time_DOSDateToStr($iDosDate)
Local $aDate = _Date_Time_DOSDateToArray($iDosDate)
Return StringFormat("%02d/%02d/%04d", $aDate[0], $aDate[1], $aDate[2])
EndFunc
Func _Date_Time_DOSTimeToArray($iDosTime)
Local $aTime[3]
$aTime[2] = BitAND($iDosTime, 0x1F) * 2
$aTime[1] = BitAND(BitShift($iDosTime, 5), 0x3F)
$aTime[0] = BitAND(BitShift($iDosTime, 11), 0x1F)
Return $aTime
EndFunc
Func _Date_Time_DOSTimeToStr($iDosTime)
Local $aTime = _Date_Time_DOSTimeToArray($iDosTime)
Return StringFormat("%02d:%02d:%02d", $aTime[0], $aTime[1], $aTime[2])
EndFunc
Func _Date_Time_EncodeFileTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour, $iMinute, $iSecond, $iMSeconds)
Return _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
EndFunc
Func _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Month", $iMonth)
DllStructSetData($tSYSTEMTIME, "Day", $iDay)
DllStructSetData($tSYSTEMTIME, "Year", $iYear)
DllStructSetData($tSYSTEMTIME, "Hour", $iHour)
DllStructSetData($tSYSTEMTIME, "Minute", $iMinute)
DllStructSetData($tSYSTEMTIME, "Second", $iSecond)
DllStructSetData($tSYSTEMTIME, "MSeconds", $iMSeconds)
Return $tSYSTEMTIME
EndFunc
Func _Date_Time_FileTimeToArray(ByRef $tFileTime)
If ((DllStructGetData($tFileTime, 1) + DllStructGetData($tFileTime, 2)) = 0) Then Return SetError(10, 0, 0)
Local $tSYSTEMTIME = _Date_Time_FileTimeToSystemTime($tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return _Date_Time_SystemTimeToArray($tSYSTEMTIME)
EndFunc
Func _Date_Time_FileTimeToStr(ByRef $tFileTime, $iFmt = 0)
Local $aDate = _Date_Time_FileTimeToArray($tFileTime)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $aDate[2], $aDate[0], $aDate[1], $aDate[3], $aDate[4], $aDate[5])
Else
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aDate[0], $aDate[1], $aDate[2], $aDate[3], $aDate[4], $aDate[5])
EndIf
EndFunc
Func _Date_Time_FileTimeToDOSDateTime($tFileTime)
Local $aDate[2]
Local $aResult = DllCall("kernel32.dll", "bool", "FileTimeToDosDateTime", "struct*", $tFileTime, "word*", 0, "word*", 0)
If @error Then Return SetError(@error, @extended, $aDate)
$aDate[0] = $aResult[2]
$aDate[1] = $aResult[3]
Return SetExtended($aResult[0], $aDate)
EndFunc
Func _Date_Time_FileTimeToLocalFileTime($tFileTime)
Local $tLocal = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "FileTimeToLocalFileTime", "struct*", $tFileTime, "struct*", $tLocal)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tLocal)
EndFunc
Func _Date_Time_FileTimeToSystemTime($tFileTime)
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "FileTimeToSystemTime", "struct*", $tFileTime, "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tSystTime)
EndFunc
Func _Date_Time_GetFileTime($hFile)
Local $aDate[3]
$aDate[0] = DllStructCreate($tagFILETIME)
$aDate[1] = DllStructCreate($tagFILETIME)
$aDate[2] = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "GetFileTime", "handle", $hFile, "struct*", $aDate[0], "struct*", $aDate[1], "struct*", $aDate[2])
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $aDate)
EndFunc
Func _Date_Time_GetLocalTime()
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tSystTime
EndFunc
Func _Date_Time_GetSystemTime()
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetSystemTime", "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tSystTime
EndFunc
Func _Date_Time_GetSystemTimeAdjustment()
Local $aInfo[3]
Local $aResult = DllCall("kernel32.dll", "bool", "GetSystemTimeAdjustment", "dword*", 0, "dword*", 0, "bool*", 0)
If @error Then Return SetError(@error, @extended, 0)
$aInfo[0] = $aResult[1]
$aInfo[1] = $aResult[2]
$aInfo[2] = $aResult[3] <> 0
Return SetExtended($aResult[0], $aInfo)
EndFunc
Func _Date_Time_GetSystemTimeAsFileTime()
Local $tFileTime = DllStructCreate($tagFILETIME)
DllCall("kernel32.dll", "none", "GetSystemTimeAsFileTime", "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tFileTime
EndFunc
Func _Date_Time_GetSystemTimes()
Local $aInfo[3]
$aInfo[0] = DllStructCreate($tagFILETIME)
$aInfo[1] = DllStructCreate($tagFILETIME)
$aInfo[2] = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "GetSystemTimes", "struct*", $aInfo[0], "struct*", $aInfo[1], "struct*", $aInfo[2])
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $aInfo)
EndFunc
Func _Date_Time_GetTickCount()
Local $aResult = DllCall("kernel32.dll", "dword", "GetTickCount")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _Date_Time_GetTimeZoneInformation()
Local $tTimeZone = DllStructCreate($tagTIME_ZONE_INFORMATION)
Local $aResult = DllCall("kernel32.dll", "dword", "GetTimeZoneInformation", "struct*", $tTimeZone)
If @error Or $aResult[0] = -1 Then Return SetError(@error, @extended, 0)
Local $aInfo[8]
$aInfo[0] = $aResult[0]
$aInfo[1] = DllStructGetData($tTimeZone, "Bias")
$aInfo[2] = DllStructGetData($tTimeZone, "StdName")
$aInfo[3] = __Date_Time_CloneSystemTime(DllStructGetPtr($tTimeZone, "StdDate"))
$aInfo[4] = DllStructGetData($tTimeZone, "StdBias")
$aInfo[5] = DllStructGetData($tTimeZone, "DayName")
$aInfo[6] = __Date_Time_CloneSystemTime(DllStructGetPtr($tTimeZone, "DayDate"))
$aInfo[7] = DllStructGetData($tTimeZone, "DayBias")
Return $aInfo
EndFunc
Func _Date_Time_LocalFileTimeToFileTime($tLocalTime)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "LocalFileTimeToFileTime", "struct*", $tLocalTime, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_SetFileTime($hFile, $tCreateTime, $tLastAccess, $tLastWrite)
Local $aResult = DllCall("kernel32.dll", "bool", "SetFileTime", "handle", $hFile, "struct*", $tCreateTime, "struct*", $tLastAccess, "struct*", $tLastWrite)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _Date_Time_SetLocalTime($tSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SetLocalTime", "struct*", $tSYSTEMTIME)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, False)
$aResult = DllCall("kernel32.dll", "bool", "SetLocalTime", "struct*", $tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _Date_Time_SetSystemTime($tSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SetSystemTime", "struct*", $tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _Date_Time_SetSystemTimeAdjustment($iAdjustment, $bDisabled)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, False)
_Security__SetPrivilege($hToken, "SeSystemtimePrivilege", True)
Local $iError = @error
Local $iLastError = @extended
Local $bRet = False
If Not @error Then
Local $aResult = DllCall("kernel32.dll", "bool", "SetSystemTimeAdjustment", "dword", $iAdjustment, "bool", $bDisabled)
If @error Then
$iError = @error
$iLastError = @extended
ElseIf $aResult[0] Then
$bRet = True
Else
$iError = 20
$iLastError = _WinAPI_GetLastError()
EndIf
_Security__SetPrivilege($hToken, "SeSystemtimePrivilege", False)
If Not $iError And @error Then $iError = 22
EndIf
_WinAPI_CloseHandle($hToken)
Return SetError($iError, $iLastError, $bRet)
EndFunc
Func _Date_Time_SetTimeZoneInformation($iBias, $sStdName, $tStdDate, $iStdBias, $sDayName, $tDayDate, $iDayBias)
Local $tZoneInfo = DllStructCreate($tagTIME_ZONE_INFORMATION)
DllStructSetData($tZoneInfo, "Bias", $iBias)
DllStructSetData($tZoneInfo, "StdName", $sStdName)
_MemMoveMemory($tStdDate, DllStructGetPtr($tZoneInfo, "StdDate"), DllStructGetSize($tStdDate))
DllStructSetData($tZoneInfo, "StdBias", $iStdBias)
DllStructSetData($tZoneInfo, "DayName", $sDayName)
_MemMoveMemory($tDayDate, DllStructGetPtr($tZoneInfo, "DayDate"), DllStructGetSize($tDayDate))
DllStructSetData($tZoneInfo, "DayBias", $iDayBias)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, False)
_Security__SetPrivilege($hToken, "SeTimeZonePrivilege", True)
Local $iError = @error
Local $iLastError = @extended
Local $bRet = False
If Not @error Then
Local $aResult = DllCall("kernel32.dll", "bool", "SetTimeZoneInformation", "struct*", $tZoneInfo)
If @error Then
$iError = @error
$iLastError = @extended
ElseIf $aResult[0] Then
$iLastError = 0
$bRet = True
Else
$iError = 20
$iLastError = _WinAPI_GetLastError()
EndIf
_Security__SetPrivilege($hToken, "SeTimeZonePrivilege", False)
If Not $iError And @error Then $iError = 22
EndIf
_WinAPI_CloseHandle($hToken)
Return SetError($iError, $iLastError, $bRet)
EndFunc
Func _Date_Time_SystemTimeToArray(ByRef $tSYSTEMTIME)
Local $aInfo[8]
$aInfo[0] = DllStructGetData($tSYSTEMTIME, "Month")
$aInfo[1] = DllStructGetData($tSYSTEMTIME, "Day")
$aInfo[2] = DllStructGetData($tSYSTEMTIME, "Year")
$aInfo[3] = DllStructGetData($tSYSTEMTIME, "Hour")
$aInfo[4] = DllStructGetData($tSYSTEMTIME, "Minute")
$aInfo[5] = DllStructGetData($tSYSTEMTIME, "Second")
$aInfo[6] = DllStructGetData($tSYSTEMTIME, "MSeconds")
$aInfo[7] = DllStructGetData($tSYSTEMTIME, "DOW")
Return $aInfo
EndFunc
Func _Date_Time_SystemTimeToDateStr(ByRef $tSYSTEMTIME, $iFmt = 0)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d", $aInfo[2], $aInfo[0], $aInfo[1])
Else
Return StringFormat("%02d/%02d/%04d", $aInfo[0], $aInfo[1], $aInfo[2])
EndIf
EndFunc
Func _Date_Time_SystemTimeToDateTimeStr(ByRef $tSYSTEMTIME, $iFmt = 0)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $aInfo[2], $aInfo[0], $aInfo[1], $aInfo[3], $aInfo[4], $aInfo[5])
Else
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aInfo[0], $aInfo[1], $aInfo[2], $aInfo[3], $aInfo[4], $aInfo[5])
EndIf
EndFunc
Func _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SystemTimeToFileTime", "struct*", $tSYSTEMTIME, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_SystemTimeToTimeStr(ByRef $tSYSTEMTIME)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
Return StringFormat("%02d:%02d:%02d", $aInfo[3], $aInfo[4], $aInfo[5])
EndFunc
Func _Date_Time_SystemTimeToTzSpecificLocalTime($tUTC, $tTimeZone = 0)
Local $tLocalTime = DllStructCreate($tagSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SystemTimeToTzSpecificLocalTime", "struct*", $tTimeZone, "struct*", $tUTC, "struct*", $tLocalTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tLocalTime)
EndFunc
Func _Date_Time_TzSpecificLocalTimeToSystemTime($tLocalTime, $tTimeZone = 0)
Local $tUTC = DllStructCreate($tagSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "TzSpecificLocalTimeToSystemTime", "struct*", $tTimeZone, "struct*", $tLocalTime, "struct*", $tUTC)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tUTC)
EndFunc
Global Const $ES_LEFT = 0
Global Const $ES_CENTER = 1
Global Const $ES_RIGHT = 2
Global Const $ES_MULTILINE = 4
Global Const $ES_UPPERCASE = 8
Global Const $ES_LOWERCASE = 16
Global Const $ES_PASSWORD = 32
Global Const $ES_AUTOVSCROLL = 64
Global Const $ES_AUTOHSCROLL = 128
Global Const $ES_NOHIDESEL = 256
Global Const $ES_OEMCONVERT = 1024
Global Const $ES_READONLY = 2048
Global Const $ES_WANTRETURN = 4096
Global Const $ES_NUMBER = 8192
Global Const $EC_ERR = -1
Global Const $ECM_FIRST = 0X1500
Global Const $EM_CANUNDO = 0xC6
Global Const $EM_CHARFROMPOS = 0xD7
Global Const $EM_EMPTYUNDOBUFFER = 0xCD
Global Const $EM_FMTLINES = 0xC8
Global Const $EM_GETCUEBANNER = ($ECM_FIRST + 2)
Global Const $EM_GETFIRSTVISIBLELINE = 0xCE
Global Const $EM_GETHANDLE = 0xBD
Global Const $EM_GETIMESTATUS = 0xD9
Global Const $EM_GETLIMITTEXT = 0xD5
Global Const $EM_GETLINE = 0xC4
Global Const $EM_GETLINECOUNT = 0xBA
Global Const $EM_GETMARGINS = 0xD4
Global Const $EM_GETMODIFY = 0xB8
Global Const $EM_GETPASSWORDCHAR = 0xD2
Global Const $EM_GETRECT = 0xB2
Global Const $EM_GETSEL = 0xB0
Global Const $EM_GETTHUMB = 0xBE
Global Const $EM_GETWORDBREAKPROC = 0xD1
Global Const $EM_HIDEBALLOONTIP = ($ECM_FIRST + 4)
Global Const $EM_LIMITTEXT = 0xC5
Global Const $EM_LINEFROMCHAR = 0xC9
Global Const $EM_LINEINDEX = 0xBB
Global Const $EM_LINELENGTH = 0xC1
Global Const $EM_LINESCROLL = 0xB6
Global Const $EM_POSFROMCHAR = 0xD6
Global Const $EM_REPLACESEL = 0xC2
Global Const $EM_SCROLL = 0xB5
Global Const $EM_SCROLLCARET = 0x00B7
Global Const $EM_SETCUEBANNER = ($ECM_FIRST + 1)
Global Const $EM_SETHANDLE = 0xBC
Global Const $EM_SETIMESTATUS = 0xD8
Global Const $EM_SETLIMITTEXT = $EM_LIMITTEXT
Global Const $EM_SETMARGINS = 0xD3
Global Const $EM_SETMODIFY = 0xB9
Global Const $EM_SETPASSWORDCHAR = 0xCC
Global Const $EM_SETREADONLY = 0xCF
Global Const $EM_SETRECT = 0xB3
Global Const $EM_SETRECTNP = 0xB4
Global Const $EM_SETSEL = 0xB1
Global Const $EM_SETTABSTOPS = 0xCB
Global Const $EM_SETWORDBREAKPROC = 0xD0
Global Const $EM_SHOWBALLOONTIP = ($ECM_FIRST + 3)
Global Const $EM_UNDO = 0xC7
Global Const $EC_LEFTMARGIN = 0x1
Global Const $EC_RIGHTMARGIN = 0x2
Global Const $EC_USEFONTINFO = 0xFFFF
Global Const $EMSIS_COMPOSITIONSTRING = 0x1
Global Const $EIMES_GETCOMPSTRATONCE = 0x1
Global Const $EIMES_CANCELCOMPSTRINFOCUS = 0x2
Global Const $EIMES_COMPLETECOMPSTRKILLFOCUS = 0x4
Global Const $EN_ALIGN_LTR_EC = 0x700
Global Const $EN_ALIGN_RTL_EC = 0x701
Global Const $EN_CHANGE = 0x300
Global Const $EN_ERRSPACE = 0x500
Global Const $EN_HSCROLL = 0X601
Global Const $EN_KILLFOCUS = 0x200
Global Const $EN_MAXTEXT = 0x501
Global Const $EN_SETFOCUS = 0x100
Global Const $EN_UPDATE = 0x400
Global Const $EN_VSCROLL = 0x602
Global Const $GUI_SS_DEFAULT_EDIT = 0x003010c0
Global Const $GUI_SS_DEFAULT_INPUT = 0x00000080
Func _FileCountLines($sFilePath)
FileReadToArray($sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return @extended
EndFunc
Func _FileCreate($sFilePath)
Local $hFileOpen = FileOpen($sFilePath, BitOR($FO_OVERWRITE, $FO_CREATEPATH))
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iFileWrite = FileWrite($hFileOpen, "")
FileClose($hFileOpen)
If Not $iFileWrite Then Return SetError(2, 0, 0)
Return 1
EndFunc
Func _FileListToArray($sFilePath, $sFilter = "*", $iFlag = $FLTA_FILESFOLDERS, $bReturnPath = False)
Local $sDelimiter = "|", $sFileList = "", $sFileName = "", $sFullPath = ""
$sFilePath = StringRegExpReplace($sFilePath, "[\\/]+$", "") & "\"
If $iFlag = Default Then $iFlag = $FLTA_FILESFOLDERS
If $bReturnPath Then $sFullPath = $sFilePath
If $sFilter = Default Then $sFilter = "*"
If Not FileExists($sFilePath) Then Return SetError(1, 0, 0)
If StringRegExp($sFilter, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(2, 0, 0)
If Not ($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 0, 0)
Local $hSearch = FileFindFirstFile($sFilePath & $sFilter)
If @error Then Return SetError(4, 0, 0)
While 1
$sFileName = FileFindNextFile($hSearch)
If @error Then ExitLoop
If ($iFlag + @extended = 2) Then ContinueLoop
$sFileList &= $sDelimiter & $sFullPath & $sFileName
WEnd
FileClose($hSearch)
If $sFileList = "" Then Return SetError(4, 0, 0)
Return StringSplit(StringTrimLeft($sFileList, 1), $sDelimiter)
EndFunc
Func _FileListToArrayRec($sFilePath, $sMask = "*", $iReturn = $FLTAR_FILESFOLDERS, $iRecur = $FLTAR_NORECUR, $iSort = $FLTAR_NOSORT, $iReturnPath = $FLTAR_RELPATH)
If Not FileExists($sFilePath) Then Return SetError(1, 1, "")
If $sMask = Default Then $sMask = "*"
If $iReturn = Default Then $iReturn = $FLTAR_FILESFOLDERS
If $iRecur = Default Then $iRecur = $FLTAR_NORECUR
If $iSort = Default Then $iSort = $FLTAR_NOSORT
If $iReturnPath = Default Then $iReturnPath = $FLTAR_RELPATH
If $iRecur > 1 Or Not IsInt($iRecur) Then Return SetError(1, 6, "")
Local $bLongPath = False
If StringLeft($sFilePath, 4) == "\\?\" Then
$bLongPath = True
EndIf
Local $sFolderSlash = ""
If StringRight($sFilePath, 1) = "\" Then
$sFolderSlash = "\"
Else
$sFilePath = $sFilePath & "\"
EndIf
Local $asFolderSearchList[100] = [1]
$asFolderSearchList[1] = $sFilePath
Local $iHide_HS = 0,  $sHide_HS = ""
If BitAND($iReturn, $FLTAR_NOHIDDEN) Then
$iHide_HS += 2
$sHide_HS &= "H"
$iReturn -= $FLTAR_NOHIDDEN
EndIf
If BitAND($iReturn, $FLTAR_NOSYSTEM) Then
$iHide_HS += 4
$sHide_HS &= "S"
$iReturn -= $FLTAR_NOSYSTEM
EndIf
Local $iHide_Link = 0
If BitAND($iReturn, $FLTAR_NOLINK) Then
$iHide_Link = 0x400
$iReturn -= $FLTAR_NOLINK
EndIf
Local $iMaxLevel = 0
If $iRecur < 0 Then
StringReplace($sFilePath, "\", "", 0, $STR_NOCASESENSEBASIC)
$iMaxLevel = @extended - $iRecur
EndIf
Local $sExclude_List = "", $sExclude_List_Folder = "", $sInclude_List = "*"
Local $aMaskSplit = StringSplit($sMask, "|")
Switch $aMaskSplit[0]
Case 3
$sExclude_List_Folder = $aMaskSplit[3]
ContinueCase
Case 2
$sExclude_List = $aMaskSplit[2]
ContinueCase
Case 1
$sInclude_List = $aMaskSplit[1]
EndSwitch
Local $sInclude_File_Mask = ".+"
If $sInclude_List <> "*" Then
If Not __FLTAR_ListToMask($sInclude_File_Mask, $sInclude_List) Then Return SetError(1, 2, "")
EndIf
Local $sInclude_Folder_Mask = ".+"
Switch $iReturn
Case 0
Switch $iRecur
Case 0
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Case 2
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Local $sExclude_File_Mask = ":"
If $sExclude_List <> "" Then
If Not __FLTAR_ListToMask($sExclude_File_Mask, $sExclude_List) Then Return SetError(1, 3, "")
EndIf
Local $sExclude_Folder_Mask = ":"
If $iRecur Then
If $sExclude_List_Folder Then
If Not __FLTAR_ListToMask($sExclude_Folder_Mask, $sExclude_List_Folder) Then Return SetError(1, 4, "")
EndIf
If $iReturn = 2 Then
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
Else
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
If Not ($iReturn = 0 Or $iReturn = 1 Or $iReturn = 2) Then Return SetError(1, 5, "")
If Not ($iSort = 0 Or $iSort = 1 Or $iSort = 2) Then Return SetError(1, 7, "")
If Not ($iReturnPath = 0 Or $iReturnPath = 1 Or $iReturnPath = 2) Then Return SetError(1, 8, "")
If $iHide_Link Then
Local $tFile_Data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" &  "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
Local $hDLL = DllOpen('kernel32.dll'), $aDLL_Ret
EndIf
Local $asReturnList[100] = [0]
Local $asFileMatchList = $asReturnList, $asRootFileMatchList = $asReturnList, $asFolderMatchList = $asReturnList
Local $bFolder = False,  $hSearch = 0,  $sCurrentPath = "", $sName = "", $sRetPath = ""
Local $iAttribs = 0,  $sAttribs = ''
Local $asFolderFileSectionList[100][2] = [[0, 0]]
While $asFolderSearchList[0] > 0
$sCurrentPath = $asFolderSearchList[$asFolderSearchList[0]]
$asFolderSearchList[0] -= 1
Switch $iReturnPath
Case 1
$sRetPath = StringReplace($sCurrentPath, $sFilePath, "")
Case 2
If $bLongPath Then
$sRetPath = StringTrimLeft($sCurrentPath, 4)
Else
$sRetPath = $sCurrentPath
EndIf
EndSwitch
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'handle', 'FindFirstFileW', 'wstr', $sCurrentPath & "*", 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ContinueLoop
EndIf
$hSearch = $aDLL_Ret[0]
Else
$hSearch = FileFindFirstFile($sCurrentPath & "*")
If $hSearch = -1 Then
ContinueLoop
EndIf
EndIf
If $iReturn = 0 And $iSort And $iReturnPath Then
__FLTAR_AddToList($asFolderFileSectionList, $sRetPath, $asFileMatchList[0] + 1)
EndIf
$sAttribs = ''
While 1
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'int', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ExitLoop
EndIf
$sName = DllStructGetData($tFile_Data, "FileName")
If $sName = ".." Then
ContinueLoop
EndIf
$iAttribs = DllStructGetData($tFile_Data, "FileAttributes")
If $iHide_HS And BitAND($iAttribs, $iHide_HS) Then
ContinueLoop
EndIf
If BitAND($iAttribs, $iHide_Link) Then
ContinueLoop
EndIf
$bFolder = False
If BitAND($iAttribs, 16) Then
$bFolder = True
EndIf
Else
$bFolder = False
$sName = FileFindNextFile($hSearch, 1)
If @error Then
ExitLoop
EndIf
$sAttribs = @extended
If StringInStr($sAttribs, "D") Then
$bFolder = True
EndIf
If StringRegExp($sAttribs, "[" & $sHide_HS & "]") Then
ContinueLoop
EndIf
EndIf
If $bFolder Then
Select
Case $iRecur < 0
StringReplace($sCurrentPath, "\", "", 0, $STR_NOCASESENSEBASIC)
If @extended < $iMaxLevel Then
ContinueCase
EndIf
Case $iRecur = 1
If Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderSearchList, $sCurrentPath & $sName & "\")
EndIf
EndSelect
EndIf
If $iSort Then
If $bFolder Then
If StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderMatchList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
If $sCurrentPath = $sFilePath Then
__FLTAR_AddToList($asRootFileMatchList, $sRetPath & $sName)
Else
__FLTAR_AddToList($asFileMatchList, $sRetPath & $sName)
EndIf
EndIf
EndIf
Else
If $bFolder Then
If $iReturn <> 1 And StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If $iReturn <> 2 And StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName)
EndIf
EndIf
EndIf
WEnd
If $iHide_Link Then
DllCall($hDLL, 'int', 'FindClose', 'ptr', $hSearch)
Else
FileClose($hSearch)
EndIf
WEnd
If $iHide_Link Then
DllClose($hDLL)
EndIf
If $iSort Then
Switch $iReturn
Case 2
If $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
$asReturnList = $asFolderMatchList
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Case 1
If $asRootFileMatchList[0] = 0 And $asFileMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList, 1)
EndIf
Case 0
If $asRootFileMatchList[0] = 0 And $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
$asReturnList[0] += $asFolderMatchList[0]
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
_ArrayConcatenate($asReturnList, $asFolderMatchList, 1)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
Local $asReturnList[$asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0] + 1]
$asReturnList[0] = $asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0]
__ArrayDualPivotSort($asRootFileMatchList, 1, $asRootFileMatchList[0])
For $i = 1 To $asRootFileMatchList[0]
$asReturnList[$i] = $asRootFileMatchList[$i]
Next
Local $iNextInsertionIndex = $asRootFileMatchList[0] + 1
__ArrayDualPivotSort($asFolderMatchList, 1, $asFolderMatchList[0])
Local $sFolderToFind = ""
For $i = 1 To $asFolderMatchList[0]
$asReturnList[$iNextInsertionIndex] = $asFolderMatchList[$i]
$iNextInsertionIndex += 1
If $sFolderSlash Then
$sFolderToFind = $asFolderMatchList[$i]
Else
$sFolderToFind = $asFolderMatchList[$i] & "\"
EndIf
Local $iFileSectionEndIndex = 0, $iFileSectionStartIndex = 0
For $j = 1 To $asFolderFileSectionList[0][0]
If $sFolderToFind = $asFolderFileSectionList[$j][0] Then
$iFileSectionStartIndex = $asFolderFileSectionList[$j][1]
If $j = $asFolderFileSectionList[0][0] Then
$iFileSectionEndIndex = $asFileMatchList[0]
Else
$iFileSectionEndIndex = $asFolderFileSectionList[$j + 1][1] - 1
EndIf
If $iSort = 1 Then
__ArrayDualPivotSort($asFileMatchList, $iFileSectionStartIndex, $iFileSectionEndIndex)
EndIf
For $k = $iFileSectionStartIndex To $iFileSectionEndIndex
$asReturnList[$iNextInsertionIndex] = $asFileMatchList[$k]
$iNextInsertionIndex += 1
Next
ExitLoop
EndIf
Next
Next
EndIf
EndSwitch
Else
If $asReturnList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asReturnList[$asReturnList[0] + 1]
EndIf
Return $asReturnList
EndFunc
Func __FLTAR_AddFileLists(ByRef $asTarget, $asSource_1, $asSource_2, $iSort = 0)
ReDim $asSource_1[$asSource_1[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_1, 1, $asSource_1[0])
$asTarget = $asSource_1
$asTarget[0] += $asSource_2[0]
ReDim $asSource_2[$asSource_2[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_2, 1, $asSource_2[0])
_ArrayConcatenate($asTarget, $asSource_2, 1)
EndFunc
Func __FLTAR_AddToList(ByRef $aList, $vValue_0, $vValue_1 = -1)
If $vValue_1 = -1 Then
$aList[0] += 1
If UBound($aList) <= $aList[0] Then ReDim $aList[UBound($aList) * 2]
$aList[$aList[0]] = $vValue_0
Else
$aList[0][0] += 1
If UBound($aList) <= $aList[0][0] Then ReDim $aList[UBound($aList) * 2][2]
$aList[$aList[0][0]][0] = $vValue_0
$aList[$aList[0][0]][1] = $vValue_1
EndIf
EndFunc
Func __FLTAR_ListToMask(ByRef $sMask, $sList)
If StringRegExp($sList, "\\|/|:|\<|\>|\|") Then Return 0
$sList = StringReplace(StringStripWS(StringRegExpReplace($sList, "\s*;\s*", ";"), BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)), ";", "|")
$sList = StringReplace(StringReplace(StringRegExpReplace($sList, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
$sMask = "(?i)^(" & $sList & ")\z"
Return 1
EndFunc
Func _FilePrint($sFilePath, $iShow = @SW_HIDE)
Return ShellExecute($sFilePath, "", @WorkingDir, "print", $iShow = Default ? @SW_HIDE : $iShow)
EndFunc
Func _FileReadToArray($sFilePath, ByRef $vReturn, $iFlags = $FRTA_COUNT, $sDelimiter = "")
$vReturn = 0
If $iFlags = Default Then $iFlags = $FRTA_COUNT
If $sDelimiter = Default Then $sDelimiter = ""
Local $bExpand = True
If BitAND($iFlags, $FRTA_INTARRAYS) Then
$bExpand = False
$iFlags -= $FRTA_INTARRAYS
EndIf
Local $iEntire = $STR_CHRSPLIT
If BitAND($iFlags, $FRTA_ENTIRESPLIT) Then
$iEntire = $STR_ENTIRESPLIT
$iFlags -= $FRTA_ENTIRESPLIT
EndIf
Local $iNoCount = 0
If $iFlags <> $FRTA_COUNT Then
$iFlags = $FRTA_NOCOUNT
$iNoCount = $STR_NOCOUNT
EndIf
If $sDelimiter Then
Local $aLines = FileReadToArray($sFilePath)
If @error Then Return SetError(@error, 0, 0)
Local $iDim_1 = UBound($aLines) + $iFlags
If $bExpand Then
Local $iDim_2 = UBound(StringSplit($aLines[0], $sDelimiter, $iEntire + $STR_NOCOUNT))
Local $aTemp_Array[$iDim_1][$iDim_2]
Local $iFields,  $aSplit
For $i = 0 To $iDim_1 - $iFlags - 1
$aSplit = StringSplit($aLines[$i], $sDelimiter, $iEntire + $STR_NOCOUNT)
$iFields = UBound($aSplit)
If $iFields <> $iDim_2 Then
Return SetError(3, 0, 0)
EndIf
For $j = 0 To $iFields - 1
$aTemp_Array[$i + $iFlags][$j] = $aSplit[$j]
Next
Next
If $iDim_2 < 2 Then Return SetError(4, 0, 0)
If $iFlags Then
$aTemp_Array[0][0] = $iDim_1 - $iFlags
$aTemp_Array[0][1] = $iDim_2
EndIf
Else
Local $aTemp_Array[$iDim_1]
For $i = 0 To $iDim_1 - $iFlags - 1
$aTemp_Array[$i + $iFlags] = StringSplit($aLines[$i], $sDelimiter, $iEntire + $iNoCount)
Next
If $iFlags Then
$aTemp_Array[0] = $iDim_1 - $iFlags
EndIf
EndIf
$vReturn = $aTemp_Array
Else
If $iFlags Then
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
If StringLen($sFileRead) Then
$vReturn = StringRegExp(@LF & $sFileRead, "(?|(\N+)\z|(\N*)(?:\R))", $STR_REGEXPARRAYGLOBALMATCH)
$vReturn[0] = UBound($vReturn) - 1
Else
Return SetError(2, 0, 0)
EndIf
Else
$vReturn = FileReadToArray($sFilePath)
If @error Then
$vReturn = 0
Return SetError(@error, 0, 0)
EndIf
EndIf
EndIf
Return 1
EndFunc
Func _FileWriteFromArray($sFilePath, Const ByRef $aArray, $iBase = Default, $iUBound = Default, $sDelimiter = "|")
Local $iReturn = 0
If Not IsArray($aArray) Then Return SetError(2, 0, $iReturn)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS)
If $iDims > 2 Then Return SetError(4, 0, 0)
Local $iLast = UBound($aArray) - 1
If $iUBound = Default Or $iUBound > $iLast Then $iUBound = $iLast
If $iBase < 0 Or $iBase = Default Then $iBase = 0
If $iBase > $iUBound Then Return SetError(5, 0, $iReturn)
If $sDelimiter = Default Then $sDelimiter = "|"
Local $hFileOpen = $sFilePath
If IsString($sFilePath) Then
$hFileOpen = FileOpen($sFilePath, $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(1, 0, $iReturn)
EndIf
Local $iError = 0
$iReturn = 1
Switch $iDims
Case 1
For $i = $iBase To $iUBound
If Not FileWrite($hFileOpen, $aArray[$i] & @CRLF) Then
$iError = 3
$iReturn = 0
ExitLoop
EndIf
Next
Case 2
Local $sTemp = ""
For $i = $iBase To $iUBound
$sTemp = $aArray[$i][0]
For $j = 1 To UBound($aArray, $UBOUND_COLUMNS) - 1
$sTemp &= $sDelimiter & $aArray[$i][$j]
Next
If Not FileWrite($hFileOpen, $sTemp & @CRLF) Then
$iError = 3
$iReturn = 0
ExitLoop
EndIf
Next
EndSwitch
If IsString($sFilePath) Then FileClose($hFileOpen)
Return SetError($iError, 0, $iReturn)
EndFunc
Func _FileWriteLog($sLogPath, $sLogMsg, $iFlag = -1)
Local $iOpenMode = $FO_APPEND
Local $sMsg = @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " : " & $sLogMsg
If $iFlag = Default Then $iFlag = -1
If $iFlag <> -1 Then
$iOpenMode = $FO_OVERWRITE
$sMsg &= @CRLF & FileRead($sLogPath)
EndIf
Local $hFileOpen = $sLogPath
If IsString($sLogPath) Then $hFileOpen = FileOpen($sLogPath, $iOpenMode)
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iReturn = FileWriteLine($hFileOpen, $sMsg)
If IsString($sLogPath) Then $iReturn = FileClose($hFileOpen)
If $iReturn <= 0 Then Return SetError(2, $iReturn, 0)
Return $iReturn
EndFunc
Func _FileWriteToLine($sFilePath, $iLine, $sText, $bOverWrite = False, $bFill = False)
If $bOverWrite = Default Then $bOverWrite = False
If $bFill = Default Then $bFill = False
If Not FileExists($sFilePath) Then Return SetError(2, 0, 0)
If $iLine <= 0 Then Return SetError(4, 0, 0)
If Not (IsBool($bOverWrite) Or $bOverWrite = 0 Or $bOverWrite = 1) Then Return SetError(5, 0, 0)
If Not IsString($sText) Then
$sText = String($sText)
If $sText = "" Then Return SetError(6, 0, 0)
EndIf
If Not IsBool($bFill) Then Return SetError(7, 0, 0)
Local $aArray = FileReadToArray($sFilePath)
If @error Then Local $aArray[0]
Local $iUBound = UBound($aArray) - 1
If $bFill Then
If $iUBound < $iLine Then
ReDim $aArray[$iLine]
$iUBound = $iLine - 1
EndIf
Else
If ($iUBound + 1) < $iLine Then Return SetError(1, 0, 0)
EndIf
$aArray[$iLine - 1] = ($bOverWrite ? $sText : $sText & @CRLF & $aArray[$iLine - 1])
Local $sData = ""
For $i = 0 To $iUBound
$sData &= $aArray[$i] & @CRLF
Next
$sData = StringTrimRight($sData, StringLen(@CRLF))
Local $hFileOpen = FileOpen($sFilePath, FileGetEncoding($sFilePath) + $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(3, 0, 0)
FileWrite($hFileOpen, $sData)
FileClose($hFileOpen)
Return 1
EndFunc
Func _PathFull($sRelativePath, $sBasePath = @WorkingDir)
If Not $sRelativePath Or $sRelativePath = "." Then Return $sBasePath
Local $sFullPath = StringReplace($sRelativePath, "/", "\")
Local Const $sFullPathConst = $sFullPath
Local $sPath
Local $bRootOnly = StringLeft($sFullPath, 1) = "\" And StringMid($sFullPath, 2, 1) <> "\"
If $sBasePath = Default Then $sBasePath = @WorkingDir
For $i = 1 To 2
$sPath = StringLeft($sFullPath, 2)
If $sPath = "\\" Then
$sFullPath = StringTrimLeft($sFullPath, 2)
Local $nServerLen = StringInStr($sFullPath, "\") - 1
$sPath = "\\" & StringLeft($sFullPath, $nServerLen)
$sFullPath = StringTrimLeft($sFullPath, $nServerLen)
ExitLoop
ElseIf StringRight($sPath, 1) = ":" Then
$sFullPath = StringTrimLeft($sFullPath, 2)
ExitLoop
Else
$sFullPath = $sBasePath & "\" & $sFullPath
EndIf
Next
If StringLeft($sFullPath, 1) <> "\" Then
If StringLeft($sFullPathConst, 2) = StringLeft($sBasePath, 2) Then
$sFullPath = $sBasePath & "\" & $sFullPath
Else
$sFullPath = "\" & $sFullPath
EndIf
EndIf
Local $aTemp = StringSplit($sFullPath, "\")
Local $aPathParts[$aTemp[0]], $j = 0
For $i = 2 To $aTemp[0]
If $aTemp[$i] = ".." Then
If $j Then $j -= 1
ElseIf Not ($aTemp[$i] = "" And $i <> $aTemp[0]) And $aTemp[$i] <> "." Then
$aPathParts[$j] = $aTemp[$i]
$j += 1
EndIf
Next
$sFullPath = $sPath
If Not $bRootOnly Then
For $i = 0 To $j - 1
$sFullPath &= "\" & $aPathParts[$i]
Next
Else
$sFullPath &= $sFullPathConst
If StringInStr($sFullPath, "..") Then $sFullPath = _PathFull($sFullPath)
EndIf
Do
$sFullPath = StringReplace($sFullPath, ".\", "\")
Until @extended = 0
Return $sFullPath
EndFunc
Func _PathGetRelative($sFrom, $sTo)
If StringRight($sFrom, 1) <> "\" Then $sFrom &= "\"
If StringRight($sTo, 1) <> "\" Then $sTo &= "\"
If $sFrom = $sTo Then Return SetError(1, 0, StringTrimRight($sTo, 1))
Local $asFrom = StringSplit($sFrom, "\")
Local $asTo = StringSplit($sTo, "\")
If $asFrom[1] <> $asTo[1] Then Return SetError(2, 0, StringTrimRight($sTo, 1))
Local $i = 2
Local $iDiff = 1
While 1
If $asFrom[$i] <> $asTo[$i] Then
$iDiff = $i
ExitLoop
EndIf
$i += 1
WEnd
$i = 1
Local $sRelPath = ""
For $j = 1 To $asTo[0]
If $i >= $iDiff Then
$sRelPath &= "\" & $asTo[$i]
EndIf
$i += 1
Next
$sRelPath = StringTrimLeft($sRelPath, 1)
$i = 1
For $j = 1 To $asFrom[0]
If $i > $iDiff Then
$sRelPath = "..\" & $sRelPath
EndIf
$i += 1
Next
If StringRight($sRelPath, 1) == "\" Then $sRelPath = StringTrimRight($sRelPath, 1)
Return $sRelPath
EndFunc
Func _PathMake($sDrive, $sDir, $sFileName, $sExtension)
If StringLen($sDrive) Then
If Not (StringLeft($sDrive, 2) = "\\") Then $sDrive = StringLeft($sDrive, 1) & ":"
EndIf
If StringLen($sDir) Then
If Not (StringRight($sDir, 1) = "\") And Not (StringRight($sDir, 1) = "/") Then $sDir = $sDir & "\"
Else
$sDir = "\"
EndIf
If StringLen($sDir) Then
If Not (StringLeft($sDir, 1) = "\") And Not (StringLeft($sDir, 1) = "/") Then $sDir = "\" & $sDir
EndIf
If StringLen($sExtension) Then
If Not (StringLeft($sExtension, 1) = ".") Then $sExtension = "." & $sExtension
EndIf
Return $sDrive & $sDir & $sFileName & $sExtension
EndFunc
Func _PathSplit($sFilePath, ByRef $sDrive, ByRef $sDir, ByRef $sFileName, ByRef $sExtension)
Local $aArray = StringRegExp($sFilePath, "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$", $STR_REGEXPARRAYMATCH)
If @error Then
ReDim $aArray[5]
$aArray[$PATH_ORIGINAL] = $sFilePath
EndIf
$sDrive = $aArray[$PATH_DRIVE]
If StringLeft($aArray[$PATH_DIRECTORY], 1) == "/" Then
$sDir = StringRegExpReplace($aArray[$PATH_DIRECTORY], "\h*[\/\\]+\h*", "\/")
Else
$sDir = StringRegExpReplace($aArray[$PATH_DIRECTORY], "\h*[\/\\]+\h*", "\\")
EndIf
$aArray[$PATH_DIRECTORY] = $sDir
$sFileName = $aArray[$PATH_FILENAME]
$sExtension = $aArray[$PATH_EXTENSION]
Return $aArray
EndFunc
Func _ReplaceStringInFile($sFilePath, $sSearchString, $sReplaceString, $iCaseSensitive = 0, $iOccurance = 1)
If StringInStr(FileGetAttrib($sFilePath), "R") Then Return SetError(1, 0, -1)
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(2, 0, -1)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
If $iCaseSensitive = Default Then $iCaseSensitive = 0
If $iOccurance = Default Then $iOccurance = 1
$sFileRead = StringReplace($sFileRead, $sSearchString, $sReplaceString, 1 - $iOccurance, $iCaseSensitive)
Local $iReturn = @extended
If $iReturn Then
Local $iFileEncoding = FileGetEncoding($sFilePath)
$hFileOpen = FileOpen($sFilePath, $iFileEncoding + $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(3, 0, -1)
FileWrite($hFileOpen, $sFileRead)
FileClose($hFileOpen)
EndIf
Return $iReturn
EndFunc
Func _TempFile($sDirectoryName = @TempDir, $sFilePrefix = "~", $sFileExtension = ".tmp", $iRandomLength = 7)
If $iRandomLength = Default Or $iRandomLength <= 0 Then $iRandomLength = 7
If $sDirectoryName = Default Or (Not FileExists($sDirectoryName)) Then $sDirectoryName = @TempDir
If $sFileExtension = Default Then $sFileExtension = ".tmp"
If $sFilePrefix = Default Then $sFilePrefix = "~"
If Not FileExists($sDirectoryName) Then $sDirectoryName = @ScriptDir
$sDirectoryName = StringRegExpReplace($sDirectoryName, "[\\/]+$", "")
$sFileExtension = StringRegExpReplace($sFileExtension, "^\.+", "")
$sFilePrefix = StringRegExpReplace($sFilePrefix, '[\\/:*?"<>|]', "")
Local $sTempName = ""
Do
$sTempName = ""
While StringLen($sTempName) < $iRandomLength
$sTempName &= Chr(Random(97, 122, 1))
WEnd
$sTempName = $sDirectoryName & "\" & $sFilePrefix & $sTempName & "." & $sFileExtension
Until Not FileExists($sTempName)
Return $sTempName
EndFunc
Global Const $GDIP_DASHCAPFLAT = 0
Global Const $GDIP_DASHCAPROUND = 2
Global Const $GDIP_DASHCAPTRIANGLE = 3
Global Const $GDIP_DASHSTYLESOLID = 0
Global Const $GDIP_DASHSTYLEDASH = 1
Global Const $GDIP_DASHSTYLEDOT = 2
Global Const $GDIP_DASHSTYLEDASHDOT = 3
Global Const $GDIP_DASHSTYLEDASHDOTDOT = 4
Global Const $GDIP_DASHSTYLECUSTOM = 5
Global Const $GDIP_EPGCHROMINANCETABLE = '{F2E455DC-09B3-4316-8260-676ADA32481C}'
Global Const $GDIP_EPGCOLORDEPTH = '{66087055-AD66-4C7C-9A18-38A2310B8337}'
Global Const $GDIP_EPGCOMPRESSION = '{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}'
Global Const $GDIP_EPGLUMINANCETABLE = '{EDB33BCE-0266-4A77-B904-27216099E717}'
Global Const $GDIP_EPGQUALITY = '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}'
Global Const $GDIP_EPGRENDERMETHOD = '{6D42C53A-229A-4825-8BB7-5C99E2B9A8B8}'
Global Const $GDIP_EPGSAVEFLAG = '{292266FC-AC40-47BF-8CFC-A85B89A655DE}'
Global Const $GDIP_EPGSCANMETHOD = '{3A4E2661-3109-4E56-8536-42C156E7DCFA}'
Global Const $GDIP_EPGTRANSFORMATION = '{8D0EB2D1-A58E-4EA8-AA14-108074B7B6F9}'
Global Const $GDIP_EPGVERSION = '{24D18C76-814A-41A4-BF53-1C219CCCF797}'
Global Const $GDIP_EPTBYTE = 1
Global Const $GDIP_EPTASCII = 2
Global Const $GDIP_EPTSHORT = 3
Global Const $GDIP_EPTLONG = 4
Global Const $GDIP_EPTRATIONAL = 5
Global Const $GDIP_EPTLONGRANGE = 6
Global Const $GDIP_EPTUNDEFINED = 7
Global Const $GDIP_EPTRATIONALRANGE = 8
Global Const $GDIP_ERROK = 0
Global Const $GDIP_ERRGENERICERROR = 1
Global Const $GDIP_ERRINVALIDPARAMETER = 2
Global Const $GDIP_ERROUTOFMEMORY = 3
Global Const $GDIP_ERROBJECTBUSY = 4
Global Const $GDIP_ERRINSUFFICIENTBUFFER = 5
Global Const $GDIP_ERRNOTIMPLEMENTED = 6
Global Const $GDIP_ERRWIN32ERROR = 7
Global Const $GDIP_ERRWRONGSTATE = 8
Global Const $GDIP_ERRABORTED = 9
Global Const $GDIP_ERRFILENOTFOUND = 10
Global Const $GDIP_ERRVALUEOVERFLOW = 11
Global Const $GDIP_ERRACCESSDENIED = 12
Global Const $GDIP_ERRUNKNOWNIMAGEFORMAT = 13
Global Const $GDIP_ERRFONTFAMILYNOTFOUND = 14
Global Const $GDIP_ERRFONTSTYLENOTFOUND = 15
Global Const $GDIP_ERRNOTTRUETYPEFONT = 16
Global Const $GDIP_ERRUNSUPPORTEDGDIVERSION = 17
Global Const $GDIP_ERRGDIPLUSNOTINITIALIZED = 18
Global Const $GDIP_ERRPROPERTYNOTFOUND = 19
Global Const $GDIP_ERRPROPERTYNOTSUPPORTED = 20
Global Const $GDIP_EVTCOMPRESSIONLZW = 2
Global Const $GDIP_EVTCOMPRESSIONCCITT3 = 3
Global Const $GDIP_EVTCOMPRESSIONCCITT4 = 4
Global Const $GDIP_EVTCOMPRESSIONRLE = 5
Global Const $GDIP_EVTCOMPRESSIONNONE = 6
Global Const $GDIP_EVTTRANSFORMROTATE90 = 13
Global Const $GDIP_EVTTRANSFORMROTATE180 = 14
Global Const $GDIP_EVTTRANSFORMROTATE270 = 15
Global Const $GDIP_EVTTRANSFORMFLIPHORIZONTAL = 16
Global Const $GDIP_EVTTRANSFORMFLIPVERTICAL = 17
Global Const $GDIP_EVTMULTIFRAME = 18
Global Const $GDIP_EVTLASTFRAME = 19
Global Const $GDIP_EVTFLUSH = 20
Global Const $GDIP_EVTFRAMEDIMENSIONPAGE = 23
Global Const $GDIP_ICFENCODER = 0x00000001
Global Const $GDIP_ICFDECODER = 0x00000002
Global Const $GDIP_ICFSUPPORTBITMAP = 0x00000004
Global Const $GDIP_ICFSUPPORTVECTOR = 0x00000008
Global Const $GDIP_ICFSEEKABLEENCODE = 0x00000010
Global Const $GDIP_ICFBLOCKINGDECODE = 0x00000020
Global Const $GDIP_ICFBUILTIN = 0x00010000
Global Const $GDIP_ICFSYSTEM = 0x00020000
Global Const $GDIP_ICFUSER = 0x00040000
Global Const $GDIP_ILMREAD = 0x0001
Global Const $GDIP_ILMWRITE = 0x0002
Global Const $GDIP_ILMUSERINPUTBUF = 0x0004
Global Const $GDIP_LINECAPFLAT = 0x00
Global Const $GDIP_LINECAPSQUARE = 0x01
Global Const $GDIP_LINECAPROUND = 0x02
Global Const $GDIP_LINECAPTRIANGLE = 0x03
Global Const $GDIP_LINECAPNOANCHOR = 0x10
Global Const $GDIP_LINECAPSQUAREANCHOR = 0x11
Global Const $GDIP_LINECAPROUNDANCHOR = 0x12
Global Const $GDIP_LINECAPDIAMONDANCHOR = 0x13
Global Const $GDIP_LINECAPARROWANCHOR = 0x14
Global Const $GDIP_LINECAPCUSTOM = 0xFF
Global Const $GDIP_PXF01INDEXED = 0x00030101
Global Const $GDIP_PXF04INDEXED = 0x00030402
Global Const $GDIP_PXF08INDEXED = 0x00030803
Global Const $GDIP_PXF16GRAYSCALE = 0x00101004
Global Const $GDIP_PXF16RGB555 = 0x00021005
Global Const $GDIP_PXF16RGB565 = 0x00021006
Global Const $GDIP_PXF16ARGB1555 = 0x00061007
Global Const $GDIP_PXF24RGB = 0x00021808
Global Const $GDIP_PXF32RGB = 0x00022009
Global Const $GDIP_PXF32ARGB = 0x0026200A
Global Const $GDIP_PXF32PARGB = 0x000E200B
Global Const $GDIP_PXF48RGB = 0x0010300C
Global Const $GDIP_PXF64ARGB = 0x0034400D
Global Const $GDIP_PXF64PARGB = 0x001A400E
Global Const $GDIP_IMAGEFORMAT_UNDEFINED = "{B96B3CA9-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_MEMORYBMP = "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_BMP = "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EMF = "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_WMF = "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_JPEG = "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_PNG = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_GIF = "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_TIFF = "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EXIF = "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_ICON = "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGETYPE_UNKNOWN = 0
Global Const $GDIP_IMAGETYPE_BITMAP = 1
Global Const $GDIP_IMAGETYPE_METAFILE = 2
Global Const $GDIP_IMAGEFLAGS_NONE = 0x0
Global Const $GDIP_IMAGEFLAGS_SCALABLE = 0x0001
Global Const $GDIP_IMAGEFLAGS_HASALPHA = 0x0002
Global Const $GDIP_IMAGEFLAGS_HASTRANSLUCENT = 0x0004
Global Const $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE = 0x0008
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_RGB = 0x0010
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_CMYK = 0x0020
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_GRAY = 0x0040
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR = 0x0080
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCCK = 0x0100
Global Const $GDIP_IMAGEFLAGS_HASREALDPI = 0x1000
Global Const $GDIP_IMAGEFLAGS_HASREALPIXELSIZE = 0x2000
Global Const $GDIP_IMAGEFLAGS_READONLY = 0x00010000
Global Const $GDIP_IMAGEFLAGS_CACHING = 0x00020000
Global Const $GDIP_SMOOTHINGMODE_INVALID = -1
Global Const $GDIP_SMOOTHINGMODE_DEFAULT = 0
Global Const $GDIP_SMOOTHINGMODE_HIGHSPEED = 1
Global Const $GDIP_SMOOTHINGMODE_HIGHQUALITY = 2
Global Const $GDIP_SMOOTHINGMODE_NONE = 3
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X4 = 4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS = $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 5
Global Const $GDIP_RLUM = 0.3086
Global Const $GDIP_GLUM = 0.6094
Global Const $GDIP_BLUM = 0.0820
Global Const $GDIP_INTERPOLATIONMODE_INVALID = -1
Global Const $GDIP_INTERPOLATIONMODE_DEFAULT = 0
Global Const $GDIP_INTERPOLATIONMODE_LOWQUALITY = 1
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITY = 2
Global Const $GDIP_INTERPOLATIONMODE_BILINEAR = 3
Global Const $GDIP_INTERPOLATIONMODE_BICUBIC = 4
Global Const $GDIP_INTERPOLATIONMODE_NEARESTNEIGHBOR = 5
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBILINEAR = 6
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 7
Global Const $GDIP_TEXTRENDERINGHINT_SYSTEMDEFAULT = 0
Global Const $GDIP_TEXTRENDERINGHINT_SINGLEBITPERPIXELGRIDFIT = 1
Global Const $GDIP_TEXTRENDERINGHINT_SINGLEBITPERPIXEL = 2
Global Const $GDIP_TEXTRENDERINGHINT_ANTIALIASGRIDFIT = 3
Global Const $GDIP_TEXTRENDERINGHINT_ANTIALIAS = 4
Global Const $GDIP_TEXTRENDERINGHINT_CLEARTYPEGRIDFIT = 5
Global Const $GDIP_PIXELOFFSETMODE_INVALID = -1
Global Const $GDIP_PIXELOFFSETMODE_DEFAULT = 0
Global Const $GDIP_PIXELOFFSETMODE_HIGHSPEED = 1
Global Const $GDIP_PIXELOFFSETMODE_HIGHQUALITY = 2
Global Const $GDIP_PIXELOFFSETMODE_NONE = 3
Global Const $GDIP_PIXELOFFSETMODE_HALF = 4
Global Const $GDIP_PENSETLINEJOIN_MITER = 0
Global Const $GDIP_PENSETLINEJOIN_BEVEL = 1
Global Const $GDIP_PENSETLINEJOIN_ROUND = 2
Global Const $GDIP_PENSETLINEJOIN_MITERCLIPPED = 3
Global Const $GDIP_FillModeAlternate = 0
Global Const $GDIP_FillModeWinding = 1
Global Const $GDIP_QUALITYMODEINVALID = -1
Global Const $GDIP_QUALITYMODEDEFAULT = 0
Global Const $GDIP_QUALITYMODELOW = 1
Global Const $GDIP_QUALITYMODEHIGH = 2
Global Const $GDIP_COMPOSITINGMODESOURCEOVER = 0
Global Const $GDIP_COMPOSITINGMODESOURCECOPY = 1
Global Const $GDIP_COMPOSITINGQUALITYINVALID = $GDIP_QUALITYMODEINVALID
Global Const $GDIP_COMPOSITINGQUALITYDEFAULT = $GDIP_QUALITYMODEDEFAULT
Global Const $GDIP_COMPOSITINGQUALITYHIGHSPEED = $GDIP_QUALITYMODELOW
Global Const $GDIP_COMPOSITINGQUALITYHIGHQUALITY = $GDIP_QUALITYMODEHIGH
Global Const $GDIP_COMPOSITINGQUALITYGAMMACORRECTED = 3
Global Const $GDIP_COMPOSITINGQUALITYASSUMELINEAR = 4
Global Const $GDIP_HATCHSTYLE_HORIZONTAL = 0
Global Const $GDIP_HATCHSTYLE_VERTICAL = 1
Global Const $GDIP_HATCHSTYLE_FORWARDDIAGONAL = 2
Global Const $GDIP_HATCHSTYLE_BACKWARDDIAGONAL = 3
Global Const $GDIP_HATCHSTYLE_CROSS = 4
Global Const $GDIP_HATCHSTYLE_DIAGONALCROSS = 5
Global Const $GDIP_HATCHSTYLE_05PERCENT = 6
Global Const $GDIP_HATCHSTYLE_10PERCENT = 7
Global Const $GDIP_HATCHSTYLE_20PERCENT = 8
Global Const $GDIP_HATCHSTYLE_25PERCENT = 9
Global Const $GDIP_HATCHSTYLE_30PERCENT = 10
Global Const $GDIP_HATCHSTYLE_40PERCENT = 11
Global Const $GDIP_HATCHSTYLE_50PERCENT = 12
Global Const $GDIP_HATCHSTYLE_60PERCENT = 13
Global Const $GDIP_HATCHSTYLE_70PERCENT = 14
Global Const $GDIP_HATCHSTYLE_75PERCENT = 15
Global Const $GDIP_HATCHSTYLE_80PERCENT = 16
Global Const $GDIP_HATCHSTYLE_90PERCENT = 17
Global Const $GDIP_HATCHSTYLE_LIGHTDOWNWARDDIAGONAL = 18
Global Const $GDIP_HATCHSTYLE_LIGHTUPWARDDIAGONAL = 19
Global Const $GDIP_HATCHSTYLE_DARKDOWNWARDDIAGONAL = 20
Global Const $GDIP_HATCHSTYLE_DARKUPWARDDIAGONAL = 21
Global Const $GDIP_HATCHSTYLE_WIDEDOWNWARDDIAGONAL = 22
Global Const $GDIP_HATCHSTYLE_WIDEUPWARDDIAGONAL = 23
Global Const $GDIP_HATCHSTYLE_LIGHTVERTICAL = 24
Global Const $GDIP_HATCHSTYLE_LIGHTHORIZONTAL = 25
Global Const $GDIP_HATCHSTYLE_NARROWVERTICAL = 26
Global Const $GDIP_HATCHSTYLE_NARROWHORIZONTAL = 27
Global Const $GDIP_HATCHSTYLE_DARKVERTICAL = 28
Global Const $GDIP_HATCHSTYLE_DARKHORIZONTAL = 29
Global Const $GDIP_HATCHSTYLE_DASHEDDOWNWARDDIAGONAL = 30
Global Const $GDIP_HATCHSTYLE_DASHEDUPWARDDIAGONAL = 31
Global Const $GDIP_HATCHSTYLE_DASHEDHORIZONTAL = 32
Global Const $GDIP_HATCHSTYLE_DASHEDVERTICAL = 33
Global Const $GDIP_HATCHSTYLE_SMALLCONFETTI = 34
Global Const $GDIP_HATCHSTYLE_LARGECONFETTI = 35
Global Const $GDIP_HATCHSTYLE_ZIGZAG = 36
Global Const $GDIP_HATCHSTYLE_WAVE = 37
Global Const $GDIP_HATCHSTYLE_DIAGONALBRICK = 38
Global Const $GDIP_HATCHSTYLE_HORIZONTALBRICK = 39
Global Const $GDIP_HATCHSTYLE_WEAVE = 40
Global Const $GDIP_HATCHSTYLE_PLAID = 41
Global Const $GDIP_HATCHSTYLE_DIVOT = 42
Global Const $GDIP_HATCHSTYLE_DOTTEDGRID = 43
Global Const $GDIP_HATCHSTYLE_DOTTEDDIAMOND = 44
Global Const $GDIP_HATCHSTYLE_SHINGLE = 45
Global Const $GDIP_HATCHSTYLE_TRELLIS = 46
Global Const $GDIP_HATCHSTYLE_SPHERE = 47
Global Const $GDIP_HATCHSTYLE_SMALLGRID = 48
Global Const $GDIP_HATCHSTYLE_SMALLCHECKERBOARD = 49
Global Const $GDIP_HATCHSTYLE_LARGECHECKERBOARD = 50
Global Const $GDIP_HATCHSTYLE_OUTLINEDDIAMOND = 51
Global Const $GDIP_HATCHSTYLE_SOLIDDIAMOND = 52
Global Const $GDIP_HATCHSTYLE_TOTAL = 53
Global Const $GDIP_HATCHSTYLE_LARGEGRID = $GDIP_HATCHSTYLE_CROSS
Global Const $GDIP_HATCHSTYLE_MIN = $GDIP_HATCHSTYLE_HORIZONTAL
Global Const $GDIP_HATCHSTYLE_MAX = $GDIP_HATCHSTYLE_TOTAL - 1
Global Const $GDIP_BlurEffectGuid = '{633C80A4-1843-482b-9EF2-BE2834C5FDD4}'
Global Const $GDIP_SharpenEffectGuid = '{63CBF3EE-C526-402c-8F71-62C540BF5142}'
Global Const $GDIP_ColorMatrixEffectGuid = '{718F2615-7933-40e3-A511-5F68FE14DD74}'
Global Const $GDIP_ColorLUTEffectGuid = '{A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}'
Global Const $GDIP_BrightnessContrastEffectGuid = '{D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}'
Global Const $GDIP_HueSaturationLightnessEffectGuid = '{8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}'
Global Const $GDIP_LevelsEffectGuid = '{99C354EC-2A31-4f3a-8C34-17A803B33A25}'
Global Const $GDIP_TintEffectGuid = '{1077AF00-2848-4441-9489-44AD4C2D7A2C}'
Global Const $GDIP_ColorBalanceEffectGuid = '{537E597D-251E-48da-9664-29CA496B70F8}'
Global Const $GDIP_RedEyeCorrectionEffectGuid = '{74D29D05-69A4-4266-9549-3CC52836B632}'
Global Const $GDIP_ColorCurveEffectGuid = '{DD6A0022-58E4-4a67-9D9B-D48EB881A53D}'
Global Const $GDIP_AdjustExposure = 0
Global Const $GDIP_AdjustDensity = 1
Global Const $GDIP_AdjustContrast = 2
Global Const $GDIP_AdjustHighlight = 3
Global Const $GDIP_AdjustShadow = 4
Global Const $GDIP_AdjustMidtone = 5
Global Const $GDIP_AdjustWhiteSaturation = 6
Global Const $GDIP_AdjustBlackSaturation = 7
Global Const $GDIP_CurveChannelAll = 0
Global Const $GDIP_CurveChannelRed = 1
Global Const $GDIP_CurveChannelGreen = 2
Global Const $GDIP_CurveChannelBlue = 3
Global Const $GDIP_PaletteTypeCustom = 0
Global Const $GDIP_PaletteTypeOptimal = 1
Global Const $GDIP_PaletteTypeFixedBW = 2
Global Const $GDIP_PaletteTypeFixedHalftone8 = 3
Global Const $GDIP_PaletteTypeFixedHalftone27 = 4
Global Const $GDIP_PaletteTypeFixedHalftone64 = 5
Global Const $GDIP_PaletteTypeFixedHalftone125 = 6
Global Const $GDIP_PaletteTypeFixedHalftone216 = 7
Global Const $GDIP_PaletteTypeFixedHalftone252 = 8
Global Const $GDIP_PaletteTypeFixedHalftone256 = 9
Global Const $GDIP_PaletteFlagsHasAlpha = 0x0001
Global Const $GDIP_PaletteFlagsGrayScale = 0x0002
Global Const $GDIP_PaletteFlagsHalftone = 0x0004
Global Const $GDIP_DitherTypeNone = 0
Global Const $GDIP_DitherTypeSolid = 1
Global Const $GDIP_DitherTypeOrdered4x4 = 2
Global Const $GDIP_DitherTypeOrdered8x8 = 3
Global Const $GDIP_DitherTypeOrdered16x16 = 4
Global Const $GDIP_DitherTypeOrdered91x91 = 5
Global Const $GDIP_DitherTypeSpiral4x4 = 6
Global Const $GDIP_DitherTypeSpiral8x8 = 7
Global Const $GDIP_DitherTypeDualSpiral4x4 = 8
Global Const $GDIP_DitherTypeDualSpiral8x8 = 9
Global Const $GDIP_DitherTypeErrorDiffusion = 10
Global Const $GDIP_DitherTypeMax = 10
Global Const $GDIP_HistogramFormatARGB = 0
Global Const $GDIP_HistogramFormatPARGB = 1
Global Const $GDIP_HistogramFormatRGB = 2
Global Const $GDIP_HistogramFormatGray = 3
Global Const $GDIP_HistogramFormatB = 4
Global Const $GDIP_HistogramFormatG = 5
Global Const $GDIP_HistogramFormatR = 6
Global Const $GDIP_HistogramFormatA = 7
Global Const $GDIP_TextRenderingHintSystemDefault = 0
Global Const $GDIP_TextRenderingHintSingleBitPerPixelGridFit = 1
Global Const $GDIP_TextRenderingHintSingleBitPerPixel = 2
Global Const $GDIP_TextRenderingHintAntialiasGridFit = 3
Global Const $GDIP_TextRenderingHintAntialias = 4
Global Const $GDIP_TextRenderingHintClearTypeGridFit = 5
Global Const $GDIP_RotateNoneFlipNone = 0
Global Const $GDIP_Rotate90FlipNone = 1
Global Const $GDIP_Rotate180FlipNone = 2
Global Const $GDIP_Rotate270FlipNone = 3
Global Const $GDIP_RotateNoneFlipX = 4
Global Const $GDIP_Rotate90FlipX = 5
Global Const $GDIP_Rotate180FlipX = 6
Global Const $GDIP_Rotate270FlipX = 7
Global Const $GDIP_RotateNoneFlipY = $GDIP_Rotate180FlipX
Global Const $GDIP_Rotate90FlipY = $GDIP_Rotate270FlipX
Global Const $GDIP_Rotate180FlipY = $GDIP_RotateNoneFlipX
Global Const $GDIP_Rotate270FlipY = $GDIP_Rotate90FlipX
Global Const $GDIP_RotateNoneFlipXY = $GDIP_Rotate180FlipNone
Global Const $GDIP_Rotate90FlipXY = $GDIP_Rotate270FlipNone
Global Const $GDIP_Rotate270FlipXY = $GDIP_Rotate90FlipNone
Global Const $GDIP_FRAMEDIMENSION_TIME = "{6AEDBD6D-3FB5-418A-83A6-7F45229DC872}"
Global Const $GDIP_FRAMEDIMENSION_RESOLUTION = "{84236F7B-3BD3-428F-8DAB-4EA1439CA315}"
Global Const $GDIP_FRAMEDIMENSION_PAGE = "{7462DC86-6180-4C7E-8E3F-EE7333A7A483}"
Global Const $GDIP_COLORADJUSTTYPE_DEFAULT = 0
Global Const $GDIP_COLORADJUSTTYPE_BITMAP = 1
Global Const $GDIP_COLORADJUSTTYPE_BRUSH = 2
Global Const $GDIP_COLORADJUSTTYPE_PEN = 3
Global Const $GDIP_COLORADJUSTTYPE_TEXT = 4
Global Const $GDIP_COLORADJUSTTYPE_COUNT = 5
Global Const $GDIP_COLORADJUSTTYPE_ANY = 6
Global Const $COINIT_APARTMENTTHREADED = 0x02
Global Const $COINIT_DISABLE_OLE1DDE = 0x04
Global Const $COINIT_MULTITHREADED = 0x00
Global Const $COINIT_SPEED_OVER_MEMORY = 0x08
#Region Global Variables and Constants
Global Const $__tagWinAPICom_GUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CLSIDFromProgID($sProgID)
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'long', 'CLSIDFromProgID', 'wstr', $sProgID, 'struct*', $tGUID)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
$aReturn = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'struct*', $tGUID, 'wstr', '', 'int', 39)
If @error Or Not $aReturn[0] Then Return SetError(@error + 20, @extended, '')
Return $aReturn[2]
EndFunc
Func _WinAPI_CoInitialize($iFlags = 0)
Local $aReturn = DllCall('ole32.dll', 'long', 'CoInitializeEx', 'ptr', 0, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
Func _WinAPI_CoTaskMemAlloc($iSize)
Local $aReturn = DllCall('ole32.dll', 'ptr', 'CoTaskMemAlloc', 'uint_ptr', $iSize)
If @error Then Return SetError(@error, @extended, 0)
Return $aReturn[0]
EndFunc
Func _WinAPI_CoTaskMemFree($pMemory)
DllCall('ole32.dll', 'none', 'CoTaskMemFree', 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_CoTaskMemRealloc($pMemory, $iSize)
Local $aReturn = DllCall('ole32.dll', 'ptr', 'CoTaskMemRealloc', 'ptr', $pMemory, 'ulong_ptr', $iSize)
If @error Then Return SetError(@error, @extended, 0)
Return $aReturn[0]
EndFunc
Func _WinAPI_CoUninitialize()
DllCall('ole32.dll', 'none', 'CoUninitialize')
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_CreateGUID()
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'long', 'CoCreateGuid', 'struct*', $tGUID)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
$aReturn = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'struct*', $tGUID, 'wstr', '', 'int', 65536)
If @error Or Not $aReturn[0] Then Return SetError(@error + 20, @extended, '')
Return $aReturn[2]
EndFunc
Func _WinAPI_CreateStreamOnHGlobal($hGlobal = 0, $bDeleteOnRelease = True)
Local $aReturn = DllCall('ole32.dll', 'long', 'CreateStreamOnHGlobal', 'handle', $hGlobal, 'bool', $bDeleteOnRelease, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[3]
EndFunc
Func _WinAPI_GetHGlobalFromStream($pStream)
Local $aReturn = DllCall('ole32.dll', 'uint', 'GetHGlobalFromStream', 'ptr', $pStream, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[2]
EndFunc
Func _WinAPI_ProgIDFromCLSID($sCLSID)
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $sCLSID, 'struct*', $tGUID)
If @error Or $aReturn[0] Then Return SetError(@error + 20, @extended, '')
$aReturn = DllCall('ole32.dll', 'uint', 'ProgIDFromCLSID', 'struct*', $tGUID, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
Local $sID = _WinAPI_GetString($aReturn[2])
_WinAPI_CoTaskMemFree($aReturn[2])
Return $sID
EndFunc
Func _WinAPI_ReleaseStream($pStream)
Local $aReturn = DllCall('oleaut32.dll', 'long', 'DispCallFunc', 'ptr', $pStream, 'ulong_ptr', 8 * (1 + @AutoItX64), 'uint', 4,  'ushort', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CharToOem($sStr)
Local $aRet = DllCall('user32.dll', 'bool', 'CharToOemW', 'wstr', $sStr, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_ClientToScreen($hWnd, ByRef $tPoint)
Local $aRet = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hWnd, "struct*", $tPoint)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_DWordToFloat($iValue)
Local $tDWord = DllStructCreate('dword')
Local $tFloat = DllStructCreate('float', DllStructGetPtr($tDWord))
DllStructSetData($tDWord, 1, $iValue)
Return DllStructGetData($tFloat, 1)
EndFunc
Func _WinAPI_DWordToInt($iValue)
Local $tData = DllStructCreate('int')
DllStructSetData($tData, 1, $iValue)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_FloatToDWord($iValue)
Local $tFloat = DllStructCreate('float')
Local $tDWord = DllStructCreate('dword', DllStructGetPtr($tFloat))
DllStructSetData($tFloat, 1, $iValue)
Return DllStructGetData($tDWord, 1)
EndFunc
Func _WinAPI_FloatToInt($nFloat)
Local $tFloat = DllStructCreate("float")
Local $tInt = DllStructCreate("int", DllStructGetPtr($tFloat))
DllStructSetData($tFloat, 1, $nFloat)
Return DllStructGetData($tInt, 1)
EndFunc
Func _WinAPI_GetXYFromPoint(ByRef $tPoint, ByRef $iX, ByRef $iY)
$iX = DllStructGetData($tPoint, "X")
$iY = DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_GUIDFromString($sGUID)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_GUIDFromStringEx($sGUID, $tGUID)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $tGUID
EndFunc
Func _WinAPI_GUIDFromStringEx($sGUID, $tGUID)
Local $aResult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sGUID, "struct*", $tGUID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_HashData($pMemory, $iSize, $iLength = 32)
If ($iLength <= 0) Or ($iLength > 256) Then Return SetError(11, 0, 0)
Local $tData = DllStructCreate('byte[' & $iLength & ']')
Local $aRet = DllCall('shlwapi.dll', 'uint', 'HashData', 'struct*', $pMemory, 'dword', $iSize, 'struct*', $tData, 'dword', $iLength)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_HashString($sString, $bCaseSensitive = True, $iLength = 32)
Local $iLengthS = StringLen($sString)
If Not $iLengthS Or ($iLength > 256) Then Return SetError(12, 0, 0)
Local $tString = DllStructCreate('wchar[' & ($iLengthS + 1) & ']')
If Not $bCaseSensitive Then
$sString = StringLower($sString)
EndIf
DllStructSetData($tString, 1, $sString)
Local $sHash = _WinAPI_HashData($tString, 2 * $iLengthS, $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return $sHash
EndFunc
Func _WinAPI_HiByte($iValue)
Return BitAND(BitShift($iValue, 8), 0xFF)
EndFunc
Func _WinAPI_HiDWord($iValue)
Local $tInt64 = DllStructCreate('int64')
Local $tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))
DllStructSetData($tInt64, 1, $iValue)
Return DllStructGetData($tQWord, 2)
EndFunc
Func _WinAPI_HiWord($iLong)
Return BitShift($iLong, 16)
EndFunc
Func _WinAPI_IntToDWord($iValue)
Local $tData = DllStructCreate('dword')
DllStructSetData($tData, 1, $iValue)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_IntToFloat($iInt)
Local $tInt = DllStructCreate("int")
Local $tFloat = DllStructCreate("float", DllStructGetPtr($tInt))
DllStructSetData($tInt, 1, $iInt)
Return DllStructGetData($tFloat, 1)
EndFunc
Func _WinAPI_LoByte($iValue)
Return BitAND($iValue, 0xFF)
EndFunc
Func _WinAPI_LoDWord($iValue)
Local $tInt64 = DllStructCreate('int64')
Local $tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))
DllStructSetData($tInt64, 1, $iValue)
Return DllStructGetData($tQWord, 1)
EndFunc
Func _WinAPI_LoWord($iLong)
Return BitAND($iLong, 0xFFFF)
EndFunc
Func _WinAPI_LongMid($iValue, $iStart, $iCount)
Return BitAND(BitShift($iValue, $iStart), BitOR(BitShift(BitShift(0x7FFFFFFF, 32 - ($iCount + 1)), 1), BitShift(1, -($iCount - 1))))
EndFunc
Func _WinAPI_MAKELANGID($iLngIDPrimary, $iLngIDSub)
Return BitOR(BitShift($iLngIDSub, -10), $iLngIDPrimary)
EndFunc
Func _WinAPI_MAKELCID($iLngID, $iSortID)
Return BitOR(BitShift($iSortID, -16), $iLngID)
EndFunc
Func _WinAPI_MakeLong($iLo, $iHi)
Return BitOR(BitShift($iHi, -16), BitAND($iLo, 0xFFFF))
EndFunc
Func _WinAPI_MakeQWord($iLoDWORD, $iHiDWORD)
Local $tInt64 = DllStructCreate("uint64")
Local $tDwords = DllStructCreate("dword;dword", DllStructGetPtr($tInt64))
DllStructSetData($tDwords, 1, $iLoDWORD)
DllStructSetData($tDwords, 2, $iHiDWORD)
Return DllStructGetData($tInt64, 1)
EndFunc
Func _WinAPI_MakeWord($iLo, $iHi)
Local $tWord = DllStructCreate('ushort')
Local $tByte = DllStructCreate('byte;byte', DllStructGetPtr($tWord))
DllStructSetData($tByte, 1, $iHi)
DllStructSetData($tByte, 2, $iLo)
Return DllStructGetData($tWord, 1)
EndFunc
Func _WinAPI_MultiByteToWideChar($vText, $iCodePage = 0, $iFlags = 0, $bRetString = False)
Local $sTextType = "str"
If Not IsString($vText) Then $sTextType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags,  $sTextType, $vText, "int", -1, "ptr", 0, "int", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Local $iOut = $aResult[0]
Local $tOut = DllStructCreate("wchar[" & $iOut & "]")
$aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags, $sTextType, $vText,  "int", -1, "struct*", $tOut, "int", $iOut)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, 0)
If $bRetString Then Return DllStructGetData($tOut, 1)
Return $tOut
EndFunc
Func _WinAPI_MultiByteToWideCharEx($sText, $pText, $iCodePage = 0, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags, "STR", $sText,  "int", -1, "struct*", $pText, "int", (StringLen($sText) + 1) * 2)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_OemToChar($sStr)
Local $aRet = DllCall('user32.dll', 'bool', 'OemToChar', 'str', $sStr, 'str', '')
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_PointFromRect(ByRef $tRECT, $bCenter = True)
Local $iX1 = DllStructGetData($tRECT, "Left")
Local $iY1 = DllStructGetData($tRECT, "Top")
Local $iX2 = DllStructGetData($tRECT, "Right")
Local $iY2 = DllStructGetData($tRECT, "Bottom")
If $bCenter Then
$iX1 = $iX1 + (($iX2 - $iX1) / 2)
$iY1 = $iY1 + (($iY2 - $iY1) / 2)
EndIf
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iX1)
DllStructSetData($tPoint, "Y", $iY1)
Return $tPoint
EndFunc
Func _WinAPI_PrimaryLangId($iLngID)
Return BitAND($iLngID, 0x3FF)
EndFunc
Func _WinAPI_ScreenToClient($hWnd, ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShortToWord($iValue)
Return BitAND($iValue, 0x0000FFFF)
EndFunc
Func _WinAPI_StrFormatByteSize($iSize)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'StrFormatByteSizeW', 'int64', $iSize, 'wstr', '', 'uint', 1024)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_StrFormatByteSizeEx($iSize)
Local $aSymbol = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'dword', 0x0400, 'dword', 0x000F, 'wstr', '', 'int', 2048)
If @error Then Return SetError(@error + 10, @extended, '')
Local $sSize = _WinAPI_StrFormatByteSize(0)
If @error Then Return SetError(@error, @extended, '')
Return StringReplace($sSize, '0', StringRegExpReplace(Number($iSize), '(?<=\d)(?=(\d{3})+\z)', $aSymbol[3]))
EndFunc
Func _WinAPI_StrFormatKBSize($iSize)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'StrFormatKBSizeW', 'int64', $iSize, 'wstr', '', 'uint', 1024)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_StrFromTimeInterval($iTime, $iDigits = 7)
Local $aRet = DllCall('shlwapi.dll', 'int', 'StrFromTimeIntervalW', 'wstr', '', 'uint', 1024, 'dword', $iTime,  'int', $iDigits)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return StringStripWS($aRet[1], $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndFunc
Func _WinAPI_StringFromGUID($tGUID)
Local $aResult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tGUID, "wstr", "", "int", 40)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_SubLangId($iLngID)
Return BitShift($iLngID, 10)
EndFunc
Func _WinAPI_SwapDWord($iValue)
Local $tStruct1 = DllStructCreate('dword;dword')
Local $tStruct2 = DllStructCreate('byte[4];byte[4]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 4
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 5 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwapQWord($iValue)
Local $tStruct1 = DllStructCreate('int64;int64')
Local $tStruct2 = DllStructCreate('byte[8];byte[8]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 8
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 9 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwapWord($iValue)
Local $tStruct1 = DllStructCreate('word;word')
Local $tStruct2 = DllStructCreate('byte[2];byte[2]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 2
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 3 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_WideCharToMultiByte($vUnicode, $iCodePage = 0, $bRetNoStruct = True, $bRetBinary = False)
Local $sUnicodeType = "wstr"
If Not IsString($vUnicode) Then $sUnicodeType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1,  "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, "")
Local $tMultiByte = DllStructCreate((($bRetBinary) ? ("byte") : ("char")) & "[" & $aResult[0] & "]")
$aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode,  "int", -1, "struct*", $tMultiByte, "int", $aResult[0], "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
If $bRetNoStruct Then Return DllStructGetData($tMultiByte, 1)
Return $tMultiByte
EndFunc
Func _WinAPI_WordToShort($iValue)
If BitAND($iValue, 0x00008000) Then
Return BitOR($iValue, 0xFFFF8000)
EndIf
Return BitAND($iValue, 0x00007FFF)
EndFunc
#EndRegion Public Functions
Global Const $FR_PRIVATE = 0x10
Global Const $FR_NOT_ENUM = 0x20
Global Const $COMPRESSION_BITMAP_PNG = 0
Global Const $COMPRESSION_BITMAP_JPEG = 1
Global Const $BS_DIBPATTERN = 5
Global Const $BS_DIBPATTERN8X8 = 8
Global Const $BS_DIBPATTERNPT = 6
Global Const $BS_HATCHED = 2
Global Const $BS_HOLLOW = 1
Global Const $BS_NULL = 1
Global Const $BS_PATTERN = 3
Global Const $BS_PATTERN8X8 = 7
Global Const $BS_SOLID = 0
Global Const $HS_BDIAGONAL = 3
Global Const $HS_CROSS = 4
Global Const $HS_DIAGCROSS = 5
Global Const $HS_FDIAGONAL = 2
Global Const $HS_HORIZONTAL = 0
Global Const $HS_VERTICAL = 1
Global Const $DIB_PAL_COLORS = 1
Global Const $DIB_RGB_COLORS = 0
Global Const $CA_NEGATIVE = 0x01
Global Const $CA_LOG_FILTER = 0x02
Global Const $ILLUMINANT_DEVICE_DEFAULT = 0
Global Const $ILLUMINANT_A = 1
Global Const $ILLUMINANT_B = 2
Global Const $ILLUMINANT_C = 3
Global Const $ILLUMINANT_D50 = 4
Global Const $ILLUMINANT_D55 = 5
Global Const $ILLUMINANT_D65 = 6
Global Const $ILLUMINANT_D75 = 7
Global Const $ILLUMINANT_F2 = 8
Global Const $ILLUMINANT_TUNGSTEN = $ILLUMINANT_A
Global Const $ILLUMINANT_DAYLIGHT = $ILLUMINANT_C
Global Const $ILLUMINANT_FLUORESCENT = $ILLUMINANT_F2
Global Const $ILLUMINANT_NTSC = $ILLUMINANT_C
Global Const $BI_RGB = 0
Global Const $BI_RLE8 = 1
Global Const $BI_RLE4 = 2
Global Const $BI_BITFIELDS = 3
Global Const $BI_JPEG = 4
Global Const $BI_PNG = 5
Global Const $ALTERNATE = 1
Global Const $WINDING = 2
Global Const $DWMWA_NCRENDERING_ENABLED = 1
Global Const $DWMWA_NCRENDERING_POLICY = 2
Global Const $DWMWA_TRANSITIONS_FORCEDISABLED = 3
Global Const $DWMWA_ALLOW_NCPAINT = 4
Global Const $DWMWA_CAPTION_BUTTON_BOUNDS = 5
Global Const $DWMWA_NONCLIENT_RTL_LAYOUT = 6
Global Const $DWMWA_FORCE_ICONIC_REPRESENTATION = 7
Global Const $DWMWA_FLIP3D_POLICY = 8
Global Const $DWMWA_EXTENDED_FRAME_BOUNDS = 9
Global Const $DWMWA_HAS_ICONIC_BITMAP = 10
Global Const $DWMWA_DISALLOW_PEEK = 11
Global Const $DWMWA_EXCLUDED_FROM_PEEK = 12
Global Const $DWMNCRP_USEWINDOWSTYLE = 0
Global Const $DWMNCRP_DISABLED = 1
Global Const $DWMNCRP_ENABLED = 2
Global Const $DWMFLIP3D_DEFAULT = 0
Global Const $DWMFLIP3D_EXCLUDEBELOW = 1
Global Const $DWMFLIP3D_EXCLUDEABOVE = 2
Global Const $DM_BITSPERPEL = 0x00040000
Global Const $DM_COLLATE = 0x0008000
Global Const $DM_COLOR = 0x00000800
Global Const $DM_COPIES = 0x00000100
Global Const $DM_DEFAULTSOURCE = 0x00000200
Global Const $DM_DISPLAYFIXEDOUTPUT = 0x20000000
Global Const $DM_DISPLAYFLAGS = 0x00200000
Global Const $DM_DISPLAYFREQUENCY = 0x00400000
Global Const $DM_DISPLAYORIENTATION = 0x00000080
Global Const $DM_DITHERTYPE = 0x04000000
Global Const $DM_DUPLEX = 0x0001000
Global Const $DM_FORMNAME = 0x00010000
Global Const $DM_ICMINTENT = 0x01000000
Global Const $DM_ICMMETHOD = 0x00800000
Global Const $DM_LOGPIXELS = 0x00020000
Global Const $DM_MEDIATYPE = 0x02000000
Global Const $DM_NUP = 0x00000040
Global Const $DM_ORIENTATION = 0x00000001
Global Const $DM_PANNINGHEIGHT = 0x10000000
Global Const $DM_PANNINGWIDTH = 0x08000000
Global Const $DM_PAPERLENGTH = 0x00000004
Global Const $DM_PAPERSIZE = 0x00000002
Global Const $DM_PAPERWIDTH = 0x00000008
Global Const $DM_PELSHEIGHT = 0x00100000
Global Const $DM_PELSWIDTH = 0x00080000
Global Const $DM_POSITION = 0x00000020
Global Const $DM_PRINTQUALITY = 0x00000400
Global Const $DM_SCALE = 0x00000010
Global Const $DM_TTOPTION = 0x0004000
Global Const $DM_YRESOLUTION = 0x0002000
Global Const $DMPAPER_LETTER = 1
Global Const $DMPAPER_LETTERSMALL = 2
Global Const $DMPAPER_TABLOID = 3
Global Const $DMPAPER_LEDGER = 4
Global Const $DMPAPER_LEGAL = 5
Global Const $DMPAPER_STATEMENT = 6
Global Const $DMPAPER_EXECUTIVE = 7
Global Const $DMPAPER_A3 = 8
Global Const $DMPAPER_A4 = 9
Global Const $DMPAPER_A4SMALL = 10
Global Const $DMPAPER_A5 = 11
Global Const $DMPAPER_B4 = 12
Global Const $DMPAPER_B5 = 13
Global Const $DMPAPER_FOLIO = 14
Global Const $DMPAPER_QUARTO = 15
Global Const $DMPAPER_10X14 = 16
Global Const $DMPAPER_11X17 = 17
Global Const $DMPAPER_NOTE = 18
Global Const $DMPAPER_ENV_9 = 19
Global Const $DMPAPER_ENV_10 = 20
Global Const $DMPAPER_ENV_11 = 21
Global Const $DMPAPER_ENV_12 = 22
Global Const $DMPAPER_ENV_14 = 23
Global Const $DMPAPER_CSHEET = 24
Global Const $DMPAPER_DSHEET = 25
Global Const $DMPAPER_ESHEET = 26
Global Const $DMPAPER_ENV_DL = 27
Global Const $DMPAPER_ENV_C5 = 28
Global Const $DMPAPER_ENV_C3 = 29
Global Const $DMPAPER_ENV_C4 = 30
Global Const $DMPAPER_ENV_C6 = 31
Global Const $DMPAPER_ENV_C65 = 32
Global Const $DMPAPER_ENV_B4 = 33
Global Const $DMPAPER_ENV_B5 = 34
Global Const $DMPAPER_ENV_B6 = 35
Global Const $DMPAPER_ENV_ITALY = 36
Global Const $DMPAPER_ENV_MONARCH = 37
Global Const $DMPAPER_ENV_PERSONAL = 38
Global Const $DMPAPER_FANFOLD_US = 39
Global Const $DMPAPER_FANFOLD_STD_GERMAN = 40
Global Const $DMPAPER_FANFOLD_LGL_GERMAN = 41
Global Const $DMPAPER_ISO_B4 = 42
Global Const $DMPAPER_JAPANESE_POSTCARD = 43
Global Const $DMPAPER_9X11 = 44
Global Const $DMPAPER_10X11 = 45
Global Const $DMPAPER_15X11 = 46
Global Const $DMPAPER_ENV_INVITE = 47
Global Const $DMPAPER_RESERVED_48 = 48
Global Const $DMPAPER_RESERVED_49 = 49
Global Const $DMPAPER_LETTER_EXTRA = 50
Global Const $DMPAPER_LEGAL_EXTRA = 51
Global Const $DMPAPER_TABLOID_EXTRA = 52
Global Const $DMPAPER_A4_EXTRA = 53
Global Const $DMPAPER_LETTER_TRANSVERSE = 54
Global Const $DMPAPER_A4_TRANSVERSE = 55
Global Const $DMPAPER_LETTER_EXTRA_TRANSVERSE = 56
Global Const $DMPAPER_A_PLUS = 57
Global Const $DMPAPER_B_PLUS = 58
Global Const $DMPAPER_LETTER_PLUS = 59
Global Const $DMPAPER_A4_PLUS = 60
Global Const $DMPAPER_A5_TRANSVERSE = 61
Global Const $DMPAPER_B5_TRANSVERSE = 62
Global Const $DMPAPER_A3_EXTRA = 63
Global Const $DMPAPER_A5_EXTRA = 64
Global Const $DMPAPER_B5_EXTRA = 65
Global Const $DMPAPER_A2 = 66
Global Const $DMPAPER_A3_TRANSVERSE = 67
Global Const $DMPAPER_A3_EXTRA_TRANSVERSE = 68
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD = 69
Global Const $DMPAPER_A6 = 70
Global Const $DMPAPER_JENV_KAKU2 = 71
Global Const $DMPAPER_JENV_KAKU3 = 72
Global Const $DMPAPER_JENV_CHOU3 = 73
Global Const $DMPAPER_JENV_CHOU4 = 74
Global Const $DMPAPER_LETTER_ROTATED = 75
Global Const $DMPAPER_A3_ROTATED = 76
Global Const $DMPAPER_A4_ROTATED = 77
Global Const $DMPAPER_A5_ROTATED = 78
Global Const $DMPAPER_B4_JIS_ROTATED = 79
Global Const $DMPAPER_B5_JIS_ROTATED = 80
Global Const $DMPAPER_JAPANESE_POSTCARD_ROTATED = 81
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82
Global Const $DMPAPER_A6_ROTATED = 83
Global Const $DMPAPER_JENV_KAKU2_ROTATED = 84
Global Const $DMPAPER_JENV_KAKU3_ROTATED = 85
Global Const $DMPAPER_JENV_CHOU3_ROTATED = 86
Global Const $DMPAPER_JENV_CHOU4_ROTATED = 87
Global Const $DMPAPER_B6_JIS = 88
Global Const $DMPAPER_B6_JIS_ROTATED = 89
Global Const $DMPAPER_12X11 = 90
Global Const $DMPAPER_JENV_YOU4 = 91
Global Const $DMPAPER_JENV_YOU4_ROTATED = 92
Global Const $DMPAPER_P16K = 93
Global Const $DMPAPER_P32K = 94
Global Const $DMPAPER_P32KBIG = 95
Global Const $DMPAPER_PENV_1 = 96
Global Const $DMPAPER_PENV_2 = 97
Global Const $DMPAPER_PENV_3 = 98
Global Const $DMPAPER_PENV_4 = 99
Global Const $DMPAPER_PENV_5 = 100
Global Const $DMPAPER_PENV_6 = 101
Global Const $DMPAPER_PENV_7 = 102
Global Const $DMPAPER_PENV_8 = 103
Global Const $DMPAPER_PENV_9 = 104
Global Const $DMPAPER_PENV_10 = 105
Global Const $DMPAPER_P16K_ROTATED = 106
Global Const $DMPAPER_P32K_ROTATED = 107
Global Const $DMPAPER_P32KBIG_ROTATED = 108
Global Const $DMPAPER_PENV_1_ROTATED = 109
Global Const $DMPAPER_PENV_2_ROTATED = 110
Global Const $DMPAPER_PENV_3_ROTATED = 111
Global Const $DMPAPER_PENV_4_ROTATED = 112
Global Const $DMPAPER_PENV_5_ROTATED = 113
Global Const $DMPAPER_PENV_6_ROTATED = 114
Global Const $DMPAPER_PENV_7_ROTATED = 115
Global Const $DMPAPER_PENV_8_ROTATED = 116
Global Const $DMPAPER_PENV_9_ROTATED = 117
Global Const $DMPAPER_PENV_10_ROTATED = 118
Global Const $DMPAPER_USER = 256
Global Const $DMBIN_UPPER = 1
Global Const $DMBIN_LOWER = 2
Global Const $DMBIN_MIDDLE = 3
Global Const $DMBIN_MANUAL = 4
Global Const $DMBIN_ENVELOPE = 5
Global Const $DMBIN_ENVMANUAL = 6
Global Const $DMBIN_AUTO = 7
Global Const $DMBIN_TRACTOR = 8
Global Const $DMBIN_SMALLFMT = 9
Global Const $DMBIN_LARGEFMT = 10
Global Const $DMBIN_LARGECAPACITY = 11
Global Const $DMBIN_CASSETTE = 14
Global Const $DMBIN_FORMSOURCE = 15
Global Const $DMBIN_USER = 256
Global Const $DMRES_DRAFT = -1
Global Const $DMRES_LOW = -2
Global Const $DMRES_MEDIUM = -3
Global Const $DMRES_HIGH = -4
Global Const $DMDO_DEFAULT = 0
Global Const $DMDO_90 = 1
Global Const $DMDO_180 = 2
Global Const $DMDO_270 = 3
Global Const $DMDFO_DEFAULT = 0
Global Const $DMDFO_STRETCH = 1
Global Const $DMDFO_CENTER = 2
Global Const $DMCOLOR_MONOCHROME = 1
Global Const $DMCOLOR_COLOR = 2
Global Const $DMDUP_SIMPLEX = 1
Global Const $DMDUP_VERTICAL = 2
Global Const $DMDUP_HORIZONTAL = 3
Global Const $DMTT_BITMAP = 1
Global Const $DMTT_DOWNLOAD = 2
Global Const $DMTT_SUBDEV = 3
Global Const $DMTT_DOWNLOAD_OUTLINE = 4
Global Const $DMCOLLATE_FALSE = 0
Global Const $DMCOLLATE_TRUE = 1
Global Const $DM_GRAYSCALE = 1
Global Const $DM_INTERLACED = 2
Global Const $DMNUP_SYSTEM = 1
Global Const $DMNUP_ONEUP = 2
Global Const $DMICMMETHOD_NONE = 1
Global Const $DMICMMETHOD_SYSTEM = 2
Global Const $DMICMMETHOD_DRIVER = 3
Global Const $DMICMMETHOD_DEVICE = 4
Global Const $DMICMMETHOD_USER = 256
Global Const $DMICM_SATURATE = 1
Global Const $DMICM_CONTRAST = 2
Global Const $DMICM_COLORIMETRIC = 3
Global Const $DMICM_ABS_COLORIMETRIC = 4
Global Const $DMICM_USER = 256
Global Const $DMMEDIA_STANDARD = 1
Global Const $DMMEDIA_TRANSPARENCY = 2
Global Const $DMMEDIA_GLOSSY = 3
Global Const $DMMEDIA_USER = 256
Global Const $DMDITHER_NONE = 1
Global Const $DMDITHER_COARSE = 2
Global Const $DMDITHER_FINE = 3
Global Const $DMDITHER_LINEART = 4
Global Const $DMDITHER_ERRORDIFFUSION = 5
Global Const $DMDITHER_RESERVED6 = 6
Global Const $DMDITHER_RESERVED7 = 7
Global Const $DMDITHER_RESERVED8 = 8
Global Const $DMDITHER_RESERVED9 = 9
Global Const $DMDITHER_GRAYSCALE = 10
Global Const $DMDITHER_USER = 256
Global Const $ENUM_CURRENT_SETTINGS = -1
Global Const $ENUM_REGISTRY_SETTINGS = -2
Global Const $DEVICE_FONTTYPE = 0x2
Global Const $RASTER_FONTTYPE = 0x1
Global Const $TRUETYPE_FONTTYPE = 0x4
Global Const $NTM_BOLD = 0x00000020
Global Const $NTM_DSIG = 0x00200000
Global Const $NTM_ITALIC = 0x00000001
Global Const $NTM_MULTIPLEMASTER = 0x00080000
Global Const $NTM_NONNEGATIVE_AC = 0x00010000
Global Const $NTM_PS_OPENTYPE = 0x00020000
Global Const $NTM_REGULAR = 0x00000040
Global Const $NTM_TT_OPENTYPE = 0x00040000
Global Const $NTM_TYPE1 = 0x00100000
Global Const $FLOODFILLBORDER = 0
Global Const $FLOODFILLSURFACE = 1
Global Const $AD_COUNTERCLOCKWISE = 1
Global Const $AD_CLOCKWISE = 2
Global Const $DCB_ACCUMULATE = 0x02
Global Const $DCB_DISABLE = 0x08
Global Const $DCB_ENABLE = 0x04
Global Const $DCB_RESET = 0x01
Global Const $DCB_SET = BitOR($DCB_RESET, $DCB_ACCUMULATE)
Global Const $DCX_WINDOW = 0x00000001
Global Const $DCX_CACHE = 0x00000002
Global Const $DCX_PARENTCLIP = 0x00000020
Global Const $DCX_CLIPSIBLINGS = 0x00000010
Global Const $DCX_CLIPCHILDREN = 0x00000008
Global Const $DCX_NORESETATTRS = 0x00000004
Global Const $DCX_LOCKWINDOWUPDATE = 0x00000400
Global Const $DCX_EXCLUDERGN = 0x00000040
Global Const $DCX_INTERSECTRGN = 0x00000080
Global Const $DCX_INTERSECTUPDATE = 0x00000200
Global Const $DCX_VALIDATE = 0x00200000
Global Const $GGO_BEZIER = 3
Global Const $GGO_BITMAP = 1
Global Const $GGO_GLYPH_INDEX = 0x0080
Global Const $GGO_GRAY2_BITMAP = 4
Global Const $GGO_GRAY4_BITMAP = 5
Global Const $GGO_GRAY8_BITMAP = 6
Global Const $GGO_METRICS = 0
Global Const $GGO_NATIVE = 2
Global Const $GGO_UNHINTED = 0x0100
Global Const $GM_COMPATIBLE = 1
Global Const $GM_ADVANCED = 2
Global Const $MM_ANISOTROPIC = 8
Global Const $MM_HIENGLISH = 5
Global Const $MM_HIMETRIC = 3
Global Const $MM_ISOTROPIC = 7
Global Const $MM_LOENGLISH = 4
Global Const $MM_LOMETRIC = 2
Global Const $MM_TEXT = 1
Global Const $MM_TWIPS = 6
Global Const $R2_BLACK = 1
Global Const $R2_COPYPEN = 13
Global Const $R2_LAST = 16
Global Const $R2_MASKNOTPEN = 3
Global Const $R2_MASKPEN = 9
Global Const $R2_MASKPENNOT = 5
Global Const $R2_MERGENOTPEN = 12
Global Const $R2_MERGEPEN = 15
Global Const $R2_MERGEPENNOT = 14
Global Const $R2_NOP = 11
Global Const $R2_NOT = 6
Global Const $R2_NOTCOPYPEN = 4
Global Const $R2_NOTMASKPEN = 8
Global Const $R2_NOTMERGEPEN = 2
Global Const $R2_NOTXORPEN = 10
Global Const $R2_WHITE = 16
Global Const $R2_XORPEN = 7
Global Const $BLACKONWHITE = 1
Global Const $COLORONCOLOR = 3
Global Const $HALFTONE = 4
Global Const $WHITEONBLACK = 2
Global Const $STRETCH_ANDSCANS = $BLACKONWHITE
Global Const $STRETCH_DELETESCANS = $COLORONCOLOR
Global Const $STRETCH_HALFTONE = $HALFTONE
Global Const $STRETCH_ORSCANS = $WHITEONBLACK
Global Const $TA_BASELINE = 0x0018
Global Const $TA_BOTTOM = 0x0008
Global Const $TA_TOP = 0x0000
Global Const $TA_CENTER = 0x0006
Global Const $TA_LEFT = 0x0000
Global Const $TA_RIGHT = 0x0002
Global Const $TA_NOUPDATECP = 0x0000
Global Const $TA_RTLREADING = 0x0100
Global Const $TA_UPDATECP = 0x0001
Global Const $VTA_BASELINE = $TA_BASELINE
Global Const $VTA_BOTTOM = $TA_RIGHT
Global Const $VTA_TOP = $TA_LEFT
Global Const $VTA_CENTER = $TA_CENTER
Global Const $VTA_LEFT = $TA_BOTTOM
Global Const $VTA_RIGHT = $TA_TOP
Global Const $UDF_BGR = 1
Global Const $UDF_RGB = 0
Global Const $MWT_IDENTITY = 0x01
Global Const $MWT_LEFTMULTIPLY = 0x02
Global Const $MWT_RIGHTMULTIPLY = 0x03
Global Const $MWT_SET = 0x04
Global Const $MONITOR_DEFAULTTONEAREST = 2
Global Const $MONITOR_DEFAULTTONULL = 0
Global Const $MONITOR_DEFAULTTOPRIMARY = 1
Global Const $PT_BEZIERTO = 4
Global Const $PT_LINETO = 2
Global Const $PT_MOVETO = 6
Global Const $PT_CLOSEFIGURE = 1
#Region Global Variables and Constants
Global $__g_hHeap = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateBuffer($iLength, $pBuffer = 0, $bAbort = True)
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 0, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
Return $pBuffer
EndFunc
Func _WinAPI_CreateBufferFromStruct($tStruct, $pBuffer = 0, $bAbort = True)
If Not IsDllStruct($tStruct) Then Return SetError(1, 0, 0)
$pBuffer = __HeapReAlloc($pBuffer, DllStructGetSize($tStruct), 0, $bAbort)
If @error Then Return SetError(@error + 100, @extended, 0)
_WinAPI_MoveMemory($pBuffer, $tStruct, DllStructGetSize($tStruct))
Return $pBuffer
EndFunc
Func _WinAPI_CreateString($sString, $pString = 0, $iLength = -1, $bUnicode = True, $bAbort = True)
$iLength = Number($iLength)
If $iLength >= 0 Then
$sString = StringLeft($sString, $iLength)
Else
$iLength = StringLen($sString)
EndIf
Local $iSize = $iLength + 1
If $bUnicode Then
$iSize *= 2
EndIf
$pString = __HeapReAlloc($pString, $iSize, 0, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
DllStructSetData(DllStructCreate(($bUnicode ? 'wchar' : 'char') & '[' & ($iLength + 1) & ']', $pString), 1, $sString)
Return SetExtended($iLength, $pString)
EndFunc
Func _WinAPI_EqualMemory($pSource1, $pSource2, $iLength)
If _WinAPI_IsBadReadPtr($pSource1, $iLength) Then Return SetError(11, @extended, 0)
If _WinAPI_IsBadReadPtr($pSource2, $iLength) Then Return SetError(12, @extended, 0)
Local $aRet = DllCall('ntdll.dll', 'ulong_ptr', 'RtlCompareMemory', 'struct*', $pSource1, 'struct*', $pSource2, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return Number($aRet[0] = $iLength)
EndFunc
Func _WinAPI_FillMemory($pMemory, $iLength, $iValue = 0)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlFillMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength, 'byte', $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_FreeMemory($pMemory)
If Not __HeapFree($pMemory, 1) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_GetMemorySize($pMemory)
Local $iResult = __HeapSize($pMemory, 1)
If @error Then Return SetError(@error, @extended, 0)
Return $iResult
EndFunc
Func _WinAPI_GlobalMemoryStatus()
Local Const $tagMEMORYSTATUSEX = "dword Length;dword MemoryLoad;" &  "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" &  "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
Local $tMem = DllStructCreate($tagMEMORYSTATUSEX)
DllStructSetData($tMem, 1, DllStructGetSize($tMem))
Local $aRet = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tMem)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aMem[7]
$aMem[0] = DllStructGetData($tMem, 2)
$aMem[1] = DllStructGetData($tMem, 3)
$aMem[2] = DllStructGetData($tMem, 4)
$aMem[3] = DllStructGetData($tMem, 5)
$aMem[4] = DllStructGetData($tMem, 6)
$aMem[5] = DllStructGetData($tMem, 7)
$aMem[6] = DllStructGetData($tMem, 8)
Return $aMem
EndFunc
Func _WinAPI_IsBadCodePtr($pAddress)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadCodePtr', 'struct*', $pAddress)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadReadPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadReadPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadStringPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadStringPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadWritePtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadWritePtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsMemory($pMemory)
Local $bResult = __HeapValidate($pMemory)
Return SetError(@error, @extended, $bResult)
EndFunc
Func _WinAPI_LocalFree($hMemory)
Local $aResult = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MoveMemory($pDestination, $pSource, $iLength)
If _WinAPI_IsBadReadPtr($pSource, $iLength) Then Return SetError(10, @extended, 0)
If _WinAPI_IsBadWritePtr($pDestination, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'struct*', $pDestination, 'struct*', $pSource, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ReadProcessMemory($hProcess, $pBaseAddress, $pBuffer, $iSize, ByRef $iRead)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hProcess,  "ptr", $pBaseAddress, "struct*", $pBuffer, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[5]
Return $aResult[0]
EndFunc
Func _WinAPI_WriteProcessMemory($hProcess, $pBaseAddress, $pBuffer, $iSize, ByRef $iWritten, $sBuffer = "ptr")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hProcess, "ptr", $pBaseAddress,  $sBuffer, $pBuffer, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[5]
Return $aResult[0]
EndFunc
Func _WinAPI_ZeroMemory($pMemory, $iLength)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlZeroMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __HeapAlloc($iSize, $bAbort = False)
Local $aRet
If Not $__g_hHeap Then
$aRet = DllCall('kernel32.dll', 'handle', 'HeapCreate', 'dword', 0, 'ulong_ptr', 0, 'ulong_ptr', 0)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
$__g_hHeap = $aRet[0]
EndIf
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 30, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func __HeapFree(ByRef $pMemory, $bCheck = False, $iCurErr = @error, $iCurExt = @extended)
If $bCheck And (Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapFree', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or Not $aRet[0] Then Return SetError(@error + 40, @extended, 0)
$pMemory = 0
Return SetError($iCurErr, $iCurExt, 1)
EndFunc
Func __HeapReAlloc($pMemory, $iSize, $bAmount = False, $bAbort = False)
Local $aRet, $pRet
If __HeapValidate($pMemory) Then
If $bAmount And (__HeapSize($pMemory) >= $iSize) Then Return SetExtended(1, Ptr($pMemory))
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapReAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ptr', $pMemory,  'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 20, @extended, Ptr($pMemory))
EndIf
$pRet = $aRet[0]
Else
$pRet = __HeapAlloc($iSize, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
EndIf
Return $pRet
EndFunc
Func __HeapSize($pMemory, $bCheck = False)
If $bCheck And (Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'ulong_ptr', 'HeapSize', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or ($aRet[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
Return $aRet[0]
EndFunc
Func __HeapValidate($pMemory)
If (Not $__g_hHeap) Or (Not Ptr($pMemory)) Then Return SetError(9, 0, False)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapValidate', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Internal Functions
Global Const $SND_APPLICATION = 0x00000080
Global Const $SND_ALIAS = 0x00010000
Global Const $SND_ALIAS_ID = 0x00110000
Global Const $SND_ASYNC = 0x00000001
Global Const $SND_FILENAME = 0x00020000
Global Const $SND_LOOP = 0x00000008
Global Const $SND_MEMORY = 0x00000004
Global Const $SND_NODEFAULT = 0x00000002
Global Const $SND_NOSTOP = 0x00000010
Global Const $SND_NOWAIT = 0x00002000
Global Const $SND_PURGE = 0x00000040
Global Const $SND_RESOURCE = 0x00040004
Global Const $SND_SENTRY = 0x00080000
Global Const $SND_SYNC = 0x00000000
Global Const $SND_SYSTEM = 0x00200000
Global Const $SND_SYSTEM_NOSTOP = 0x00200010
Global Const $SND_ALIAS_SYSTEMASTERISK = 'SystemAsterisk'
Global Const $SND_ALIAS_SYSTEMDEFAULT = 'SystemDefault'
Global Const $SND_ALIAS_SYSTEMEXCLAMATION = 'SystemExclamation'
Global Const $SND_ALIAS_SYSTEMEXIT = 'SystemExit'
Global Const $SND_ALIAS_SYSTEMHAND = 'SystemHand'
Global Const $SND_ALIAS_SYSTEMQUESTION = 'SystemQuestion'
Global Const $SND_ALIAS_SYSTEMSTART = 'SystemStart'
Global Const $SND_ALIAS_SYSTEMWELCOME = 'SystemWelcome'
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_ArrayToStruct(Const ByRef $aData, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aData, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'wchar[' & (StringLen($aData[$i]) + 1) & '];'
Next
Local $tData = DllStructCreate($tagStruct & 'wchar[1]')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tData, $iCount, $aData[$i])
$iCount += 1
Next
DllStructSetData($tData, $iCount, ChrW(0))
Return $tData
EndFunc
Func _WinAPI_CreateMargins($iLeftWidth, $iRightWidth, $iTopHeight, $iBottomHeight)
Local $tMARGINS = DllStructCreate($tagMARGINS)
DllStructSetData($tMARGINS, 1, $iLeftWidth)
DllStructSetData($tMARGINS, 2, $iRightWidth)
DllStructSetData($tMARGINS, 3, $iTopHeight)
DllStructSetData($tMARGINS, 4, $iBottomHeight)
Return $tMARGINS
EndFunc
Func _WinAPI_CreatePoint($iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
DllStructSetData($tPOINT, 1, $iX)
DllStructSetData($tPOINT, 2, $iY)
Return $tPOINT
EndFunc
Func _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iLeft)
DllStructSetData($tRECT, 2, $iTop)
DllStructSetData($tRECT, 3, $iRight)
DllStructSetData($tRECT, 4, $iBottom)
Return $tRECT
EndFunc
Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iX)
DllStructSetData($tRECT, 2, $iY)
DllStructSetData($tRECT, 3, $iX + $iWidth)
DllStructSetData($tRECT, 4, $iY + $iHeight)
Return $tRECT
EndFunc
Func _WinAPI_CreateSize($iWidth, $iHeight)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, $iWidth)
DllStructSetData($tSIZE, 2, $iHeight)
Return $tSIZE
EndFunc
Func _WinAPI_CopyStruct($tStruct, $sStruct = '')
Local $iSize = DllStructGetSize($tStruct)
If Not $iSize Then Return SetError(1, 0, 0)
Local $tResult
If Not StringStripWS($sStruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) Then
$tResult = DllStructCreate('byte[' & $iSize & ']')
Else
$tResult = DllStructCreate($sStruct)
EndIf
If DllStructGetSize($tResult) < $iSize Then Return SetError(2, 0, 0)
_WinAPI_MoveMemory($tResult, $tStruct, $iSize)
Return $tResult
EndFunc
Func _WinAPI_GetExtended()
Return $__g_vExt
EndFunc
Func _WinAPI_GetMousePos($bToClient = False, $hWnd = 0)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
If $bToClient And Not _WinAPI_ScreenToClient($hWnd, $tPoint) Then Return SetError(@error + 20, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_GetMousePosX($bToClient = False, $hWnd = 0)
Local $tPoint = _WinAPI_GetMousePos($bToClient, $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPoint, "X")
EndFunc
Func _WinAPI_GetMousePosY($bToClient = False, $hWnd = 0)
Local $tPoint = _WinAPI_GetMousePos($bToClient, $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_MulDiv($iNumber, $iNumerator, $iDenominator)
Local $aResult = DllCall("kernel32.dll", "int", "MulDiv", "int", $iNumber, "int", $iNumerator, "int", $iDenominator)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_PlaySound($sSound, $iFlags = $SND_SYSTEM_NOSTOP, $hInstance = 0)
Local $sTypeOfSound = 'ptr'
If $sSound Then
If IsString($sSound) Then
$sTypeOfSound = 'wstr'
EndIf
Else
$sSound = 0
$iFlags = 0
EndIf
Local $aRet = DllCall('winmm.dll', 'bool', 'PlaySoundW', $sTypeOfSound, $sSound, 'handle', $hInstance, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StringLenA(Const ByRef $tString)
Local $aResult = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tString)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_StringLenW(Const ByRef $tString)
Local $aResult = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tString)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_StructToArray(ByRef $tStruct, $iItems = 0)
Local $iSize = 2 * Floor(DllStructGetSize($tStruct) / 2)
Local $pStruct = DllStructGetPtr($tStruct)
If Not $iSize Or Not $pStruct Then Return SetError(1, 0, 0)
Local $tData, $iLength, $iOffset = 0
Local $aResult[101] = [0]
While 1
$iLength = _WinAPI_StrLen($pStruct + $iOffset)
If Not $iLength Then
ExitLoop
EndIf
If 2 * (1 + $iLength) + $iOffset > $iSize Then Return SetError(3, 0, 0)
$tData = DllStructCreate('wchar[' & (1 + $iLength) & ']', $pStruct + $iOffset)
If @error Then Return SetError(@error + 10, 0, 0)
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tData, 1)
If $aResult[0] = $iItems Then
ExitLoop
EndIf
$iOffset += 2 * (1 + $iLength)
If $iOffset >= $iSize Then Return SetError(3, 0, 0)
WEnd
If Not $aResult[0] Then Return SetError(2, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_UnionStruct($tStruct1, $tStruct2, $sStruct = '')
Local $aSize[2] = [DllStructGetSize($tStruct1), DllStructGetSize($tStruct2)]
If Not $aSize[0] Or Not $aSize[1] Then Return SetError(1, 0, 0)
Local $tResult
If Not StringStripWS($sStruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) Then
$tResult = DllStructCreate('byte[' & ($aSize[0] + $aSize[1]) & ']')
Else
$tResult = DllStructCreate($sStruct)
EndIf
If DllStructGetSize($tResult) < ($aSize[0] + $aSize[1]) Then Return SetError(2, 0, 0)
_WinAPI_MoveMemory($tResult, $tStruct1, $aSize[0])
_WinAPI_MoveMemory(DllStructGetPtr($tResult) + $aSize[0], $tStruct2, $aSize[1])
Return $tResult
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Global Const $tagBITMAPV5HEADER = 'struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct'
Global Const $tagDIBSECTION = $tagBITMAP & ';' & $tagBITMAPINFOHEADER & ';dword dsBitfields[3];ptr dshSection;dword dsOffset'
Global Const $TMPF_FIXED_PITCH = 0x01
Global Const $TMPF_VECTOR = 0x02
Global Const $TMPF_TRUETYPE = 0x04
Global Const $TMPF_DEVICE = 0x08
Global Const $__WINAPICONSTANT_FW_NORMAL = 400
Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 1
Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_BitBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $iROP)
Local $aResult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hDestDC, "int", $iXDest, "int", $iYDest, "int", $iWidth,  "int", $iHeight, "handle", $hSrcDC, "int", $iXSrc, "int", $iYSrc, "dword", $iROP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CombineRgn($hRgnDest, $hRgnSrc1, $hRgnSrc2, $iCombineMode)
Local $aResult = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hRgnDest, "handle", $hRgnSrc1, "handle", $hRgnSrc2,  "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CopyBitmap($hBitmap)
$hBitmap = _WinAPI_CopyImage($hBitmap, 0, 0, 0, 0x2000)
Return SetError(@error, @extended, $hBitmap)
EndFunc
Func _WinAPI_CopyImage($hImage, $iType = 0, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CopyImage', 'handle', $hImage, 'uint', $iType,  'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateANDBitmap($hBitmap)
Local $iError = 0, $hDib = 0
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Do
Local $atDIB[2]
$atDIB[0] = DllStructCreate($tagDIBSECTION)
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($atDIB[0]), $atDIB[0]))  Or (DllStructGetData($atDIB[0], 'bmBitsPixel') <> 32) Or (DllStructGetData($atDIB[0], 'biCompression')) Then
$iError = 10
ExitLoop
EndIf
$atDIB[1] = DllStructCreate($tagBITMAP)
$hDib = _WinAPI_CreateDIB(DllStructGetData($atDIB[0], 'bmWidth'), DllStructGetData($atDIB[0], 'bmHeight'), 1)
If Not _WinAPI_GetObject($hDib, DllStructGetSize($atDIB[1]), $atDIB[1]) Then
$iError = 11
ExitLoop
EndIf
Local $aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __ANDProc(), 'ptr', 0, 'uint', 0,  'wparam', DllStructGetPtr($atDIB[0]), 'lparam', DllStructGetPtr($atDIB[1]))
If @error Then
$iError = @error
ExitLoop
EndIf
If Not $aRet[0] Then
$iError = 12
ExitLoop
EndIf
$iError = 0
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
$hDib = 0
EndIf
Return SetError($iError, 0, $hDib)
EndFunc
Func _WinAPI_CreateBitmap($iWidth, $iHeight, $iPlanes = 1, $iBitsPerPel = 1, $pBits = 0)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iWidth, "int", $iHeight, "uint", $iPlanes,  "uint", $iBitsPerPel, "struct*", $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hDC, "int", $iWidth, "int", $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel = 32, $tColorTable = 0, $iColorCount = 0)
Local $aRGBQ[2], $iColors, $tagRGBQ
Switch $iBitsPerPel
Case 1
$iColors = 2
Case 4
$iColors = 16
Case 8
$iColors = 256
Case Else
$iColors = 0
EndSwitch
If $iColors Then
If Not IsDllStruct($tColorTable) Then
Switch $iBitsPerPel
Case 1
$aRGBQ[0] = 0
$aRGBQ[1] = 0xFFFFFF
$tColorTable = _WinAPI_CreateDIBColorTable($aRGBQ)
Case Else
EndSwitch
Else
If $iColors > $iColorCount Then
$iColors = $iColorCount
EndIf
If (Not $iColors) Or ((4 * $iColors) > DllStructGetSize($tColorTable)) Then
Return SetError(20, 0, 0)
EndIf
EndIf
$tagRGBQ = ';dword aRGBQuad[' & $iColors & ']'
Else
$tagRGBQ = ''
EndIf
Local $tBITMAPINFO = DllStructCreate($tagBITMAPINFOHEADER & $tagRGBQ)
DllStructSetData($tBITMAPINFO, 'biSize', 40)
DllStructSetData($tBITMAPINFO, 'biWidth', $iWidth)
DllStructSetData($tBITMAPINFO, 'biHeight', $iHeight)
DllStructSetData($tBITMAPINFO, 'biPlanes', 1)
DllStructSetData($tBITMAPINFO, 'biBitCount', $iBitsPerPel)
DllStructSetData($tBITMAPINFO, 'biCompression', 0)
DllStructSetData($tBITMAPINFO, 'biSizeImage', 0)
DllStructSetData($tBITMAPINFO, 'biXPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biYPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biClrUsed', $iColors)
DllStructSetData($tBITMAPINFO, 'biClrImportant', 0)
If $iColors Then
If IsDllStruct($tColorTable) Then
_WinAPI_MoveMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), $tColorTable, 4 * $iColors)
Else
_WinAPI_ZeroMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), 4 * $iColors)
EndIf
EndIf
Local $hBitmap = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $__g_vExt)
If Not $hBitmap Then Return SetError(@error, @extended, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateDIBSection($hDC, $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)
$pBits = 0
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBSection', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'uint', $iUsage,  'ptr*', 0, 'handle', $hSection, 'dword', $iOffset)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBits = $aRet[4]
Return $aRet[0]
EndFunc
Func _WinAPI_CreateDIBColorTable(Const ByRef $aColorTable, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aColorTable, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tColorTable = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tColorTable, 1, _WinAPI_SwitchColor(__RGB($aColorTable[$i])), $iCount)
$iCount += 1
Next
Return $tColorTable
EndFunc
Func _WinAPI_CreateFont($iHeight, $iWidth, $iEscape = 0, $iOrientn = 0, $iWeight = $__WINAPICONSTANT_FW_NORMAL, $bItalic = False, $bUnderline = False, $bStrikeout = False, $iCharset = $__WINAPICONSTANT_DEFAULT_CHARSET, $iOutputPrec = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $iClipPrec = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $iQuality = $__WINAPICONSTANT_DEFAULT_QUALITY, $iPitch = 0, $sFace = 'Arial')
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iHeight, "int", $iWidth, "int", $iEscape,  "int", $iOrientn, "int", $iWeight, "dword", $bItalic, "dword", $bUnderline, "dword", $bStrikeout,  "dword", $iCharset, "dword", $iOutputPrec, "dword", $iClipPrec, "dword", $iQuality, "dword", $iPitch, "wstr", $sFace)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFontIndirect($tLogFont)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tLogFont)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateRectRgn($iLeftRect, $iTopRect, $iRightRect, $iBottomRect)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $iLeftRect, "int", $iTopRect, "int", $iRightRect,  "int", $iBottomRect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateRoundRectRgn($iLeftRect, $iTopRect, $iRightRect, $iBottomRect, $iWidthEllipse, $iHeightEllipse)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $iLeftRect, "int", $iTopRect,  "int", $iRightRect, "int", $iBottomRect, "int", $iWidthEllipse, "int", $iHeightEllipse)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateSolidBrush($iColor)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "INT", $iColor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetBitmapDimension($hBitmap)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return _WinAPI_CreateSize(DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'))
EndFunc
Func _WinAPI_GetSysColorBrush($iIndex)
Local $aResult = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetTextExtentPoint32($hDC, $sText)
Local $tSize = DllStructCreate($tagSIZE)
Local $iSize = StringLen($sText)
Local $aRet = DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sText, "int", $iSize, "struct*", $tSize)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSize
EndFunc
Func _WinAPI_GetTextMetrics($hDC)
Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetTextMetricsW', 'handle', $hDC, 'struct*', $tTEXTMETRIC)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tTEXTMETRIC
EndFunc
Func _WinAPI_GetWindowRgn($hWnd, $hRgn)
Local $aResult = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hWnd, "handle", $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_IsAlphaBitmap($hBitmap)
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Local $aRet, $iError = 0
Do
Local $tDIB = DllStructCreate($tagDIBSECTION)
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or (DllStructGetData($tDIB, 'bmBitsPixel') <> 32) Or (DllStructGetData($tDIB, 'biCompression')) Then
$iError = 1
ExitLoop
EndIf
$aRet = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __AlphaProc(), 'ptr', 0, 'uint', 0, 'struct*', $tDIB, 'ptr', 0)
If @error Or ($aRet[0] = -1) Then
$iError = @error + 10
ExitLoop
EndIf
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRect(ByRef $tRECT, ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "bool", "PtInRect", "struct*", $tRECT, "struct", $tPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RedrawWindow($hWnd, $tRECT = 0, $hRegion = 0, $iFlags = 5)
Local $aResult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hWnd, "struct*", $tRECT, "handle", $hRegion,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowRgn($hWnd, $hRgn, $bRedraw = True)
Local $aResult = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hWnd, "handle", $hRgn, "bool", $bRedraw)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
Func __AlphaProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' &  '48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883' &  '7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB' &  '034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B' &  '6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24' &  '287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080' &  '7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB' &  '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D' &  '1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407' &  'B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302' &  '83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00' &  '007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __ANDProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C2420554157415648C7C009000000' &  '4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405' &  '4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405' &  '4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405' &  '4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405' &  '4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048' &  '21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000' &  'EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7' &  '44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100' &  '0048C74424380000000048C74424400000000048C744244800000000488BAC24' &  'A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B' &  '7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440' &  '4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24' &  '4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7' &  '442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C' &  '24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845' &  '0048FF4424604883442458F871B948C74424380000000048C744244000000000' &  '48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7' &  'D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C' &  '244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D' &  '184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24' &  '585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0' &  '010000004863C0EB034831C04883C470415E415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05' &  'B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24' &  '38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0' &  'EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000' &  '00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7' &  '042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000' &  'C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B' &  '3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480' &  '7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24' &  '0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000' &  '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' &  'FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424' &  '0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3' &  '8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000' &  '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' &  'FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8' &  '01000000EB0231C083C4205F5B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __XORProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' &  '48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074' &  '054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0' &  '4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C' &  '3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405' &  '4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C' &  '897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB' &  '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074' &  '0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB' &  '5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B' &  '6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303' &  '895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D' &  'C21000'))
EndIf
EndIf
Return $pProc
EndFunc
#EndRegion Embedded DLL Functions
#Region Internal Functions
Func __Init($dData)
Local $iLength = BinaryLen($dData)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'VirtualAlloc', 'ptr', 0, 'ulong_ptr', $iLength, 'dword', 0x00001000, 'dword', 0x00000040)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
Local $tData = DllStructCreate('byte[' & $iLength & "]", $aRet[0])
DllStructSetData($tData, 1, $dData)
Return $aRet[0]
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $DI_MASK = 0x0001
Global Const $DI_IMAGE = 0x0002
Global Const $DI_NORMAL = 0x0003
Global Const $DI_COMPAT = 0x0004
Global Const $DI_DEFAULTSIZE = 0x0008
Global Const $DI_NOMIRROR = 0x0010
Global Const $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 0x00000001
Global Const $DISPLAY_DEVICE_MULTI_DRIVER = 0x00000002
Global Const $DISPLAY_DEVICE_PRIMARY_DEVICE = 0x00000004
Global Const $DISPLAY_DEVICE_MIRRORING_DRIVER = 0x00000008
Global Const $DISPLAY_DEVICE_VGA_COMPATIBLE = 0x00000010
Global Const $DISPLAY_DEVICE_REMOVABLE = 0x00000020
Global Const $DISPLAY_DEVICE_DISCONNECT = 0x02000000
Global Const $DISPLAY_DEVICE_REMOTE = 0x04000000
Global Const $DISPLAY_DEVICE_MODESPRUNED = 0x08000000
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateCompatibleDC($hDC)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteDC($hDC)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawEdge($hDC, $tRECT, $iEdgeType, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hDC, "struct*", $tRECT, "uint", $iEdgeType,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawFrameControl($hDC, $tRECT, $iType, $iState)
Local $aResult = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hDC, "struct*", $tRECT, "uint", $iType,  "uint", $iState)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIcon($hDC, $iX, $iY, $hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIconEx($hDC, $iX, $iY, $hIcon, $iWidth = 0, $iHeight = 0, $iStep = 0, $hBrush = 0, $iFlags = 3)
Local $iOptions
Switch $iFlags
Case 1
$iOptions = $DI_MASK
Case 2
$iOptions = $DI_IMAGE
Case 3
$iOptions = $DI_NORMAL
Case 4
$iOptions = $DI_COMPAT
Case 5
$iOptions = $DI_DEFAULTSIZE
Case Else
$iOptions = $DI_NOMIRROR
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon,  "int", $iWidth, "int", $iHeight, "uint", $iStep, "handle", $hBrush, "uint", $iOptions)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawText($hDC, $sText, ByRef $tRECT, $iFlags)
Local $aResult = DllCall("user32.dll", "int", "DrawTextW", "handle", $hDC, "wstr", $sText, "int", -1, "struct*", $tRECT,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_EnumDisplayDevices($sDevice, $iDevNum)
Local $tName = 0, $iFlags = 0, $aDevice[5]
If $sDevice <> "" Then
$tName = DllStructCreate("wchar Text[" & StringLen($sDevice) + 1 & "]")
DllStructSetData($tName, "Text", $sDevice)
EndIf
Local Const $tagDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
Local $tDevice = DllStructCreate($tagDISPLAY_DEVICE)
Local $iDevice = DllStructGetSize($tDevice)
DllStructSetData($tDevice, "Size", $iDevice)
Local $aRet = DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tName, "dword", $iDevNum, "struct*", $tDevice, "dword", 1)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $iN = DllStructGetData($tDevice, "Flags")
If BitAND($iN, $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) <> 0 Then $iFlags = BitOR($iFlags, 1)
If BitAND($iN, $DISPLAY_DEVICE_PRIMARY_DEVICE) <> 0 Then $iFlags = BitOR($iFlags, 2)
If BitAND($iN, $DISPLAY_DEVICE_MIRRORING_DRIVER) <> 0 Then $iFlags = BitOR($iFlags, 4)
If BitAND($iN, $DISPLAY_DEVICE_VGA_COMPATIBLE) <> 0 Then $iFlags = BitOR($iFlags, 8)
If BitAND($iN, $DISPLAY_DEVICE_REMOVABLE) <> 0 Then $iFlags = BitOR($iFlags, 16)
If BitAND($iN, $DISPLAY_DEVICE_MODESPRUNED) <> 0 Then $iFlags = BitOR($iFlags, 32)
$aDevice[0] = True
$aDevice[1] = DllStructGetData($tDevice, "Name")
$aDevice[2] = DllStructGetData($tDevice, "String")
$aDevice[3] = $iFlags
$aDevice[4] = DllStructGetData($tDevice, "ID")
Return $aDevice
EndFunc
Func _WinAPI_FillRect($hDC, $tRECT, $hBrush)
Local $aResult
If IsPtr($hBrush) Then
$aResult = DllCall("user32.dll", "int", "FillRect", "handle", $hDC, "struct*", $tRECT, "handle", $hBrush)
Else
$aResult = DllCall("user32.dll", "int", "FillRect", "handle", $hDC, "struct*", $tRECT, "dword_ptr", $hBrush)
EndIf
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FrameRect($hDC, $tRECT, $hBrush)
Local $aResult = DllCall("user32.dll", "int", "FrameRect", "handle", $hDC, "struct*", $tRECT, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetBkMode($hDC)
Local $aResult = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDCEx($hWnd, $hRgn, $iFlags)
Local $aRet = DllCall('user32.dll', 'handle', 'GetDCEx', 'hwnd', $hWnd, 'handle', $hRgn, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetDeviceCaps($hDC, $iIndex)
Local $aResult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetTextColor($hDC)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetTextColor', 'handle', $hDC)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetWindowDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_PrintWindow($hWnd, $hDC, $bClient = False)
Local $aRet = DllCall('user32.dll', 'bool', 'PrintWindow', 'hwnd', $hWnd, 'handle', $hDC, 'uint', $bClient)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseDC($hWnd, $hDC)
Local $aResult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RestoreDC($hDC, $iID)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RestoreDC', 'handle', $hDC, 'int', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SaveDC($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'SaveDC', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBkColor($hDC, $iColor)
Local $aResult = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hDC, "INT", $iColor)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetBkMode($hDC, $iBkMode)
Local $aResult = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hDC, "int", $iBkMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetTextColor($hDC, $iColor)
Local $aResult = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hDC, "INT", $iColor)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_TwipsPerPixelX()
Local $hDC, $iTwipsPerPixelX
$hDC = _WinAPI_GetDC(0)
Local Const $__WINAPICONSTANT_LOGPIXELSX = 88
$iTwipsPerPixelX = 1440 / _WinAPI_GetDeviceCaps($hDC, $__WINAPICONSTANT_LOGPIXELSX)
_WinAPI_ReleaseDC(0, $hDC)
Return $iTwipsPerPixelX
EndFunc
Func _WinAPI_TwipsPerPixelY()
Local $hDC, $iTwipsPerPixelY
$hDC = _WinAPI_GetDC(0)
Local Const $__WINAPICONSTANT_LOGPIXELSY = 90
$iTwipsPerPixelY = 1440 / _WinAPI_GetDeviceCaps($hDC, $__WINAPICONSTANT_LOGPIXELSY)
_WinAPI_ReleaseDC(0, $hDC)
Return $iTwipsPerPixelY
EndFunc
#EndRegion Public Functions
#Region Internal Functions
#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Global Const $tagICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Func _WinAPI_AddIconTransparency($hIcon, $iPercent = 50, $bDelete = False)
Local $tBITMAP, $hDib = 0, $hResult = 0
Local $ahBitmap[2]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $iError = 0
Do
$hDib = _WinAPI_CopyBitmap($ahBitmap[1])
If Not $hDib Then
$iError = 20
ExitLoop
EndIf
$tBITMAP = DllStructCreate($tagBITMAP)
If (Not _WinAPI_GetObject($hDib, DllStructGetSize($tBITMAP), $tBITMAP)) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 32) Then
$iError = 21
ExitLoop
EndIf
$aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'PTR', __TransparencyProc(), 'hwnd', 0,  'uint', $iPercent, 'wparam', DllStructGetPtr($tBITMAP), 'lparam', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
If $aRet[0] = -1 Then
$hResult = _WinAPI_CreateEmptyIcon(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Else
$hResult = _WinAPI_CreateIconIndirect($hDib, $ahBitmap[0])
EndIf
If Not $hResult Then $iError = 22
Until 1
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
For $i = 0 To 1
If $ahBitmap[$i] Then
_WinAPI_DeleteObject($ahBitmap[$i])
EndIf
Next
If $iError Then Return SetError($iError, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CopyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_Create32BitHICON($hIcon, $bDelete = False)
Local $ahBitmap[2], $hResult = 0
Local $aDIB[2][2] = [[0, 0], [0, 0]]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
If _WinAPI_IsAlphaBitmap($ahBitmap[1]) Then
$aDIB[0][0] = _WinAPI_CreateANDBitmap($ahBitmap[1])
If Not @error Then
$hResult = _WinAPI_CreateIconIndirect($ahBitmap[1], $aDIB[0][0])
EndIf
Else
Local $tSIZE = _WinAPI_GetBitmapDimension($ahBitmap[1])
Local $aSize[2]
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tSIZE, $i + 1)
Next
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv, $hDstSv
For $i = 0 To 1
$aDIB[$i][0] = _WinAPI_CreateDIB($aSize[0], $aSize[1])
$aDIB[$i][1] = $__g_vExt
$hSrcSv = _WinAPI_SelectObject($hSrcDC, $ahBitmap[$i])
$hDstSv = _WinAPI_SelectObject($hDstDC, $aDIB[$i][0])
_WinAPI_BitBlt($hDstDC, 0, 0, $aSize[0], $aSize[1], $hSrcDC, 0, 0, 0x00C000CA)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_SelectObject($hDstDC, $hDstSv)
Next
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_DeleteDC($hDstDC)
$aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __XORProc(), 'ptr', 0,  'uint', $aSize[0] * $aSize[1] * 4, 'wparam', $aDIB[0][1], 'lparam', $aDIB[1][1])
If Not @error And $aRet[0] Then
$hResult = _WinAPI_CreateIconIndirect($aDIB[1][0], $ahBitmap[0])
EndIf
EndIf
For $i = 0 To 1
_WinAPI_DeleteObject($ahBitmap[$i])
If $aDIB[$i][0] Then
_WinAPI_DeleteObject($aDIB[$i][0])
EndIf
Next
If Not $hResult Then Return SetError(11, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CreateEmptyIcon($iWidth, $iHeight, $iBitsPerPel = 32)
Local $hXOR = _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel)
Local $hAND = _WinAPI_CreateDIB($iWidth, $iHeight, 1)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hAND)
Local $hBrush = _WinAPI_CreateSolidBrush(0xFFFFFF)
Local $tRECT = _WinAPI_CreateRect(0, 0, $iWidth, $iHeight)
_WinAPI_FillRect($hDC, $tRECT, $hBrush)
_WinAPI_DeleteObject($hBrush)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Local $hIcon = _WinAPI_CreateIconIndirect($hXOR, $hAND)
Local $iError = @error
If $hXOR Then
_WinAPI_DeleteObject($hXOR)
EndIf
If $hAND Then
_WinAPI_DeleteObject($hAND)
EndIf
If Not $hIcon Then Return SetError($iError + 10, 0, 0)
Return $hIcon
EndFunc
Func _WinAPI_CreateIcon($hInstance, $iWidth, $iHeight, $iPlanes, $iBitsPixel, $pANDBits, $pXORBits)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIcon', 'handle', $hInstance, 'int', $iWidth, 'int', $iHeight,  'byte', $iPlanes, 'byte', $iBitsPixel, 'struct*', $pANDBits, 'struct*', $pXORBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIconFromResourceEx($pData, $iSize, $bIcon = True, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIconFromResourceEx', 'ptr', $pData, 'dword', $iSize, 'bool', $bIcon,  'dword', 0x00030000, 'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIconIndirect($hBitmap, $hMask, $iXHotspot = 0, $iYHotspot = 0, $bIcon = True)
Local $tICONINFO = DllStructCreate($tagICONINFO)
DllStructSetData($tICONINFO, 1, $bIcon)
DllStructSetData($tICONINFO, 2, $iXHotspot)
DllStructSetData($tICONINFO, 3, $iYHotspot)
DllStructSetData($tICONINFO, 4, $hMask)
DllStructSetData($tICONINFO, 5, $hBitmap)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIconIndirect', 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DestroyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ExtractIcon($sIcon, $iIndex, $bSmall = False)
Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')
If $bSmall Then
$pLarge = 0
$pSmall = DllStructGetPtr($tPtr)
Else
$pLarge = DllStructGetPtr($tPtr)
$pSmall = 0
EndIf
DllCall('shell32.dll', 'uint', 'ExtractIconExW', 'wstr', $sIcon, 'int', $iIndex, 'ptr', $pLarge, 'ptr', $pSmall, 'uint', 1)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPtr, 1)
EndFunc
Func _WinAPI_ExtractIconEx($sFilePath, $iIndex, $paLarge, $paSmall, $iIcons)
Local $aResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sFilePath, "int", $iIndex, "struct*", $paLarge,  "struct*", $paSmall, "uint", $iIcons)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FileIconInit($bRestore = True)
Local $aRet = DllCall('shell32.dll', 'int', 660, 'int', $bRestore)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return 1
EndFunc
Func _WinAPI_GetIconDimension($hIcon)
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $tSIZE = _WinAPI_GetBitmapDimension(DllStructGetData($tICONINFO, 5))
For $i = 4 To 5
_WinAPI_DeleteObject(DllStructGetData($tICONINFO, $i))
Next
If Not IsDllStruct($tSIZE) Then Return SetError(20, 0, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetIconInfo($hIcon)
Local $tInfo = DllStructCreate($tagICONINFO)
Local $aRet = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hIcon, "struct*", $tInfo)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aIcon[6]
$aIcon[0] = True
$aIcon[1] = DllStructGetData($tInfo, "Icon") <> 0
$aIcon[2] = DllStructGetData($tInfo, "XHotSpot")
$aIcon[3] = DllStructGetData($tInfo, "YHotSpot")
$aIcon[4] = DllStructGetData($tInfo, "hMask")
$aIcon[5] = DllStructGetData($tInfo, "hColor")
Return $aIcon
EndFunc
Func _WinAPI_GetIconInfoEx($hIcon)
Local $tIIEX = DllStructCreate('dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]')
DllStructSetData($tIIEX, 1, DllStructGetSize($tIIEX))
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfoExW', 'handle', $hIcon, 'struct*', $tIIEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[8]
For $i = 0 To 7
$aResult[$i] = DllStructGetData($tIIEX, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_LoadIcon($hInstance, $sName)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'LoadIconW', 'handle', $hInstance, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadIconMetric($hInstance, $sName, $iMetric)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('comctl32.dll', 'long', 'LoadIconMetric', 'handle', $hInstance, $sTypeOfName, $sName, 'int', $iMetric, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[4]
EndFunc
Func _WinAPI_LoadIconWithScaleDown($hInstance, $sName, $iWidth, $iHeight)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('comctl32.dll', 'long', 'LoadIconWithScaleDown', 'handle', $hInstance, $sTypeOfName, $sName,  'int', $iWidth, 'int', $iHeight, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[5]
EndFunc
Func _WinAPI_LoadShell32Icon($iIconID)
Local $tIcons = DllStructCreate("ptr Data")
Local $iIcons = _WinAPI_ExtractIconEx("shell32.dll", $iIconID, 0, $tIcons, 1)
If @error Then Return SetError(@error, @extended, 0)
If $iIcons <= 0 Then Return SetError(10, 0, 0)
Return DllStructGetData($tIcons, "Data")
EndFunc
Func _WinAPI_LookupIconIdFromDirectoryEx($pData, $bIcon = True, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'int', 'LookupIconIdFromDirectoryEx', 'ptr', $pData, 'bool', $bIcon,  'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MirrorIcon($hIcon, $bDelete = False)
If Not $bDelete Then
$hIcon = _WinAPI_CopyIcon($hIcon)
EndIf
Local $aRet = DllCall('comctl32.dll', 'int', 414, 'ptr', 0, 'ptr*', $hIcon)
If @error Or Not $aRet[0] Then
Local $iError = @error + 10
If $hIcon And Not $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return SetError($iError, 0, 0)
EndIf
Return $aRet[2]
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
Func __TransparencyProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C0505050505050' &  '4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522' &  '488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502' &  'EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63' &  '7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF' &  '7D08C74424780000000048C74424280100000048C74424300000000048C74424' &  '3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF' &  'F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18' &  '4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C' &  '244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899' &  '48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7' &  '4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24' &  '3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0' &  'FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F' &  '5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24' &  '28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021' &  'C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24' &  '2421DB7D08C744242400000000C7042401000000C744240400000000C7442408' &  '000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B' &  '6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24' &  '100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058' &  '8845008B6C240C807D00007407C7042400000000C74424040100000083442408' &  '047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF' &  'FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
#EndRegion Embedded DLL Functions
#Region Global Variables and Constants
Global Const $tagBITMAPV4HEADER = 'struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct'
Global Const $tagCOLORADJUSTMENT = 'ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint'
Global Const $tagDEVMODE = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight'
Global Const $tagDEVMODE_DISPLAY = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;' & $tagPOINT & ';dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency'
Global Const $tagDWM_COLORIZATION_PARAMETERS = 'dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend'
Global Const $tagENHMETAHEADER = 'struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct'
Global Const $tagEXTLOGPEN = 'dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries'
Global Const $tagFONTSIGNATURE = 'dword fsUsb[4];dword fsCsb[2]'
Global Const $tagGLYPHMETRICS = 'uint BlackBoxX;uint BlackBoxY;' & $tagPOINT & ';short CellIncX;short CellIncY'
Global Const $tagLOGBRUSH = 'uint Style;dword Color;ulong_ptr Hatch'
Global Const $tagLOGPEN = 'uint Style;dword Width;dword Color'
Global Const $tagMAT2 = 'short eM11[2];short eM12[2];short eM21[2];short eM22[2]'
Global Const $tagNEWTEXTMETRIC = $tagTEXTMETRIC & ';dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth'
Global Const $tagNEWTEXTMETRICEX = $tagNEWTEXTMETRIC & ';' & $tagFONTSIGNATURE
Global Const $tagPANOSE = 'struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct'
Global Const $tagOUTLINETEXTMETRIC = 'struct;uint otmSize;' & $tagTEXTMETRIC & ';byte otmFiller;' & $tagPANOSE & ';byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct'
Global Const $tagPAINTSTRUCT = 'hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]'
Global Const $tagRGNDATAHEADER = 'struct;dword Size;dword Type;dword Count;dword RgnSize;' & $tagRECT & ';endstruct'
Global Const $tagXFORM = 'float eM11;float eM12;float eM21;float eM22;float eDx;float eDy'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_AbortPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'AbortPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AddFontMemResourceEx($pData, $iSize)
Local $aRet = DllCall('gdi32.dll', 'handle', 'AddFontMemResourceEx', 'ptr', $pData, 'dword', $iSize, 'ptr', 0, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aRet[4], $aRet[0])
EndFunc
Func _WinAPI_AddFontResourceEx($sFont, $iFlag = 0, $bNotify = False)
Local $aRet = DllCall('gdi32.dll', 'int', 'AddFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
If $bNotify Then
Local Const $WM_FONTCHANGE = 0x001D
Local Const $HWND_BROADCAST = 0xFFFF
DllCall('user32.dll', 'lresult', 'SendMessage', 'hwnd', $HWND_BROADCAST, 'uint', $WM_FONTCHANGE, 'wparam', 0,  'lparam', 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_AddIconOverlay($hIcon, $hOverlay)
Local $aRet, $hResult = 0, $iError = 0
Local $ahDev[2] = [0, 0]
Local $tSIZE = _WinAPI_GetIconDimension($hIcon)
Local $hIL = DllCall('comctl32.dll', 'handle', 'ImageList_Create', 'int', DllStructGetData($tSIZE, 1),  'int', DllStructGetData($tSIZE, 2), 'uint', 0x0021, 'int', 2, 'int', 2)
If @error Or Not $hIL[0] Then Return SetError(@error + 10, @extended, 0)
Do
$ahDev[0] = _WinAPI_Create32BitHICON($hIcon)
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'handle', $hIL[0], 'int', -1, 'handle', $ahDev[0])
If @error Or ($aRet[0] = -1) Then
$iError = @error + 200
ExitLoop
EndIf
$ahDev[1] = _WinAPI_Create32BitHICON($hOverlay)
If @error Then
$iError = @error + 300
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'handle', $hIL[0], 'int', -1, 'handle', $ahDev[1])
If @error Or ($aRet[0] = -1) Then
$iError = @error + 400
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'bool', 'ImageList_SetOverlayImage', 'handle', $hIL[0], 'int', 1, 'int', 1)
If @error Or Not $aRet[0] Then
$iError = @error + 500
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'handle', 'ImageList_GetIcon', 'handle', $hIL[0], 'int', 0, 'uint', 0x00000100)
If @error Or Not $aRet[0] Then
$iError = @error + 600
ExitLoop
EndIf
$hResult = $aRet[0]
Until 1
DllCall('comctl32.dll', 'bool', 'ImageList_Destroy', 'handle', $hIL[0])
For $i = 0 To 1
If $ahDev[$i] Then
_WinAPI_DestroyIcon($ahDev[$i])
EndIf
Next
If Not $hResult Then Return SetError($iError, 0, 0)
Return $hResult
EndFunc
Func _WinAPI_AdjustBitmap($hBitmap, $iWidth, $iHeight, $iMode = 3, $tAdjustment = 0)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
If $iWidth = -1 Then
$iWidth = DllStructGetData($tObj, 'bmWidth')
EndIf
If $iHeight = -1 Then
$iHeight = DllStructGetData($tObj, 'bmHeight')
EndIf
$aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', 0)
Local $hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleBitmap', 'handle', $hDC, 'int', $iWidth, 'int', $iHeight)
Local $hBmp = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBmp)
Local $hDestSv = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hSrcDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hBitmap)
Local $hSrcSv = $aRet[0]
If _WinAPI_SetStretchBltMode($hDestDC, $iMode) Then
Switch $iMode
Case 4
If IsDllStruct($tAdjustment) Then
If Not _WinAPI_SetColorAdjustment($hDestDC, $tAdjustment) Then
EndIf
EndIf
Case Else
EndSwitch
EndIf
$aRet = _WinAPI_StretchBlt($hDestDC, 0, 0, $iWidth, $iHeight, $hSrcDC, 0, 0, DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'), 0x00CC0020)
DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'handle', $hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hSrcSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hSrcDC)
If Not $aRet Then Return SetError(10, 0, 0)
Return $hBmp
EndFunc
Func _WinAPI_AlphaBlend($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iAlpha, $bAlpha = False)
Local $iBlend = BitOR(BitShift(Not ($bAlpha = False), -24), BitShift(BitAND($iAlpha, 0xFF), -16))
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiAlphaBlend', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'handle', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iBlend)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AngleArc($hDC, $iX, $iY, $iRadius, $nStartAngle, $nSweepAngle)
Local $aRet = DllCall('gdi32.dll', 'bool', 'AngleArc', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', $iRadius,  'float', $nStartAngle, 'float', $nSweepAngle)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Arc($hDC, $tRECT, $iXStartArc, $iYStartArc, $iXEndArc, $iYEndArc)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Arc', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4),  'int', $iXStartArc, 'int', $iYStartArc, 'int', $iXEndArc, 'int', $iYEndArc)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ArcTo($hDC, $tRECT, $iXRadial1, $iYRadial1, $iXRadial2, $iYRadial2)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ArcTo', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4),  'int', $iXRadial1, 'int', $iYRadial1, 'int', $iXRadial2, 'int', $iYRadial2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginPaint($hWnd, ByRef $tPAINTSTRUCT)
$tPAINTSTRUCT = DllStructCreate($tagPAINTSTRUCT)
Local $aRet = DllCall('user32.dll', 'handle', 'BeginPaint', 'hwnd', $hWnd, 'struct*', $tPAINTSTRUCT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'BeginPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseEnhMetaFile($hDC)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CloseEnhMetaFile', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseFigure($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'CloseFigure', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ColorAdjustLuma($iRGB, $iPercent, $bScale = True)
If $iRGB = -1 Then Return SetError(10, 0, -1)
If $bScale Then
$iPercent = Floor($iPercent * 10)
EndIf
Local $aRet = DllCall('shlwapi.dll', 'dword', 'ColorAdjustLuma', 'dword', __RGB($iRGB), 'int', $iPercent, 'bool', $bScale)
If @error Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_ColorHLSToRGB($iHue, $iLuminance, $iSaturation)
If Not $iSaturation Then $iHue = 160
Local $aRet = DllCall('shlwapi.dll', 'dword', 'ColorHLSToRGB', 'word', $iHue, 'word', $iLuminance, 'word', $iSaturation)
If @error Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_ColorRGBToHLS($iRGB, ByRef $iHue, ByRef $iLuminance, ByRef $iSaturation)
Local $aRet = DllCall('shlwapi.dll', 'none', 'ColorRGBToHLS', 'dword', __RGB($iRGB), 'word*', 0, 'word*', 0, 'word*', 0)
If @error Then Return SetError(@error, @extended, 0)
$iHue = $aRet[2]
$iLuminance = $aRet[3]
$iSaturation = $aRet[4]
Return 1
EndFunc
Func _WinAPI_CombineTransform($tXFORM1, $tXFORM2)
Local $tXFORM = DllStructCreate($tagXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'CombineTransform', 'struct*', $tXFORM, 'struct*', $tXFORM1, 'struct*', $tXFORM2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tXFORM
EndFunc
Func _WinAPI_CompressBitmapBits($hBitmap, ByRef $pBuffer, $iCompression = 0, $iQuality = 100)
If Not __DLL('gdiplus.dll') Then Return SetError(103, 0, 0)
Local $aSize[2], $iCount, $iFormat, $iLength, $sMime, $aRet, $hDC, $hSv, $hMem, $tBits, $tData, $pData, $iError = 1
Local $hSource = 0, $hImage = 0, $hToken = 0, $pStream = 0, $tParam = 0
Local $tDIB = DllStructCreate($tagDIBSECTION)
Do
Switch $iCompression
Case 0
$sMime = 'image/png'
Case 1
$sMime = 'image/jpeg'
Case Else
$iError = 10
ExitLoop
EndSwitch
While $hBitmap
If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB) Then
$iError = 11
ExitLoop 2
EndIf
If (DllStructGetData($tDIB, 'bmBitsPixel') = 32) And (Not DllStructGetData($tDIB, 'biCompression')) Then
$iError = 12
ExitLoop
EndIf
If $hSource Then
$iError = 13
ExitLoop 2
EndIf
$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'))
If Not $hSource Then
$iError = @error + 100
ExitLoop 2
EndIf
$hDC = _WinAPI_CreateCompatibleDC(0)
$hSv = _WinAPI_SelectObject($hDC, $hSource)
If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
$hBitmap = $hSource
Else
$iError = @error + 200
$hBitmap = 0
EndIf
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
WEnd
If Not $hBitmap Then
ExitLoop
EndIf
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tDIB, $i + 2)
Next
$tBits = DllStructCreate('byte[' & ($aSize[0] * $aSize[1] * 4) & ']')
If Not _WinAPI_GetBitmapBits($hBitmap, DllStructGetSize($tBits), $tBits) Then
$iError = @error + 300
ExitLoop
EndIf
$tData = DllStructCreate($tagGDIPSTARTUPINPUT)
DllStructSetData($tData, "Version", 1)
$aRet = DllCall('gdiplus.dll', 'int', 'GdiplusStartup', 'ulong_ptr*', 0, 'struct*', $tData, 'ptr', 0)
If @error Or $aRet[0] Then
$iError = @error + 400
ExitLoop
EndIf
If _WinAPI_IsAlphaBitmap($hBitmap) Then
$iFormat = 0x0026200A
Else
$iFormat = 0x00022009
EndIf
$hToken = $aRet[1]
$aRet = DllCall('gdiplus.dll', 'int', 'GdipCreateBitmapFromScan0', 'int', $aSize[0], 'int', $aSize[1],  'uint', $aSize[0] * 4, 'int', $iFormat, 'struct*', $tBits, 'ptr*', 0)
If @error Or $aRet[0] Then
$iError = @error + 500
ExitLoop
EndIf
$hImage = $aRet[6]
$aRet = DllCall('gdiplus.dll', 'int', 'GdipGetImageEncodersSize', 'uint*', 0, 'uint*', 0)
If @error Or $aRet[0] Then
$iError = @error + 600
ExitLoop
EndIf
$iCount = $aRet[1]
$tData = DllStructCreate('byte[' & $aRet[2] & ']')
If @error Then
$iError = @error + 700
ExitLoop
EndIf
$pData = DllStructGetPtr($tData)
$aRet = DllCall('gdiplus.dll', 'int', 'GdipGetImageEncoders', 'uint', $iCount, 'uint', $aRet[2], 'struct*', $tData)
If @error Or $aRet[0] Then
$iError = @error + 800
ExitLoop
EndIf
Local $tCodec, $pEncoder = 0
For $i = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pData)
If Not StringInStr(_WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, 'MimeType')), $sMime) Then
$pData += DllStructGetSize($tagGDIPIMAGECODECINFO)
Else
$pEncoder = $pData
$iError = 0
ExitLoop
EndIf
Next
If Not $pEncoder Then
$iError = 15
ExitLoop
EndIf
Switch $iCompression
Case 0
Case 1
Local Const $tagENCODERPARAMETER = 'byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue'
$tParam = DllStructCreate('dword Count;' & $tagENCODERPARAMETER & ';ulong Quality')
DllStructSetData($tParam, 'Count', 1)
DllStructSetData($tParam, 'NumberOfValues', 1)
DllStructSetData($tParam, 'Type', 4)
DllStructSetData($tParam, 'pValue', DllStructGetPtr($tParam, 'Quality'))
DllStructSetData($tParam, 'Quality', $iQuality)
$aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}',  'ptr', DllStructGetPtr($tParam, 2))
If @error Or $aRet[0] Then
$tParam = 0
EndIf
EndSwitch
$pStream = _WinAPI_CreateStreamOnHGlobal()
$aRet = DllCall('gdiplus.dll', 'int', 'GdipSaveImageToStream', 'handle', $hImage, 'ptr', $pStream,  'ptr', $pEncoder, 'struct*', $tParam)
If @error Or $aRet[0] Then
$iError = @error + 900
ExitLoop
EndIf
$hMem = _WinAPI_GetHGlobalFromStream($pStream)
$aRet = DllCall('kernel32.dll', 'ulong_ptr', 'GlobalSize', 'handle', $hMem)
If @error Or Not $aRet[0] Then
$iError = @error + 1000
ExitLoop
EndIf
$iLength = $aRet[0]
$aRet = DllCall('kernel32.dll', 'ptr', 'GlobalLock', 'handle', $hMem)
If @error Or Not $aRet[0] Then
$iError = @error + 1100
ExitLoop
EndIf
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 1)
If Not @error Then
_WinAPI_MoveMemory($pBuffer, $aRet[0], $iLength)
Else
$iError = @error + 1300
EndIf
Until 1
If $pStream Then
_WinAPI_ReleaseStream($pStream)
EndIf
If $hImage Then
DllCall('gdiplus.dll', 'int', 'GdipDisposeImage', 'handle', $hImage)
EndIf
If $hToken Then
DllCall('gdiplus.dll', 'none', 'GdiplusShutdown', 'ulong_ptr', $hToken)
EndIf
If $hSource Then
_WinAPI_DeleteObject($hSource)
EndIf
If $iError Then Return SetError($iError, 0, 0)
Return $iLength
EndFunc
Func _WinAPI_CopyEnhMetaFile($hEmf, $sFilePath = '')
Local $sTypeOfFile = 'wstr'
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFile = 'ptr'
$sFilePath = 0
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CopyEnhMetaFileW', 'handle', $hEmf, $sTypeOfFile, $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CopyRect($tRECT)
Local $tData = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'CopyRect', 'struct*', $tData, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then SetError(@error + 10, @extended, 0)
Return $tData
EndFunc
Func _WinAPI_Create32BitHBITMAP($hIcon, $bDib = False, $bDelete = False)
Local $hBitmap = 0
Local $aDIB[2] = [0, 0]
Local $hTemp = _WinAPI_Create32BitHICON($hIcon)
If @error Then Return SetError(@error, @extended, 0)
Local $iError = 0
Do
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hTemp, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
For $i = 0 To 1
$aDIB[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($aDIB[0], DllStructGetSize($tBITMAP), $tBITMAP) Then
$iError = @error + 20
ExitLoop
EndIf
If $bDib Then
$hBitmap = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
_WinAPI_DrawIconEx($hDC, 0, 0, $hTemp)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = $aDIB[1]
$aDIB[1] = 0
EndIf
Until 1
For $i = 0 To 1
If $aDIB[$i] Then
_WinAPI_DeleteObject($aDIB[$i])
EndIf
Next
_WinAPI_DestroyIcon($hTemp)
If $iError Then Return SetError($iError, 0, 0)
If Not $hBitmap Then Return SetError(12, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hBitmap
EndFunc
Func _WinAPI_CreateBitmapIndirect(ByRef $tBITMAP)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateBitmapIndirect', 'struct*', $tBITMAP)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateBrushIndirect($iStyle, $iRGB, $iHatch = 0)
Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)
DllStructSetData($tLOGBRUSH, 1, $iStyle)
DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
DllStructSetData($tLOGBRUSH, 3, $iHatch)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateBrushIndirect', 'struct*', $tLOGBRUSH)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateColorAdjustment($iFlags = 0, $iIlluminant = 0, $iGammaR = 10000, $iGammaG = 10000, $iGammaB = 10000, $iBlack = 0, $iWhite = 10000, $iContrast = 0, $iBrightness = 0, $iColorfulness = 0, $iTint = 0)
Local $tCA = DllStructCreate($tagCOLORADJUSTMENT)
DllStructSetData($tCA, 1, DllStructGetSize($tCA))
DllStructSetData($tCA, 2, $iFlags)
DllStructSetData($tCA, 3, $iIlluminant)
DllStructSetData($tCA, 4, $iGammaR)
DllStructSetData($tCA, 5, $iGammaG)
DllStructSetData($tCA, 6, $iGammaB)
DllStructSetData($tCA, 7, $iBlack)
DllStructSetData($tCA, 8, $iWhite)
DllStructSetData($tCA, 9, $iContrast)
DllStructSetData($tCA, 10, $iBrightness)
DllStructSetData($tCA, 11, $iColorfulness)
DllStructSetData($tCA, 12, $iTint)
Return $tCA
EndFunc
Func _WinAPI_CreateCompatibleBitmapEx($hDC, $iWidth, $iHeight, $iRGB)
Local $hBrush = _WinAPI_CreateBrushIndirect(0, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleBitmap', 'handle', $hDC, 'int', $iWidth, 'int', $iHeight)
Local $hBmp = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBmp)
Local $hDestSv = $aRet[0]
Local $tRECT = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
Local $iError = 0
$aRet = DllCall('user32.dll', 'int', 'FillRect', 'handle', $hDestDC, 'struct*', $tRECT, 'handle', $hBrush)
If @error Or Not $aRet[0] Then
$iError = @error + 10
_WinAPI_DeleteObject($hBmp)
EndIf
_WinAPI_DeleteObject($hBrush)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
If $iError Then Return SetError($iError, 0, 0)
Return $hBmp
EndFunc
Func _WinAPI_CreateDIBitmap($hDC, ByRef $tBITMAPINFO, $iUsage, $pBits = 0)
Local $iInit = 0
If $pBits Then
$iInit = 0x04
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBitmap', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'dword', $iInit, 'struct*', $pBits,  'struct*', $tBITMAPINFO, 'uint', $iUsage)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateEllipticRgn($tRECT)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateEllipticRgnIndirect', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateEnhMetaFile($hDC = 0, $tRECT = 0, $bPixels = False, $sFilePath = '', $sDescription = '')
Local $sTypeOfFile = 'wstr'
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFile = 'ptr'
$sFilePath = 0
EndIf
Local $tData = 0, $aData = StringSplit($sDescription, '|', $STR_NOCOUNT)
If UBound($aData) < 2 Then
ReDim $aData[2]
$aData[1] = ''
EndIf
For $i = 0 To 1
$aData[$i] = StringStripWS($aData[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)
Next
If ($aData[0]) Or ($aData[1]) Then
$tData = _WinAPI_ArrayToStruct($aData)
EndIf
Local $iXp, $iYp, $iXm, $iYm, $hRef = 0
If $bPixels And (IsDllStruct($tRECT)) Then
If Not $hDC Then
$hRef = _WinAPI_GetDC(0)
EndIf
$iXp = _WinAPI_GetDeviceCaps($hRef, 8)
$iYp = _WinAPI_GetDeviceCaps($hRef, 10)
$iXm = _WinAPI_GetDeviceCaps($hRef, 4)
$iYm = _WinAPI_GetDeviceCaps($hRef, 6)
If $hRef Then
_WinAPI_ReleaseDC(0, $hRef)
EndIf
For $i = 1 To 3 Step 2
DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $iXm / $iXp * 100))
Next
For $i = 2 To 4 Step 2
DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $iYm / $iYp * 100))
Next
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateEnhMetaFileW', 'handle', $hDC, $sTypeOfFile, $sFilePath, 'struct*', $tRECT,  'struct*', $tData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateFontEx($iHeight, $iWidth = 0, $iEscapement = 0, $iOrientation = 0, $iWeight = 400, $bItalic = False, $bUnderline = False, $bStrikeOut = False, $iCharSet = 1, $iOutPrecision = 0, $iClipPrecision = 0, $iQuality = 0, $iPitchAndFamily = 0, $sFaceName = '', $iStyle = 0)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateFontW', 'int', $iHeight, 'int', $iWidth, 'int', $iEscapement,  'int', $iOrientation, 'int', $iWeight, 'dword', $bItalic, 'dword', $bUnderline, 'dword', $bStrikeOut,  'dword', $iCharSet, 'dword', $iOutPrecision, 'dword', $iClipPrecision, 'dword', $iQuality,  'dword', $iPitchAndFamily, 'wstr', _WinAPI_GetFontName($sFaceName, $iStyle, $iCharSet))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateNullRgn()
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateRectRgn', 'int', 0, 'int', 0, 'int', 0, 'int', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreatePen($iPenStyle, $iWidth, $iColor)
Local $aResult = DllCall("gdi32.dll", "handle", "CreatePen", "int", $iPenStyle, "int", $iWidth, "INT", $iColor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreatePolygonRgn(Const ByRef $aPoint, $iStart = 0, $iEnd = -1, $iMode = 1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, 0)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'int[2];'
Next
Local $tData = DllStructCreate($tagStruct)
Local $iCount = 1
For $i = $iStart To $iEnd
For $j = 0 To 1
DllStructSetData($tData, $iCount, $aPoint[$i][$j], $j + 1)
Next
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreatePolygonRgn', 'struct*', $tData, 'int', $iCount - 1, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateRectRgnIndirect($tRECT)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateRectRgnIndirect', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight, $bRGB = 1)
Local $hDC = _WinAPI_GetDC($hWnd)
Local $hDestDC = _WinAPI_CreateCompatibleDC($hDC)
Local $hBitmap = _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $hOld = _WinAPI_SelectObject($hDestDC, $hBitmap)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, 0)
DllStructSetData($tRECT, 2, 0)
DllStructSetData($tRECT, 3, $iWidth)
DllStructSetData($tRECT, 4, $iHeight)
If $bRGB Then
$iColor = BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndIf
Local $hBrush = _WinAPI_CreateSolidBrush($iColor)
If Not _WinAPI_FillRect($hDestDC, $tRECT, $hBrush) Then
_WinAPI_DeleteObject($hBitmap)
$hBitmap = 0
EndIf
_WinAPI_DeleteObject($hBrush)
_WinAPI_ReleaseDC($hWnd, $hDC)
_WinAPI_SelectObject($hDestDC, $hOld)
_WinAPI_DeleteDC($hDestDC)
If Not $hBitmap Then Return SetError(1, 0, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateTransform($nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $tXFORM = DllStructCreate($tagXFORM)
DllStructSetData($tXFORM, 1, $nM11)
DllStructSetData($tXFORM, 2, $nM12)
DllStructSetData($tXFORM, 3, $nM21)
DllStructSetData($tXFORM, 4, $nM22)
DllStructSetData($tXFORM, 5, $nDX)
DllStructSetData($tXFORM, 6, $nDY)
Return $tXFORM
EndFunc
Func _WinAPI_DeleteEnhMetaFile($hEmf)
Local $aRet = DllCall('gdi32.dll', 'bool', 'DeleteEnhMetaFile', 'handle', $hEmf)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DPtoLP($hDC, ByRef $tPOINT, $iCount = 1)
Local $aRet = DllCall('gdi32.dll', 'bool', 'DPtoLP', 'handle', $hDC, 'struct*', $tPOINT, 'int', $iCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawAnimatedRects($hWnd, $tRectFrom, $tRectTo)
Local $aRet = DllCall('user32.dll', 'bool', 'DrawAnimatedRects', 'hwnd', $hWnd, 'int', 3, 'struct*', $tRectFrom,  'struct*', $tRectTo)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawBitmap($hDC, $iX, $iY, $hBitmap, $iRop = 0x00CC0020)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', 0)
Local $_hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $_hDC)
Local $hSrcDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hBitmap)
Local $hSrcSv = $aRet[0]
Local $iError = 0
$aRet = DllCall('gdi32.dll', 'int', 'BitBlt', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'int', DllStructGetData($tObj, 'bmWidth'), 'int', DllStructGetData($tObj, 'bmHeight'), 'hwnd', $hSrcDC, 'int', 0, 'int', 0, 'int', $iRop)
If @error Or Not $aRet[0] Then
$iError = @error + 1
EndIf
DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'handle', $_hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hSrcSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hSrcDC)
If $iError Then Return SetError(10, 0, 0)
Return 1
EndFunc
Func _WinAPI_DrawFocusRect($hDC, $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'DrawFocusRect', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawLine($hDC, $iX1, $iY1, $iX2, $iY2)
_WinAPI_MoveTo($hDC, $iX1, $iY1)
If @error Then Return SetError(@error, @extended, False)
_WinAPI_LineTo($hDC, $iX2, $iY2)
If @error Then Return SetError(@error + 10, @extended, False)
Return True
EndFunc
Func _WinAPI_DrawShadowText($hDC, $sText, $iRGBText, $iRGBShadow, $iXOffset = 0, $iYOffset = 0, $tRECT = 0, $iFlags = 0)
Local $aRet
If Not IsDllStruct($tRECT) Then
$tRECT = DllStructCreate($tagRECT)
$aRet = DllCall('user32.dll', 'bool', 'GetClientRect', 'hwnd', _WinAPI_WindowFromDC($hDC), 'struct*', $tRECT)
If @error Then Return SetError(@error + 10, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'DrawShadowText', 'handle', $hDC, 'wstr', $sText, 'uint', -1, 'struct*', $tRECT,  'dword', $iFlags, 'int', __RGB($iRGBText), 'int', __RGB($iRGBShadow), 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DwmDefWindowProc($hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('dwmapi.dll', 'bool', 'DwmDefWindowProc', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam, 'lresult*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[5]
EndFunc
Func _WinAPI_DwmEnableBlurBehindWindow($hWnd, $bEnable = True, $bTransition = False, $hRgn = 0)
Local $tBLURBEHIND = DllStructCreate('dword;bool;handle;bool')
Local $iFlags = 0
If $hRgn Then
$iFlags += 2
DllStructSetData($tBLURBEHIND, 3, $hRgn)
EndIf
DllStructSetData($tBLURBEHIND, 1, BitOR($iFlags, 0x05))
DllStructSetData($tBLURBEHIND, 2, $bEnable)
DllStructSetData($tBLURBEHIND, 4, $bTransition)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableBlurBehindWindow', 'hwnd', $hWnd, 'struct*', $tBLURBEHIND)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmEnableComposition($bEnable)
If $bEnable Then $bEnable = 1
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableComposition', 'uint', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmExtendFrameIntoClientArea($hWnd, $tMARGINS = 0)
If Not IsDllStruct($tMARGINS) Then
$tMARGINS = _WinAPI_CreateMargins(-1, -1, -1, -1)
EndIf
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmExtendFrameIntoClientArea', 'hwnd', $hWnd, 'struct*', $tMARGINS)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmGetColorizationColor()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmGetColorizationColor', 'dword*', 0, 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return SetExtended($aRet[2], $aRet[1])
EndFunc
Func _WinAPI_DwmGetColorizationParameters()
Local $tDWMCP = DllStructCreate($tagDWM_COLORIZATION_PARAMETERS)
Local $aRet = DllCall('dwmapi.dll', 'uint', 127, 'struct*', $tDWMCP)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tDWMCP
EndFunc
Func _WinAPI_DwmGetWindowAttribute($hWnd, $iAttribute)
Local $tagStruct
Switch $iAttribute
Case 5, 9
$tagStruct = $tagRECT
Case 1
$tagStruct = 'uint'
Case Else
Return SetError(11, 0, 0)
EndSwitch
Local $tData = DllStructCreate($tagStruct)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmGetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute,  'struct*', $tData, 'dword', DllStructGetSize($tData))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Switch $iAttribute
Case 1
Return DllStructGetData($tData, 1)
Case Else
Return $tData
EndSwitch
EndFunc
Func _WinAPI_DwmInvalidateIconicBitmaps($hWnd)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmInvalidateIconicBitmaps', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmIsCompositionEnabled()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmIsCompositionEnabled', 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[1]
EndFunc
Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmQueryThumbnailSourceSize', 'handle', $hThumbnail, 'struct*', $tSIZE)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tSIZE
EndFunc
Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[3]
EndFunc
Func _WinAPI_DwmSetColorizationParameters($tDWMCP)
Local $aRet = DllCall('dwmapi.dll', 'uint', 131, 'struct*', $tDWMCP, 'uint', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetIconicLivePreviewBitmap($hWnd, $hBitmap, $bFrame = False, $tClient = 0)
Local $iFlags
If $bFrame Then
$iFlags = 0x00000001
Else
$iFlags = 0
EndIf
Local $aRet = DllCall('dwmapi.dll', 'uint', 'DwmSetIconicLivePreviewBitmap', 'hwnd', $hWnd, 'handle', $hBitmap,  'struct*', $tClient, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetIconicThumbnail($hWnd, $hBitmap, $bFrame = False)
Local $iFlags
If $bFrame Then
$iFlags = 0x00000001
Else
$iFlags = 0
EndIf
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmSetIconicThumbnail', 'hwnd', $hWnd, 'handle', $hBitmap, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetWindowAttribute($hWnd, $iAttribute, $iData)
Switch $iAttribute
Case 2, 3, 4, 6, 7, 8, 10, 11, 12
Case Else
Return SetError(1, 0, 0)
EndSwitch
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmSetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute,  'dword*', $iData, 'dword', 4)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUnregisterThumbnail', 'handle', $hThumbnail)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $bVisible = True, $bClientAreaOnly = False, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)
Local Const $tagDWM_THUMBNAIL_PROPERTIES = 'struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct'
Local $tTHUMBNAILPROPERTIES = DllStructCreate($tagDWM_THUMBNAIL_PROPERTIES)
Local $tSIZE, $iFlags = 0
If Not IsDllStruct($tRectDest) Then
$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
If @error Then
Return SetError(@error + 10, @extended, 0)
EndIf
$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
EndIf
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 2, DllStructGetData($tRectDest, $i), $i)
Next
If IsDllStruct($tRectSrc) Then
$iFlags += 2
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 3, DllStructGetData($tRectSrc, $i), $i)
Next
EndIf
DllStructSetData($tTHUMBNAILPROPERTIES, 1, BitOR($iFlags, 0x1D))
DllStructSetData($tTHUMBNAILPROPERTIES, 4, $iOpacity)
DllStructSetData($tTHUMBNAILPROPERTIES, 5, $bVisible)
DllStructSetData($tTHUMBNAILPROPERTIES, 6, $bClientAreaOnly)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUpdateThumbnailProperties', 'handle', $hThumbnail,  'struct*', $tTHUMBNAILPROPERTIES)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_Ellipse($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Ellipse', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EndPaint($hWnd, ByRef $tPAINTSTRUCT)
Local $aRet = DllCall('user32.dll', 'bool', 'EndPaint', 'hwnd', $hWnd, 'struct*', $tPAINTSTRUCT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EndPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'EndPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumDisplayMonitors($hDC = 0, $tRECT = 0)
Local $hEnumProc = DllCallbackRegister('__EnumDisplayMonitorsProc', 'bool', 'handle;handle;ptr;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDisplayMonitors', 'handle', $hDC, 'struct*', $tRECT,  'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDisplaySettings($sDevice, $iMode)
Local $sTypeOfDevice = 'wstr'
If Not StringStripWS($sDevice, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfDevice = 'ptr'
$sDevice = 0
EndIf
Local $tDEVMODE = DllStructCreate($tagDEVMODE_DISPLAY)
DllStructSetData($tDEVMODE, 'Size', DllStructGetSize($tDEVMODE))
DllStructSetData($tDEVMODE, 'DriverExtra', 0)
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDisplaySettingsW', $sTypeOfDevice, $sDevice, 'dword', $iMode,  'struct*', $tDEVMODE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[5]
$aResult[0] = DllStructGetData($tDEVMODE, 'PelsWidth')
$aResult[1] = DllStructGetData($tDEVMODE, 'PelsHeight')
$aResult[2] = DllStructGetData($tDEVMODE, 'BitsPerPel')
$aResult[3] = DllStructGetData($tDEVMODE, 'DisplayFrequency')
$aResult[4] = DllStructGetData($tDEVMODE, 'DisplayFlags')
Return $aResult
EndFunc
Func _WinAPI_EnumFontFamilies($hDC = 0, $sFaceName = '', $iCharSet = 1, $iFontType = 0x07, $sPattern = '', $bExclude = False)
Local $tLOGFONT = DllStructCreate($tagLOGFONT)
Local $tPattern = DllStructCreate('uint;uint;ptr;wchar[' & (StringLen($sPattern) + 1) & ']')
DllStructSetData($tPattern, 1, $iFontType)
If Not $sPattern Then
DllStructSetData($tPattern, 2, 0)
DllStructSetData($tPattern, 3, 0)
Else
DllStructSetData($tPattern, 2, $bExclude)
DllStructSetData($tPattern, 3, DllStructGetPtr($tPattern, 4))
DllStructSetData($tPattern, 4, $sPattern)
EndIf
DllStructSetData($tLOGFONT, 9, $iCharSet)
DllStructSetData($tLOGFONT, 13, 0)
DllStructSetData($tLOGFONT, 14, StringLeft($sFaceName, 31))
Local $hCDC
If Not $hDC Then
$hCDC = _WinAPI_CreateCompatibleDC(0)
Else
$hCDC = $hDC
EndIf
Dim $__g_vEnum[101][8] = [[0]]
Local $hEnumProc = DllCallbackRegister('__EnumFontFamiliesProc', 'int', 'ptr;ptr;dword;PTR')
Local $aRet = DllCall('gdi32.dll', 'int', 'EnumFontFamiliesExW', 'handle', $hCDC, 'struct*', $tLOGFONT,  'ptr', DllCallbackGetPtr($hEnumProc), 'struct*', $tPattern, 'dword', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If Not $hDC Then
_WinAPI_DeleteDC($hCDC)
EndIf
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EqualRect($tRECT1, $tRECT2)
Local $aRet = DllCall('user32.dll', 'bool', 'EqualRect', 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EqualRgn($hRgn1, $hRgn2)
Local $aRet = DllCall('gdi32.dll', 'bool', 'EqualRgn', 'handle', $hRgn1, 'handle', $hRgn2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ExcludeClipRect($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'ExcludeClipRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtCreatePen($iPenStyle, $iWidth, $iBrushStyle, $iRGB, $iHatch = 0, $aUserStyle = 0, $iStart = 0, $iEnd = -1)
Local $iCount = 0, $tStyle = 0
If BitAND($iPenStyle, 0xFF) = 7 Then
If __CheckErrorArrayBounds($aUserStyle, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$tStyle = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
For $i = $iStart To $iEnd
DllStructSetData($tStyle, 1, $aUserStyle[$i], $iCount + 1)
$iCount += 1
Next
EndIf
Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)
DllStructSetData($tLOGBRUSH, 1, $iBrushStyle)
DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
DllStructSetData($tLOGBRUSH, 3, $iHatch)
Local $aRet = DllCall('gdi32.dll', 'handle', 'ExtCreatePen', 'dword', $iPenStyle, 'dword', $iWidth, 'struct*', $tLOGBRUSH,  'dword', $iCount, 'struct*', $tStyle)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtCreateRegion($tRGNDATA, $tXFORM = 0)
Local $aRet = DllCall('gdi32.dll', 'handle', 'ExtCreateRegion', 'struct*', $tXFORM, 'dword', DllStructGetSize($tRGNDATA),  'struct*', $tRGNDATA)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtFloodFill($hDC, $iX, $iY, $iRGB, $iType = 0)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ExtFloodFill', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB),  'uint', $iType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtSelectClipRgn($hDC, $hRgn, $iMode = 5)
Local $aRet = DllCall('gdi32.dll', 'int', 'ExtSelectClipRgn', 'handle', $hDC, 'handle', $hRgn, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FillPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FillPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FillRgn($hDC, $hRgn, $hBrush)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FillRgn', 'handle', $hDC, 'handle', $hRgn, 'handle', $hBrush)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FlattenPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FlattenPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FrameRgn($hDC, $hRgn, $hBrush, $iWidth, $iHeight)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FrameRgn', 'handle', $hDC, 'handle', $hRgn, 'handle', $hBrush, 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GdiComment($hDC, $pBuffer, $iSize)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiComment', 'handle', $hDC, 'uint', $iSize, 'struct*', $pBuffer)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GetArcDirection($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetArcDirection', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
If ($aRet[0] < 1) Or ($aRet[0] > 2) Then Return SetError(10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetBitmapBits($hBitmap, $iSize, $pBits)
Local $aRet = DllCall('gdi32.dll', 'long', 'GetBitmapBits', 'handle', $hBitmap, 'long', $iSize, 'struct*', $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetBitmapDimensionEx($hBitmap)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetBitmapDimensionEx', 'handle', $hBitmap, 'struct*', $tSIZE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetBkColor($hDC)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetBkColor', 'handle', $hDC)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetBoundsRect($hDC, $iFlags = 0)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetBoundsRect', 'handle', $hDC, 'struct*', $tRECT, 'uint', $iFlags)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended($aRet[0], $tRECT)
EndFunc
Func _WinAPI_GetBrushOrg($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetBrushOrgEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetBValue($iRGB)
Return BitShift(BitAND(__RGB($iRGB), 0xFF0000), 16)
EndFunc
Func _WinAPI_GetClipBox($hDC, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetClipBox', 'handle', $hDC, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then
$tRECT = 0
Return SetError(@error, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetClipRgn($hDC)
Local $hRgn = _WinAPI_CreateRectRgn(0, 0, 0, 0)
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'int', 'GetClipRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Or ($aRet[0] = -1) Then $iError = @error + 10
If $iError Or Not $aRet[0] Then
_WinAPI_DeleteObject($hRgn)
$hRgn = 0
EndIf
Return SetError($iError, 0, $hRgn)
EndFunc
Func _WinAPI_GetColorAdjustment($hDC)
Local $tAdjustment = DllStructCreate($tagCOLORADJUSTMENT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetColorAdjustment', 'handle', $hDC, 'struct*', $tAdjustment)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tAdjustment
EndFunc
Func _WinAPI_GetCurrentPosition($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetCurrentPositionEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetDeviceGammaRamp($hDC, ByRef $aRamp)
$aRamp = 0
Local $tData = DllStructCreate('word[256];word[256];word[256]')
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetDeviceGammaRamp', 'handle', $hDC, 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Dim $aRamp[256][3]
For $i = 0 To 2
For $j = 0 To 255
$aRamp[$j][$i] = DllStructGetData($tData, $i + 1, $j + 1)
Next
Next
Return 1
EndFunc
Func _WinAPI_GetDIBColorTable($hBitmap)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
Local $tPeak = DllStructCreate('dword[256]')
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetDIBColorTable', 'handle', $hDC, 'uint', 0, 'uint', 256, 'struct*', $tPeak)
If @error Or Not $aRet[0] Then $iError = @error + 10
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
If $iError Then Return SetError($iError, 0, 0)
Local $tData = DllStructCreate('dword[' & $aRet[0] & ']')
If @error Then Return SetError(@error + 20, @extended, 0)
_WinAPI_MoveMemory($tData, $aRet[4], 4 * $aRet[0])
Return SetExtended($aRet[0], $tData)
EndFunc
Func _WinAPI_GetDIBits($hDC, $hBitmap, $iStartScan, $iScanLines, $pBits, $tBI, $iUsage)
Local $aResult = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hDC, "handle", $hBitmap, "uint", $iStartScan,  "uint", $iScanLines, "struct*", $pBits, "struct*", $tBI, "uint", $iUsage)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetEnhMetaFile($sFilePath)
Local $aRet = DllCall('gdi32.dll', 'handle', 'GetEnhMetaFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetEnhMetaFileBits($hEmf, ByRef $pBuffer)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'handle', $hEmf, 'uint', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 50, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error, @extended, 0)
$aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'handle', $hEmf, 'uint', $aRet[0], 'ptr', $pBuffer)
If Not $aRet[0] Then Return SetError(60, 0, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetEnhMetaFileDescription($hEmf)
Local $tData = DllStructCreate('wchar[4096]')
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileDescriptionW', 'handle', $hEmf, 'uint', 4096, 'struct*', $tData)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error + 20, $aRet[0], 0)
If Not $aRet[0] Then Return 0
Local $aData = _WinAPI_StructToArray($tData)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[2]
For $i = 0 To 1
If $aData[0] > $i Then
$aResult[$i] = $aData[$i + 1]
Else
$aResult[$i] = ''
EndIf
Next
Return $aResult
EndFunc
Func _WinAPI_GetEnhMetaFileDimension($hEmf)
Local $tENHMETAHEADER = _WinAPI_GetEnhMetaFileHeader($hEmf)
If @error Then Return SetError(@error, @extended, 0)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 3) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 1)) * DllStructGetData($tENHMETAHEADER, 'Device', 1) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 1) / 100))
DllStructSetData($tSIZE, 2, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 4) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 2)) * DllStructGetData($tENHMETAHEADER, 'Device', 2) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 2) / 100))
Return $tSIZE
EndFunc
Func _WinAPI_GetEnhMetaFileHeader($hEmf)
Local $tENHMETAHEADER = DllStructCreate($tagENHMETAHEADER)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileHeader', 'handle', $hEmf,  'uint', DllStructGetSize($tENHMETAHEADER), 'struct*', $tENHMETAHEADER)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended($aRet[0], $tENHMETAHEADER)
EndFunc
Func _WinAPI_GetFontName($sFaceName, $iStyle = 0, $iCharSet = 1)
If Not $sFaceName Then Return SetError(1, 0, '')
Local $iFlags = 0
If BitAND($iStyle, 0x01) Then
$iFlags += 0x00000020
EndIf
If BitAND($iStyle, 0x02) Then
$iFlags += 0x00000001
EndIf
If Not $iFlags Then
$iFlags = 0x00000040
EndIf
Local $tLOGFONT = DllStructCreate($tagLOGFONT)
DllStructSetData($tLOGFONT, 9, $iCharSet)
DllStructSetData($tLOGFONT, 13, 0)
DllStructSetData($tLOGFONT, 14, StringLeft($sFaceName, 31))
Local $tFN = DllStructCreate('dword;wchar[64]')
DllStructSetData($tFN, 1, $iFlags)
DllStructSetData($tFN, 2, '')
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hEnumProc = DllCallbackRegister('__EnumFontStylesProc', 'int', 'ptr;ptr;dword;lparam')
Local $sRet = ''
Local $aRet = DllCall('gdi32.dll', 'int', 'EnumFontFamiliesExW', 'handle', $hDC, 'struct*', $tLOGFONT,  'ptr', DllCallbackGetPtr($hEnumProc), 'struct*', $tFN, 'dword', 0)
If Not @error And Not $aRet[0] Then $sRet = DllStructGetData($tFN, 2)
DllCallbackFree($hEnumProc)
_WinAPI_DeleteDC($hDC)
If Not $sRet Then Return SetError(2, 0, '')
Return $sRet
EndFunc
Func _WinAPI_GetFontResourceInfo($sFont, $bForce = False, $iFlag = Default)
If $iFlag = Default Then
If $bForce Then
If Not _WinAPI_AddFontResourceEx($sFont, $FR_NOT_ENUM) Then Return SetError(@error + 20, @extended, '')
EndIf
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetFontResourceInfoW', 'wstr', $sFont, 'dword*', 4096, 'wstr', '', 'dword', 0x01)
If @error Or Not $aRet[0] Then $iError = @error + 10
If $bForce Then
_WinAPI_RemoveFontResourceEx($sFont, $FR_NOT_ENUM)
EndIf
If $iError Then Return SetError($iError, 0, '')
Return $aRet[3]
Else
If Not FileExists($sFont) Then
$sFont = RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $sFont
If Not FileExists($sFont) Then Return SetError(31, 0, "")
EndIf
Local Const $hFile = _WinAPI_CreateFile($sFont, 2, 2, 2)
If Not $hFile Then Return SetError(32, _WinAPI_GetLastError(), "")
Local Const $iFile = FileGetSize($sFont)
Local Const $tBuffer = DllStructCreate("byte[" & $iFile + 1 & "]")
Local Const $pFile = DllStructGetPtr($tBuffer)
Local $iRead
_WinAPI_ReadFile($hFile, $pFile, $iFile, $iRead)
_WinAPI_CloseHandle($hFile)
Local $sTTFName = _WinAPI_GetFontMemoryResourceInfo($pFile, $iFlag)
If @error Then
If @error = 1 And $iFlag = 4 Then
$sTTFName = _WinAPI_GetFontResourceInfo($sFont, True)
Return SetError(@error, @extended, $sTTFName)
EndIf
Return SetError(33, @error, "")
EndIf
Return $sTTFName
EndIf
EndFunc
Func _WinAPI_GetFontMemoryResourceInfo($pMemory, $iFlag = 1)
Local Const $tagTT_OFFSET_TABLE = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
Local Const $tagTT_TABLE_DIRECTORY = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
Local Const $tagTT_NAME_TABLE_HEADER = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
Local Const $tagTT_NAME_RECORD = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
Local $tTTOffsetTable = DllStructCreate($tagTT_OFFSET_TABLE, $pMemory)
Local $iNumOfTables = _WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uNumOfTables"))
If Not (_WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uMajorVersion")) = 1 And _WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uMinorVersion")) = 0) Then Return SetError(1, 0, "")
Local $iTblDirSize = DllStructGetSize(DllStructCreate($tagTT_TABLE_DIRECTORY))
Local $bFound = False, $iOffset, $tTblDir
For $i = 0 To $iNumOfTables - 1
$tTblDir = DllStructCreate($tagTT_TABLE_DIRECTORY, $pMemory + DllStructGetSize($tTTOffsetTable) + $i * $iTblDirSize)
If StringLeft(DllStructGetData($tTblDir, "szTag"), 4) = "name" Then
$bFound = True
$iOffset = _WinAPI_SwapDWord(DllStructGetData($tTblDir, "uOffset"))
ExitLoop
EndIf
Next
If Not $bFound Then Return SetError(2, 0, "")
Local $tNTHeader = DllStructCreate($tagTT_NAME_TABLE_HEADER, $pMemory + $iOffset)
Local $iNTHeaderSize = DllStructGetSize($tNTHeader)
Local $iNRCount = _WinAPI_SwapWord(DllStructGetData($tNTHeader, "uNRCount"))
Local $iStorageOffset = _WinAPI_SwapWord(DllStructGetData($tNTHeader, "uStorageOffset"))
Local $iTTRecordSize = DllStructGetSize(DllStructCreate($tagTT_NAME_RECORD))
Local $tResult, $sResult, $iStringLength, $iStringOffset, $iEncodingID, $tTTRecord
For $i = 0 To $iNRCount - 1
$tTTRecord = DllStructCreate($tagTT_NAME_RECORD, $pMemory + $iOffset + $iNTHeaderSize + $i * $iTTRecordSize)
If _WinAPI_SwapWord($tTTRecord.uNameID) = $iFlag Then
$iStringLength = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uStringLength"))
$iStringOffset = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uStringOffset"))
$iEncodingID = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uEncodingID"))
Local $sWchar = "char"
If $iEncodingID = 1 Then
$sWchar = "word"
$iStringLength = $iStringLength / 2
EndIf
$tResult = DllStructCreate($sWchar & " szTTFName[" & $iStringLength & "]", $pMemory + $iOffset + $iStringOffset + $iStorageOffset)
If $iEncodingID = 1 Then
$sResult = ""
For $j = 1 To $iStringLength
$sResult &= ChrW(_WinAPI_SwapWord(DllStructGetData($tResult, 1, $j)))
Next
Else
$sResult = $tResult.szTTFName
EndIf
If StringLen($sResult) > 0 Then ExitLoop
EndIf
Next
Return $sResult
EndFunc
Func _WinAPI_GetGlyphOutline($hDC, $sChar, $iFormat, ByRef $pBuffer, $tMAT2 = 0)
Local $tGM = DllStructCreate($tagGLYPHMETRICS)
Local $aRet, $iLength = 0
If Not IsDllStruct($tMAT2) Then
$tMAT2 = DllStructCreate('short[8]')
DllStructSetData($tMAT2, 1, 1, 2)
DllStructSetData($tMAT2, 1, 1, 8)
EndIf
If $iFormat Then
$aRet = DllCall('gdi32.dll', 'dword', 'GetGlyphOutlineW', 'handle', $hDC, 'uint', AscW($sChar), 'uint', $iFormat,  'struct*', $tGM, 'dword', 0, 'ptr', 0, 'struct*', $tMAT2)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error + 10, @extended, 0)
$iLength = $aRet[0]
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 1)
If @error Then Return SetError(@error + 20, @extended, 0)
EndIf
$aRet = DllCall('gdi32.dll', 'dword', 'GetGlyphOutlineW', 'handle', $hDC, 'uint', AscW($sChar), 'uint', $iFormat,  'struct*', $tGM, 'dword', $iLength, 'ptr', $pBuffer, 'struct*', $tMAT2)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return SetExtended($iLength, $tGM)
EndFunc
Func _WinAPI_GetGraphicsMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetGraphicsMode', 'handle', $hDC)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetGValue($iRGB)
Return BitShift(BitAND(__RGB($iRGB), 0x00FF00), 8)
EndFunc
Func _WinAPI_GetMapMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetMapMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetMonitorInfo($hMonitor)
Local $tMIEX = DllStructCreate('dword;long[4];long[4];dword;wchar[32]')
DllStructSetData($tMIEX, 1, DllStructGetSize($tMIEX))
Local $aRet = DllCall('user32.dll', 'bool', 'GetMonitorInfoW', 'handle', $hMonitor, 'struct*', $tMIEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[4]
For $i = 0 To 1
$aResult[$i] = DllStructCreate($tagRECT)
_WinAPI_MoveMemory($aResult[$i], DllStructGetPtr($tMIEX, $i + 2), 16)
Next
$aResult[3] = DllStructGetData($tMIEX, 5)
Switch DllStructGetData($tMIEX, 4)
Case 1
$aResult[2] = 1
Case Else
$aResult[2] = 0
EndSwitch
Return $aResult
EndFunc
Func _WinAPI_GetOutlineTextMetrics($hDC)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'handle', $hDC, 'uint', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $tData = DllStructCreate('byte[' & $aRet[0] & ']')
Local $tOLTM = DllStructCreate($tagOUTLINETEXTMETRIC, DllStructGetPtr($tData))
$aRet = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'handle', $hDC, 'uint', $aRet[0], 'struct*', $tData)
If Not $aRet[0] Then Return SetError(20, 0, 0)
Return $tOLTM
EndFunc
Func _WinAPI_GetPixel($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetPixel', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetPolyFillMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetPolyFillMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetPosFromRect($tRECT)
Local $aResult[4]
For $i = 0 To 3
$aResult[$i] = DllStructGetData($tRECT, $i + 1)
If @error Then Return SetError(@error, @extended, 0)
Next
For $i = 2 To 3
$aResult[$i] -= $aResult[$i - 2]
Next
Return $aResult
EndFunc
Func _WinAPI_GetRegionData($hRgn, ByRef $tRGNDATA)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'handle', $hRgn, 'dword', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then
$tRGNDATA = 0
Return SetError(@error, @extended, False)
EndIf
$tRGNDATA = DllStructCreate($tagRGNDATAHEADER)
Local $iRectSize = $aRet[0] - DllStructGetSize($tRGNDATA)
If $iRectSize > 0 Then $tRGNDATA = DllStructCreate($tagRGNDATAHEADER & ';byte[' & $iRectSize & ']')
$aRet = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'handle', $hRgn, 'dword', $aRet[0], 'struct*', $tRGNDATA)
If Not $aRet[0] Then $tRGNDATA = 0
Return $aRet[0]
EndFunc
Func _WinAPI_GetRgnBox($hRgn, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetRgnBox', 'handle', $hRgn, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then
$tRECT = 0
Return SetError(@error, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetROP2($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetROP2', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetRValue($iRGB)
Return BitAND(__RGB($iRGB), 0x0000FF)
EndFunc
Func _WinAPI_GetStretchBltMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetStretchBltMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTabbedTextExtent($hDC, $sText, $aTab = 0, $iStart = 0, $iEnd = -1)
Local $iTab, $iCount
If Not IsArray($aTab) Then
If $aTab Then
$iTab = $aTab
Dim $aTab[1] = [$iTab]
$iStart = 0
$iEnd = 0
$iCount = 1
Else
$iCount = 0
EndIf
Else
$iCount = 1
EndIf
Local $tTab = 0
If $iCount Then
If __CheckErrorArrayBounds($aTab, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
$tTab = DllStructCreate('uint[' & $iCount & ']')
$iTab = 1
For $i = $iStart To $iEnd
DllStructSetData($tTab, 1, $aTab[$i], $iTab)
$iTab += 1
Next
EndIf
Local $aRet = DllCall('user32.dll', 'dword', 'GetTabbedTextExtentW', 'handle', $hDC, 'wstr', $sText, 'int', StringLen($sText), 'int', $iCount, 'struct*', $tTab)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Return _WinAPI_CreateSize(_WinAPI_LoWord($aRet[0]), _WinAPI_HiWord($aRet[0]))
EndFunc
Func _WinAPI_GetTextAlign($hDC)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetTextAlign', 'handle', $hDC)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTextCharacterExtra($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetTextCharacterExtra', 'handle', $hDC)
If @error Or ($aRet[0] = 0x8000000) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTextFace($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetTextFaceW', 'handle', $hDC, 'int', 2048, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetUDFColorMode()
Return Number($__g_iRGBMode)
EndFunc
Func _WinAPI_GetUpdateRect($hWnd, $bErase = True)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetUpdateRect', 'hwnd', $hWnd, 'struct*', $tRECT, 'bool', $bErase)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetUpdateRgn($hWnd, $hRgn, $bErase = True)
Local $aRet = DllCall('user32.dll', 'int', 'GetUpdateRgn', 'hwnd', $hWnd, 'handle', $hRgn, 'bool', $bErase)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWindowExt($hDC)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWindowExtEx', 'handle', $hDC, 'struct*', $tSIZE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetWindowOrg($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWindowOrgEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetWindowRgnBox($hWnd, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetWindowRgnBox', 'hwnd', $hWnd, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWorldTransform($hDC)
Local $tXFORM = DllStructCreate($tagXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWorldTransform', 'handle', $hDC, 'struct*', $tXFORM)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tXFORM
EndFunc
Func _WinAPI_GradientFill($hDC, Const ByRef $aVertex, $iStart = 0, $iEnd = -1, $bRotate = False)
If __CheckErrorArrayBounds($aVertex, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aVertex, $UBOUND_COLUMNS) < 3 Then Return SetError(13, 0, 0)
Local $iPoint = $iEnd - $iStart + 1
If $iPoint > 3 Then
$iEnd = $iStart + 2
$iPoint = 3
EndIf
Local $iMode
Switch $iPoint
Case 2
$iMode = Number(Not $bRotate)
Case 3
$iMode = 2
Case Else
Return SetError(15, 0, 0)
EndSwitch
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'ushort[8];'
Next
Local $tVertex = DllStructCreate($tagStruct)
Local $iCount = 1
Local $tGradient = DllStructCreate('ulong[' & $iPoint & ']')
For $i = $iStart To $iEnd
DllStructSetData($tGradient, 1, $iCount - 1, $iCount)
DllStructSetData($tVertex, $iCount, _WinAPI_LoWord($aVertex[$i][0]), 1)
DllStructSetData($tVertex, $iCount, _WinAPI_HiWord($aVertex[$i][0]), 2)
DllStructSetData($tVertex, $iCount, _WinAPI_LoWord($aVertex[$i][1]), 3)
DllStructSetData($tVertex, $iCount, _WinAPI_HiWord($aVertex[$i][1]), 4)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetRValue($aVertex[$i][2]), -8), 5)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetGValue($aVertex[$i][2]), -8), 6)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetBValue($aVertex[$i][2]), -8), 7)
DllStructSetData($tVertex, $iCount, 0, 8)
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiGradientFill', 'handle', $hDC, 'struct*', $tVertex, 'ulong', $iPoint,  'struct*', $tGradient, 'ulong', 1, 'ulong', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_InflateRect(ByRef $tRECT, $iDX, $iDY)
Local $aRet = DllCall('user32.dll', 'bool', 'InflateRect', 'struct*', $tRECT, 'int', $iDX, 'int', $iDY)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IntersectClipRect($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'IntersectClipRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3),  'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_IntersectRect($tRECT1, $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'IntersectRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_InvalidateRgn($hWnd, $hRgn = 0, $bErase = True)
Local $aRet = DllCall('user32.dll', 'bool', 'InvalidateRgn', 'hwnd', $hWnd, 'handle', $hRgn, 'bool', $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_InvertANDBitmap($hBitmap, $bDelete = False)
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tBITMAP), $tBITMAP) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 1) Then
Return SetError(@error + 10, @extended, 0)
EndIf
Local $hResult = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), 1)
If Not $hResult Then Return SetError(@error, @extended, 0)
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv = _WinAPI_SelectObject($hSrcDC, $hBitmap)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstSv = _WinAPI_SelectObject($hDstDC, $hResult)
_WinAPI_BitBlt($hDstDC, 0, 0, DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), $hSrcDC, 0, 0, 0x00330008)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_SelectObject($hDstDC, $hDstSv)
_WinAPI_DeleteDC($hDstDC)
If $bDelete Then
_WinAPI_DeleteObject($hBitmap)
EndIf
Return $hResult
EndFunc
Func _WinAPI_InvertColor($iColor)
If $iColor = -1 Then Return 0
Return 0xFFFFFF - BitAND($iColor, 0xFFFFFF)
EndFunc
Func _WinAPI_InvertRect($hDC, ByRef $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'InvertRect', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_InvertRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'bool', 'InvertRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsRectEmpty(ByRef $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'IsRectEmpty', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LineDDA($iX1, $iY1, $iX2, $iY2, $pLineProc, $pData = 0)
Local $aRet = DllCall('gdi32.dll', 'bool', 'LineDDA', 'int', $iX1, 'int', $iY1, 'int', $iX2, 'int', $iY2, 'ptr', $pLineProc,  'lparam', $pData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LineTo($hDC, $iX, $iY)
Local $aResult = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hDC, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_LockWindowUpdate($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'LockWindowUpdate', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LPtoDP($hDC, ByRef $tPOINT, $iCount = 1)
Local $aRet = DllCall('gdi32.dll', 'bool', 'LPtoDP', 'handle', $hDC, 'struct*', $tPOINT, 'int', $iCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MaskBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $hMask, $iXMask, $iYMask, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'MaskBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidth, 'int', $iHeight, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'handle', $hMask,  'int', $iXMask, 'int', $iYMask, 'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ModifyWorldTransform($hDC, ByRef $tXFORM, $iMode)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ModifyWorldTransform', 'handle', $hDC, 'struct*', $tXFORM, 'dword', $iMode)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromPoint(ByRef $tPOINT, $iFlag = 1)
If DllStructGetSize($tPOINT) <> 8 Then Return SetError(@error + 10, @extended, 0)
Local $aRet = DllCall('user32.dll', 'handle', 'MonitorFromPoint', 'struct', $tPOINT, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromRect(ByRef $tRECT, $iFlag = 1)
Local $aRet = DllCall('user32.dll', 'ptr', 'MonitorFromRect', 'struct*', $tRECT, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromWindow($hWnd, $iFlag = 1)
Local $aRet = DllCall('user32.dll', 'handle', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MoveTo($hDC, $iX, $iY)
Local $aResult = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hDC, "int", $iX, "int", $iY, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MoveToEx($hDC, $iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'MoveToEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_OffsetClipRgn($hDC, $iXOffset, $iYOffset)
Local $aRet = DllCall('gdi32.dll', 'int', 'OffsetClipRgn', 'handle', $hDC, 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetPoints(ByRef $aPoint, $iXOffset, $iYOffset, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 2 Then Return SetError(13, 0, 0)
For $i = $iStart To $iEnd
$aPoint[$i][0] += $iXOffset
$aPoint[$i][1] += $iYOffset
Next
Return 1
EndFunc
Func _WinAPI_OffsetRect(ByRef $tRECT, $iDX, $iDY)
Local $aRet = DllCall('user32.dll', 'bool', 'OffsetRect', 'struct*', $tRECT, 'int', $iDX, 'int', $iDY)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetRgn($hRgn, $iXOffset, $iYOffset)
Local $aRet = DllCall('gdi32.dll', 'int', 'OffsetRgn', 'handle', $hRgn, 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetWindowOrg($hDC, $iXOffset, $iYOffset)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'OffsetWindowOrgEx', 'handle', $hDC, 'int', $iXOffset, 'int', $iYOffset,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PaintDesktop($hDC)
Local $aRet = DllCall('user32.dll', 'bool', 'PaintDesktop', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PaintRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PaintRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PatBlt($hDC, $iX, $iY, $iWidth, $iHeight, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PatBlt', 'handle', $hDC, 'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight,  'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathToRegion($hDC)
Local $aRet = DllCall('gdi32.dll', 'handle', 'PathToRegion', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PlayEnhMetaFile($hDC, $hEmf, ByRef $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PlayEnhMetaFile', 'handle', $hDC, 'handle', $hEmf, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PlgBlt($hDestDC, Const ByRef $aPoint, $hSrcDC, $iXSrc, $iYSrc, $iWidth, $iHeight, $hMask = 0, $iXMask = 0, $iYMask = 0)
If (UBound($aPoint) < 3) Or (UBound($aPoint, $UBOUND_COLUMNS) < 2) Then Return SetError(12, 0, False)
Local $tPoints = DllStructCreate('long[2];long[2];long[2]')
For $i = 0 To 2
For $j = 0 To 1
DllStructSetData($tPoints, $i + 1, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PlgBlt', 'handle', $hDestDC, 'struct*', $tPoints, 'handle', $hSrcDC,  'int', $iXSrc, 'int', $iYSrc, 'int', $iWidth, 'int', $iHeight, 'handle', $hMask,  'int', $iXMask, 'int', $iYMask)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyBezier($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $iPoint = 1 + 3 * Floor(($iEnd - $iStart) / 3)
If $iPoint < 1 Then Return SetError(15, 0, False)
$iEnd = $iStart + $iPoint - 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyBezier', 'handle', $hDC, 'struct*', $tPOINT, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyBezierTo($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $iPoint = 3 * Floor(($iEnd - $iStart + 1) / 3)
If $iPoint < 3 Then Return SetError(15, 0, False)
$iEnd = $iStart + $iPoint - 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyBezierTo', 'handle', $hDC, 'struct*', $tPOINT, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyDraw($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 3 Then Return SetError(13, 0, False)
Local $iPoint = $iEnd - $iStart + 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $tTypes = DllStructCreate('byte[' & $iPoint & ']')
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
DllStructSetData($tTypes, 1, $aPoint[$i][2], $iCount)
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyDraw', 'handle', $hDC, 'struct*', $tPOINT, 'struct*', $tTypes, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Polygon($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'int[2];'
Next
Local $tData = DllStructCreate($tagStruct)
Local $iCount = 1
For $i = $iStart To $iEnd
For $j = 0 To 1
DllStructSetData($tData, $iCount, $aPoint[$i][$j], $j + 1)
Next
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'Polygon', 'handle', $hDC, 'struct*', $tData, 'int', $iCount - 1)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRectEx($iX, $iY, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tPOINT = _WinAPI_CreatePoint($iX, $iY)
Local $aRet = DllCall('user32.dll', 'bool', 'PtInRect', 'struct*', $tRECT, 'struct', $tPOINT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRegion($hRgn, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PtInRegion', 'handle', $hRgn, 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtVisible($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PtVisible', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] = -1 Then Return SetError(10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RadialGradientFill($hDC, $iX, $iY, $iRadius, $iRGB1, $iRGB2, $fAngleStart = 0, $fAngleEnd = 360, $fStep = 5)
If Abs($fAngleStart) > 360 Then
$fAngleStart = Mod($fAngleStart, 360)
EndIf
If Abs($fAngleEnd) > 360 Then
$fAngleEnd = Mod($fAngleEnd, 360)
EndIf
If ($fAngleStart < 0) Or ($fAngleEnd < 0) Then
$fAngleStart += 360
$fAngleEnd += 360
EndIf
If $fAngleStart > $fAngleEnd Then
Local $fVal = $fAngleStart
$fAngleStart = $fAngleEnd
$fAngleEnd = $fVal
EndIf
If $fStep < 1 Then
$fStep = 1
EndIf
Local $fKi = ATan(1) / 45
Local $iXp = Round($iX + $iRadius * Cos($fKi * $fAngleStart))
Local $iYp = Round($iY + $iRadius * Sin($fKi * $fAngleStart))
Local $iXn, $iYn, $fAn = $fAngleStart
Local $aVertex[3][3]
While $fAn < $fAngleEnd
$fAn += $fStep
If $fAn > $fAngleEnd Then
$fAn = $fAngleEnd
EndIf
$iXn = Round($iX + $iRadius * Cos($fKi * $fAn))
$iYn = Round($iY + $iRadius * Sin($fKi * $fAn))
$aVertex[0][0] = $iX
$aVertex[0][1] = $iY
$aVertex[0][2] = $iRGB1
$aVertex[1][0] = $iXp
$aVertex[1][1] = $iYp
$aVertex[1][2] = $iRGB2
$aVertex[2][0] = $iXn
$aVertex[2][1] = $iYn
$aVertex[2][2] = $iRGB2
If Not _WinAPI_GradientFill($hDC, $aVertex, 0, 2) Then
Return SetError(@error, @extended, 0)
EndIf
$iXp = $iXn
$iYp = $iYn
WEnd
Return 1
EndFunc
Func _WinAPI_Rectangle($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Rectangle', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RectInRegion($hRgn, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RectInRegion', 'handle', $hRgn, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RectIsEmpty(ByRef $tRECT)
Return (DllStructGetData($tRECT, "Left") = 0) And (DllStructGetData($tRECT, "Top") = 0) And  (DllStructGetData($tRECT, "Right") = 0) And (DllStructGetData($tRECT, "Bottom") = 0)
EndFunc
Func _WinAPI_RectVisible($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RectVisible', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Switch $aRet[0]
Case 0, 1, 2
Case Else
Return SetError(10, $aRet[0], 0)
EndSwitch
Return $aRet[0]
EndFunc
Func _WinAPI_RemoveFontMemResourceEx($hFont)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RemoveFontMemResourceEx', 'handle', $hFont)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RemoveFontResourceEx($sFont, $iFlag = 0, $bNotify = False)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RemoveFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
If $bNotify Then
Local Const $WM_FONTCHANGE = 0x001D
Local Const $HWND_BROADCAST = 0xFFFF
DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $HWND_BROADCAST, 'uint', $WM_FONTCHANGE, 'wparam', 0, 'lparam', 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_RGB($iRed, $iGreen, $iBlue)
Return __RGB(BitOR(BitShift($iBlue, -16), BitShift($iGreen, -8), $iRed))
EndFunc
Func _WinAPI_RotatePoints(ByRef $aPoint, $iXC, $iYC, $fAngle, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 2 Then Return SetError(13, 0, 0)
Local $fCos = Cos(ATan(1) / 45 * $fAngle)
Local $fSin = Sin(ATan(1) / 45 * $fAngle)
Local $iXn, $iYn
For $i = $iStart To $iEnd
$iXn = $aPoint[$i][0] - $iXC
$iYn = $aPoint[$i][1] - $iYC
$aPoint[$i][0] = $iXC + Round($iXn * $fCos - $iYn * $fSin)
$aPoint[$i][1] = $iYC + Round($iXn * $fSin + $iYn * $fCos)
Next
Return 1
EndFunc
Func _WinAPI_RoundRect($hDC, $tRECT, $iWidth, $iHeight)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RoundRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3),  'int', DllStructGetData($tRECT, 4), 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SaveHBITMAPToFile($sFilePath, $hBitmap, $iXPelsPerMeter = Default, $iYPelsPerMeter = Default)
Local $tBMP = DllStructCreate('align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset')
Local $tDIB = DllStructCreate($tagDIBSECTION)
Local $hDC, $hSv, $hSource = 0
While $hBitmap
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or (DllStructGetData($tDIB, 'biCompression')) Then
$hBitmap = 0
Else
Switch DllStructGetData($tDIB, 'bmBitsPixel')
Case 32
If Not _WinAPI_IsAlphaBitmap($hBitmap) Then
If Not $hSource Then
$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'), 24)
If Not $hSource Then
$hBitmap = 0
EndIf
$hDC = _WinAPI_CreateCompatibleDC(0)
$hSv = _WinAPI_SelectObject($hDC, $hSource)
If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
$hBitmap = $hSource
Else
$hBitmap = 0
EndIf
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = 0
EndIf
ContinueLoop
EndIf
Case Else
EndSwitch
If (Not DllStructGetData($tDIB, 'bmBits')) Or (Not DllStructGetData($tDIB, 'biSizeImage')) Then
If Not $hSource Then
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
$hSource = $hBitmap
Else
$hBitmap = 0
EndIf
Else
ExitLoop
EndIf
EndIf
WEnd
Local $hFile = 0, $iError = 0, $iResult = 0
Do
If Not $hBitmap Then
$iError = 1
ExitLoop
EndIf
Local $aData[4][2]
$aData[0][0] = DllStructGetPtr($tBMP)
$aData[0][1] = DllStructGetSize($tBMP)
$aData[1][0] = DllStructGetPtr($tDIB, 'biSize')
$aData[1][1] = 40
$aData[2][1] = DllStructGetData($tDIB, 'biClrUsed') * 4
Local $tTable = 0
If $aData[2][1] Then
$tTable = _WinAPI_GetDIBColorTable($hBitmap)
If @error Or (@extended <> $aData[2][1] / 4) Then
$iError = @error + 10
ExitLoop
EndIf
EndIf
$aData[2][0] = DllStructGetPtr($tTable)
$aData[3][0] = DllStructGetData($tDIB, 'bmBits')
$aData[3][1] = DllStructGetData($tDIB, 'biSizeImage')
DllStructSetData($tBMP, 'bfType', 0x4D42)
DllStructSetData($tBMP, 'bfSize', $aData[0][1] + $aData[1][1] + $aData[2][1] + $aData[3][1])
DllStructSetData($tBMP, 'bfReserved1', 0)
DllStructSetData($tBMP, 'bfReserved2', 0)
DllStructSetData($tBMP, 'bfOffset', $aData[0][1] + $aData[1][1] + $aData[2][1])
$hDC = _WinAPI_GetDC(0)
If $iXPelsPerMeter = Default Then
If Not DllStructGetData($tDIB, 'biXPelsPerMeter') Then
DllStructSetData($tDIB, 'biXPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 8) / _WinAPI_GetDeviceCaps($hDC, 4) * 1000)
EndIf
Else
DllStructSetData($tDIB, 'biXPelsPerMeter', $iXPelsPerMeter)
EndIf
If $iYPelsPerMeter = Default Then
If Not DllStructGetData($tDIB, 'biYPelsPerMeter') Then
DllStructSetData($tDIB, 'biYPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 10) / _WinAPI_GetDeviceCaps($hDC, 6) * 1000)
EndIf
Else
DllStructSetData($tDIB, 'biYPelsPerMeter', $iYPelsPerMeter)
EndIf
_WinAPI_ReleaseDC(0, $hDC)
$hFile = _WinAPI_CreateFile($sFilePath, 1, 4)
If @error Then
$iError = @error + 20
ExitLoop
EndIf
Local $iBytes
For $i = 0 To 3
If $aData[$i][1] Then
If Not _WinAPI_WriteFile($hFile, $aData[$i][0], $aData[$i][1], $iBytes) Then
$iError = @error + 30
ExitLoop 2
EndIf
EndIf
Next
$iResult = 1
Until 1
If $hSource Then
_WinAPI_DeleteObject($hSource)
EndIf
_WinAPI_CloseHandle($hFile)
If Not $iResult Then
FileDelete($sFilePath)
EndIf
Return SetError($iError, 0, $iResult)
EndFunc
Func _WinAPI_SaveHICONToFile($sFilePath, Const ByRef $vIcon, $bCompress = 0, $iStart = 0, $iEnd = -1)
Local $aIcon, $aTemp, $iCount = 1
If Not IsArray($vIcon) Then
Dim $aIcon[1] = [$vIcon]
Dim $aTemp[1] = [0]
Else
If __CheckErrorArrayBounds($vIcon, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
If $iCount Then
Dim $aIcon[$iCount]
Dim $aTemp[$iCount]
For $i = 0 To $iCount - 1
$aIcon[$i] = $vIcon[$iStart + $i]
$aTemp[$i] = 0
Next
EndIf
EndIf
Local $hFile = _WinAPI_CreateFile($sFilePath, 1, 4)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tIco = DllStructCreate('align 1;ushort Reserved;ushort Type;ushort Count;byte Data[' & (16 * $iCount) & ']')
Local $iLength = DllStructGetSize($tIco)
Local $tBI = DllStructCreate($tagBITMAPINFOHEADER)
Local $tII = DllStructCreate($tagICONINFO)
Local $tDIB = DllStructCreate($tagDIBSECTION)
Local $iDIB = DllStructGetSize($tDIB)
Local $pDIB = DllStructGetPtr($tDIB)
Local $iOffset = $iLength
DllStructSetData($tBI, 'biSize', 40)
DllStructSetData($tBI, 'biPlanes', 1)
DllStructSetData($tBI, 'biXPelsPerMeter', 0)
DllStructSetData($tBI, 'biYPelsPerMeter', 0)
DllStructSetData($tBI, 'biClrUsed', 0)
DllStructSetData($tBI, 'biClrImportant', 0)
DllStructSetData($tIco, 'Reserved', 0)
DllStructSetData($tIco, 'Type', 1)
DllStructSetData($tIco, 'Count', $iCount)
Local $iResult = 0, $iError = 0, $iBytes
Local $aInfo[8], $aRet, $pData = 0, $iIndex = 0
Local $aSize[2], $tData = 0
Do
If Not _WinAPI_WriteFile($hFile, $tIco, $iLength, $iBytes) Then
$iError = @error + 30
ExitLoop
EndIf
While $iCount > $iIndex
$aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $aIcon[$iIndex], 'struct*', $tII)
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop 2
EndIf
For $i = 4 To 5
$aInfo[$i] = _WinAPI_CopyImage(DllStructGetData($tII, $i), 0, 0, 0, 0x2008)
If _WinAPI_GetObject($aInfo[$i], $iDIB, $pDIB) Then
$aInfo[$i - 4] = DllStructGetData($tDIB, 'biSizeImage')
$aInfo[$i - 2] = DllStructGetData($tDIB, 'bmBits')
Else
$iError = @error + 50
EndIf
Next
$aInfo[6] = 40
$aInfo[7] = DllStructGetData($tDIB, 'bmBitsPixel')
Switch $aInfo[7]
Case 16, 24
Case 32
If Not _WinAPI_IsAlphaBitmap($aInfo[5]) Then
If Not $aTemp[$iIndex] Then
$aIcon[$iIndex] = _WinAPI_Create32BitHICON($aIcon[$iIndex])
$aTemp[$iIndex] = $aIcon[$iIndex]
If Not @error Then
ContinueLoop
Else
ContinueCase
EndIf
EndIf
Else
If ($aInfo[1] >= 256 * 256 * 4) And ($bCompress) Then
$iBytes = _WinAPI_CompressBitmapBits($aInfo[5], $pData)
If Not @error Then
$aInfo[0] = 0
$aInfo[1] = $iBytes
$aInfo[2] = 0
$aInfo[3] = $pData
$aInfo[6] = 0
EndIf
EndIf
EndIf
Case Else
$iError = 60
EndSwitch
If Not $iError Then
$tData = DllStructCreate('byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset', DllStructGetPtr($tIco) + 6 + 16 * $iIndex)
DllStructSetData($tData, 'ColorCount', 0)
DllStructSetData($tData, 'Reserved', 0)
DllStructSetData($tData, 'Planes', 1)
DllStructSetData($tData, 'BitCount', $aInfo[7])
DllStructSetData($tData, 'Size', $aInfo[0] + $aInfo[1] + $aInfo[6])
DllStructSetData($tData, 'Offset', $iOffset)
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tDIB, $i + 2)
If $aSize[$i] < 256 Then
DllStructSetData($tData, $i + 1, $aSize[$i])
Else
DllStructSetData($tData, $i + 1, 0)
EndIf
Next
DllStructSetData($tBI, 'biWidth', $aSize[0])
DllStructSetData($tBI, 'biHeight', 2 * $aSize[1])
DllStructSetData($tBI, 'biBitCount', $aInfo[7])
DllStructSetData($tBI, 'biCompression', 0)
DllStructSetData($tBI, 'biSizeImage', $aInfo[0] + $aInfo[1])
$iOffset += $aInfo[0] + $aInfo[1] + $aInfo[6]
Do
If $aInfo[6] Then
If Not _WinAPI_WriteFile($hFile, $tBI, $aInfo[6], $iBytes) Then
$iError = @error + 70
ExitLoop
EndIf
For $i = 1 To 0 Step -1
If Not _WinAPI_WriteFile($hFile, $aInfo[$i + 2], $aInfo[$i], $iBytes) Then
$iError = @error + 80
ExitLoop 2
EndIf
Next
Else
If Not _WinAPI_WriteFile($hFile, $aInfo[3], $aInfo[1], $iBytes) Then
$iError = @error + 90
ExitLoop
EndIf
EndIf
Until 1
EndIf
For $i = 4 To 5
_WinAPI_DeleteObject($aInfo[$i])
Next
If $iError Then
ExitLoop 2
EndIf
$iIndex += 1
WEnd
$aRet = DllCall('kernel32.dll', 'bool', 'SetFilePointerEx', 'handle', $hFile, 'int64', 0, 'int64*', 0, 'dword', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 100
ExitLoop
EndIf
If Not _WinAPI_WriteFile($hFile, $tIco, $iLength, $iBytes) Then
$iError = @error + 110
ExitLoop
EndIf
$iResult = 1
Until 1
For $i = 0 To $iCount - 1
If $aTemp[$i] Then
_WinAPI_DestroyIcon($aTemp[$i])
EndIf
Next
If $pData Then
__HeapFree($pData)
EndIf
_WinAPI_CloseHandle($hFile)
If Not $iResult Then
FileDelete($sFilePath)
EndIf
Return SetError($iError, 0, $iResult)
EndFunc
Func _WinAPI_ScaleWindowExt($hDC, $iXNum, $iXDenom, $iYNum, $iYDenom)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ScaleWindowExtEx', 'handle', $hDC, 'int', $iXNum, 'int', $iXDenom, 'int', $iYNum,  'int', $iYDenom, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SelectClipPath($hDC, $iMode = 5)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SelectClipPath', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SelectClipRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'int', 'SelectClipRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetArcDirection($hDC, $iDirection)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetArcDirection', 'handle', $hDC, 'int', $iDirection)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBitmapBits($hBitmap, $iSize, $pBits)
Local $aRet = DllCall('gdi32.dll', 'long', 'SetBitmapBits', 'handle', $hBitmap, 'dword', $iSize, 'struct*', $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBitmapDimensionEx($hBitmap, $iWidth, $iHeight)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetBitmapDimensionEx', 'handle', $hBitmap, 'int', $iWidth, 'int', $iHeight,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBoundsRect($hDC, $iFlags, $tRECT = 0)
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetBoundsRect', 'handle', $hDC, 'struct*', $tRECT, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBrushOrg($hDC, $iX, $iY)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetBrushOrgEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetColorAdjustment($hDC, $tAdjustment)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetColorAdjustment', 'handle', $hDC, 'struct*', $tAdjustment)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDCBrushColor($hDC, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'dword', 'SetDCBrushColor', 'handle', $hDC, 'dword', __RGB($iRGB))
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_SetDCPenColor($hDC, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'dword', 'SetDCPenColor', 'handle', $hDC, 'dword', __RGB($iRGB))
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_SetDeviceGammaRamp($hDC, Const ByRef $aRamp)
If (UBound($aRamp, $UBOUND_DIMENSIONS) <> 2) Or (UBound($aRamp, $UBOUND_ROWS) <> 256) Or (UBound($aRamp, $UBOUND_COLUMNS) <> 3) Then
Return SetError(12, 0, 0)
EndIf
Local $tData = DllStructCreate('ushort[256];ushort[256];ushort[256]')
For $i = 0 To 2
For $j = 0 To 255
DllStructSetData($tData, $i + 1, $aRamp[$j][$i], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetDeviceGammaRamp', 'handle', $hDC, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDIBColorTable($hBitmap, $tColorTable, $iColorCount)
If $iColorCount > DllStructGetSize($tColorTable) / 4 Then Return SetError(1, 0, 0)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetDIBColorTable', 'handle', $hDC, 'uint', 0, 'uint', $iColorCount, 'struct*', $tColorTable)
If @error Then $iError = @error
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDIBits($hDC, $hBitmap, $iStartScan, $iScanLines, $pBits, $tBMI, $iColorUse = 0)
Local $aResult = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hDC, "handle", $hBitmap, "uint", $iStartScan,  "uint", $iScanLines, "struct*", $pBits, "struct*", $tBMI, "INT", $iColorUse)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetDIBitsToDevice($hDC, $iXDest, $iYDest, $iWidth, $iHeight, $iXSrc, $iYSrc, $iStartScan, $iScanLines, $tBITMAPINFO, $iUsage, $pBits)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetDIBitsToDevice', 'handle', $hDC, 'int', $iXDest, 'int', $iYDest,  'dword', $iWidth, 'dword', $iHeight, 'int', $iXSrc, 'int', $iYSrc, 'uint', $iStartScan,  'uint', $iScanLines, 'struct*', $pBits, 'struct*', $tBITMAPINFO, 'uint', $iUsage)
If @error Or ($aRet[0] = -1) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetEnhMetaFileBits($pData, $iLength)
Local $aRet = DllCall('gdi32.dll', 'handle', 'SetEnhMetaFileBits', 'uint', $iLength, 'struct*', $pData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetGraphicsMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetGraphicsMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetMapMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetMapMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPixel($hDC, $iX, $iY, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetPixelV', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPolyFillMode($hDC, $iMode = 1)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetPolyFillMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetRectRgn($hRgn, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetRectRgn', 'handle', $hRgn, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetROP2($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetROP2', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetStretchBltMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetStretchBltMode', 'handle', $hDC, 'int', $iMode)
If @error Or Not $aRet[0] Or ($aRet[0] = 87) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextAlign($hDC, $iMode = 0)
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetTextAlign', 'handle', $hDC, 'uint', $iMode)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextCharacterExtra($hDC, $iCharExtra)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetTextCharacterExtra', 'handle', $hDC, 'int', $iCharExtra)
If @error Or ($aRet[0] = 0x80000000) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextJustification($hDC, $iBreakExtra, $iBreakCount)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetTextJustification', 'handle', $hDC, 'int', $iBreakExtra, 'int', $iBreakCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetUDFColorMode($iMode)
$__g_iRGBMode = Not ($iMode = 0)
EndFunc
Func _WinAPI_SetWindowExt($hDC, $iXExtent, $iYExtent)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWindowExtEx', 'handle', $hDC, 'int', $iXExtent, 'int', $iYExtent,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowOrg($hDC, $iX, $iY)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWindowOrgEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWorldTransform($hDC, ByRef $tXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWorldTransform', 'handle', $hDC, 'struct*', $tXFORM)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StretchBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StretchBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest,  'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StretchDIBits($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $tBITMAPINFO, $iUsage, $pBits, $iRop)
Local $aRet = DllCall('gdi32.dll', 'int', 'StretchDIBits', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'struct*', $pBits, 'struct*', $tBITMAPINFO, 'uint', $iUsage,  'dword', $iRop)
If @error Or ($aRet[0] = -1) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_StrokeAndFillPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StrokeAndFillPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StrokePath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StrokePath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SubtractRect(ByRef $tRECT1, ByRef $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'SubtractRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_TabbedTextOut($hDC, $iX, $iY, $sText, $aTab = 0, $iStart = 0, $iEnd = -1, $iOrigin = 0)
Local $iTab, $iCount
If Not IsArray($aTab) Then
If $aTab Then
$iTab = $aTab
Dim $aTab[1] = [$iTab]
$iStart = 0
$iEnd = 0
$iCount = 1
Else
$iCount = 0
EndIf
Else
$iCount = 1
EndIf
Local $tTab = 0
If $iCount Then
If __CheckErrorArrayBounds($aTab, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
$tTab = DllStructCreate('uint[' & $iCount & ']')
$iTab = 1
For $i = $iStart To $iEnd
DllStructSetData($tTab, 1, $aTab[$i], $iTab)
$iTab += 1
Next
EndIf
Local $aRet = DllCall('user32.dll', 'long', 'TabbedTextOutW', 'handle', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText,  'int', StringLen($sText), 'int', $iCount, 'struct*', $tTab, 'int', $iOrigin)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$__g_vExt = _WinAPI_CreateSize(_WinAPI_LoWord($aRet[0]), _WinAPI_HiWord($aRet[0]))
Return 1
EndFunc
Func _WinAPI_TextOut($hDC, $iX, $iY, $sText)
Local $aRet = DllCall('gdi32.dll', 'bool', 'TextOutW', 'handle', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText,  'int', StringLen($sText))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TransparentBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiTransparentBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', __RGB($iRGB))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UnionRect(ByRef $tRECT1, ByRef $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'UnionRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, 0, 0)
Return $tRECT
EndFunc
Func _WinAPI_ValidateRect($hWnd, $tRECT = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'ValidateRect', 'hwnd', $hWnd, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ValidateRgn($hWnd, $hRgn = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'ValidateRgn', 'hwnd', $hWnd, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_WidenPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'WidenPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_WindowFromDC($hDC)
Local $aRet = DllCall('user32.dll', 'hwnd', 'WindowFromDC', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __EnumDisplayMonitorsProc($hMonitor, $hDC, $pRECT, $lParam)
#forceref $hDC, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hMonitor
If Not $pRECT Then
$__g_vEnum[$__g_vEnum[0][0]][1] = 0
Else
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructCreate($tagRECT)
If Not _WinAPI_MoveMemory(DllStructGetPtr($__g_vEnum[$__g_vEnum[0][0]][1]), $pRECT, 16) Then Return 0
EndIf
Return 1
EndFunc
Func __EnumFontFamiliesProc($pELFEX, $pNTMEX, $iFontType, $pPattern)
Local $tELFEX = DllStructCreate($tagLOGFONT & ';wchar FullName[64];wchar Style[32];wchar Script[32]', $pELFEX)
Local $tNTMEX = DllStructCreate($tagNEWTEXTMETRICEX, $pNTMEX)
Local $tPattern = DllStructCreate('uint;uint;ptr', $pPattern)
If $iFontType And Not BitAND($iFontType, DllStructGetData($tPattern, 1)) Then
Return 1
EndIf
If DllStructGetData($tPattern, 3) Then
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMatchSpecW', 'ptr', DllStructGetPtr($tELFEX, 14), 'ptr', DllStructGetData($tPattern, 3))
If Not @error Then
If DllStructGetData($tPattern, 2) Then
If $aRet[0] Then
Return 1
Else
EndIf
Else
If $aRet[0] Then
Else
Return 1
EndIf
EndIf
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData($tELFEX, 14)
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructGetData($tELFEX, 16)
$__g_vEnum[$__g_vEnum[0][0]][2] = DllStructGetData($tELFEX, 15)
$__g_vEnum[$__g_vEnum[0][0]][3] = DllStructGetData($tELFEX, 17)
$__g_vEnum[$__g_vEnum[0][0]][4] = $iFontType
$__g_vEnum[$__g_vEnum[0][0]][5] = DllStructGetData($tNTMEX, 19)
$__g_vEnum[$__g_vEnum[0][0]][6] = DllStructGetData($tNTMEX, 20)
$__g_vEnum[$__g_vEnum[0][0]][7] = DllStructGetData($tNTMEX, 21)
Return 1
EndFunc
Func __EnumFontStylesProc($pELFEX, $pNTMEX, $iFontType, $pFN)
#forceref $iFontType
Local $tELFEX = DllStructCreate($tagLOGFONT & ';wchar FullName[64];wchar Style[32];wchar Script[32]', $pELFEX)
Local $tNTMEX = DllStructCreate($tagNEWTEXTMETRICEX, $pNTMEX)
Local $tFN = DllStructCreate('dword;wchar[64]', $pFN)
If BitAND(DllStructGetData($tNTMEX, 'ntmFlags'), 0x0061) = DllStructGetData($tFN, 1) Then
DllStructSetData($tFN, 2, DllStructGetData($tELFEX, 'FullName'))
Return 0
Else
Return 1
EndIf
EndFunc
#EndRegion Internal Functions
Global $__g_hGDIPBrush = 0
Global $__g_hGDIPDll = 0
Global $__g_hGDIPPen = 0
Global $__g_iGDIPRef = 0
Global $__g_iGDIPToken = 0
Global $__g_bGDIP_V1_0 = True
Func _GDIPlus_ArrowCapCreate($fHeight, $fWidth, $bFilled = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateAdjustableArrowCap", "float", $fHeight, "float", $fWidth, "bool", $bFilled, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_ArrowCapDispose($hCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteCustomLineCap", "handle", $hCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapGetFillState($hArrowCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapFillState", "handle", $hArrowCap, "bool*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapGetHeight($hArrowCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapHeight", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ArrowCapGetMiddleInset($hArrowCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapMiddleInset", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ArrowCapGetWidth($hArrowCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapWidth", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ArrowCapSetFillState($hArrowCap, $bFilled = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapFillState", "handle", $hArrowCap, "bool", $bFilled)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetHeight($hArrowCap, $fHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapHeight", "handle", $hArrowCap, "float", $fHeight)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetMiddleInset($hArrowCap, $fInset)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapMiddleInset", "handle", $hArrowCap, "float", $fInset)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetWidth($hArrowCap, $fWidth)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapWidth", "handle", $hArrowCap, "float", $fWidth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCloneArea($hBitmap, $nLeft, $nTop, $nWidth, $nHeight, $iFormat = 0x00021808)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneBitmapArea", "float", $nLeft, "float", $nTop, "float", $nWidth, "float", $nHeight,  "int", $iFormat, "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
Local $aRet = DllCall($__g_hGDIPDll, "uint", "GdipGetImageDimension", "handle", $hBitmap, "float*", 0, "float*", 0)
If @error Or $aRet[0] Then Return SetError(@error + 10, $aRet[0], 0)
Local $tData = _GDIPlus_BitmapLockBits($hBitmap, 0, 0, $aRet[2], $aRet[3], $GDIP_ILMREAD, $GDIP_PXF32ARGB)
Local $pBits = DllStructGetData($tData, "Scan0")
If Not $pBits Then Return 0
Local $tBIHDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIHDR, "bV5Size", DllStructGetSize($tBIHDR))
DllStructSetData($tBIHDR, "bV5Width", $aRet[2])
DllStructSetData($tBIHDR, "bV5Height", $aRet[3])
DllStructSetData($tBIHDR, "bV5Planes", 1)
DllStructSetData($tBIHDR, "bV5BitCount", 32)
DllStructSetData($tBIHDR, "bV5Compression", 0)
DllStructSetData($tBIHDR, "bV5SizeImage", $aRet[3] * DllStructGetData($tData, "Stride"))
DllStructSetData($tBIHDR, "bV5AlphaMask", 0xFF000000)
DllStructSetData($tBIHDR, "bV5RedMask", 0x00FF0000)
DllStructSetData($tBIHDR, "bV5GreenMask", 0x0000FF00)
DllStructSetData($tBIHDR, "bV5BlueMask", 0x000000FF)
DllStructSetData($tBIHDR, "bV5CSType", 2)
DllStructSetData($tBIHDR, "bV5Intent", 4)
Local $hHBitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $tBIHDR, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
If Not @error And $hHBitmapv5[0] Then
DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hHBitmapv5[0], "dword", $aRet[2] * $aRet[3] * 4, "ptr", DllStructGetData($tData, "Scan0"))
$hHBitmapv5 = $hHBitmapv5[0]
Else
$hHBitmapv5 = 0
EndIf
_GDIPlus_BitmapUnlockBits($hBitmap, $tData)
$tData = 0
$tBIHDR = 0
Return $hHBitmapv5
EndFunc
Func _GDIPlus_BitmapCreateFromFile($sFileName)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateFromGraphics($iWidth, $iHeight, $hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromGraphics", "int", $iWidth, "int", $iHeight, "handle", $hGraphics,  "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_BitmapCreateFromHBITMAP($hBitmap, $hPal = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hBitmap, "handle", $hPal, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_BitmapCreateFromMemory($dImage, $bHBITMAP = False)
If Not IsBinary($dImage) Then Return SetError(1, 0, 0)
Local $aResult = 0
Local Const $dMemBitmap = Binary($dImage)
Local Const $iLen = BinaryLen($dMemBitmap)
Local Const $GMEM_MOVEABLE = 0x0002
$aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $iLen)
If @error Then Return SetError(4, 0, 0)
Local Const $hData = $aResult[0]
$aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hData)
If @error Then Return SetError(5, 0, 0)
Local $tMem = DllStructCreate("byte[" & $iLen & "]", $aResult[0])
DllStructSetData($tMem, 1, $dMemBitmap)
DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hData)
If @error Then Return SetError(6, 0, 0)
Local Const $hStream = _WinAPI_CreateStreamOnHGlobal($hData)
If @error Then Return SetError(2, 0, 0)
Local Const $hBitmap = _GDIPlus_BitmapCreateFromStream($hStream)
If @error Then Return SetError(3, 0, 0)
DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $hStream, "ulong_ptr", 8 * (1 + @AutoItX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
If $bHBITMAP Then
Local Const $hHBmp = _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
_GDIPlus_BitmapDispose($hBitmap)
Return $hHBmp
EndIf
Return $hBitmap
EndFunc
Func _GDIPlus_BitmapCreateFromResource($hInst, $vResourceName)
Local $sType = "int"
If IsString($vResourceName) Then $sType = "wstr"
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromResource", "handle", $hInst, $sType, $vResourceName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $iPixelFormat = $GDIP_PXF32ARGB, $iStride = 0, $pScan0 = 0)
Local $aResult = DllCall($__g_hGDIPDll, "uint", "GdipCreateBitmapFromScan0", "int", $iWidth, "int", $iHeight, "int", $iStride, "int", $iPixelFormat, "struct*", $pScan0, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_BitmapCreateFromStream($pStream)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateHBITMAPFromBitmap($hBitmap, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateHBITMAPFromBitmap", "handle", $hBitmap, "handle*", 0, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapDispose($hBitmap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCreateFromHICON($hIcon)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHICON", "handle", $hIcon, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateFromHICON32($hIcon)
Local $tSIZE = _WinAPI_GetIconDimension($hIcon)
Local $iWidth = DllStructGetData($tSIZE, 'X')
Local $iHeight = DllStructGetData($tSIZE, 'Y')
If $iWidth <= 0 Or $iHeight <= 0 Then Return SetError(10, -1, 0)
Local $tBITMAPINFO = DllStructCreate("dword Size;long Width;long Height;word Planes;word BitCount;dword Compression;dword SizeImage;long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImportant;dword RGBQuad")
DllStructSetData($tBITMAPINFO, 'Size', DllStructGetSize($tBITMAPINFO) - 4)
DllStructSetData($tBITMAPINFO, 'Width', $iWidth)
DllStructSetData($tBITMAPINFO, 'Height', -$iHeight)
DllStructSetData($tBITMAPINFO, 'Planes', 1)
DllStructSetData($tBITMAPINFO, 'BitCount', 32)
DllStructSetData($tBITMAPINFO, 'Compression', 0)
DllStructSetData($tBITMAPINFO, 'SizeImage', 0)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $pBits
Local $hBmp = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $pBits)
Local $hOrig = _WinAPI_SelectObject($hDC, $hBmp)
_WinAPI_DrawIconEx($hDC, 0, 0, $hIcon, $iWidth, $iHeight)
Local $hBitmapIcon = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $GDIP_PXF32ARGB, $iWidth * 4, $pBits)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
Local $hContext = _GDIPlus_ImageGetGraphicsContext($hBitmap)
_GDIPlus_GraphicsDrawImage($hContext, $hBitmapIcon, 0, 0)
_GDIPlus_GraphicsDispose($hContext)
_GDIPlus_BitmapDispose($hBitmapIcon)
_WinAPI_SelectObject($hDC, $hOrig)
_WinAPI_DeleteDC($hDC)
_WinAPI_DeleteObject($hBmp)
Return $hBitmap
EndFunc
Func _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_BitmapLockBits($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $iFlags = $GDIP_ILMREAD, $iFormat = $GDIP_PXF32RGB)
Local $tData = DllStructCreate($tagGDIPBITMAPDATA)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iWidth)
DllStructSetData($tRECT, "Bottom", $iHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapLockBits", "handle", $hBitmap, "struct*", $tRECT, "uint", $iFlags, "int", $iFormat, "struct*", $tData)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tData
EndFunc
Func _GDIPlus_BitmapSetPixel($hBitmap, $iX, $iY, $iARGB)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapSetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapSetResolution($hBitmap, $fDpiX, $fDpiY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapSetResolution", "handle", $hBitmap, "float", $fDpiX, "float", $fDpiY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapUnlockBits($hBitmap, $tBitmapData)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapUnlockBits", "handle", $hBitmap, "struct*", $tBitmapData)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BrushClone($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneBrush", "handle", $hBrush, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushCreateSolid($iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateSolidFill", "int", $iARGB, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushDispose($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteBrush", "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BrushGetSolidColor($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetSolidFillColor", "handle", $hBrush, "dword*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushGetType($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetBrushType", "handle", $hBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushSetSolidColor($hBrush, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetSolidFillColor", "handle", $hBrush, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ColorMatrixCreate()
Return _GDIPlus_ColorMatrixCreateScale(1, 1, 1, 1)
EndFunc
Func _GDIPlus_ColorMatrixCreateGrayScale()
Local $iI, $iJ, $tCM, $aLums[4] = [$GDIP_RLUM, $GDIP_GLUM, $GDIP_BLUM, 0]
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
For $iI = 0 To 3
For $iJ = 1 To 3
DllStructSetData($tCM, "m", $aLums[$iI], $iI * 5 + $iJ)
Next
Next
DllStructSetData($tCM, "m", 1, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateNegative()
Local $iI, $tCM
$tCM = _GDIPlus_ColorMatrixCreateScale(-1, -1, -1, 1)
For $iI = 1 To 4
DllStructSetData($tCM, "m", 1, 20 + $iI)
Next
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateSaturation($fSat)
Local $fSatComp, $tCM
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
$fSatComp = (1 - $fSat)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM + $fSat, 1)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM, 2)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM, 3)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM, 6)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM + $fSat, 7)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM, 8)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM, 11)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM, 12)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM + $fSat, 13)
DllStructSetData($tCM, "m", 1, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateScale($fRed, $fGreen, $fBlue, $fAlpha = 1)
Local $tCM
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
DllStructSetData($tCM, "m", $fRed, 1)
DllStructSetData($tCM, "m", $fGreen, 7)
DllStructSetData($tCM, "m", $fBlue, 13)
DllStructSetData($tCM, "m", $fAlpha, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateTranslate($fRed, $fGreen, $fBlue, $fAlpha = 0)
Local $iI, $tCM, $aFactors[4] = [$fRed, $fGreen, $fBlue, $fAlpha]
$tCM = _GDIPlus_ColorMatrixCreate()
For $iI = 0 To 3
DllStructSetData($tCM, "m", $aFactors[$iI], 21 + $iI)
Next
Return $tCM
EndFunc
Func _GDIPlus_CustomLineCapClone($hCustomLineCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneCustomLineCap", "handle", $hCustomLineCap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_CustomLineCapCreate($hPathFill, $hPathStroke, $iLineCap = 0, $nBaseInset = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateCustomLineCap", "handle", $hPathFill, "handle", $hPathStroke, "int", $iLineCap, "float", $nBaseInset, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_CustomLineCapDispose($hCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteCustomLineCap", "handle", $hCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_CustomLineCapGetStrokeCaps($hCustomLineCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCustomLineCapStrokeCaps", "hwnd", $hCustomLineCap, "ptr*", 0, "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then SetError(10, $aResult[0], 0)
Local $aCaps[2]
$aCaps[0] = $aResult[2]
$aCaps[1] = $aResult[3]
Return $aCaps
EndFunc
Func _GDIPlus_CustomLineCapSetStrokeCaps($hCustomLineCap, $iStartCap, $iEndCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetCustomLineCapStrokeCaps", "handle", $hCustomLineCap, "int", $iStartCap, "int", $iEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Decoders()
Local $iCount = _GDIPlus_DecodersGetCount()
Local $iSize = _GDIPlus_DecodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_DecodersGetCount()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[1]
EndFunc
Func _GDIPlus_DecodersGetSize()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_DrawImagePoints($hGraphic, $hImage, $nULX, $nULY, $nURX, $nURY, $nLLX, $nLLY, $iCount = 3)
Local $tPoint = DllStructCreate("float X;float Y;float X2;float Y2;float X3;float Y3")
DllStructSetData($tPoint, "X", $nULX)
DllStructSetData($tPoint, "Y", $nULY)
DllStructSetData($tPoint, "X2", $nURX)
DllStructSetData($tPoint, "Y2", $nURY)
DllStructSetData($tPoint, "X3", $nLLX)
DllStructSetData($tPoint, "Y3", $nLLY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImagePoints", "handle", $hGraphic, "handle", $hImage, "struct*", $tPoint, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Encoders()
Local $iCount = _GDIPlus_EncodersGetCount()
Local $iSize = _GDIPlus_EncodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_EncodersGetCLSID($sFileExtension)
Local $aEncoders = _GDIPlus_Encoders()
If @error Then Return SetError(@error, 0, "")
For $iI = 1 To $aEncoders[0][0]
If StringInStr($aEncoders[$iI][6], "*." & $sFileExtension) > 0 Then Return $aEncoders[$iI][1]
Next
Return SetError(-1, -1, "")
EndFunc
Func _GDIPlus_EncodersGetCount()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[1]
EndFunc
Func _GDIPlus_EncodersGetParamList($hImage, $sEncoder)
Local $iSize = _GDIPlus_EncodersGetParamListSize($hImage, $sEncoder)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $iRemainingSize = $iSize - 4 - _GDIPlus_ParamSize()
Local $tBuffer
If $iRemainingSize Then
$tBuffer = DllStructCreate("dword Count;" & $tagGDIPENCODERPARAM & ";byte [" & $iRemainingSize & "]")
Else
$tBuffer = DllStructCreate("dword Count;" & $tagGDIPENCODERPARAM)
EndIf
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEncoderParameterList", "handle", $hImage, "struct*", $tGUID, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tBuffer
EndFunc
Func _GDIPlus_EncodersGetParamListSize($hImage, $sEncoder)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEncoderParameterListSize", "handle", $hImage, "struct*", $tGUID, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_EncodersGetSize()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_FontCreate($hFamily, $fSize, $iStyle = 0, $iUnit = 3)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFont", "handle", $hFamily, "float", $fSize, "int", $iStyle, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_FontDispose($hFont)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFont", "handle", $hFont)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyCreate($sFamily, $pCollection = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFamily, "ptr", $pCollection, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyCreateFromCollection($sFontName, $hFontCollection)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFontName, "ptr", $hFontCollection, "ptr*", 0)
If @error Then Return SetError(@error, @extended, "")
If $aResult[0] Then Return SetError(10, $aResult[0], "")
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyDispose($hFamily)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFontFamily", "handle", $hFamily)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyGetCellAscent($hFontFamily, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCellAscent", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyGetCellDescent($hFontFamily, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCellDescent", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyGetEmHeight($hFontFamily, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEmHeight", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyGetLineSpacing($hFontFamily, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetLineSpacing", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontGetHeight($hFont, $hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetFontHeight", "handle", $hFont, "handle", $hGraphics, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontPrivateAddFont($hFontCollection, $sFontFile)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPrivateAddFontFile", "ptr", $hFontCollection, "wstr", $sFontFile)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateAddMemoryFont($hFontCollection, $tFont)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPrivateAddMemoryFont", "handle", $hFontCollection, "struct*", $tFont, "int", DllStructGetSize($tFont))
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateCollectionDispose($hFontCollection)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePrivateFontCollection", "handle*", $hFontCollection)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateCreateCollection()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipNewPrivateFontCollection", "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_GraphicsClear($hGraphics, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGraphicsClear", "handle", $hGraphics, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsCreateFromHDC($hDC)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHDC", "handle", $hDC, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsCreateFromHWND($hWnd)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHWND", "hwnd", $hWnd, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsDispose($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteGraphics", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawArc($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawArc", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawBezier($hGraphics, $nX1, $nY1, $nX2, $nY2, $nX3, $nY3, $nX4, $nY4, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawBezier", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1,  "float", $nX2, "float", $nY2, "float", $nX3, "float", $nY3, "float", $nX4, "float", $nY4)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawClosedCurve($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawClosedCurve", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawClosedCurve2($hGraphics, $aPoints, $nTension, $hPen = 0)
Local $iI, $iCount, $tPoints, $aResult
__GDIPlus_PenDefCreate($hPen)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawClosedCurve2", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount, "float", $nTension)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawCurve($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawCurve", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawCurve2($hGraphics, $aPoints, $nTension, $hPen = 0)
Local $iI, $iCount, $tPoints, $aResult
__GDIPlus_PenDefCreate($hPen)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawCurve2", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount, "float", $nTension)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawEllipse", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImage($hGraphics, $hImage, $nX, $nY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImage", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImagePointsRect($hGraphics, $hImage, $nULX, $nULY, $nURX, $nURY, $nLLX, $nLLY, $nSrcX, $nSrcY, $nSrcWidth, $nSrcHeight, $hImageAttributes = 0, $iUnit = 2)
Local $tPoints = DllStructCreate("float X; float Y; float X2; float Y2; float X3; float Y3;")
DllStructSetData($tPoints, "X", $nULX)
DllStructSetData($tPoints, "Y", $nULY)
DllStructSetData($tPoints, "X2", $nURX)
DllStructSetData($tPoints, "Y2", $nURY)
DllStructSetData($tPoints, "X3", $nLLX)
DllStructSetData($tPoints, "Y3", $nLLY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImagePointsRect", "handle", $hGraphics, "handle", $hImage, "struct*", $tPoints, "int", 3, "float", $nSrcX, "float", $nSrcY, "float", $nSrcWidth, "float", $nSrcHeight, "int", $iUnit, "handle", $hImageAttributes, "ptr", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRect($hGraphics, $hImage, $nX, $nY, $nW, $nH)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRect", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY,  "float", $nW, "float", $nH)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRectRect($hGraphics, $hImage, $nSrcX, $nSrcY, $nSrcWidth, $nSrcHeight, $nDstX, $nDstY, $nDstWidth, $nDstHeight, $pAttributes = 0, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRectRect", "handle", $hGraphics, "handle", $hImage,  "float", $nDstX, "float", $nDstY, "float", $nDstWidth, "float", $nDstHeight,  "float", $nSrcX, "float", $nSrcY, "float", $nSrcWidth, "float", $nSrcHeight,  "int", $iUnit, "handle", $pAttributes, "ptr", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawLine($hGraphics, $nX1, $nY1, $nX2, $nY2, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawLine", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1,  "float", $nX2, "float", $nY2)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPath($hGraphics, $hPath, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawPath", "handle", $hGraphics, "handle", $hPen, "handle", $hPath)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPie($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawPie", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPolygon($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawPolygon", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawRectangle", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawString($hGraphics, $sString, $nX, $nY, $sFont = "Arial", $fSize = 10, $iFormat = 0)
Local $hBrush = _GDIPlus_BrushCreateSolid()
Local $hFormat = _GDIPlus_StringFormatCreate($iFormat)
Local $hFamily = _GDIPlus_FontFamilyCreate($sFont)
Local $hFont = _GDIPlus_FontCreate($hFamily, $fSize)
Local $tLayout = _GDIPlus_RectFCreate($nX, $nY, 0.0, 0.0)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult = _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
Local $iError = @error, $iExtended = @extended
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
Return SetError($iError, $iExtended, $aResult)
EndFunc
Func _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $tLayout, $hFormat, $hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont,  "struct*", $tLayout, "handle", $hFormat, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillClosedCurve($hGraphics, $aPoints, $hBrush = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillClosedCurve", "handle", $hGraphics, "handle", $hBrush, "struct*", $tPoints, "int", $iCount)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillClosedCurve2($hGraphics, $aPoints, $nTension, $hBrush = 0, $iFillMode = 0)
Local $iI, $iCount, $tPoints, $aResult
__GDIPlus_BrushDefCreate($hBrush)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipFillClosedCurve2", "handle", $hGraphics, "handle", $hBrush, "struct*", $tPoints, "int", $iCount, "float", $nTension, "int", $iFillMode)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillEllipse", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPath($hGraphics, $hPath, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillPath", "handle", $hGraphics, "handle", $hBrush, "handle", $hPath)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPie($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillPie", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPolygon($hGraphics, $aPoints, $hBrush = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillPolygon", "handle", $hGraphics, "handle", $hBrush,  "struct*", $tPoints, "int", $iCount, "int", "FillModeAlternate")
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillRectangle", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRegion($hGraphics, $hRegion, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillRegion", "handle", $hGraphics, "handle", $hBrush, "handle", $hRegion)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsGetCompositingMode($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCompositingMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsGetCompositingQuality($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCompositingQuality", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsGetDC($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetDC", "handle", $hGraphics, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsGetInterpolationMode($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetInterpolationMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsGetSmoothingMode($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetSmoothingMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Switch $aResult[2]
Case $GDIP_SMOOTHINGMODE_NONE
Return 0
Case $GDIP_SMOOTHINGMODE_HIGHQUALITY, $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
Return 1
Case $GDIP_SMOOTHINGMODE_ANTIALIAS8X8
Return 2
Case Else
Return 0
EndSwitch
EndFunc
Func _GDIPlus_GraphicsGetTransform($hGraphics, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetWorldTransform", "handle", $hGraphics, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsMeasureCharacterRanges($hGraphics, $sString, $hFont, $tLayout, $hStringFormat)
Local $iCount = _GDIPlus_StringFormatGetMeasurableCharacterRangeCount($hStringFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $tRegions = DllStructCreate("handle[" & $iCount & "]")
Local $aRegions[$iCount + 1] = [$iCount]
For $iI = 1 To $iCount
$aRegions[$iI] = _GDIPlus_RegionCreate()
DllStructSetData($tRegions, 1, $aRegions[$iI], $iI)
Next
DllCall($__g_hGDIPDll, "int", "GdipMeasureCharacterRanges", "handle", $hGraphics, "wstr", $sString, "int", -1, "hwnd", $hFont, "struct*", $tLayout, "handle", $hStringFormat, "int", $iCount, "struct*", $tRegions)
Local $iError = @error, $iExtended = @extended
If $iError Then
For $iI = 1 To $iCount
_GDIPlus_RegionDispose($aRegions[$iI])
Next
Return SetError($iError + 10, $iExtended, 0)
EndIf
Return $aRegions
EndFunc
Func _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMeasureString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont,  "struct*", $tLayout, "handle", $hFormat, "struct*", $tRECTF, "int*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $aInfo[3]
$aInfo[0] = $tRECTF
$aInfo[1] = $aResult[8]
$aInfo[2] = $aResult[9]
Return $aInfo
EndFunc
Func _GDIPlus_GraphicsReleaseDC($hGraphics, $hDC)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipReleaseDC", "handle", $hGraphics, "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsResetClip($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetClip", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsResetTransform($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetWorldTransform", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsRestore($hGraphics, $iState)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipRestoreGraphics", "handle", $hGraphics, "uint", $iState)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsRotateTransform($hGraphics, $fAngle, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipRotateWorldTransform", "handle", $hGraphics, "float", $fAngle, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSave($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveGraphics", "handle", $hGraphics, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsScaleTransform($hGraphics, $fScaleX, $fScaleY, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipScaleWorldTransform", "handle", $hGraphics, "float", $fScaleX, "float", $fScaleY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipPath($hGraphics, $hPath, $iCombineMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetClipPath", "handle", $hGraphics, "handle", $hPath, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $iCombineMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetClipRect", "handle", $hGraphics, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipRegion($hGraphics, $hRegion, $iCombineMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetClipRegion", "handle", $hGraphics, "handle", $hRegion, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetCompositingMode($hGraphics, $iCompositionMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetCompositingMode", "handle", $hGraphics, "int", $iCompositionMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetCompositingQuality($hGraphics, $iCompositionQuality)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetCompositingQuality", "handle", $hGraphics, "int", $iCompositionQuality)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetInterpolationMode($hGraphics, $iInterpolationMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetInterpolationMode", "handle", $hGraphics, "int", $iInterpolationMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetPixelOffsetMode($hGraphics, $iPixelOffsetMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPixelOffsetMode", "handle", $hGraphics, "int", $iPixelOffsetMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetSmoothingMode($hGraphics, $iSmooth)
If $iSmooth < $GDIP_SMOOTHINGMODE_DEFAULT Or $iSmooth > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 Then $iSmooth = $GDIP_SMOOTHINGMODE_DEFAULT
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetSmoothingMode", "handle", $hGraphics, "int", $iSmooth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetTextRenderingHint($hGraphics, $iTextRenderingHint)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetTextRenderingHint", "handle", $hGraphics, "int", $iTextRenderingHint)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetTransform($hGraphics, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetWorldTransform", "handle", $hGraphics, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsTransformPoints($hGraphics, ByRef $aPoints, $iCoordSpaceTo = 0, $iCoordSpaceFrom = 1)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTransformPoints", "handle", $hGraphics, "int", $iCoordSpaceTo, "int", $iCoordSpaceFrom, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 2)
Next
Return True
EndFunc
Func _GDIPlus_GraphicsTranslateTransform($hGraphics, $nDX, $nDY, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTranslateWorldTransform", "handle", $hGraphics, "float", $nDX, "float", $nDY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_HatchBrushCreate($iHatchStyle = 0, $iARGBForeground = 0xFFFFFFFF, $iARGBBackground = 0xFFFFFFFF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateHatchBrush", "int", $iHatchStyle, "uint", $iARGBForeground, "uint", $iARGBBackground, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_HICONCreateFromBitmap($hBitmap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateHICONFromBitmap", "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageAttributesCreate()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateImageAttributes", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_ImageAttributesDispose($hImageAttributes)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImageAttributes", "handle", $hImageAttributes)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetColorKeys($hImageAttributes, $iColorAdjustType = 0, $bEnable = False, $iARGBLow = 0, $iARGBHigh = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesColorKeys", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "uint", $iARGBLow, "uint", $iARGBHigh)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetColorMatrix($hImageAttributes, $iColorAdjustType = 0, $bEnable = False, $tClrMatrix = 0, $tGrayMatrix = 0, $iColorMatrixFlags = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesColorMatrix", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "struct*", $tClrMatrix, "struct*", $tGrayMatrix, "int", $iColorMatrixFlags)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetRemapTable($hImageAttributes, $aColorMap = 0, $iColorAdjustType = 0, $bEnable = True)
Local $aResult
If IsArray($aColorMap) Then
Local $iCount = $aColorMap[0][0]
Local $tColorMap = DllStructCreate("uint[" & $iCount * 2 & "]")
For $i = 1 To $iCount
DllStructSetData($tColorMap, 1, $aColorMap[$i][0], ($i - 1) * 2 + 1)
DllStructSetData($tColorMap, 1, $aColorMap[$i][1], ($i - 1) * 2 + 2)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesRemapTable", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "int", $iCount, "struct*", $tColorMap)
Else
$aResult = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesRemapTable", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "int", 0, "struct*", 0)
EndIf
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetThreshold($hImageAttributes, $fThreshold, $iColorAdjustType = $GDIP_COLORADJUSTTYPE_DEFAULT, $bEnable = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesThreshold", "handle", $hImageAttributes, "int", $iColorAdjustType, "bool", $bEnable, "float", $fThreshold)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageClone($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneImage", "handle", $hImage, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageDispose($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hImage)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageGetDimension($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageDimension", "handle", $hImage, "float*", 0, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $aImgDim[2] = [$aResult[2], $aResult[3]]
Return $aImgDim
EndFunc
Func _GDIPlus_ImageGetFlags($hImage)
Local $aFlag[2] = [0, ""]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aFlag)
Local $aImageFlags[13][2] =  [["Pixel data Cacheable", $GDIP_IMAGEFLAGS_CACHING],  ["Pixel data read-only", $GDIP_IMAGEFLAGS_READONLY],  ["Pixel size in image", $GDIP_IMAGEFLAGS_HASREALPIXELSIZE],  ["DPI info in image", $GDIP_IMAGEFLAGS_HASREALDPI],  ["YCCK color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCCK],  ["YCBCR color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR],  ["Grayscale image", $GDIP_IMAGEFLAGS_COLORSPACE_GRAY],  ["CMYK color space", $GDIP_IMAGEFLAGS_COLORSPACE_CMYK],  ["RGB color space", $GDIP_IMAGEFLAGS_COLORSPACE_RGB],  ["Partially scalable", $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE],  ["Alpha values other than 0 (transparent) and 255 (opaque)", $GDIP_IMAGEFLAGS_HASTRANSLUCENT],  ["Alpha values", $GDIP_IMAGEFLAGS_HASALPHA],  ["Scalable", $GDIP_IMAGEFLAGS_SCALABLE]]
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageFlags", "handle", $hImage, "long*", 0)
If @error Then Return SetError(@error, @extended, $aFlag)
If $aResult[0] Then Return SetError(10, $aResult[0], $aFlag)
If $aResult[2] = $GDIP_IMAGEFLAGS_NONE Then
$aFlag[1] = "No pixel data"
Return SetError(12, $aResult[2], $aFlag)
EndIf
$aFlag[0] = $aResult[2]
For $i = 0 To 12
If BitAND($aResult[2], $aImageFlags[$i][1]) = $aImageFlags[$i][1] Then
If StringLen($aFlag[1]) Then $aFlag[1] &= "|"
$aResult[2] -= $aImageFlags[$i][1]
$aFlag[1] &= $aImageFlags[$i][0]
EndIf
Next
Return $aFlag
EndFunc
Func _GDIPlus_ImageGetFrameCount($hImage, $sDimensionID)
Local $tGUID = _WinAPI_GUIDFromString($sDimensionID)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipImageGetFrameCount", "handle", $hImage, "struct*", $tGUID, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[3]
EndFunc
Func _GDIPlus_ImageGetGraphicsContext($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageGraphicsContext", "handle", $hImage, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetHeight($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageHeight", "handle", $hImage, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetHorizontalResolution($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageHorizontalResolution", "handle", $hImage, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return Round($aResult[2])
EndFunc
Func _GDIPlus_ImageGetPixelFormat($hImage)
Local $aFormat[2] = [0, ""]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aFormat)
Local $aPixelFormat[14][2] =  [["1 Bpp Indexed", $GDIP_PXF01INDEXED],  ["4 Bpp Indexed", $GDIP_PXF04INDEXED],  ["8 Bpp Indexed", $GDIP_PXF08INDEXED],  ["16 Bpp Grayscale", $GDIP_PXF16GRAYSCALE],  ["16 Bpp RGB 555", $GDIP_PXF16RGB555],  ["16 Bpp RGB 565", $GDIP_PXF16RGB565],  ["16 Bpp ARGB 1555", $GDIP_PXF16ARGB1555],  ["24 Bpp RGB", $GDIP_PXF24RGB],  ["32 Bpp RGB", $GDIP_PXF32RGB],  ["32 Bpp ARGB", $GDIP_PXF32ARGB],  ["32 Bpp PARGB", $GDIP_PXF32PARGB],  ["48 Bpp RGB", $GDIP_PXF48RGB],  ["64 Bpp ARGB", $GDIP_PXF64ARGB],  ["64 Bpp PARGB", $GDIP_PXF64PARGB]]
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImagePixelFormat", "handle", $hImage, "int*", 0)
If @error Then Return SetError(@error, @extended, $aFormat)
If $aResult[0] Then Return SetError(10, $aResult[0], $aFormat)
For $i = 0 To 13
If $aPixelFormat[$i][1] = $aResult[2] Then
$aFormat[0] = $aPixelFormat[$i][1]
$aFormat[1] = $aPixelFormat[$i][0]
Return $aFormat
EndIf
Next
Return SetError(12, 0, $aFormat)
EndFunc
Func __GDIPlus_ImageGetPropertyCount($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPropertyCount", "handle", $hImage, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetPropertyIdList($hImage)
Local $iCount = __GDIPlus_ImageGetPropertyCount($hImage)
If @error Then Return SetError(@error, @extended, False)
Local $tProperties = DllStructCreate("uint[" & $iCount & "]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPropertyIdList", "handle", $hImage, "int", $iCount, "struct*", $tProperties)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Local $sPropertyTagInfo = "0x0000=GpsVer;0x0001=GpsLatitudeRef;0x0002=GpsLatitude;0x0003=GpsLongitudeRef;0x0004=GpsLongitude;0x0005=GpsAltitudeRef;0x0006=GpsAltitude;0x0007=GpsGpsTime;0x0008=GpsGpsSatellites;0x0009=GpsGpsStatus;0x000A=GpsGpsMeasureMode;0x000B=GpsGpsDop;0x000C=GpsSpeedRef;0x000D=GpsSpeed;0x000E=GpsTrackRef;0x000F=GpsTrack;0x0010=GpsImgDirRef;0x0011=GpsImgDir;0x0012=GpsMapDatum;0x0013=GpsDestLatRef;0x0014=GpsDestLat;0x0015=GpsDestLongRef;0x0016=GpsDestLong;0x0017=GpsDestBearRef;0x0018=GpsDestBear;0x0019=GpsDestDistRef;0x001A=GpsDestDist;0x00FE=NewSubfileType;0x00FF=SubfileType;0x0100=ImageWidth;0x0101=ImageHeight;0x0102=BitsPerSample;0x0103=Compression;0x0106=PhotometricInterp;0x0107=ThreshHolding;0x0108=CellWidth;0x0109=CellHeight;0x010A=FillOrder;0x010D=DocumentName;0x010E=ImageDescription;0x010F=EquipMake;0x0110=EquipModel;0x0111=StripOffsets;0x0112=Orientation;0x0115=SamplesPerPixel;0x0116=RowsPerStrip;0x0117=StripBytesCount;0x0118=MinSampleValue;0x0119=MaxSampleValue;0x011A=XResolution;0x011B=YResolution;0x011C=PlanarConfig;0x011D=PageName;0x011E=XPosition;0x011F=YPosition;0x0120=FreeOffset;0x0121=FreeByteCounts;0x0122=GrayResponseUnit;0x0123=GrayResponseCurve;0x0124=T4Option;0x0125=T6Option;0x0128=ResolutionUnit;0x0129=PageNumber;0x012D=TransferFunction;0x0131=SoftwareUsed;0x0132=DateTime;0x013B=Artist;0x013C=HostComputer;0x013D=Predictor;0x013E=WhitePoint;0x013F=PrimaryChromaticities;0x0140=ColorMap;0x0141=HalftoneHints;0x0142=TileWidth;0x0143=TileLength;0x0144=TileOffset;0x0145=TileByteCounts;0x014C=InkSet;0x014D=InkNames;0x014E=NumberOfInks;0x0150=DotRange;0x0151=TargetPrinter;0x0152=ExtraSamples;0x0153=SampleFormat;0x0154=SMinSampleValue;0x0155=SMaxSampleValue;0x0156=TransferRange;0x0200=JPEGProc;0x0201=JPEGInterFormat;0x0202=JPEGInterLength;0x0203=JPEGRestartInterval;0x0205=JPEGLosslessPredictors;0x0206=JPEGPointTransforms;0x0207=JPEGQTables;0x0208=JPEGDCTables;0x0209=JPEGACTables;0x0211=YCbCrCoefficients;0x0212=YCbCrSubsampling;0x0213=YCbCrPositioning;0x0214=REFBlackWhite;0x0301=Gamma;0x0302=ICCProfileDescriptor;0x0303=SRGBRenderingIntent;0x0320=ImageTitle;0x5001=ResolutionXUnit;0x5002=ResolutionYUnit;0x5003=ResolutionXLengthUnit;0x5004=ResolutionYLengthUnit;0x5005=PrintFlags;0x5006=PrintFlagsVersion;0x5007=PrintFlagsCrop;0x5008=PrintFlagsBleedWidth;0x5009=PrintFlagsBleedWidthScale;0x500A=HalftoneLPI;0x500B=HalftoneLPIUnit;0x500C=HalftoneDegree;" & _
"0x500D=HalftoneShape;0x500E=HalftoneMisc;0x500F=HalftoneScreen;0x5010=JPEGQuality;0x5011=GridSize;0x5012=ThumbnailFormat;0x5013=ThumbnailWidth;0x5014=ThumbnailHeight;0x5015=ThumbnailColorDepth;0x5016=ThumbnailPlanes;0x5017=ThumbnailRawBytes;0x5018=ThumbnailSize;0x5019=ThumbnailCompressedSize;0x501A=ColorTransferFunction;0x501B=ThumbnailData;0x5020=ThumbnailImageWidth;0x5021=ThumbnailImageHeight;0x5022=ThumbnailBitsPerSample;0x5023=ThumbnailCompression;0x5024=ThumbnailPhotometricInterp;0x5025=ThumbnailImageDescription;0x5026=ThumbnailEquipMake;0x5027=ThumbnailEquipModel;0x5028=ThumbnailStripOffsets;0x5029=ThumbnailOrientation;0x502A=ThumbnailSamplesPerPixel;0x502B=ThumbnailRowsPerStrip;0x502C=ThumbnailStripBytesCount;0x502D=ThumbnailResolutionX;0x502E=ThumbnailResolutionY;0x502F=ThumbnailPlanarConfig;0x5030=ThumbnailResolutionUnit;0x5031=ThumbnailTransferFunction;0x5032=ThumbnailSoftwareUsed;0x5033=ThumbnailDateTime;0x5034=ThumbnailArtist;0x5035=ThumbnailWhitePoint;0x5036=ThumbnailPrimaryChromaticities;0x5037=ThumbnailYCbCrCoefficients;0x5038=ThumbnailYCbCrSubsampling;0x5039=ThumbnailYCbCrPositioning;0x503A=ThumbnailRefBlackWhite;0x503B=ThumbnailCopyRight;0x5090=LuminanceTable;0x5091=ChrominanceTable;0x5100=FrameDelay;0x5101=LoopCount;0x5102=GlobalPalette;0x5103=IndexBackground;0x5104=IndexTransparent;0x5110=PixelUnit;0x5111=PixelPerUnitX;0x5112=PixelPerUnitY;0x5113=PaletteHistogram;0x8298=Copyright;0x829A=ExifExposureTime;0x829D=ExifFNumber;0x8769=ExifIFD;0x8773=ICCProfile;0x8822=ExifExposureProg;0x8824=ExifSpectralSense;0x8825=GpsIFD;0x8827=ExifISOSpeed;0x8828=ExifOECF;0x9000=ExifVer;0x9003=ExifDTOrig;0x9004=ExifDTDigitized;0x9101=ExifCompConfig;0x9102=ExifCompBPP;0x9201=ExifShutterSpeed;0x9202=ExifAperture;0x9203=ExifBrightness;0x9204=ExifExposureBias;0x9205=ExifMaxAperture;0x9206=ExifSubjectDist;0x9207=ExifMeteringMode;0x9208=ExifLightSource;0x9209=ExifFlash;0x920A=ExifFocalLength;0x927C=ExifMakerNote;0x9286=ExifUserComment;0x9290=ExifDTSubsec;0x9291=ExifDTOrigSS;0x9292=ExifDTDigSS;0xA000=ExifFPXVer;0xA001=ExifColorSpace;0xA002=ExifPixXDim;0xA003=ExifPixYDim;0xA004=ExifRelatedWav;0xA005=ExifInterop;0xA20B=ExifFlashEnergy;0xA20C=ExifSpatialFR;0xA20E=ExifFocalXRes;0xA20F=ExifFocalYRes;0xA210=ExifFocalResUnit;0xA214=ExifSubjectLoc;0xA215=ExifExposureIndex;0xA217=ExifSensingMethod;0xA300=ExifFileSource;0xA301=ExifSceneType;0xA302=ExifCfaPattern"
Local $aProperties[$iCount + 1][2] = [[$iCount]]
Local $aRegExp
For $i = 1 To $iCount
$aProperties[$i][0] = DllStructGetData($tProperties, 1, $i)
$aRegExp = StringRegExp($sPropertyTagInfo, "(?i)" & Hex(DllStructGetData($tProperties, 1, $i), 4) & "=(\w+)", 3)
Switch IsArray($aRegExp)
Case True
$aProperties[$i][1] = $aRegExp[0]
Case Else
$aProperties[$i][1] = "PropertyTagUnKnown"
EndSwitch
Next
Return $aProperties
EndFunc
Func __GDIPlus_ImageGetPropertyItemSize($hImage, $iPropID)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPropertyItemSize", "handle", $hImage, "uint", $iPropID, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[3]
EndFunc
Func _GDIPlus_ImageGetPropertyItem($hImage, $iPropID)
Local $iSize = __GDIPlus_ImageGetPropertyItemSize($hImage, $iPropID)
If @error Then Return SetError(@error, @extended, False)
Local $tBuffer = DllStructCreate("byte[" & $iSize & "];")
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPropertyItem", "handle", $hImage, "uint", $iPropID, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Local $tPropertyItem = DllStructCreate("int id; int length; short type; ptr value;", $pBuffer)
Local $iBytes = DllStructGetData($tPropertyItem, "length")
Local $pValue = DllStructGetData($tPropertyItem, "value")
Local $tValues, $iValues
Switch DllStructGetData($tPropertyItem, "type")
Case 2
$iValues = 1
$tValues = DllStructCreate("char[" & $iBytes & "];", $pValue)
Case 3
$iValues = Int($iBytes / 2)
$tValues = DllStructCreate("ushort[" & $iValues & "];", $pValue)
Case 4, 5
$iValues = Int($iBytes / 4)
$tValues = DllStructCreate("uint[" & $iValues & "];", $pValue)
Case 9, 10
$iValues = Int($iBytes / 4)
$tValues = DllStructCreate("int[" & $iValues & "];", $pValue)
Case Else
$iValues = 1
$tValues = DllStructCreate("byte[" & $iBytes & "];", $pValue)
EndSwitch
Local $aValues[$iValues + 1] = [$iValues]
Switch DllStructGetData($tPropertyItem, "type")
Case 5, 10
$iValues = Int($iValues / 2)
ReDim $aValues[$iValues + 1]
$aValues[0] = $iValues
For $j = 1 To $iValues
$aValues[$j] = DllStructGetData($tValues, 1, ($j - 1) * 2 + 1) / DllStructGetData($tValues, 1, ($j - 1) * 2 + 2)
Next
Case 3, 4, 9
For $j = 1 To $iValues
$aValues[$j] = DllStructGetData($tValues, 1, $j)
Next
Case Else
$aValues[1] = DllStructGetData($tValues, 1)
EndSwitch
Return $aValues
EndFunc
Func _GDIPlus_ImageGetRawFormat($hImage)
Local $aGuid[2]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aGuid)
Local $aImageType[11][2] =  [["UNDEFINED", $GDIP_IMAGEFORMAT_UNDEFINED],  ["MEMORYBMP", $GDIP_IMAGEFORMAT_MEMORYBMP],  ["BMP", $GDIP_IMAGEFORMAT_BMP],  ["EMF", $GDIP_IMAGEFORMAT_EMF],  ["WMF", $GDIP_IMAGEFORMAT_WMF],  ["JPEG", $GDIP_IMAGEFORMAT_JPEG],  ["PNG", $GDIP_IMAGEFORMAT_PNG],  ["GIF", $GDIP_IMAGEFORMAT_GIF],  ["TIFF", $GDIP_IMAGEFORMAT_TIFF],  ["EXIF", $GDIP_IMAGEFORMAT_EXIF],  ["ICON", $GDIP_IMAGEFORMAT_ICON]]
Local $tStruct = DllStructCreate("byte[16]")
Local $aResult1 = DllCall($__g_hGDIPDll, "int", "GdipGetImageRawFormat", "handle", $hImage, "struct*", $tStruct)
If @error Then Return SetError(@error, @extended, $aGuid)
If $aResult1[0] Then Return SetError(10, $aResult1[0], $aGuid)
Local $sResult2 = _WinAPI_StringFromGUID($aResult1[2])
If @error Then Return SetError(@error + 20, @extended, $aGuid)
If $sResult2 = "" Then Return SetError(12, 0, $aGuid)
For $i = 0 To 10
If $aImageType[$i][1] == $sResult2 Then
$aGuid[0] = $aImageType[$i][1]
$aGuid[1] = $aImageType[$i][0]
Return $aGuid
EndIf
Next
Return SetError(13, 0, $aGuid)
EndFunc
Func _GDIPlus_ImageGetThumbnail($hImage, $iWidth = 0, $iHeight = 0, $bKeepRatio = True, $hCallback = Null, $hCallbackData = Null)
If $bKeepRatio Then
Local $aImgDim = _GDIPlus_ImageGetDimension($hImage)
If @error Then Return SetError(@error + 20, @extended, False)
Local $f
If $iWidth < 1 Or $iHeight < 1 Then
$iWidth = 0
$iHeight = 0
Else
If ($aImgDim[0] / $aImgDim[1]) > 1 Then
$f = $aImgDim[0] / $iWidth
Else
$f = $aImgDim[1] / $iHeight
EndIf
$iWidth = Int($aImgDim[0] / $f)
$iHeight = Int($aImgDim[1] / $f)
EndIf
EndIf
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageThumbnail", "handle", $hImage, "uint", $iWidth, "uint", $iHeight, "ptr*", 0, "ptr", $hCallback, "ptr", $hCallbackData)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return $aResult[4]
EndFunc
Func _GDIPlus_ImageGetType($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, -1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageType", "handle", $hImage, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetVerticalResolution($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageVerticalResolution", "handle", $hImage, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return Round($aResult[2])
EndFunc
Func _GDIPlus_ImageGetWidth($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageWidth", "handle", $hImage, "uint*", -1)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageLoadFromFile($sFileName)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipLoadImageFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageLoadFromStream($pStream)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipLoadImageFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageRotateFlip($hImage, $iRotateFlipType)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipImageRotateFlip", "handle", $hImage, "int", $iRotateFlipType)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveAdd($hImage, $tParams)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveAdd", "handle", $hImage, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveAddImage($hImage, $hImageNew, $tParams)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveAddImage", "handle", $hImage, "handle", $hImageNew, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveToFile($hImage, $sFileName)
Local $sExt = __GDIPlus_ExtractFileExt($sFileName)
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-1, 0, False)
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, 0)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sEncoder, $tParams = 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToFile", "handle", $hImage, "wstr", $sFileName, "struct*", $tGUID, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveToStream($hImage, $pStream, $tEncoder, $tParams = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToStream", "handle", $hImage, "ptr", $pStream, "struct*", $tEncoder, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageScale($hImage, $iScaleW, $iScaleH, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $iWidth = _GDIPlus_ImageGetWidth($hImage) * $iScaleW
If @error Then Return SetError(1, 0, 0)
Local $iHeight = _GDIPlus_ImageGetHeight($hImage) * $iScaleH
If @error Then Return SetError(2, 0, 0)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
If @error Then Return SetError(3, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
If @error Then
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, 0, 0)
EndIf
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(5, 0, 0)
EndIf
_GDIPlus_GraphicsDrawImageRect($hBmpCtxt, $hImage, 0, 0, $iWidth, $iHeight)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(6, 0, 0)
EndIf
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func _GDIPlus_ImageSelectActiveFrame($hImage, $sDimensionID, $iFrameIndex)
Local $tGUID = _WinAPI_GUIDFromString($sDimensionID)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipImageSelectActiveFrame", "handle", $hImage, "struct*", $tGUID, "uint", $iFrameIndex)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageResize($hImage, $iNewWidth, $iNewHeight, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iNewWidth, $iNewHeight)
If @error Then Return SetError(1, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
If @error Then
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(2, @extended, 0)
EndIf
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(3, @extended, 0)
EndIf
_GDIPlus_GraphicsDrawImageRect($hBmpCtxt, $hImage, 0, 0, $iNewWidth, $iNewHeight)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, @extended, 0)
EndIf
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func _GDIPlus_LineBrushCreate($nX1, $nY1, $nX2, $nY2, $iARGBClr1, $iARGBClr2, $iWrapMode = 0)
Local $tPointF1, $tPointF2, $aResult
$tPointF1 = DllStructCreate("float;float")
$tPointF2 = DllStructCreate("float;float")
DllStructSetData($tPointF1, 1, $nX1)
DllStructSetData($tPointF1, 2, $nY1)
DllStructSetData($tPointF2, 1, $nX2)
DllStructSetData($tPointF2, 2, $nY2)
$aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrush", "struct*", $tPointF1, "struct*", $tPointF2, "uint", $iARGBClr1, "uint", $iARGBClr2, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_LineBrushCreateFromRect($tRECTF, $iARGBClr1, $iARGBClr2, $iGradientMode = 0, $iWrapMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrushFromRect", "struct*", $tRECTF, "uint", $iARGBClr1, "uint", $iARGBClr2, "int", $iGradientMode, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_LineBrushCreateFromRectWithAngle($tRECTF, $iARGBClr1, $iARGBClr2, $fAngle, $bIsAngleScalable = True, $iWrapMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrushFromRectWithAngle", "struct*", $tRECTF, "uint", $iARGBClr1, "uint", $iARGBClr2, "float", $fAngle, "int", $bIsAngleScalable, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_LineBrushGetColors($hLineGradientBrush)
Local $tARGBs, $aARGBs[2], $aResult
$tARGBs = DllStructCreate("uint;uint")
$aResult = DllCall($__g_hGDIPDll, "uint", "GdipGetLineColors", "handle", $hLineGradientBrush, "struct*", $tARGBs)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
$aARGBs[0] = DllStructGetData($tARGBs, 1)
$aARGBs[1] = DllStructGetData($tARGBs, 2)
Return $aARGBs
EndFunc
Func _GDIPlus_LineBrushGetRect($hLineGradientBrush)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetLineRect", "handle", $hLineGradientBrush, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_LineBrushMultiplyTransform($hLineGradientBrush, $hMatrix, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMultiplyLineTransform", "handle", $hLineGradientBrush, "handle", $hMatrix, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushResetTransform($hLineGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetLineTransform", "handle", $hLineGradientBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetBlend($hLineGradientBrush, $aBlends)
Local $iI, $iCount, $tFactors, $tPositions, $aResult
$iCount = $aBlends[0][0]
$tFactors = DllStructCreate("float[" & $iCount & "]")
$tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tFactors, 1, $aBlends[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aBlends[$iI][1], $iI)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineBlend", "handle", $hLineGradientBrush, "struct*", $tFactors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetColors($hLineGradientBrush, $iARGBStart, $iARGBEnd)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineColors", "handle", $hLineGradientBrush, "uint", $iARGBStart, "uint", $iARGBEnd)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetGammaCorrection($hLineGradientBrush, $bUseGammaCorrection = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineGammaCorrection", "handle", $hLineGradientBrush, "int", $bUseGammaCorrection)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetLinearBlend($hLineGradientBrush, $fFocus, $fScale = 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineLinearBlend", "handle", $hLineGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetPresetBlend($hLineGradientBrush, $aInterpolations)
Local $iI, $iCount, $tColors, $tPositions, $aResult
$iCount = $aInterpolations[0][0]
$tColors = DllStructCreate("uint[" & $iCount & "]")
$tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aInterpolations[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aInterpolations[$iI][1], $iI)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLinePresetBlend", "handle", $hLineGradientBrush, "struct*", $tColors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetSigmaBlend($hLineGradientBrush, $fFocus, $fScale = 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineSigmaBlend", "handle", $hLineGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetTransform($hLineGradientBrush, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineTransform", "handle", $hLineGradientBrush, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixCreate()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateMatrix", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_MatrixCreate2($nM11 = 1, $nM12 = 1, $nM21 = 1, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateMatrix2", "float", $nM11, "float", $nM12, "float", $nM21, "float", $nM22, "float", $nDX, "float", $nDY, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_MatrixClone($hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneMatrix", "handle", $hMatrix, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_MatrixDispose($hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteMatrix", "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixGetElements($hMatrix)
Local $tElements = DllStructCreate("float[6]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetMatrixElements", "handle", $hMatrix, "struct*", $tElements)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aElements[6]
For $iI = 1 To 6
$aElements[$iI - 1] = DllStructGetData($tElements, 1, $iI)
Next
Return $aElements
EndFunc
Func _GDIPlus_MatrixInvert($hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipInvertMatrix", "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixMultiply($hMatrix1, $hMatrix2, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMultiplyMatrix", "handle", $hMatrix1, "handle", $hMatrix2, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixRotate($hMatrix, $fAngle, $bAppend = False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipRotateMatrix", "handle", $hMatrix, "float", $fAngle, "int", $bAppend)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixScale($hMatrix, $fScaleX, $fScaleY, $bOrder = False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipScaleMatrix", "handle", $hMatrix, "float", $fScaleX, "float", $fScaleY, "int", $bOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixSetElements($hMatrix, $nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetMatrixElements", "handle", $hMatrix, "float", $nM11, "float", $nM12,  "float", $nM21, "float", $nM22, "float", $nDX, "float", $nDY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixShear($hMatrix, $fShearX, $fShearY, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipShearMatrix", "handle", $hMatrix, "float", $fShearX, "float", $fShearY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixTransformPoints($hMatrix, ByRef $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTransformMatrixPoints", "handle", $hMatrix, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 2)
Next
Return True
EndFunc
Func _GDIPlus_MatrixTranslate($hMatrix, $fOffsetX, $fOffsetY, $bAppend = False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTranslateMatrix", "handle", $hMatrix, "float", $fOffsetX, "float", $fOffsetY, "int", $bAppend)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ParamAdd(ByRef $tParams, $sGUID, $iNbOfValues, $iType, $pValues)
Local $iCount = DllStructGetData($tParams, "Count")
Local $pGUID = DllStructGetPtr($tParams, "GUID") + ($iCount * _GDIPlus_ParamSize())
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM, $pGUID)
_WinAPI_GUIDFromStringEx($sGUID, $pGUID)
DllStructSetData($tParam, "Type", $iType)
DllStructSetData($tParam, "NumberOfValues", $iNbOfValues)
DllStructSetData($tParam, "Values", $pValues)
DllStructSetData($tParams, "Count", $iCount + 1)
EndFunc
Func _GDIPlus_ParamInit($iCount)
Local $sStruct = $tagGDIPENCODERPARAMS
For $i = 2 To $iCount
$sStruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
Next
Return DllStructCreate($sStruct)
EndFunc
Func _GDIPlus_ParamSize()
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM)
Return DllStructGetSize($tParam)
EndFunc
Func _GDIPlus_PathAddArc($hPath, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathArc", "handle", $hPath, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddBezier($hPath, $nX1, $nY1, $nX2, $nY2, $nX3, $nY3, $nX4, $nY4)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathBezier", "handle", $hPath, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2, "float", $nX3, "float", $nY3, "float", $nX4, "float", $nY4)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddClosedCurve($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathClosedCurve", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddClosedCurve2($hPath, $aPoints, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathClosedCurve2", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve2($hPath, $aPoints, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve2", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve3($hPath, $aPoints, $iOffset, $iNumOfSegments, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve3", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "int", $iOffset, "int", $iNumOfSegments, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddEllipse($hPath, $nX, $nY, $nWidth, $nHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathEllipse", "handle", $hPath, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddLine($hPath, $nX1, $nY1, $nX2, $nY2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathLine", "handle", $hPath, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddLine2($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathLine2", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPath($hPath1, $hPath2, $bConnect = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathPath", "handle", $hPath1, "handle", $hPath2, "int", $bConnect)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPie($hPath, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathPie", "handle", $hPath, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPolygon($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathPolygon", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddRectangle($hPath, $nX, $nY, $nWidth, $nHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathRectangle", "handle", $hPath, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddString($hPath, $sString, $tLayout, $hFamily, $iStyle = 0, $fSize = 8.5, $hFormat = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathString", "handle", $hPath, "wstr", $sString, "int", -1,  "handle", $hFamily, "int", $iStyle, "float", $fSize, "struct*", $tLayout, "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushCreate($aPoints, $iWrapMode = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePathGradient", "struct*", $tPoints, "int", $iCount, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PathBrushCreateFromPath($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePathGradientFromPath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathBrushGetCenterPoint($hPathGradientBrush)
Local $tPointF = DllStructCreate("float;float")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientCenterPoint", "handle", $hPathGradientBrush, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aPointF[2]
$aPointF[0] = DllStructGetData($tPointF, 1)
$aPointF[1] = DllStructGetData($tPointF, 2)
Return $aPointF
EndFunc
Func _GDIPlus_PathBrushGetFocusScales($hPathGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientFocusScales", "handle", $hPathGradientBrush, "float*", 0, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aScales[2]
$aScales[0] = $aResult[2]
$aScales[1] = $aResult[3]
Return $aScales
EndFunc
Func _GDIPlus_PathBrushGetPointCount($hPathGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientPointCount", "handle", $hPathGradientBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathBrushGetRect($hPathGradientBrush)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientRect", "handle", $hPathGradientBrush, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_PathBrushGetWrapMode($hPathGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientWrapMode", "handle", $hPathGradientBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathBrushMultiplyTransform($hPathGradientBrush, $hMatrix, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMultiplyPathGradientTransform", "handle", $hPathGradientBrush, "handle", $hMatrix, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushResetTransform($hPathGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetPathGradientTransform", "handle", $hPathGradientBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetBlend($hPathGradientBrush, $aBlends)
Local $iCount = $aBlends[0][0]
Local $tFactors = DllStructCreate("float[" & $iCount & "]")
Local $tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tFactors, 1, $aBlends[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aBlends[$iI][1], $iI)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientBlend", "handle", $hPathGradientBrush, "struct*", $tFactors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetCenterColor($hPathGradientBrush, $iARGB)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientCenterColor", "handle", $hPathGradientBrush, "uint", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetCenterPoint($hPathGradientBrush, $nX, $nY)
Local $tPointF = DllStructCreate("float;float")
DllStructSetData($tPointF, 1, $nX)
DllStructSetData($tPointF, 2, $nY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientCenterPoint", "handle", $hPathGradientBrush, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetFocusScales($hPathGradientBrush, $fScaleX, $fScaleY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientFocusScales", "handle", $hPathGradientBrush, "float", $fScaleX, "float", $fScaleY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetGammaCorrection($hPathGradientBrush, $bUseGammaCorrection)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientGammaCorrection", "handle", $hPathGradientBrush, "int", $bUseGammaCorrection)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetLinearBlend($hPathGradientBrush, $fFocus, $fScale = 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientLinearBlend", "handle", $hPathGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetPresetBlend($hPathGradientBrush, $aInterpolations)
Local $iCount = $aInterpolations[0][0]
Local $tColors = DllStructCreate("uint[" & $iCount & "]")
Local $tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aInterpolations[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aInterpolations[$iI][1], $iI)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientPresetBlend", "handle", $hPathGradientBrush, "struct*", $tColors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSigmaBlend($hPathGradientBrush, $fFocus, $fScale = 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSigmaBlend", "handle", $hPathGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSurroundColor($hPathGradientBrush, $iARGB)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hPathGradientBrush, "uint*", $iARGB, "int*", 1)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSurroundColorsWithCount($hPathGradientBrush, $aColors)
Local $iCount = $aColors[0]
Local $iColors = _GDIPlus_PathBrushGetPointCount($hPathGradientBrush)
If $iColors < $iCount Then $iCount = $iColors
Local $tColors = DllStructCreate("uint[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aColors[$iI], $iI)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hPathGradientBrush, "struct*", $tColors, "int*", $iCount)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_PathBrushSetTransform($hPathGradientBrush, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientTransform", "handle", $hPathGradientBrush, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetWrapMode($hPathGradientBrush, $iWrapMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientWrapMode", "handle", $hPathGradientBrush, "int", $iWrapMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathClone($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipClonePath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathCloseFigure($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipClosePathFigure", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathCreate($iFillMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePath", "int", $iFillMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathCreate2($aPathData, $iFillMode = 0)
Local $iCount = $aPathData[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
Local $tTypes = DllStructCreate("byte[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPathData[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPathData[$iI][1], (($iI - 1) * 2) + 2)
DllStructSetData($tTypes, 1, $aPathData[$iI][2], $iI)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePath2", "struct*", $tPoints, "struct*", $tTypes, "int", $iCount, "int", $iFillMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_PathDispose($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathFlatten($hPath, $fFlatness = 0.25, $hMatrix = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFlattenPath", "handle", $hPath, "handle", $hMatrix, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathGetData($hPath)
Local $iCount = _GDIPlus_PathGetPointCount($hPath)
Local $tPathData = DllStructCreate("int Count; ptr Points; ptr Types;")
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
Local $tTypes = DllStructCreate("byte[" & $iCount & "]")
DllStructSetData($tPathData, "Count", $iCount)
DllStructSetData($tPathData, "Points", DllStructGetPtr($tPoints))
DllStructSetData($tPathData, "Types", DllStructGetPtr($tTypes))
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathData", "handle", $hPath, "struct*", $tPathData)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError($aResult[0], $aResult[0], -1)
Local $aData[$iCount + 1][3]
$aData[0][0] = $iCount
For $iI = 1 To $iCount
$aData[$iI][0] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 1)
$aData[$iI][1] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 2)
$aData[$iI][2] = DllStructGetData($tTypes, 1, $iI)
Next
Return $aData
EndFunc
Func _GDIPlus_PathGetFillMode($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathFillMode", "handle", $hPath, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathGetLastPoint($hPath)
Local $tPointF = DllStructCreate("float;float")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathLastPoint", "handle", $hPath, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aPointF[2]
$aPointF[0] = DllStructGetData($tPointF, 1)
$aPointF[1] = DllStructGetData($tPointF, 2)
Return $aPointF
EndFunc
Func _GDIPlus_PathGetPointCount($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPointCount", "handle", $hPath, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathGetPoints($hPath)
Local $iI, $iCount, $tPoints, $aPoints[1][1], $aResult
$iCount = _GDIPlus_PathGetPointCount($hPath)
If @error Then Return SetError(@error + 10, @extended, -1)
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
$aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathPoints", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aPoints[$iCount + 1][2]
$aPoints[0][0] = $iCount
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 2)
Next
Return $aPoints
EndFunc
Func _GDIPlus_PathGetWorldBounds($hPath, $hMatrix = 0, $hPen = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathWorldBounds", "handle", $hPath, "struct*", $tRECTF, "handle", $hMatrix, "handle", $hPen)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_PathIsOutlineVisiblePoint($hPath, $nX, $nY, $hPen = 0, $hGraphics = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipIsOutlineVisiblePathPoint", "handle", $hPath, "float", $nX, "float", $nY, "handle", $hPen, "handle", $hGraphics, "int*", 0)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return $aResult[6] <> 0
EndFunc
Func _GDIPlus_PathIsVisiblePoint($hPath, $nX, $nY, $hGraphics = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipIsVisiblePathPoint", "handle", $hPath, "float", $nX, "float", $nY, "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return $aResult[5] <> 0
EndFunc
Func _GDIPlus_PathIterCreate($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePathIter", "handle*", 0, "handle", $hPath)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_PathIterDispose($hPathIter)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePathIter", "handle", $hPathIter)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathIterGetSubpathCount($hPathIter)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPathIterGetSubpathCount", "handle", $hPathIter, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathIterNextMarkerPath($hPathIter, $hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPathIterNextMarkerPath", "handle", $hPathIter, "int*", 0, "handle", $hPath)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathIterNextSubpathPath($hPathIter, $hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPathIterNextSubpathPath", "handle", $hPathIter, "int*", 0, "handle", $hPath, "bool*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aReturn[2]
$aReturn[0] = $aResult[2]
$aReturn[1] = $aResult[4]
Return $aReturn
EndFunc
Func _GDIPlus_PathIterRewind($hPathIter)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPathIterRewind", "handle", $hPathIter)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathReset($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetPath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathReverse($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipReversePath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathSetFillMode($hPath, $iFillMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathFillMode", "handle", $hPath, "int", $iFillMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathSetMarker($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathMarker", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathStartFigure($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipStartPathFigure", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathTransform($hPath, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTransformPath", "handle", $hPath, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathWarp($hPath, $hMatrix, $aPoints, $nX, $nY, $nWidth, $nHeight, $iWarpMode = 0, $fFlatness = 0.25)
Local $iCount = $aPoints[0][0]
If $iCount <> 3 And $iCount <> 4 Then Return SetError(11, 0, False)
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipWarpPath", "handle", $hPath, "handle", $hMatrix, "struct*", $tPoints, "int", $iCount,  "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "int", $iWarpMode, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathWiden($hPath, $hPen, $hMatrix = 0, $fFlatness = 0.25)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipWidenPath", "handle", $hPath, "handle", $hPen, "handle", $hMatrix, "float", $fFlatness)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathWindingModeOutline($hPath, $hMatrix = 0, $fFlatness = 0.25)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipWindingModeOutline", "handle", $hPath, "handle", $hMatrix, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenCreate($iARGB = 0xFF000000, $nWidth = 1, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePen1", "dword", $iARGB, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PenCreate2($hBrush, $nWidth = 1, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePen2", "handle", $hBrush, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PenDispose($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePen", "handle", $hPen)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenGetAlignment($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenMode", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetColor($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenColor", "handle", $hPen, "dword*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetCustomEndCap($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenCustomEndCap", "handle", $hPen, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetDashCap($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenDashCap197819", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetDashStyle($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenDashStyle", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetEndCap($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenEndCap", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetMiterLimit($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenMiterLimit", "handle", $hPen, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetWidth($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenWidth", "handle", $hPen, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenResetTransform($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetPenTransform", "handle", $hPen)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenRotateTransform($hPen, $fAngle, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipRotatePenTransform", "handle", $hPen, "float", $fAngle, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenScaleTransform($hPen, $fScaleX, $fScaleY, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipScalePenTransform", "handle", $hPen, "float", $fScaleX, "float", $fScaleY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetAlignment($hPen, $iAlignment = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenMode", "handle", $hPen, "int", $iAlignment)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetColor($hPen, $iARGB)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenColor", "handle", $hPen, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetCompound($hPen, $aCompounds)
Local $iCount = $aCompounds[0]
Local $tCompounds = DllStructCreate("float[" & $iCount & "];")
For $i = 1 To $iCount
DllStructSetData($tCompounds, 1, $aCompounds[$i], $i)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenCompoundArray", "handle", $hPen, "struct*", $tCompounds, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetCustomEndCap($hPen, $hEndCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenCustomEndCap", "handle", $hPen, "handle", $hEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetDashCap($hPen, $iDash = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenDashCap197819", "handle", $hPen, "int", $iDash)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetDashStyle($hPen, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenDashStyle", "handle", $hPen, "int", $iStyle)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetEndCap($hPen, $iEndCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenEndCap", "handle", $hPen, "int", $iEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetLineCap($hPen, $iStartCap, $iEndCap, $iDashCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenLineCap197819", "handle", $hPen, "int", $iStartCap, "int", $iEndCap, "int", $iDashCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetLineJoin($hPen, $iLineJoin)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenLineJoin", "handle", $hPen, "int", $iLineJoin)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetMiterLimit($hPen, $fMiterLimit)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenMiterLimit", "handle", $hPen, "float", $fMiterLimit)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetStartCap($hPen, $iLineCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenStartCap", "handle", $hPen, "int", $iLineCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetTransform($hPen, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenTransform", "handle", $hPen, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetWidth($hPen, $fWidth)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenWidth", "handle", $hPen, "float", $fWidth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RectFCreate($nX = 0, $nY = 0, $nWidth = 0, $nHeight = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
DllStructSetData($tRECTF, "X", $nX)
DllStructSetData($tRECTF, "Y", $nY)
DllStructSetData($tRECTF, "Width", $nWidth)
DllStructSetData($tRECTF, "Height", $nHeight)
Return $tRECTF
EndFunc
Func _GDIPlus_RegionClone($hRegion)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneRegion", "handle", $hRegion, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_RegionCombinePath($hRegion, $hPath, $iCombineMode = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionPath", "handle", $hRegion, "handle", $hPath, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCombineRect($hRegion, $nX, $nY, $nWidth, $nHeight, $iCombineMode = 2)
Local $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nWidth, $nHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionRect", "handle", $hRegion, "struct*", $tRECTF, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCombineRegion($hRegionDst, $hRegionSrc, $iCombineMode = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionRegion", "handle", $hRegionDst, "handle", $hRegionSrc, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCreate()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateRegion", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_RegionCreateFromPath($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateRegionPath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_RegionCreateFromRect($nX, $nY, $nWidth, $nHeight)
Local $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nWidth, $nHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateRegionRect", "struct*", $tRECTF, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_RegionDispose($hRegion)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteRegion", "handle", $hRegion)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionGetBounds($hRegion, $hGraphics)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetRegionBounds", "handle", $hRegion, "handle", $hGraphics, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aBounds[4]
For $iI = 1 To 4
$aBounds[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aBounds
EndFunc
Func _GDIPlus_RegionGetHRgn($hRegion, $hGraphics = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetRegionHRgn", "handle", $hRegion, "handle", $hGraphics, "handle*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return $aResult[3]
EndFunc
Func _GDIPlus_RegionSetEmpty($hRegion)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetEmpty", "handle", $hRegion)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionSetInfinite($hRegion)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetInfinite", "handle", $hRegion)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionTransform($hRegion, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTransformRegion", "handle", $hRegion, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionTranslate($hRegion, $nDX, $nDY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTranslateRegion", "handle", $hRegion, "float", $nDX, "float", $nDY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Shutdown()
If $__g_hGDIPDll = 0 Then Return SetError(-1, -1, False)
$__g_iGDIPRef -= 1
If $__g_iGDIPRef = 0 Then
DllCall($__g_hGDIPDll, "none", "GdiplusShutdown", "ulong_ptr", $__g_iGDIPToken)
DllClose($__g_hGDIPDll)
$__g_hGDIPDll = 0
EndIf
Return True
EndFunc
Func _GDIPlus_Startup($sGDIPDLL = Default, $bRetDllHandle = False)
$__g_iGDIPRef += 1
If $__g_iGDIPRef > 1 Then Return True
If $sGDIPDLL = Default Then $sGDIPDLL = "gdiplus.dll"
$__g_hGDIPDll = DllOpen($sGDIPDLL)
If $__g_hGDIPDll = -1 Then
$__g_iGDIPRef = 0
Return SetError(1, 2, False)
EndIf
Local $sVer = FileGetVersion($sGDIPDLL)
$sVer = StringSplit($sVer, ".")
If $sVer[1] > 5 Then $__g_bGDIP_V1_0 = False
Local $tInput = DllStructCreate($tagGDIPSTARTUPINPUT)
Local $tToken = DllStructCreate("ulong_ptr Data")
DllStructSetData($tInput, "Version", 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdiplusStartup", "struct*", $tToken, "struct*", $tInput, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
$__g_iGDIPToken = DllStructGetData($tToken, "Data")
If $bRetDllHandle Then Return $__g_hGDIPDll
Return SetExtended($sVer[1], True)
EndFunc
Func _GDIPlus_StringFormatCreate($iFormat = 0, $iLangID = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateStringFormat", "int", $iFormat, "word", $iLangID, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_StringFormatDispose($hFormat)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteStringFormat", "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatGetMeasurableCharacterRangeCount($hStringFormat)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetStringFormatMeasurableCharacterRangeCount", "handle", $hStringFormat, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_StringFormatSetAlign($hStringFormat, $iFlag)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatAlign", "handle", $hStringFormat, "int", $iFlag)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatSetLineAlign($hStringFormat, $iStringAlign)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatLineAlign", "handle", $hStringFormat, "int", $iStringAlign)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatSetMeasurableCharacterRanges($hStringFormat, $aRanges)
Local $iCount = $aRanges[0][0]
Local $tCharacterRanges = DllStructCreate("int[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tCharacterRanges, 1, $aRanges[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tCharacterRanges, 1, $aRanges[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatMeasurableCharacterRanges", "handle", $hStringFormat, "int", $iCount, "struct*", $tCharacterRanges)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_TextureCreate($hImage, $iWrapMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateTexture", "handle", $hImage, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_TextureCreate2($hImage, $nX, $nY, $nWidth, $nHeight, $iWrapMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateTexture2", "handle", $hImage, "int", $iWrapMode, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_TextureCreateIA($hImage, $nX, $nY, $nWidth, $nHeight, $pImageAttributes = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateTextureIA", "handle", $hImage, "handle", $pImageAttributes, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func __GDIPlus_BrushDefCreate(ByRef $hBrush)
If $hBrush = 0 Then
$__g_hGDIPBrush = _GDIPlus_BrushCreateSolid()
$hBrush = $__g_hGDIPBrush
EndIf
EndFunc
Func __GDIPlus_BrushDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPBrush <> 0 Then
_GDIPlus_BrushDispose($__g_hGDIPBrush)
$__g_hGDIPBrush = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func __GDIPlus_ExtractFileExt($sFileName, $bNoDot = True)
Local $iIndex = __GDIPlus_LastDelimiter(".\:", $sFileName)
If ($iIndex > 0) And (StringMid($sFileName, $iIndex, 1) = '.') Then
If $bNoDot Then
Return StringMid($sFileName, $iIndex + 1)
Else
Return StringMid($sFileName, $iIndex)
EndIf
Else
Return ""
EndIf
EndFunc
Func __GDIPlus_LastDelimiter($sDelimiters, $sString)
Local $sDelimiter, $iN
For $iI = 1 To StringLen($sDelimiters)
$sDelimiter = StringMid($sDelimiters, $iI, 1)
$iN = StringInStr($sString, $sDelimiter, $STR_NOCASESENSEBASIC, -1)
If $iN > 0 Then Return $iN
Next
EndFunc
Func __GDIPlus_PenDefCreate(ByRef $hPen)
If $hPen = 0 Then
$__g_hGDIPPen = _GDIPlus_PenCreate()
$hPen = $__g_hGDIPPen
EndIf
EndFunc
Func __GDIPlus_PenDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPPen <> 0 Then
_GDIPlus_PenDispose($__g_hGDIPPen)
$__g_hGDIPPen = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func _GDIPlus_BitmapApplyEffect($hBitmap, $hEffect, $tRECT = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
If Not IsPtr($hEffect) Then Return SetError(10, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapApplyEffect", "handle", $hBitmap, "handle", $hEffect, "struct*", $tRECT, "int", 0, "ptr*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapApplyEffectEx($hBitmap, $hEffect, $iX = 0, $iY = 0, $iW = 0, $iH = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $tRECT = 0
If BitOR($iX, $iY, $iW, $iH) Then
$tRECT = DllStructCreate("int Left; int Top; int Right; int Bottom;")
DllStructSetData($tRECT, "Right", $iW + DllStructSetData($tRECT, "Left", $iX))
DllStructSetData($tRECT, "Bottom", $iH + DllStructSetData($tRECT, "Top", $iY))
EndIf
Local $iStatus = _GDIPlus_BitmapApplyEffect($hBitmap, $hEffect, $tRECT)
If Not $iStatus Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _GDIPlus_BitmapConvertFormat($hBitmap, $iPixelFormat, $iDitherType, $iPaletteType, $tPalette, $fAlphaThresholdPercent = 0.0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapConvertFormat", "handle", $hBitmap, "uint", $iPixelFormat, "uint", $iDitherType, "uint", $iPaletteType, "struct*", $tPalette, "float", $fAlphaThresholdPercent)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCreateApplyEffect($hBitmap, $hEffect, $tRECT = Null, $tOutRECT = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapCreateApplyEffect", "handle*", $hBitmap, "int", 1, "handle", $hEffect, "struct*", $tRECT, "struct*", $tOutRECT, "handle*", 0, "int", 0, "ptr*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_BitmapCreateApplyEffectEx($hBitmap, $hEffect, $iX = 0, $iY = 0, $iW = 0, $iH = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tRECT = 0
If BitOR($iX, $iY, $iW, $iH) Then
$tRECT = DllStructCreate("int Left; int Top; int Right; int Bottom;")
DllStructSetData($tRECT, "Right", $iW + DllStructSetData($tRECT, "Left", $iX))
DllStructSetData($tRECT, "Bottom", $iH + DllStructSetData($tRECT, "Top", $iY))
EndIf
Local $hBitmap_FX = _GDIPlus_BitmapCreateApplyEffect($hBitmap, $hEffect, $tRECT, Null)
Return SetError(@error, @extended, $hBitmap_FX)
EndFunc
Func _GDIPlus_BitmapGetHistogram($hBitmap, $iHistogramFormat, $iHistogramSize, $tChannel_0, $tChannel_1 = 0, $tChannel_2 = 0, $tChannel_3 = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetHistogram", "handle", $hBitmap, "uint", $iHistogramFormat, "uint", $iHistogramSize, "struct*", $tChannel_0, "struct*", $tChannel_1, "struct*", $tChannel_2, "struct*", $tChannel_3)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapGetHistogramEx($hBitmap)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $iSize = _GDIPlus_BitmapGetHistogramSize($GDIP_HistogramFormatARGB)
Local $tHistogram = DllStructCreate("int Size; uint Red[" & $iSize & "]; uint MaxRed; uint Green[" & $iSize & "]; uint MaxGreen; uint Blue[" & $iSize & "]; uint MaxBlue; uint Alpha[" & $iSize & "]; uint MaxAlpha; uint Grey[" & $iSize & "]; uint MaxGrey;")
DllStructSetData($tHistogram, "Size", $iSize)
Local $iStatus = _GDIPlus_BitmapGetHistogram($hBitmap, $GDIP_HistogramFormatARGB, $iSize, DllStructGetPtr($tHistogram, "Alpha"), DllStructGetPtr($tHistogram, "Red"), DllStructGetPtr($tHistogram, "Green"), DllStructGetPtr($tHistogram, "Blue"))
If Not $iStatus Then Return SetError(@error, @extended, 0)
$iStatus = _GDIPlus_BitmapGetHistogram($hBitmap, $GDIP_HistogramFormatGray, $iSize, DllStructGetPtr($tHistogram, "Grey"))
If Not $iStatus Then Return SetError(@error + 10, @extended, 0)
Local $iMaxRed = 0, $iMaxGreen = 0, $iMaxBlue = 0, $iMaxAlpha = 0, $iMaxGrey = 0
For $i = 1 To $iSize
If DllStructGetData($tHistogram, "Red", $i) > $iMaxRed Then $iMaxRed = DllStructGetData($tHistogram, "Red", $i)
If DllStructGetData($tHistogram, "Green", $i) > $iMaxGreen Then $iMaxGreen = DllStructGetData($tHistogram, "Green", $i)
If DllStructGetData($tHistogram, "Blue", $i) > $iMaxBlue Then $iMaxBlue = DllStructGetData($tHistogram, "Blue", $i)
If DllStructGetData($tHistogram, "Alpha", $i) > $iMaxAlpha Then $iMaxAlpha = DllStructGetData($tHistogram, "Alpha", $i)
If DllStructGetData($tHistogram, "Grey", $i) > $iMaxGrey Then $iMaxGrey = DllStructGetData($tHistogram, "Grey", $i)
Next
DllStructSetData($tHistogram, "MaxRed", $iMaxRed)
DllStructSetData($tHistogram, "MaxGreen", $iMaxGreen)
DllStructSetData($tHistogram, "MaxBlue", $iMaxBlue)
DllStructSetData($tHistogram, "MaxAlpha", $iMaxAlpha)
DllStructSetData($tHistogram, "MaxGrey", $iMaxGrey)
Return $tHistogram
EndFunc
Func _GDIPlus_BitmapGetHistogramSize($iFormat)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetHistogramSize", "uint", $iFormat, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_DrawImageFX($hGraphics, $hImage, $hEffect, $tRECTF = 0, $hMatrix = 0, $hImgAttributes = 0, $iUnit = 2)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageFX", "handle", $hGraphics, "handle", $hImage, "struct*", $tRECTF, "handle", $hMatrix, "handle", $hEffect, "handle", $hImgAttributes, "uint", $iUnit)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_DrawImageFXEx($hGraphics, $hImage, $hEffect, $nX = 0, $nY = 0, $nW = 0, $nH = 0, $hMatrix = 0, $hImgAttributes = 0, $iUnit = 2)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $tRECTF = 0
If BitOR($nX, $nY, $nW, $nH) Then $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nW, $nH)
Local $iStatus = _GDIPlus_DrawImageFX($hGraphics, $hImage, $hEffect, $tRECTF, $hMatrix, $hImgAttributes, $iUnit)
Return SetError(@error, @extended, $iStatus)
EndFunc
Func _GDIPlus_EffectCreate($sEffectGUID)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tGUID = _WinAPI_GUIDFromString($sEffectGUID)
Local $aResult = 0
If @AutoItX64 Then
$aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateEffect", "struct*", $tGUID, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndIf
Local $tElem = DllStructCreate("uint64[2];", DllStructGetPtr($tGUID))
$aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateEffect", "uint64", DllStructGetData($tElem, 1, 1), "uint64", DllStructGetData($tElem, 1, 2), "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_EffectCreateBlur($fRadius = 10.0, $bExpandEdge = False)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Blur)
DllStructSetData($tEffectParameters, "Radius", $fRadius)
DllStructSetData($tEffectParameters, "ExpandEdge", $bExpandEdge)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_BlurEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateBrightnessContrast($iBrightnessLevel = 0, $iContrastLevel = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_BrightnessContrast)
DllStructSetData($tEffectParameters, "BrightnessLevel", $iBrightnessLevel)
DllStructSetData($tEffectParameters, "ContrastLevel", $iContrastLevel)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_BrightnessContrastEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorBalance($iCyanRed = 0, $iMagentaGreen = 0, $iYellowBlue = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorBalance)
DllStructSetData($tEffectParameters, "CyanRed", $iCyanRed)
DllStructSetData($tEffectParameters, "MagentaGreen", $iMagentaGreen)
DllStructSetData($tEffectParameters, "YellowBlue", $iYellowBlue)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorBalanceEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorCurve($iAdjustment, $iChannel, $iAdjustValue)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorCurve)
DllStructSetData($tEffectParameters, "Adjustment", $iAdjustment)
DllStructSetData($tEffectParameters, "Channel", $iChannel)
DllStructSetData($tEffectParameters, "AdjustValue", $iAdjustValue)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorCurveEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorLUT($aColorLUT)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorLUT)
For $iI = 0 To 255
DllStructSetData($tEffectParameters, "LutA", $aColorLUT[$iI][0], $iI + 1)
DllStructSetData($tEffectParameters, "LutR", $aColorLUT[$iI][1], $iI + 1)
DllStructSetData($tEffectParameters, "LutG", $aColorLUT[$iI][2], $iI + 1)
DllStructSetData($tEffectParameters, "LutB", $aColorLUT[$iI][3], $iI + 1)
Next
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorLUTEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorMatrix($tColorMatrix)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorMatrixEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tColorMatrix)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateHueSaturationLightness($iHueLevel = 0, $iSaturationLevel = 0, $iLightnessLevel = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_HueSaturationLightness)
DllStructSetData($tEffectParameters, "HueLevel", $iHueLevel)
DllStructSetData($tEffectParameters, "SaturationLevel", $iSaturationLevel)
DllStructSetData($tEffectParameters, "LightnessLevel", $iLightnessLevel)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_HueSaturationLightnessEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateLevels($iHighlight = 100, $iMidtone = 0, $iShadow = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Levels)
DllStructSetData($tEffectParameters, "Highlight", $iHighlight)
DllStructSetData($tEffectParameters, "Midtone", $iMidtone)
DllStructSetData($tEffectParameters, "Shadow", $iShadow)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_LevelsEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateRedEyeCorrection($aAreas)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $iCount = $aAreas[0][0]
Local $tAreas = DllStructCreate("long[" & $iCount * 4 & "]")
For $iI = 1 To $iCount
DllStructSetData($tAreas, 1, DllStructSetData($tAreas, 1, $aAreas[$iI][0], (($iI - 1) * 4) + 1) + $aAreas[$iI][2], (($iI - 1) * 4) + 3)
DllStructSetData($tAreas, 1, DllStructSetData($tAreas, 1, $aAreas[$iI][1], (($iI - 1) * 4) + 2) + $aAreas[$iI][3], (($iI - 1) * 4) + 4)
Next
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_RedEyeCorrection)
DllStructSetData($tEffectParameters, "NumberOfAreas", $iCount)
DllStructSetData($tEffectParameters, "Areas", DllStructGetPtr($tAreas))
Local $hEffect = _GDIPlus_EffectCreate($GDIP_RedEyeCorrectionEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters, (DllStructGetSize($tAreas) + DllStructGetSize($tEffectParameters)) / DllStructGetSize($tEffectParameters))
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateSharpen($fRadius = 10.0, $fAmount = 50.0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Sharpen)
DllStructSetData($tEffectParameters, "Radius", $fRadius)
DllStructSetData($tEffectParameters, "Amount", $fAmount)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_SharpenEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateTint($iHue = 0, $iAmount = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Tint)
DllStructSetData($tEffectParameters, "Hue", $iHue)
DllStructSetData($tEffectParameters, "Amount", $iAmount)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_TintEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectDispose($hEffect)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteEffect", "handle", $hEffect)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_EffectGetParameters($hEffect, $tEffectParameters)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
If DllStructGetSize($tEffectParameters) < __GDIPlus_EffectGetParameterSize($hEffect) Then Return SetError(2, 5, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEffectParameters", "handle", $hEffect, "uint*", DllStructGetSize($tEffectParameters), "struct*", $tEffectParameters)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func __GDIPlus_EffectGetParameterSize($hEffect)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, -1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEffectParameterSize", "handle", $hEffect, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_EffectSetParameters($hEffect, $tEffectParameters, $iSizeAdjust = 1)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $iSize = __GDIPlus_EffectGetParameterSize($hEffect)
If @error Then Return SetError(@error, @extended, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetEffectParameters", "handle", $hEffect, "struct*", $tEffectParameters, "uint", $iSize * $iSizeAdjust)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PaletteInitialize($iEntries, $iPaletteType = $GDIP_PaletteTypeOptimal, $iOptimalColors = 0, $bUseTransparentColor = True, $hBitmap = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
If $iOptimalColors > 0 Then $iPaletteType = $GDIP_PaletteTypeOptimal
Local $tPalette = DllStructCreate("uint Flags; uint Count; uint ARGB[" & $iEntries & "];")
DllStructSetData($tPalette, "Flags", $iPaletteType)
DllStructSetData($tPalette, "Count", $iEntries)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipInitializePalette", "struct*", $tPalette, "uint", $iPaletteType, "uint", $iOptimalColors, "bool", $bUseTransparentColor, "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tPalette
EndFunc
Global Const $ACS_CENTER = 1
Global Const $ACS_TRANSPARENT = 2
Global Const $ACS_AUTOPLAY = 4
Global Const $ACS_TIMER = 8
Global Const $ACS_NONTRANSPARENT = 16
Global Const $GUI_SS_DEFAULT_AVI = $ACS_TRANSPARENT
Global Const $__AVICONSTANT_WM_USER = 0x400
Global Const $ACM_OPENA = $__AVICONSTANT_WM_USER + 100
Global Const $ACM_PLAY = $__AVICONSTANT_WM_USER + 101
Global Const $ACM_STOP = $__AVICONSTANT_WM_USER + 102
Global Const $ACM_ISPLAYING = $__AVICONSTANT_WM_USER + 104
Global Const $ACM_OPENW = $__AVICONSTANT_WM_USER + 103
Global Const $ACN_START = 0x00000001
Global Const $ACN_STOP = 0x00000002
Global Const $CB_ERR = -1
Global Const $CB_ERRATTRIBUTE = -3
Global Const $CB_ERRREQUIRED = -4
Global Const $CB_ERRSPACE = -2
Global Const $CB_OKAY = 0
Global Const $STATE_SYSTEM_INVISIBLE = 0x8000
Global Const $STATE_SYSTEM_PRESSED = 0x8
Global Const $CBS_AUTOHSCROLL = 0x40
Global Const $CBS_DISABLENOSCROLL = 0x800
Global Const $CBS_DROPDOWN = 0x2
Global Const $CBS_DROPDOWNLIST = 0x3
Global Const $CBS_HASSTRINGS = 0x200
Global Const $CBS_LOWERCASE = 0x4000
Global Const $CBS_NOINTEGRALHEIGHT = 0x400
Global Const $CBS_OEMCONVERT = 0x80
Global Const $CBS_OWNERDRAWFIXED = 0x10
Global Const $CBS_OWNERDRAWVARIABLE = 0x20
Global Const $CBS_SIMPLE = 0x1
Global Const $CBS_SORT = 0x100
Global Const $CBS_UPPERCASE = 0x2000
Global Const $CBM_FIRST = 0x1700
Global Const $CB_ADDSTRING = 0x143
Global Const $CB_DELETESTRING = 0x144
Global Const $CB_DIR = 0x145
Global Const $CB_FINDSTRING = 0x14C
Global Const $CB_FINDSTRINGEXACT = 0x158
Global Const $CB_GETCOMBOBOXINFO = 0x164
Global Const $CB_GETCOUNT = 0x146
Global Const $CB_GETCUEBANNER = ($CBM_FIRST + 4)
Global Const $CB_GETCURSEL = 0x147
Global Const $CB_GETDROPPEDCONTROLRECT = 0x152
Global Const $CB_GETDROPPEDSTATE = 0x157
Global Const $CB_GETDROPPEDWIDTH = 0X15f
Global Const $CB_GETEDITSEL = 0x140
Global Const $CB_GETEXTENDEDUI = 0x156
Global Const $CB_GETHORIZONTALEXTENT = 0x15d
Global Const $CB_GETITEMDATA = 0x150
Global Const $CB_GETITEMHEIGHT = 0x154
Global Const $CB_GETLBTEXT = 0x148
Global Const $CB_GETLBTEXTLEN = 0x149
Global Const $CB_GETLOCALE = 0x15A
Global Const $CB_GETMINVISIBLE = 0x1702
Global Const $CB_GETTOPINDEX = 0x15b
Global Const $CB_INITSTORAGE = 0x161
Global Const $CB_LIMITTEXT = 0x141
Global Const $CB_RESETCONTENT = 0x14B
Global Const $CB_INSERTSTRING = 0x14A
Global Const $CB_SELECTSTRING = 0x14D
Global Const $CB_SETCUEBANNER = ($CBM_FIRST + 3)
Global Const $CB_SETCURSEL = 0x14E
Global Const $CB_SETDROPPEDWIDTH = 0x160
Global Const $CB_SETEDITSEL = 0x142
Global Const $CB_SETEXTENDEDUI = 0x155
Global Const $CB_SETHORIZONTALEXTENT = 0x15e
Global Const $CB_SETITEMDATA = 0x151
Global Const $CB_SETITEMHEIGHT = 0x153
Global Const $CB_SETLOCALE = 0x159
Global Const $CB_SETMINVISIBLE = 0x1701
Global Const $CB_SETTOPINDEX = 0x15c
Global Const $CB_SHOWDROPDOWN = 0x14F
Global Const $CBN_CLOSEUP = 8
Global Const $CBN_DBLCLK = 2
Global Const $CBN_DROPDOWN = 7
Global Const $CBN_EDITCHANGE = 5
Global Const $CBN_EDITUPDATE = 6
Global Const $CBN_ERRSPACE = (-1)
Global Const $CBN_KILLFOCUS = 4
Global Const $CBN_SELCHANGE = 1
Global Const $CBN_SELENDCANCEL = 10
Global Const $CBN_SELENDOK = 9
Global Const $CBN_SETFOCUS = 3
Global Const $CBES_EX_CASESENSITIVE = 0x10
Global Const $CBES_EX_NOEDITIMAGE = 0x1
Global Const $CBES_EX_NOEDITIMAGEINDENT = 0x2
Global Const $CBES_EX_NOSIZELIMIT = 0x8
Global Const $__COMBOBOXCONSTANT_WM_USER = 0X400
Global Const $CBEM_DELETEITEM = $CB_DELETESTRING
Global Const $CBEM_GETCOMBOCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 6)
Global Const $CBEM_GETEDITCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 7)
Global Const $CBEM_GETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
Global Const $CBEM_GETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
Global Const $CBEM_GETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 3)
Global Const $CBEM_GETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 4)
Global Const $CBEM_GETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 13)
Global Const $CBEM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $CBEM_HASEDITCHANGED = ($__COMBOBOXCONSTANT_WM_USER + 10)
Global Const $CBEM_INSERTITEMA = ($__COMBOBOXCONSTANT_WM_USER + 1)
Global Const $CBEM_INSERTITEMW = ($__COMBOBOXCONSTANT_WM_USER + 11)
Global Const $CBEM_SETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 8)
Global Const $CBEM_SETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 14)
Global Const $CBEM_SETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 2)
Global Const $CBEM_SETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 5)
Global Const $CBEM_SETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 12)
Global Const $CBEM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $CBEM_SETWINDOWTHEME = 0x2000 + 11
Global Const $CBEN_FIRST = (-800)
Global Const $CBEN_LAST = (-830)
Global Const $CBEN_BEGINEDIT = ($CBEN_FIRST - 4)
Global Const $CBEN_DELETEITEM = ($CBEN_FIRST - 2)
Global Const $CBEN_DRAGBEGINA = ($CBEN_FIRST - 8)
Global Const $CBEN_DRAGBEGINW = ($CBEN_FIRST - 9)
Global Const $CBEN_ENDEDITA = ($CBEN_FIRST - 5)
Global Const $CBEN_ENDEDITW = ($CBEN_FIRST - 6)
Global Const $CBEN_GETDISPINFO = ($CBEN_FIRST - 0)
Global Const $CBEN_GETDISPINFOA = ($CBEN_FIRST - 0)
Global Const $CBEN_GETDISPINFOW = ($CBEN_FIRST - 7)
Global Const $CBEN_INSERTITEM = ($CBEN_FIRST - 1)
Global Const $CBEIF_DI_SETITEM = 0x10000000
Global Const $CBEIF_IMAGE = 0x2
Global Const $CBEIF_INDENT = 0x10
Global Const $CBEIF_LPARAM = 0x20
Global Const $CBEIF_OVERLAY = 0x8
Global Const $CBEIF_SELECTEDIMAGE = 0x4
Global Const $CBEIF_TEXT = 0x1
Global Const $GUI_SS_DEFAULT_COMBO = 0x00200042
Global Const $GUI_EVENT_SINGLE = 0
Global Const $GUI_EVENT_ARRAY = 1
Global Const $GUI_EVENT_NONE = 0
Global Const $GUI_EVENT_CLOSE = -3
Global Const $GUI_EVENT_MINIMIZE = -4
Global Const $GUI_EVENT_RESTORE = -5
Global Const $GUI_EVENT_MAXIMIZE = -6
Global Const $GUI_EVENT_PRIMARYDOWN = -7
Global Const $GUI_EVENT_PRIMARYUP = -8
Global Const $GUI_EVENT_SECONDARYDOWN = -9
Global Const $GUI_EVENT_SECONDARYUP = -10
Global Const $GUI_EVENT_MOUSEMOVE = -11
Global Const $GUI_EVENT_RESIZED = -12
Global Const $GUI_EVENT_DROPPED = -13
Global Const $GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $GUI_AVISTOP = 0
Global Const $GUI_AVISTART = 1
Global Const $GUI_AVICLOSE = 2
Global Const $GUI_CHECKED = 1
Global Const $GUI_INDETERMINATE = 2
Global Const $GUI_UNCHECKED = 4
Global Const $GUI_DROPACCEPTED = 8
Global Const $GUI_NODROPACCEPTED = 4096
Global Const $GUI_ACCEPTFILES = $GUI_DROPACCEPTED
Global Const $GUI_SHOW = 16
Global Const $GUI_HIDE = 32
Global Const $GUI_ENABLE = 64
Global Const $GUI_DISABLE = 128
Global Const $GUI_FOCUS = 256
Global Const $GUI_NOFOCUS = 8192
Global Const $GUI_DEFBUTTON = 512
Global Const $GUI_EXPAND = 1024
Global Const $GUI_ONTOP = 2048
Global Const $GUI_FONTNORMAL = 0
Global Const $GUI_FONTITALIC = 2
Global Const $GUI_FONTUNDER = 4
Global Const $GUI_FONTSTRIKE = 8
Global Const $GUI_DOCKAUTO = 0x0001
Global Const $GUI_DOCKLEFT = 0x0002
Global Const $GUI_DOCKRIGHT = 0x0004
Global Const $GUI_DOCKHCENTER = 0x0008
Global Const $GUI_DOCKTOP = 0x0020
Global Const $GUI_DOCKBOTTOM = 0x0040
Global Const $GUI_DOCKVCENTER = 0x0080
Global Const $GUI_DOCKWIDTH = 0x0100
Global Const $GUI_DOCKHEIGHT = 0x0200
Global Const $GUI_DOCKSIZE = 0x0300
Global Const $GUI_DOCKMENUBAR = 0x0220
Global Const $GUI_DOCKSTATEBAR = 0x0240
Global Const $GUI_DOCKALL = 0x0322
Global Const $GUI_DOCKBORDERS = 0x0066
Global Const $GUI_GR_CLOSE = 1
Global Const $GUI_GR_LINE = 2
Global Const $GUI_GR_BEZIER = 4
Global Const $GUI_GR_MOVE = 6
Global Const $GUI_GR_COLOR = 8
Global Const $GUI_GR_RECT = 10
Global Const $GUI_GR_ELLIPSE = 12
Global Const $GUI_GR_PIE = 14
Global Const $GUI_GR_DOT = 16
Global Const $GUI_GR_PIXEL = 18
Global Const $GUI_GR_HINT = 20
Global Const $GUI_GR_REFRESH = 22
Global Const $GUI_GR_PENSIZE = 24
Global Const $GUI_GR_NOBKCOLOR = -2
Global Const $GUI_BKCOLOR_DEFAULT = -1
Global Const $GUI_BKCOLOR_TRANSPARENT = -2
Global Const $GUI_BKCOLOR_LV_ALTERNATE = 0xFE000000
Global Const $GUI_READ_DEFAULT = 0
Global Const $GUI_READ_EXTENDED = 1
Global Const $GUI_CURSOR_NOOVERRIDE = 0
Global Const $GUI_CURSOR_OVERRIDE = 1
Global Const $GUI_WS_EX_PARENTDRAG = 0x00100000
Global Const $LBS_NOTIFY = 0x00000001
Global Const $LBS_SORT = 0x00000002
Global Const $LBS_NOREDRAW = 0x00000004
Global Const $LBS_MULTIPLESEL = 0x00000008
Global Const $LBS_OWNERDRAWFIXED = 0x00000010
Global Const $LBS_OWNERDRAWVARIABLE = 0x00000020
Global Const $LBS_HASSTRINGS = 0x00000040
Global Const $LBS_USETABSTOPS = 0x00000080
Global Const $LBS_NOINTEGRALHEIGHT = 0x00000100
Global Const $LBS_MULTICOLUMN = 0x00000200
Global Const $LBS_WANTKEYBOARDINPUT = 0x00000400
Global Const $LBS_EXTENDEDSEL = 0x00000800
Global Const $LBS_DISABLENOSCROLL = 0x00001000
Global Const $LBS_NODATA = 0x00002000
Global Const $LBS_NOSEL = 0x00004000
Global Const $LBS_COMBOBOX = 0x00008000
Global Const $LBS_STANDARD = 0x00000003
Global Const $GUI_SS_DEFAULT_LIST = 0x00a00003
Global Const $LB_ERR = -1
Global Const $LB_ERRATTRIBUTE = -3
Global Const $LB_ERRREQUIRED = -4
Global Const $LB_ERRSPACE = -2
Global Const $LB_ADDSTRING = 0x0180
Global Const $LB_INSERTSTRING = 0x0181
Global Const $LB_DELETESTRING = 0x0182
Global Const $LB_SELITEMRANGEEX = 0x0183
Global Const $LB_RESETCONTENT = 0x0184
Global Const $LB_SETSEL = 0x0185
Global Const $LB_SETCURSEL = 0x0186
Global Const $LB_GETSEL = 0x0187
Global Const $LB_GETCURSEL = 0x0188
Global Const $LB_GETTEXT = 0x0189
Global Const $LB_GETTEXTLEN = 0x018A
Global Const $LB_GETCOUNT = 0x018B
Global Const $LB_SELECTSTRING = 0x018C
Global Const $LB_DIR = 0x018D
Global Const $LB_GETTOPINDEX = 0x018E
Global Const $LB_FINDSTRING = 0x018F
Global Const $LB_GETSELCOUNT = 0x0190
Global Const $LB_GETSELITEMS = 0x0191
Global Const $LB_SETTABSTOPS = 0x0192
Global Const $LB_GETHORIZONTALEXTENT = 0x0193
Global Const $LB_SETHORIZONTALEXTENT = 0x0194
Global Const $LB_SETCOLUMNWIDTH = 0x0195
Global Const $LB_ADDFILE = 0x0196
Global Const $LB_SETTOPINDEX = 0x0197
Global Const $LB_GETITEMRECT = 0x0198
Global Const $LB_GETITEMDATA = 0x0199
Global Const $LB_SETITEMDATA = 0x019A
Global Const $LB_SELITEMRANGE = 0x019B
Global Const $LB_SETANCHORINDEX = 0x019C
Global Const $LB_GETANCHORINDEX = 0x019D
Global Const $LB_SETCARETINDEX = 0x019E
Global Const $LB_GETCARETINDEX = 0x019F
Global Const $LB_SETITEMHEIGHT = 0x01A0
Global Const $LB_GETITEMHEIGHT = 0x01A1
Global Const $LB_FINDSTRINGEXACT = 0x01A2
Global Const $LB_SETLOCALE = 0x01A5
Global Const $LB_GETLOCALE = 0x01A6
Global Const $LB_SETCOUNT = 0x01A7
Global Const $LB_INITSTORAGE = 0x01A8
Global Const $LB_ITEMFROMPOINT = 0x01A9
Global Const $LB_MULTIPLEADDSTRING = 0x01B1
Global Const $LB_GETLISTBOXINFO = 0x01B2
Global Const $LBN_ERRSPACE = 0xFFFFFFFE
Global Const $LBN_SELCHANGE = 0x00000001
Global Const $LBN_DBLCLK = 0x00000002
Global Const $LBN_SELCANCEL = 0x00000003
Global Const $LBN_SETFOCUS = 0x00000004
Global Const $LBN_KILLFOCUS = 0x00000005
Global Const $LVGS_NORMAL = 0x00000000
Global Const $LVGS_COLLAPSED = 0x00000001
Global Const $LVGS_HIDDEN = 0x00000002
Global Const $LVGS_NOHEADER = 0x00000004
Global Const $LVGS_COLLAPSIBLE = 0x00000008
Global Const $LVGS_FOCUSED = 0x00000010
Global Const $LVGS_SELECTED = 0x00000020
Global Const $LVGS_SUBSETED = 0x00000040
Global Const $LVGS_SUBSETLINKFOCUSED = 0x00000080
Global Const $LVGGR_GROUP = 0
Global Const $LVGGR_HEADER = 1
Global Const $LVGGR_LABEL = 2
Global Const $LVGGR_SUBSETLINK = 3
Global Const $LV_ERR = -1
Global Const $LVBKIF_SOURCE_NONE = 0x00000000
Global Const $LVBKIF_SOURCE_HBITMAP = 0x00000001
Global Const $LVBKIF_SOURCE_URL = 0x00000002
Global Const $LVBKIF_SOURCE_MASK = 0x00000003
Global Const $LVBKIF_STYLE_NORMAL = 0x00000000
Global Const $LVBKIF_STYLE_TILE = 0x00000010
Global Const $LVBKIF_STYLE_MASK = 0x00000010
Global Const $LVBKIF_FLAG_TILEOFFSET = 0x00000100
Global Const $LVBKIF_TYPE_WATERMARK = 0x10000000
Global Const $LV_VIEW_DETAILS = 0x0001
Global Const $LV_VIEW_ICON = 0x0000
Global Const $LV_VIEW_LIST = 0x0003
Global Const $LV_VIEW_SMALLICON = 0x0002
Global Const $LV_VIEW_TILE = 0x0004
Global Const $LVA_ALIGNLEFT = 0x0001
Global Const $LVA_ALIGNTOP = 0x0002
Global Const $LVA_DEFAULT = 0x0000
Global Const $LVA_SNAPTOGRID = 0x0005
Global Const $LVCDI_ITEM = 0x00000000
Global Const $LVCDI_GROUP = 0x00000001
Global Const $LVCF_ALLDATA = 0X0000003F
Global Const $LVCF_FMT = 0x0001
Global Const $LVCF_IMAGE = 0x0010
Global Const $LVCFMT_JUSTIFYMASK = 0x0003
Global Const $LVCF_TEXT = 0x0004
Global Const $LVCF_WIDTH = 0x0002
Global Const $LVCFMT_BITMAP_ON_RIGHT = 0x1000
Global Const $LVCFMT_CENTER = 0x0002
Global Const $LVCFMT_COL_HAS_IMAGES = 0x8000
Global Const $LVCFMT_IMAGE = 0x0800
Global Const $LVCFMT_LEFT = 0x0000
Global Const $LVCFMT_RIGHT = 0x0001
Global Const $LVCFMT_LINE_BREAK = 0x100000
Global Const $LVCFMT_FILL = 0x200000
Global Const $LVCFMT_WRAP = 0x400000
Global Const $LVCFMT_NO_TITLE = 0x800000
Global Const $LVCFMT_TILE_PLACEMENTMASK = BitOR($LVCFMT_LINE_BREAK, $LVCFMT_FILL)
Global Const $LVFI_NEARESTXY = 0x0040
Global Const $LVFI_PARAM = 0x0001
Global Const $LVFI_PARTIAL = 0x0008
Global Const $LVFI_STRING = 0x0002
Global Const $LVFI_SUBSTRING = 0x0004
Global Const $LVFI_WRAP = 0x0020
Global Const $LVGA_FOOTER_LEFT = 0x00000008
Global Const $LVGA_FOOTER_CENTER = 0x00000010
Global Const $LVGA_FOOTER_RIGHT = 0x00000020
Global Const $LVGA_HEADER_LEFT = 0x00000001
Global Const $LVGA_HEADER_CENTER = 0x00000002
Global Const $LVGA_HEADER_RIGHT = 0x00000004
Global Const $LVGF_ALIGN = 0x00000008
Global Const $LVGF_DESCRIPTIONTOP = 0x00000400
Global Const $LVGF_DESCRIPTIONBOTTOM = 0x00000800
Global Const $LVGF_EXTENDEDIMAGE = 0x00002000
Global Const $LVGF_FOOTER = 0x00000002
Global Const $LVGF_GROUPID = 0x00000010
Global Const $LVGF_HEADER = 0x00000001
Global Const $LVGF_ITEMS = 0x00004000
Global Const $LVGF_NONE = 0x00000000
Global Const $LVGF_STATE = 0x00000004
Global Const $LVGF_SUBSET = 0x00008000
Global Const $LVGF_SUBSETITEMS = 0x00010000
Global Const $LVGF_SUBTITLE = 0x00000100
Global Const $LVGF_TASK = 0x00000200
Global Const $LVGF_TITLEIMAGE = 0x00001000
Global Const $LVHT_ABOVE = 0x00000008
Global Const $LVHT_BELOW = 0x00000010
Global Const $LVHT_NOWHERE = 0x00000001
Global Const $LVHT_ONITEMICON = 0x00000002
Global Const $LVHT_ONITEMLABEL = 0x00000004
Global Const $LVHT_ONITEMSTATEICON = 0x00000008
Global Const $LVHT_TOLEFT = 0x00000040
Global Const $LVHT_TORIGHT = 0x00000020
Global Const $LVHT_ONITEM = BitOR($LVHT_ONITEMICON, $LVHT_ONITEMLABEL, $LVHT_ONITEMSTATEICON)
Global Const $LVHT_EX_GROUP_HEADER = 0x10000000
Global Const $LVHT_EX_GROUP_FOOTER = 0x20000000
Global Const $LVHT_EX_GROUP_COLLAPSE = 0x40000000
Global Const $LVHT_EX_GROUP_BACKGROUND = 0x80000000
Global Const $LVHT_EX_GROUP_STATEICON = 0x01000000
Global Const $LVHT_EX_GROUP_SUBSETLINK = 0x02000000
Global Const $LVHT_EX_GROUP = BitOR($LVHT_EX_GROUP_BACKGROUND, $LVHT_EX_GROUP_COLLAPSE, $LVHT_EX_GROUP_FOOTER, $LVHT_EX_GROUP_HEADER, $LVHT_EX_GROUP_STATEICON, $LVHT_EX_GROUP_SUBSETLINK)
Global Const $LVHT_EX_ONCONTENTS = 0x04000000
Global Const $LVHT_EX_FOOTER = 0x08000000
Global Const $LVIF_COLFMT = 0x00010000
Global Const $LVIF_COLUMNS = 0x00000200
Global Const $LVIF_GROUPID = 0x00000100
Global Const $LVIF_IMAGE = 0x00000002
Global Const $LVIF_INDENT = 0x00000010
Global Const $LVIF_NORECOMPUTE = 0x00000800
Global Const $LVIF_PARAM = 0x00000004
Global Const $LVIF_STATE = 0x00000008
Global Const $LVIF_TEXT = 0x00000001
Global Const $LVIM_AFTER = 0x00000001
Global Const $LVIR_BOUNDS = 0
Global Const $LVIR_ICON = 1
Global Const $LVIR_LABEL = 2
Global Const $LVIR_SELECTBOUNDS = 3
Global Const $LVIS_CUT = 0x0004
Global Const $LVIS_DROPHILITED = 0x0008
Global Const $LVIS_FOCUSED = 0x0001
Global Const $LVIS_OVERLAYMASK = 0x0F00
Global Const $LVIS_SELECTED = 0x0002
Global Const $LVIS_STATEIMAGEMASK = 0xF000
Global Const $LVS_ALIGNLEFT = 0x0800
Global Const $LVS_ALIGNMASK = 0x0c00
Global Const $LVS_ALIGNTOP = 0x0000
Global Const $LVS_AUTOARRANGE = 0x0100
Global Const $LVS_DEFAULT = 0x0000000D
Global Const $LVS_EDITLABELS = 0x0200
Global Const $LVS_ICON = 0x0000
Global Const $LVS_LIST = 0x0003
Global Const $LVS_NOCOLUMNHEADER = 0x4000
Global Const $LVS_NOLABELWRAP = 0x0080
Global Const $LVS_NOSCROLL = 0x2000
Global Const $LVS_NOSORTHEADER = 0x8000
Global Const $LVS_OWNERDATA = 0x1000
Global Const $LVS_OWNERDRAWFIXED = 0x0400
Global Const $LVS_REPORT = 0x0001
Global Const $LVS_SHAREIMAGELISTS = 0x0040
Global Const $LVS_SHOWSELALWAYS = 0x0008
Global Const $LVS_SINGLESEL = 0x0004
Global Const $LVS_SMALLICON = 0x0002
Global Const $LVS_SORTASCENDING = 0x0010
Global Const $LVS_SORTDESCENDING = 0x0020
Global Const $LVS_TYPEMASK = 0x0003
Global Const $LVS_TYPESTYLEMASK = 0xfc00
Global Const $LVS_EX_AUTOAUTOARRANGE = 0x01000000
Global Const $LVS_EX_AUTOCHECKSELECT = 0x08000000
Global Const $LVS_EX_AUTOSIZECOLUMNS = 0x10000000
Global Const $LVS_EX_BORDERSELECT = 0x00008000
Global Const $LVS_EX_CHECKBOXES = 0x00000004
Global Const $LVS_EX_COLUMNOVERFLOW = 0x80000000
Global Const $LVS_EX_COLUMNSNAPPOINTS = 0x40000000
Global Const $LVS_EX_DOUBLEBUFFER = 0x00010000
Global Const $LVS_EX_FLATSB = 0x00000100
Global Const $LVS_EX_FULLROWSELECT = 0x00000020
Global Const $LVS_EX_GRIDLINES = 0x00000001
Global Const $LVS_EX_HEADERDRAGDROP = 0x00000010
Global Const $LVS_EX_HEADERINALLVIEWS = 0x02000000
Global Const $LVS_EX_HIDELABELS = 0x20000
Global Const $LVS_EX_INFOTIP = 0x00000400
Global Const $LVS_EX_JUSTIFYCOLUMNS = 0x00200000
Global Const $LVS_EX_LABELTIP = 0x00004000
Global Const $LVS_EX_MULTIWORKAREAS = 0x00002000
Global Const $LVS_EX_ONECLICKACTIVATE = 0x00000040
Global Const $LVS_EX_REGIONAL = 0x00000200
Global Const $LVS_EX_SIMPLESELECT = 0x00100000
Global Const $LVS_EX_SNAPTOGRID = 0x00080000
Global Const $LVS_EX_SUBITEMIMAGES = 0x00000002
Global Const $LVS_EX_TRACKSELECT = 0x00000008
Global Const $LVS_EX_TRANSPARENTBKGND = 0x00400000
Global Const $LVS_EX_TRANSPARENTSHADOWTEXT = 0x00800000
Global Const $LVS_EX_TWOCLICKACTIVATE = 0x00000080
Global Const $LVS_EX_UNDERLINECOLD = 0x00001000
Global Const $LVS_EX_UNDERLINEHOT = 0x00000800
Global Const $GUI_SS_DEFAULT_LISTVIEW = BitOR($LVS_SHOWSELALWAYS, $LVS_SINGLESEL)
Global Const $LVM_FIRST = 0x1000
Global Const $LVM_APPROXIMATEVIEWRECT = ($LVM_FIRST + 64)
Global Const $LVM_ARRANGE = ($LVM_FIRST + 22)
Global Const $LVM_CANCELEDITLABEL = ($LVM_FIRST + 179)
Global Const $LVM_CREATEDRAGIMAGE = ($LVM_FIRST + 33)
Global Const $LVM_DELETEALLITEMS = ($LVM_FIRST + 9)
Global Const $LVM_DELETECOLUMN = ($LVM_FIRST + 28)
Global Const $LVM_DELETEITEM = ($LVM_FIRST + 8)
Global Const $LVM_EDITLABELA = ($LVM_FIRST + 23)
Global Const $LVM_EDITLABELW = ($LVM_FIRST + 118)
Global Const $LVM_EDITLABEL = $LVM_EDITLABELA
Global Const $LVM_ENABLEGROUPVIEW = ($LVM_FIRST + 157)
Global Const $LVM_ENSUREVISIBLE = ($LVM_FIRST + 19)
Global Const $LVM_FINDITEM = ($LVM_FIRST + 13)
Global Const $LVM_GETBKCOLOR = ($LVM_FIRST + 0)
Global Const $LVM_GETBKIMAGEA = ($LVM_FIRST + 69)
Global Const $LVM_GETBKIMAGEW = ($LVM_FIRST + 139)
Global Const $LVM_GETCALLBACKMASK = ($LVM_FIRST + 10)
Global Const $LVM_GETCOLUMNA = ($LVM_FIRST + 25)
Global Const $LVM_GETCOLUMNW = ($LVM_FIRST + 95)
Global Const $LVM_GETCOLUMNORDERARRAY = ($LVM_FIRST + 59)
Global Const $LVM_GETCOLUMNWIDTH = ($LVM_FIRST + 29)
Global Const $LVM_GETCOUNTPERPAGE = ($LVM_FIRST + 40)
Global Const $LVM_GETEDITCONTROL = ($LVM_FIRST + 24)
Global Const $LVM_GETEMPTYTEXT = ($LVM_FIRST + 204)
Global Const $LVM_GETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 55)
Global Const $LVM_GETFOCUSEDGROUP = ($LVM_FIRST + 93)
Global Const $LVM_GETFOOTERINFO = ($LVM_FIRST + 206)
Global Const $LVM_GETFOOTERITEM = ($LVM_FIRST + 208)
Global Const $LVM_GETFOOTERITEMRECT = ($LVM_FIRST + 207)
Global Const $LVM_GETFOOTERRECT = ($LVM_FIRST + 205)
Global Const $LVM_GETGROUPCOUNT = ($LVM_FIRST + 152)
Global Const $LVM_GETGROUPINFO = ($LVM_FIRST + 149)
Global Const $LVM_GETGROUPINFOBYINDEX = ($LVM_FIRST + 153)
Global Const $LVM_GETGROUPMETRICS = ($LVM_FIRST + 156)
Global Const $LVM_GETGROUPRECT = ($LVM_FIRST + 98)
Global Const $LVM_GETGROUPSTATE = ($LVM_FIRST + 92)
Global Const $LVM_GETHEADER = ($LVM_FIRST + 31)
Global Const $LVM_GETHOTCURSOR = ($LVM_FIRST + 63)
Global Const $LVM_GETHOTITEM = ($LVM_FIRST + 61)
Global Const $LVM_GETHOVERTIME = ($LVM_FIRST + 72)
Global Const $LVM_GETIMAGELIST = ($LVM_FIRST + 2)
Global Const $LVM_GETINSERTMARK = ($LVM_FIRST + 167)
Global Const $LVM_GETINSERTMARKCOLOR = ($LVM_FIRST + 171)
Global Const $LVM_GETINSERTMARKRECT = ($LVM_FIRST + 169)
Global Const $LVM_GETISEARCHSTRINGA = ($LVM_FIRST + 52)
Global Const $LVM_GETISEARCHSTRINGW = ($LVM_FIRST + 117)
Global Const $LVM_GETITEMA = ($LVM_FIRST + 5)
Global Const $LVM_GETITEMW = ($LVM_FIRST + 75)
Global Const $LVM_GETITEMCOUNT = ($LVM_FIRST + 4)
Global Const $LVM_GETITEMINDEXRECT = ($LVM_FIRST + 209)
Global Const $LVM_GETITEMPOSITION = ($LVM_FIRST + 16)
Global Const $LVM_GETITEMRECT = ($LVM_FIRST + 14)
Global Const $LVM_GETITEMSPACING = ($LVM_FIRST + 51)
Global Const $LVM_GETITEMSTATE = ($LVM_FIRST + 44)
Global Const $LVM_GETITEMTEXTA = ($LVM_FIRST + 45)
Global Const $LVM_GETITEMTEXTW = ($LVM_FIRST + 115)
Global Const $LVM_GETNEXTITEM = ($LVM_FIRST + 12)
Global Const $LVM_GETNEXTITEMINDEX = ($LVM_FIRST + 211)
Global Const $LVM_GETNUMBEROFWORKAREAS = ($LVM_FIRST + 73)
Global Const $LVM_GETORIGIN = ($LVM_FIRST + 41)
Global Const $LVM_GETOUTLINECOLOR = ($LVM_FIRST + 176)
Global Const $LVM_GETSELECTEDCOLUMN = ($LVM_FIRST + 174)
Global Const $LVM_GETSELECTEDCOUNT = ($LVM_FIRST + 50)
Global Const $LVM_GETSELECTIONMARK = ($LVM_FIRST + 66)
Global Const $LVM_GETSTRINGWIDTHA = ($LVM_FIRST + 17)
Global Const $LVM_GETSTRINGWIDTHW = ($LVM_FIRST + 87)
Global Const $LVM_GETSUBITEMRECT = ($LVM_FIRST + 56)
Global Const $LVM_GETTEXTBKCOLOR = ($LVM_FIRST + 37)
Global Const $LVM_GETTEXTCOLOR = ($LVM_FIRST + 35)
Global Const $LVM_GETTILEINFO = ($LVM_FIRST + 165)
Global Const $LVM_GETTILEVIEWINFO = ($LVM_FIRST + 163)
Global Const $LVM_GETTOOLTIPS = ($LVM_FIRST + 78)
Global Const $LVM_GETTOPINDEX = ($LVM_FIRST + 39)
Global Const $LVM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $LVM_GETVIEW = ($LVM_FIRST + 143)
Global Const $LVM_GETVIEWRECT = ($LVM_FIRST + 34)
Global Const $LVM_GETWORKAREAS = ($LVM_FIRST + 70)
Global Const $LVM_HASGROUP = ($LVM_FIRST + 161)
Global Const $LVM_HITTEST = ($LVM_FIRST + 18)
Global Const $LVM_INSERTCOLUMNA = ($LVM_FIRST + 27)
Global Const $LVM_INSERTCOLUMNW = ($LVM_FIRST + 97)
Global Const $LVM_INSERTGROUP = ($LVM_FIRST + 145)
Global Const $LVM_INSERTGROUPSORTED = ($LVM_FIRST + 159)
Global Const $LVM_INSERTITEMA = ($LVM_FIRST + 7)
Global Const $LVM_INSERTITEMW = ($LVM_FIRST + 77)
Global Const $LVM_INSERTMARKHITTEST = ($LVM_FIRST + 168)
Global Const $LVM_ISGROUPVIEWENABLED = ($LVM_FIRST + 175)
Global Const $LVM_ISITEMVISIBLE = ($LVM_FIRST + 182)
Global Const $LVM_MAPIDTOINDEX = ($LVM_FIRST + 181)
Global Const $LVM_MAPINDEXTOID = ($LVM_FIRST + 180)
Global Const $LVM_MOVEGROUP = ($LVM_FIRST + 151)
Global Const $LVM_REDRAWITEMS = ($LVM_FIRST + 21)
Global Const $LVM_REMOVEALLGROUPS = ($LVM_FIRST + 160)
Global Const $LVM_REMOVEGROUP = ($LVM_FIRST + 150)
Global Const $LVM_SCROLL = ($LVM_FIRST + 20)
Global Const $LVM_SETBKCOLOR = ($LVM_FIRST + 1)
Global Const $LVM_SETBKIMAGEA = ($LVM_FIRST + 68)
Global Const $LVM_SETBKIMAGEW = ($LVM_FIRST + 138)
Global Const $LVM_SETCALLBACKMASK = ($LVM_FIRST + 11)
Global Const $LVM_SETCOLUMNA = ($LVM_FIRST + 26)
Global Const $LVM_SETCOLUMNW = ($LVM_FIRST + 96)
Global Const $LVM_SETCOLUMNORDERARRAY = ($LVM_FIRST + 58)
Global Const $LVM_SETCOLUMNWIDTH = ($LVM_FIRST + 30)
Global Const $LVM_SETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 54)
Global Const $LVM_SETGROUPINFO = ($LVM_FIRST + 147)
Global Const $LVM_SETGROUPMETRICS = ($LVM_FIRST + 155)
Global Const $LVM_SETHOTCURSOR = ($LVM_FIRST + 62)
Global Const $LVM_SETHOTITEM = ($LVM_FIRST + 60)
Global Const $LVM_SETHOVERTIME = ($LVM_FIRST + 71)
Global Const $LVM_SETICONSPACING = ($LVM_FIRST + 53)
Global Const $LVM_SETIMAGELIST = ($LVM_FIRST + 3)
Global Const $LVM_SETINFOTIP = ($LVM_FIRST + 173)
Global Const $LVM_SETINSERTMARK = ($LVM_FIRST + 166)
Global Const $LVM_SETINSERTMARKCOLOR = ($LVM_FIRST + 170)
Global Const $LVM_SETITEMA = ($LVM_FIRST + 6)
Global Const $LVM_SETITEMW = ($LVM_FIRST + 76)
Global Const $LVM_SETITEMCOUNT = ($LVM_FIRST + 47)
Global Const $LVM_SETITEMINDEXSTATE = ($LVM_FIRST + 210)
Global Const $LVM_SETITEMPOSITION = ($LVM_FIRST + 15)
Global Const $LVM_SETITEMPOSITION32 = ($LVM_FIRST + 49)
Global Const $LVM_SETITEMSTATE = ($LVM_FIRST + 43)
Global Const $LVM_SETITEMTEXTA = ($LVM_FIRST + 46)
Global Const $LVM_SETITEMTEXTW = ($LVM_FIRST + 116)
Global Const $LVM_SETOUTLINECOLOR = ($LVM_FIRST + 177)
Global Const $LVM_SETSELECTEDCOLUMN = ($LVM_FIRST + 140)
Global Const $LVM_SETSELECTIONMARK = ($LVM_FIRST + 67)
Global Const $LVM_SETTEXTBKCOLOR = ($LVM_FIRST + 38)
Global Const $LVM_SETTEXTCOLOR = ($LVM_FIRST + 36)
Global Const $LVM_SETTILEINFO = ($LVM_FIRST + 164)
Global Const $LVM_SETTILEVIEWINFO = ($LVM_FIRST + 162)
Global Const $LVM_SETTILEWIDTH = ($LVM_FIRST + 141)
Global Const $LVM_SETTOOLTIPS = ($LVM_FIRST + 74)
Global Const $LVM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $LVM_SETVIEW = ($LVM_FIRST + 142)
Global Const $LVM_SETWORKAREAS = ($LVM_FIRST + 65)
Global Const $LVM_SORTGROUPS = ($LVM_FIRST + 158)
Global Const $LVM_SORTITEMS = ($LVM_FIRST + 48)
Global Const $LVM_SORTITEMSEX = ($LVM_FIRST + 81)
Global Const $LVM_SUBITEMHITTEST = ($LVM_FIRST + 57)
Global Const $LVM_UPDATE = ($LVM_FIRST + 42)
Global Const $LVN_FIRST = -100
Global Const $LVN_LAST = -199
Global Const $LVN_BEGINDRAG = ($LVN_FIRST - 9)
Global Const $LVN_BEGINLABELEDITA = ($LVN_FIRST - 5)
Global Const $LVN_BEGINLABELEDITW = ($LVN_FIRST - 75)
Global Const $LVN_BEGINRDRAG = ($LVN_FIRST - 11)
Global Const $LVN_BEGINSCROLL = ($LVN_FIRST - 80)
Global Const $LVN_COLUMNCLICK = ($LVN_FIRST - 8)
Global Const $LVN_COLUMNDROPDOWN = ($LVN_FIRST - 64)
Global Const $LVN_COLUMNOVERFLOWCLICK = ($LVN_FIRST - 66)
Global Const $LVN_DELETEALLITEMS = ($LVN_FIRST - 4)
Global Const $LVN_DELETEITEM = ($LVN_FIRST - 3)
Global Const $LVN_ENDLABELEDITA = ($LVN_FIRST - 6)
Global Const $LVN_ENDLABELEDITW = ($LVN_FIRST - 76)
Global Const $LVN_ENDSCROLL = ($LVN_FIRST - 81)
Global Const $LVN_GETDISPINFOA = ($LVN_FIRST - 50)
Global Const $LVN_GETDISPINFOW = ($LVN_FIRST - 77)
Global Const $LVN_GETDISPINFO = $LVN_GETDISPINFOA
Global Const $LVN_GETEMPTYMARKUP = ($LVN_FIRST - 87)
Global Const $LVN_GETINFOTIPA = ($LVN_FIRST - 57)
Global Const $LVN_GETINFOTIPW = ($LVN_FIRST - 58)
Global Const $LVN_HOTTRACK = ($LVN_FIRST - 21)
Global Const $LVN_INCREMENTALSEARCHA = ($LVN_FIRST - 62)
Global Const $LVN_INCREMENTALSEARCHW = ($LVN_FIRST - 63)
Global Const $LVN_INSERTITEM = ($LVN_FIRST - 2)
Global Const $LVN_ITEMACTIVATE = ($LVN_FIRST - 14)
Global Const $LVN_ITEMCHANGED = ($LVN_FIRST - 1)
Global Const $LVN_ITEMCHANGING = ($LVN_FIRST - 0)
Global Const $LVN_KEYDOWN = ($LVN_FIRST - 55)
Global Const $LVN_LINKCLICK = ($LVN_FIRST - 84)
Global Const $LVN_MARQUEEBEGIN = ($LVN_FIRST - 56)
Global Const $LVN_ODCACHEHINT = ($LVN_FIRST - 13)
Global Const $LVN_ODFINDITEMA = ($LVN_FIRST - 52)
Global Const $LVN_ODFINDITEMW = ($LVN_FIRST - 79)
Global Const $LVN_ODFINDITEM = $LVN_ODFINDITEMA
Global Const $LVN_ODSTATECHANGED = ($LVN_FIRST - 15)
Global Const $LVN_SETDISPINFOA = ($LVN_FIRST - 51)
Global Const $LVN_SETDISPINFOW = ($LVN_FIRST - 78)
Global Const $LVNI_ABOVE = 0x0100
Global Const $LVNI_BELOW = 0x0200
Global Const $LVNI_TOLEFT = 0x0400
Global Const $LVNI_TORIGHT = 0x0800
Global Const $LVNI_ALL = 0x0000
Global Const $LVNI_CUT = 0x0004
Global Const $LVNI_DROPHILITED = 0x0008
Global Const $LVNI_FOCUSED = 0x0001
Global Const $LVNI_SELECTED = 0x0002
Global Const $LVSCW_AUTOSIZE = -1
Global Const $LVSCW_AUTOSIZE_USEHEADER = -2
Global Const $LVSICF_NOINVALIDATEALL = 0x00000001
Global Const $LVSICF_NOSCROLL = 0x00000002
Global Const $LVSIL_NORMAL = 0
Global Const $LVSIL_SMALL = 1
Global Const $LVSIL_STATE = 2
Global Const $LVFN_DIR_LEFT = 0
Global Const $LVFN_DIR_RIGHT = 1
Global Const $LVFN_DIR_UP = 2
Global Const $LVFN_DIR_DOWN = 3
Global Const $LVFN_DIR_START = 4
Global Const $LVFN_DIR_MEND = 5
Global Const $LVFN_DIR_PRIOR = 6
Global Const $LVFN_DIR_NEXT = 7
Global Const $PBS_MARQUEE = 0x00000008
Global Const $PBS_SMOOTH = 1
Global Const $PBS_SMOOTHREVERSE = 0x10
Global Const $PBS_VERTICAL = 4
Global Const $GUI_SS_DEFAULT_PROGRESS = 0
Global Const $__PROGRESSBARCONSTANT_WM_USER = 0X400
Global Const $PBM_DELTAPOS = $__PROGRESSBARCONSTANT_WM_USER + 3
Global Const $PBM_GETBARCOLOR = 0x040F
Global Const $PBM_GETBKCOLOR = 0x040E
Global Const $PBM_GETPOS = $__PROGRESSBARCONSTANT_WM_USER + 8
Global Const $PBM_GETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 7
Global Const $PBM_GETSTATE = 0x0411
Global Const $PBM_GETSTEP = 0x040D
Global Const $PBM_SETBARCOLOR = $__PROGRESSBARCONSTANT_WM_USER + 9
Global Const $PBM_SETBKCOLOR = 0x2000 + 1
Global Const $PBM_SETMARQUEE = $__PROGRESSBARCONSTANT_WM_USER + 10
Global Const $PBM_SETPOS = $__PROGRESSBARCONSTANT_WM_USER + 2
Global Const $PBM_SETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 1
Global Const $PBM_SETRANGE32 = $__PROGRESSBARCONSTANT_WM_USER + 6
Global Const $PBM_SETSTATE = 0x0410
Global Const $PBM_SETSTEP = $__PROGRESSBARCONSTANT_WM_USER + 4
Global Const $PBM_STEPIT = $__PROGRESSBARCONSTANT_WM_USER + 5
Global Const $__RICHEDITCONSTANT_WM_USER = 0x400
Global Const $EM_AUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 91
Global Const $EM_CANPASTE = $__RICHEDITCONSTANT_WM_USER + 50
Global Const $EM_CANREDO = $__RICHEDITCONSTANT_WM_USER + 85
Global Const $EM_DISPLAYBAND = $__RICHEDITCONSTANT_WM_USER + 51
Global Const $EM_EXGETSEL = $__RICHEDITCONSTANT_WM_USER + 52
Global Const $EM_EXLIMITTEXT = $__RICHEDITCONSTANT_WM_USER + 53
Global Const $EM_EXLINEFROMCHAR = $__RICHEDITCONSTANT_WM_USER + 54
Global Const $EM_EXSETSEL = $__RICHEDITCONSTANT_WM_USER + 55
Global Const $EM_FINDTEXT = $__RICHEDITCONSTANT_WM_USER + 56
Global Const $EM_FINDTEXTEX = $__RICHEDITCONSTANT_WM_USER + 79
Global Const $EM_FINDTEXTEXW = $__RICHEDITCONSTANT_WM_USER + 124
Global Const $EM_FINDTEXTW = $__RICHEDITCONSTANT_WM_USER + 123
Global Const $EM_FINDWORDBREAK = $__RICHEDITCONSTANT_WM_USER + 76
Global Const $EM_FORMATRANGE = $__RICHEDITCONSTANT_WM_USER + 57
Global Const $EM_GETAUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 92
Global Const $EM_GETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 201
Global Const $EM_GETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 58
Global Const $EM_GETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 205
Global Const $EM_GETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 59
Global Const $EM_GETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 105
Global Const $EM_GETIMECOMPMODE = $__RICHEDITCONSTANT_WM_USER + 122
Global Const $EM_GETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 127
Global Const $EM_GETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 107
Global Const $EM_GETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 121
Global Const $EM_GETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 78
Global Const $EM_GETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 61
Global Const $EM_GETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 101
Global Const $EM_GETREDONAME = $__RICHEDITCONSTANT_WM_USER + 87
Global Const $EM_GETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 221
Global Const $EM_GETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 265
Global Const $EM_GETSELTEXT = $__RICHEDITCONSTANT_WM_USER + 62
Global Const $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 94
Global Const $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 95
Global Const $EM_GETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 90
Global Const $EM_GETTEXTRANGE = $__RICHEDITCONSTANT_WM_USER + 75
Global Const $EM_GETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 203
Global Const $EM_GETUNDONAME = $__RICHEDITCONSTANT_WM_USER + 86
Global Const $EM_GETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 80
Global Const $EM_GETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 103
Global Const $EM_GETZOOM = $__RICHEDITCONSTANT_WM_USER + 224
Global Const $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 63
Global Const $EM_INSERTTABLE = $__RICHEDITCONSTANT_WM_USER + 232
Global Const $EM_PASTESPECIAL = $__RICHEDITCONSTANT_WM_USER + 64
Global Const $EM_RECONVERSION = $__RICHEDITCONSTANT_WM_USER + 125
Global Const $EM_REDO = $__RICHEDITCONSTANT_WM_USER + 84
Global Const $EM_REQUESTRESIZE = $__RICHEDITCONSTANT_WM_USER + 65
Global Const $EM_SELECTIONTYPE = $__RICHEDITCONSTANT_WM_USER + 66
Global Const $EM_SETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 200
Global Const $EM_SETBKGNDCOLOR = $__RICHEDITCONSTANT_WM_USER + 67
Global Const $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 68
Global Const $EM_SETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 204
Global Const $EM_SETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 69
Global Const $EM_SETFONTSIZE = $__RICHEDITCONSTANT_WM_USER + 223
Global Const $EM_SETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 104
Global Const $EM_SETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 126
Global Const $EM_SETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 106
Global Const $EM_SETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 120
Global Const $EM_SETOLECALLBACK = $__RICHEDITCONSTANT_WM_USER + 70
Global Const $EM_SETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 77
Global Const $EM_SETPALETTE = $__RICHEDITCONSTANT_WM_USER + 93
Global Const $EM_SETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 71
Global Const $EM_SETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 100
Global Const $EM_SETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 222
Global Const $EM_SETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 307
Global Const $EM_SETTARGETDEVICE = $__RICHEDITCONSTANT_WM_USER + 72
Global Const $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 97
Global Const $EM_SETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 89
Global Const $EM_SETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 202
Global Const $EM_SETUNDOLIMIT = $__RICHEDITCONSTANT_WM_USER + 82
Global Const $EM_SETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 81
Global Const $EM_SETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 102
Global Const $EM_SETZOOM = $__RICHEDITCONSTANT_WM_USER + 225
Global Const $EM_SHOWSCROLLBAR = $__RICHEDITCONSTANT_WM_USER + 96
Global Const $EM_STOPGROUPTYPING = $__RICHEDITCONSTANT_WM_USER + 88
Global Const $EM_STREAMIN = $__RICHEDITCONSTANT_WM_USER + 73
Global Const $EM_STREAMOUT = $__RICHEDITCONSTANT_WM_USER + 74
Global Const $EN_ALIGNLTR = 0X710
Global Const $EN_ALIGNRTL = 0X711
Global Const $EN_CORRECTTEXT = 0X705
Global Const $EN_DRAGDROPDONE = 0X70c
Global Const $EN_DROPFILES = 0X703
Global Const $EN_IMECHANGE = 0X707
Global Const $EN_LINK = 0X70b
Global Const $EN_MSGFILTER = 0X700
Global Const $EN_OBJECTPOSITIONS = 0X70a
Global Const $EN_OLEOPFAILED = 0X709
Global Const $EN_PROTECTED = 0X704
Global Const $EN_REQUESTRESIZE = 0X701
Global Const $EN_SAVECLIPBOARD = 0X708
Global Const $EN_SELCHANGE = 0X702
Global Const $EN_STOPNOUNDO = 0X706
Global Const $ENM_CHANGE = 0x1
Global Const $ENM_CORRECTTEXT = 0x400000
Global Const $ENM_DRAGDROPDONE = 0x10
Global Const $ENM_DROPFILES = 0x100000
Global Const $ENM_IMECHANGE = 0x800000
Global Const $ENM_KEYEVENTS = 0x10000
Global Const $ENM_LINK = 0x4000000
Global Const $ENM_MOUSEEVENTS = 0x20000
Global Const $ENM_OBJECTPOSITIONS = 0x2000000
Global Const $ENM_PROTECTED = 0x200000
Global Const $ENM_REQUESTRESIZE = 0x40000
Global Const $ENM_SCROLL = 0x4
Global Const $ENM_SCROLLEVENTS = 0x8
Global Const $ENM_SELCHANGE = 0x80000
Global Const $ENM_UPDATE = 0x2
Global Const $BOM_DEFPARADIR = 0x1
Global Const $BOM_PLAINTEXT = 0x2
Global Const $BOM_NEUTRALOVERRIDE = 0x4
Global Const $BOM_CONTEXTREADING = 0x8
Global Const $BOM_CONTEXTALIGNMENT = 0x10
Global Const $BOM_LEGACYBIDICLASS = 0x0040
Global Const $BOE_RTLDIR = 0x1
Global Const $BOE_PLAINTEXT = 0x2
Global Const $BOE_NEUTRALOVERRIDE = 0x4
Global Const $BOE_CONTEXTREADING = 0x8
Global Const $BOE_CONTEXTALIGNMENT = 0x10
Global Const $BOE_LEGACYBIDICLASS = 0x0040
Global Const $ST_DEFAULT = 0
Global Const $ST_KEEPUNDO = 1
Global Const $ST_SELECTION = 2
Global Const $GT_DEFAULT = 0
Global Const $GT_SELECTION = 2
Global Const $GT_USECRLF = 1
Global Const $GTL_CLOSE = 4
Global Const $GTL_DEFAULT = 0
Global Const $GTL_NUMBYTES = 16
Global Const $GTL_NUMCHARS = 8
Global Const $GTL_PRECISE = 2
Global Const $GTL_USECRLF = 1
Global Const $CFU_UNDERLINENONE = 0
Global Const $CFU_UNDERLINE = 1
Global Const $CFU_UNDERLINEWORD = 2
Global Const $CFU_UNDERLINEDOUBLE = 3
Global Const $CFU_UNDERLINEDOTTED = 4
Global Const $CP_ACP = 0
Global Const $CP_UNICODE = 1200
Global Const $CFE_SUBSCRIPT = 0x00010000
Global Const $CFE_SUPERSCRIPT = 0x00020000
Global Const $CFM_ALLCAPS = 0x80
Global Const $CFM_ANIMATION = 0x40000
Global Const $CFM_BACKCOLOR = 0x4000000
Global Const $CFM_BOLD = 0x1
Global Const $CFM_CHARSET = 0x8000000
Global Const $CFM_COLOR = 0x40000000
Global Const $CFM_DISABLED = 0x2000
Global Const $CFM_EMBOSS = 0x800
Global Const $CFM_FACE = 0x20000000
Global Const $CFM_HIDDEN = 0x100
Global Const $CFM_IMPRINT = 0x1000
Global Const $CFM_ITALIC = 0x2
Global Const $CFM_KERNING = 0x100000
Global Const $CFM_LCID = 0x2000000
Global Const $CFM_LINK = 0x20
Global Const $CFM_OFFSET = 0x10000000
Global Const $CFM_OUTLINE = 0x200
Global Const $CFM_PROTECTED = 0x10
Global Const $CFM_REVAUTHOR = 0x8000
Global Const $CFM_REVISED = 0x4000
Global Const $CFM_SHADOW = 0x400
Global Const $CFM_SIZE = 0x80000000
Global Const $CFM_SMALLCAPS = 0x40
Global Const $CFM_SPACING = 0x200000
Global Const $CFM_STRIKEOUT = 0x8
Global Const $CFM_STYLE = 0x80000
Global Const $CFM_SUBSCRIPT = BitOR($CFE_SUBSCRIPT, $CFE_SUPERSCRIPT)
Global Const $CFM_SUPERSCRIPT = $CFM_SUBSCRIPT
Global Const $CFM_UNDERLINE = 0x4
Global Const $CFM_UNDERLINETYPE = 0x800000
Global Const $CFM_WEIGHT = 0x400000
Global Const $CFE_ALLCAPS = $CFM_ALLCAPS
Global Const $CFE_AUTOBACKCOLOR = $CFM_BACKCOLOR
Global Const $CFE_AUTOCOLOR = $CFM_COLOR
Global Const $CFE_BOLD = $CFM_BOLD
Global Const $CFE_DISABLED = $CFM_DISABLED
Global Const $CFE_EMBOSS = $CFM_EMBOSS
Global Const $CFE_HIDDEN = $CFM_HIDDEN
Global Const $CFE_IMPRINT = $CFM_IMPRINT
Global Const $CFE_ITALIC = $CFM_ITALIC
Global Const $CFE_LINK = $CFM_LINK
Global Const $CFE_OUTLINE = $CFM_OUTLINE
Global Const $CFE_PROTECTED = $CFM_PROTECTED
Global Const $CFE_REVISED = $CFM_REVISED
Global Const $CFE_SHADOW = $CFM_SHADOW
Global Const $CFE_SMALLCAPS = $CFM_SMALLCAPS
Global Const $CFE_STRIKEOUT = $CFM_STRIKEOUT
Global Const $CFE_UNDERLINE = $CFM_UNDERLINE
Global Const $FR_MATCHALEFHAMZA = 0x80000000
Global Const $FR_MATCHDIAC = 0x20000000
Global Const $FR_MATCHKASHIDA = 0x40000000
Global Const $SCF_DEFAULT = 0x0
Global Const $SCF_SELECTION = 0x1
Global Const $SCF_WORD = 0x2
Global Const $SCF_ALL = 0x4
Global Const $SCF_USEUIRULES = 0x8
Global Const $SCF_ASSOCIATEFONT = 0x10
Global Const $SCF_NOKBUPDATE = 0x20
Global Const $LF_FACESIZE = 32
Global Const $MAX_TAB_STOPS = 32
Global Const $PFA_LEFT = 0x1
Global Const $PFA_RIGHT = 0x2
Global Const $PFA_CENTER = 0x3
Global Const $PFA_JUSTIFY = 4
Global Const $PFA_FULL_INTERWORD = 4
Global Const $PFE_TABLE = 0x4000
Global Const $PFM_NUMBERING = 0x20
Global Const $PFM_ALIGNMENT = 0x8
Global Const $PFM_SPACEBEFORE = 0x40
Global Const $PFM_NUMBERINGSTYLE = 0x2000
Global Const $PFM_NUMBERINGSTART = 0x8000
Global Const $PFM_BORDER = 0x800
Global Const $PFM_RIGHTINDENT = 0x2
Global Const $PFM_STARTINDENT = 0x1
Global Const $PFM_OFFSET = 0x4
Global Const $PFM_LINESPACING = 0x100
Global Const $PFM_SPACEAFTER = 0x80
Global Const $PFM_NUMBERINGTAB = 0x4000
Global Const $PFM_TABLE = 0x40000000
Global Const $PFM_TABSTOPS = 0x10
Global Const $PFN_BULLET = 0x1
Global Const $PFM_RTLPARA = 0x10000
Global Const $PFM_KEEP = 0x20000
Global Const $PFM_KEEPNEXT = 0x40000
Global Const $PFM_PAGEBREAKBEFORE = 0x80000
Global Const $PFM_NOLINENUMBER = 0x100000
Global Const $PFM_NOWIDOWCONTROL = 0x200000
Global Const $PFM_DONOTHYPHEN = 0x400000
Global Const $PFM_SIDEBYSIDE = 0x800000
Global Const $PFE_RTLPARA = 0x00000001
Global Const $PFE_KEEP = 0x00000002
Global Const $PFE_KEEPNEXT = 0x00000004
Global Const $PFE_PAGEBREAKBEFORE = 0x00000008
Global Const $PFE_NOLINENUMBER = 0x00000010
Global Const $PFE_NOWIDOWCONTROL = 0x00000020
Global Const $PFE_DONOTHYPHEN = 0x00000040
Global Const $PFE_SIDEBYSIDE = 0x00000080
Global Const $PFM_SHADING = 0x1000
Global Const $WB_CLASSIFY = 3
Global Const $WB_ISDELIMITER = 2
Global Const $WB_LEFT = 0
Global Const $WB_LEFTBREAK = 6
Global Const $WB_MOVEWORDLEFT = 4
Global Const $WB_MOVEWORDNEXT = 5
Global Const $WB_MOVEWORDPREV = 4
Global Const $WB_MOVEWORDRIGHT = 5
Global Const $WB_NEXTBREAK = 7
Global Const $WB_PREVBREAK = 6
Global Const $WB_RIGHT = 1
Global Const $WB_RIGHTBREAK = 7
Global Const $WBF_ISWHITE = 0x10
Global Const $WBF_BREAKLINE = 0x20
Global Const $WBF_BREAKAFTER = 0x40
Global Const $SF_TEXT = 0x1
Global Const $SF_RTF = 0x2
Global Const $SF_RTFNOOBJS = 0x3
Global Const $SF_TEXTIZED = 0x4
Global Const $SF_UNICODE = 0x0010
Global Const $SF_USECODEPAGE = 0x20
Global Const $SFF_PLAINRTF = 0x4000
Global Const $SFF_SELECTION = 0x8000
Global Const $TBCD_CHANNEL = 0x3
Global Const $TBCD_THUMB = 0x2
Global Const $TBCD_TICS = 0x1
Global Const $__SLIDERCONSTANT_WM_USER = 0x400
Global Const $TBM_CLEARSEL = $__SLIDERCONSTANT_WM_USER + 19
Global Const $TBM_CLEARTICS = $__SLIDERCONSTANT_WM_USER + 9
Global Const $TBM_GETBUDDY = $__SLIDERCONSTANT_WM_USER + 33
Global Const $TBM_GETCHANNELRECT = $__SLIDERCONSTANT_WM_USER + 26
Global Const $TBM_GETLINESIZE = $__SLIDERCONSTANT_WM_USER + 24
Global Const $TBM_GETNUMTICS = $__SLIDERCONSTANT_WM_USER + 16
Global Const $TBM_GETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 22
Global Const $TBM_GETPOS = $__SLIDERCONSTANT_WM_USER
Global Const $TBM_GETPTICS = $__SLIDERCONSTANT_WM_USER + 14
Global Const $TBM_GETSELEND = $__SLIDERCONSTANT_WM_USER + 18
Global Const $TBM_GETSELSTART = $__SLIDERCONSTANT_WM_USER + 17
Global Const $TBM_GETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 2
Global Const $TBM_GETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 1
Global Const $TBM_GETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 28
Global Const $TBM_GETTHUMBRECT = $__SLIDERCONSTANT_WM_USER + 25
Global Const $TBM_GETTIC = $__SLIDERCONSTANT_WM_USER + 3
Global Const $TBM_GETTICPOS = $__SLIDERCONSTANT_WM_USER + 15
Global Const $TBM_GETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 30
Global Const $TBM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $TBM_SETBUDDY = $__SLIDERCONSTANT_WM_USER + 32
Global Const $TBM_SETLINESIZE = $__SLIDERCONSTANT_WM_USER + 23
Global Const $TBM_SETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 21
Global Const $TBM_SETPOS = $__SLIDERCONSTANT_WM_USER + 5
Global Const $TBM_SETRANGE = $__SLIDERCONSTANT_WM_USER + 6
Global Const $TBM_SETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 8
Global Const $TBM_SETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 7
Global Const $TBM_SETSEL = $__SLIDERCONSTANT_WM_USER + 10
Global Const $TBM_SETSELEND = $__SLIDERCONSTANT_WM_USER + 12
Global Const $TBM_SETSELSTART = $__SLIDERCONSTANT_WM_USER + 11
Global Const $TBM_SETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 27
Global Const $TBM_SETTIC = $__SLIDERCONSTANT_WM_USER + 4
Global Const $TBM_SETTICFREQ = $__SLIDERCONSTANT_WM_USER + 20
Global Const $TBM_SETTIPSIDE = $__SLIDERCONSTANT_WM_USER + 31
Global Const $TBM_SETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 29
Global Const $TBM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $TBTS_BOTTOM = 2
Global Const $TBTS_LEFT = 1
Global Const $TBTS_RIGHT = 3
Global Const $TBTS_TOP = 0
Global Const $TBS_AUTOTICKS = 0x0001
Global Const $TBS_BOTH = 0x0008
Global Const $TBS_BOTTOM = 0x0000
Global Const $TBS_DOWNISLEFT = 0x0400
Global Const $TBS_ENABLESELRANGE = 0x20
Global Const $TBS_FIXEDLENGTH = 0x40
Global Const $TBS_HORZ = 0x0000
Global Const $TBS_LEFT = 0x0004
Global Const $TBS_NOTHUMB = 0x0080
Global Const $TBS_NOTICKS = 0x0010
Global Const $TBS_REVERSED = 0x200
Global Const $TBS_RIGHT = 0x0000
Global Const $TBS_TOP = 0x0004
Global Const $TBS_TOOLTIPS = 0x100
Global Const $TBS_VERT = 0x0002
Global Const $GUI_SS_DEFAULT_SLIDER = $TBS_AUTOTICKS
Global Const $SS_LEFT = 0x0
Global Const $SS_CENTER = 0x1
Global Const $SS_RIGHT = 0x2
Global Const $SS_ICON = 0x3
Global Const $SS_BLACKRECT = 0x4
Global Const $SS_GRAYRECT = 0x5
Global Const $SS_WHITERECT = 0x6
Global Const $SS_BLACKFRAME = 0x7
Global Const $SS_GRAYFRAME = 0x8
Global Const $SS_WHITEFRAME = 0x9
Global Const $SS_SIMPLE = 0xB
Global Const $SS_LEFTNOWORDWRAP = 0xC
Global Const $SS_BITMAP = 0xE
Global Const $SS_ENHMETAFILE = 0xF
Global Const $SS_ETCHEDHORZ = 0x10
Global Const $SS_ETCHEDVERT = 0x11
Global Const $SS_ETCHEDFRAME = 0x12
Global Const $SS_REALSIZECONTROL = 0x40
Global Const $SS_NOPREFIX = 0x0080
Global Const $SS_NOTIFY = 0x0100
Global Const $SS_CENTERIMAGE = 0x0200
Global Const $SS_RIGHTJUST = 0x0400
Global Const $SS_SUNKEN = 0x1000
Global Const $GUI_SS_DEFAULT_LABEL = 0
Global Const $GUI_SS_DEFAULT_GRAPHIC = 0
Global Const $GUI_SS_DEFAULT_ICON = $SS_NOTIFY
Global Const $GUI_SS_DEFAULT_PIC = $SS_NOTIFY
Global Const $STM_SETICON = 0x0170
Global Const $STM_GETICON = 0x0171
Global Const $STM_SETIMAGE = 0x0172
Global Const $STM_GETIMAGE = 0x0173
Global Const $TCS_EX_FLATSEPARATORS = 0x00000001
Global Const $TCS_EX_REGISTERDROP = 0x00000002
Global Const $TCHT_NOWHERE = 0x00000001
Global Const $TCHT_ONITEMICON = 0x00000002
Global Const $TCHT_ONITEMLABEL = 0x00000004
Global Const $TCHT_ONITEM = 0x00000006
Global Const $TCIF_TEXT = 0x00000001
Global Const $TCIF_IMAGE = 0x00000002
Global Const $TCIF_RTLREADING = 0x00000004
Global Const $TCIF_PARAM = 0x00000008
Global Const $TCIF_STATE = 0x00000010
Global Const $TCIF_ALLDATA = 0x0000001B
Global Const $TCIS_BUTTONPRESSED = 0x00000001
Global Const $TCIS_HIGHLIGHTED = 0x00000002
Global Const $TC_ERR = -1
Global Const $TCS_BOTTOM = 0x00000002
Global Const $TCS_BUTTONS = 0x00000100
Global Const $TCS_FIXEDWIDTH = 0x00000400
Global Const $TCS_FLATBUTTONS = 0x00000008
Global Const $TCS_FOCUSNEVER = 0x00008000
Global Const $TCS_FOCUSONBUTTONDOWN = 0x00001000
Global Const $TCS_FORCEICONLEFT = 0x00000010
Global Const $TCS_FORCELABELLEFT = 0x00000020
Global Const $TCS_HOTTRACK = 0x00000040
Global Const $TCS_MULTILINE = 0x00000200
Global Const $TCS_MULTISELECT = 0x00000004
Global Const $TCS_OWNERDRAWFIXED = 0x00002000
Global Const $TCS_RAGGEDRIGHT = 0x00000800
Global Const $TCS_RIGHT = 0x00000002
Global Const $TCS_RIGHTJUSTIFY = 0x00000000
Global Const $TCS_SCROLLOPPOSITE = 0x00000001
Global Const $TCS_SINGLELINE = 0x00000000
Global Const $TCS_TABS = 0x00000000
Global Const $TCS_TOOLTIPS = 0x00004000
Global Const $TCS_VERTICAL = 0x00000080
Global Const $GUI_SS_DEFAULT_TAB = 0
Global Const $TCM_FIRST = 0x1300
Global Const $TCCM_FIRST = 0X2000
Global Const $TCM_ADJUSTRECT = ($TCM_FIRST + 40)
Global Const $TCM_DELETEALLITEMS = ($TCM_FIRST + 9)
Global Const $TCM_DELETEITEM = ($TCM_FIRST + 8)
Global Const $TCM_DESELECTALL = ($TCM_FIRST + 50)
Global Const $TCM_GETCURFOCUS = ($TCM_FIRST + 47)
Global Const $TCM_GETCURSEL = ($TCM_FIRST + 11)
Global Const $TCM_GETEXTENDEDSTYLE = ($TCM_FIRST + 53)
Global Const $TCM_GETIMAGELIST = ($TCM_FIRST + 2)
Global Const $TCM_GETITEMA = ($TCM_FIRST + 5)
Global Const $TCM_GETITEMW = ($TCM_FIRST + 60)
Global Const $TCM_GETITEMCOUNT = ($TCM_FIRST + 4)
Global Const $TCM_GETITEMRECT = ($TCM_FIRST + 10)
Global Const $TCM_GETROWCOUNT = ($TCM_FIRST + 44)
Global Const $TCM_GETTOOLTIPS = ($TCM_FIRST + 45)
Global Const $TCCM_GETUNICODEFORMAT = ($TCCM_FIRST + 6)
Global Const $TCM_GETUNICODEFORMAT = $TCCM_GETUNICODEFORMAT
Global Const $TCM_HIGHLIGHTITEM = ($TCM_FIRST + 51)
Global Const $TCM_HITTEST = ($TCM_FIRST + 13)
Global Const $TCM_INSERTITEMA = ($TCM_FIRST + 7)
Global Const $TCM_INSERTITEMW = ($TCM_FIRST + 62)
Global Const $TCM_REMOVEIMAGE = ($TCM_FIRST + 42)
Global Const $TCM_SETITEMA = ($TCM_FIRST + 6)
Global Const $TCM_SETITEMW = ($TCM_FIRST + 61)
Global Const $TCM_SETITEMEXTRA = ($TCM_FIRST + 14)
Global Const $TCM_SETITEMSIZE = $TCM_FIRST + 41
Global Const $TCM_SETCURFOCUS = ($TCM_FIRST + 48)
Global Const $TCM_SETCURSEL = ($TCM_FIRST + 12)
Global Const $TCM_SETEXTENDEDSTYLE = ($TCM_FIRST + 52)
Global Const $TCM_SETIMAGELIST = $TCM_FIRST + 3
Global Const $TCM_SETMINTABWIDTH = ($TCM_FIRST + 49)
Global Const $TCM_SETPADDING = ($TCM_FIRST + 43)
Global Const $TCM_SETTOOLTIPS = ($TCM_FIRST + 46)
Global Const $TCCM_SETUNICODEFORMAT = ($TCCM_FIRST + 5)
Global Const $TCM_SETUNICODEFORMAT = $TCCM_SETUNICODEFORMAT
Global Const $TCN_FIRST = -550
Global Const $TCN_FOCUSCHANGE = ($TCN_FIRST - 4)
Global Const $TCN_GETOBJECT = ($TCN_FIRST - 3)
Global Const $TCN_KEYDOWN = ($TCN_FIRST - 0)
Global Const $TCN_SELCHANGE = ($TCN_FIRST - 1)
Global Const $TCN_SELCHANGING = ($TCN_FIRST - 2)
Global Const $TVS_HASBUTTONS = 0x00000001
Global Const $TVS_HASLINES = 0x00000002
Global Const $TVS_LINESATROOT = 0x00000004
Global Const $TVS_EDITLABELS = 0x00000008
Global Const $TVS_DISABLEDRAGDROP = 0x00000010
Global Const $TVS_SHOWSELALWAYS = 0x00000020
Global Const $TVS_RTLREADING = 0x00000040
Global Const $TVS_NOTOOLTIPS = 0x00000080
Global Const $TVS_CHECKBOXES = 0x00000100
Global Const $TVS_TRACKSELECT = 0x00000200
Global Const $TVS_SINGLEEXPAND = 0x00000400
Global Const $TVS_INFOTIP = 0x00000800
Global Const $TVS_FULLROWSELECT = 0x00001000
Global Const $TVS_NOSCROLL = 0x00002000
Global Const $TVS_NONEVENHEIGHT = 0x00004000
Global Const $TVS_NOHSCROLL = 0x00008000
Global Const $TVS_DEFAULT = 0x00000037
Global Const $GUI_SS_DEFAULT_TREEVIEW = BitOR($TVS_HASBUTTONS, $TVS_HASLINES, $TVS_LINESATROOT, $TVS_DISABLEDRAGDROP, $TVS_SHOWSELALWAYS)
Global Const $TVE_COLLAPSE = 0x0001
Global Const $TVE_EXPAND = 0x0002
Global Const $TVE_TOGGLE = 0x0003
Global Const $TVE_EXPANDPARTIAL = 0x4000
Global Const $TVE_COLLAPSERESET = 0x8000
Global Const $TVGN_ROOT = 0x00000000
Global Const $TVGN_NEXT = 0x00000001
Global Const $TVGN_PREVIOUS = 0x00000002
Global Const $TVGN_PARENT = 0x00000003
Global Const $TVGN_CHILD = 0x00000004
Global Const $TVGN_FIRSTVISIBLE = 0x00000005
Global Const $TVGN_NEXTVISIBLE = 0x00000006
Global Const $TVGN_PREVIOUSVISIBLE = 0x00000007
Global Const $TVGN_DROPHILITE = 0x00000008
Global Const $TVGN_CARET = 0x00000009
Global Const $TVGN_LASTVISIBLE = 0x0000000A
Global Const $TVHT_NOWHERE = 0x00000001
Global Const $TVHT_ONITEMICON = 0x00000002
Global Const $TVHT_ONITEMLABEL = 0x00000004
Global Const $TVHT_ONITEMINDENT = 0x00000008
Global Const $TVHT_ONITEMBUTTON = 0x00000010
Global Const $TVHT_ONITEMRIGHT = 0x00000020
Global Const $TVHT_ONITEMSTATEICON = 0x00000040
Global Const $TVHT_ONITEM = 0x00000046
Global Const $TVHT_ABOVE = 0x00000100
Global Const $TVHT_BELOW = 0x00000200
Global Const $TVHT_TORIGHT = 0x00000400
Global Const $TVHT_TOLEFT = 0x00000800
Global Const $TVI_ROOT = 0xFFFF0000
Global Const $TVI_FIRST = 0xFFFF0001
Global Const $TVI_LAST = 0xFFFF0002
Global Const $TVI_SORT = 0xFFFF0003
Global Const $TVIF_TEXT = 0x00000001
Global Const $TVIF_IMAGE = 0x00000002
Global Const $TVIF_PARAM = 0x00000004
Global Const $TVIF_STATE = 0x00000008
Global Const $TVIF_HANDLE = 0x00000010
Global Const $TVIF_SELECTEDIMAGE = 0x00000020
Global Const $TVIF_CHILDREN = 0x00000040
Global Const $TVIF_INTEGRAL = 0x00000080
Global Const $TVIF_EXPANDEDIMAGE = 0x00000100
Global Const $TVIF_STATEEX = 0x00000200
Global Const $TVIF_DI_SETITEM = 0x00001000
Global Const $TVSIL_NORMAL = 0
Global Const $TVSIL_STATE = 2
Global Const $TVC_BYKEYBOARD = 0x2
Global Const $TVC_BYMOUSE = 0x1
Global Const $TVC_UNKNOWN = 0x0
Global Const $TVIS_FOCUSED = 0x00000001
Global Const $TVIS_SELECTED = 0x00000002
Global Const $TVIS_CUT = 0x00000004
Global Const $TVIS_DROPHILITED = 0x00000008
Global Const $TVIS_BOLD = 0x00000010
Global Const $TVIS_EXPANDED = 0x00000020
Global Const $TVIS_EXPANDEDONCE = 0x00000040
Global Const $TVIS_EXPANDPARTIAL = 0x00000080
Global Const $TVIS_OVERLAYMASK = 0x00000F00
Global Const $TVIS_STATEIMAGEMASK = 0x0000F000
Global Const $TVIS_USERMASK = 0x0000F000
Global Const $TVIS_UNCHECKED = 4096
Global Const $TVIS_CHECKED = 8192
Global Const $TVNA_ADD = 1
Global Const $TVNA_ADDFIRST = 2
Global Const $TVNA_ADDCHILD = 3
Global Const $TVNA_ADDCHILDFIRST = 4
Global Const $TVNA_INSERT = 5
Global Const $TVTA_ADDFIRST = 1
Global Const $TVTA_ADD = 2
Global Const $TVTA_INSERT = 3
Global Const $TV_FIRST = 0x1100
Global Const $TVM_INSERTITEMA = $TV_FIRST + 0
Global Const $TVM_DELETEITEM = $TV_FIRST + 1
Global Const $TVM_EXPAND = $TV_FIRST + 2
Global Const $TVM_GETITEMRECT = $TV_FIRST + 4
Global Const $TVM_GETCOUNT = $TV_FIRST + 5
Global Const $TVM_GETINDENT = $TV_FIRST + 6
Global Const $TVM_SETINDENT = $TV_FIRST + 7
Global Const $TVM_GETIMAGELIST = $TV_FIRST + 8
Global Const $TVM_SETIMAGELIST = $TV_FIRST + 9
Global Const $TVM_GETNEXTITEM = $TV_FIRST + 10
Global Const $TVM_SELECTITEM = $TV_FIRST + 11
Global Const $TVM_GETITEMA = $TV_FIRST + 12
Global Const $TVM_SETITEMA = $TV_FIRST + 13
Global Const $TVM_EDITLABELA = $TV_FIRST + 14
Global Const $TVM_GETEDITCONTROL = $TV_FIRST + 15
Global Const $TVM_GETVISIBLECOUNT = $TV_FIRST + 16
Global Const $TVM_HITTEST = $TV_FIRST + 17
Global Const $TVM_CREATEDRAGIMAGE = $TV_FIRST + 18
Global Const $TVM_SORTCHILDREN = $TV_FIRST + 19
Global Const $TVM_ENSUREVISIBLE = $TV_FIRST + 20
Global Const $TVM_SORTCHILDRENCB = $TV_FIRST + 21
Global Const $TVM_ENDEDITLABELNOW = $TV_FIRST + 22
Global Const $TVM_GETISEARCHSTRINGA = $TV_FIRST + 23
Global Const $TVM_SETTOOLTIPS = $TV_FIRST + 24
Global Const $TVM_GETTOOLTIPS = $TV_FIRST + 25
Global Const $TVM_SETINSERTMARK = $TV_FIRST + 26
Global Const $TVM_SETITEMHEIGHT = $TV_FIRST + 27
Global Const $TVM_GETITEMHEIGHT = $TV_FIRST + 28
Global Const $TVM_SETBKCOLOR = $TV_FIRST + 29
Global Const $TVM_SETTEXTCOLOR = $TV_FIRST + 30
Global Const $TVM_GETBKCOLOR = $TV_FIRST + 31
Global Const $TVM_GETTEXTCOLOR = $TV_FIRST + 32
Global Const $TVM_SETSCROLLTIME = $TV_FIRST + 33
Global Const $TVM_GETSCROLLTIME = $TV_FIRST + 34
Global Const $TVM_SETINSERTMARKCOLOR = $TV_FIRST + 37
Global Const $TVM_GETINSERTMARKCOLOR = $TV_FIRST + 38
Global Const $TVM_GETITEMSTATE = $TV_FIRST + 39
Global Const $TVM_SETLINECOLOR = $TV_FIRST + 40
Global Const $TVM_GETLINECOLOR = $TV_FIRST + 41
Global Const $TVM_MAPACCIDTOHTREEITEM = $TV_FIRST + 42
Global Const $TVM_MAPHTREEITEMTOACCID = $TV_FIRST + 43
Global Const $TVM_INSERTITEMW = $TV_FIRST + 50
Global Const $TVM_GETITEMW = $TV_FIRST + 62
Global Const $TVM_SETITEMW = $TV_FIRST + 63
Global Const $TVM_GETISEARCHSTRINGW = $TV_FIRST + 64
Global Const $TVM_EDITLABELW = $TV_FIRST + 65
Global Const $TVM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $TVM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $TVN_FIRST = -400
Global Const $TVN_SELCHANGINGA = $TVN_FIRST - 1
Global Const $TVN_SELCHANGEDA = $TVN_FIRST - 2
Global Const $TVN_GETDISPINFOA = $TVN_FIRST - 3
Global Const $TVN_SETDISPINFOA = $TVN_FIRST - 4
Global Const $TVN_ITEMEXPANDINGA = $TVN_FIRST - 5
Global Const $TVN_ITEMEXPANDEDA = $TVN_FIRST - 6
Global Const $TVN_BEGINDRAGA = $TVN_FIRST - 7
Global Const $TVN_BEGINRDRAGA = $TVN_FIRST - 8
Global Const $TVN_DELETEITEMA = $TVN_FIRST - 9
Global Const $TVN_BEGINLABELEDITA = $TVN_FIRST - 10
Global Const $TVN_ENDLABELEDITA = $TVN_FIRST - 11
Global Const $TVN_KEYDOWN = $TVN_FIRST - 12
Global Const $TVN_GETINFOTIPA = $TVN_FIRST - 13
Global Const $TVN_GETINFOTIPW = $TVN_FIRST - 14
Global Const $TVN_SINGLEEXPAND = $TVN_FIRST - 15
Global Const $TVN_ITEMCHANGINGA = $TVN_FIRST - 16
Global Const $TVN_ITEMCHANGINGW = $TVN_FIRST - 17
Global Const $TVN_ITEMCHANGEDA = $TVN_FIRST - 18
Global Const $TVN_ITEMCHANGEDW = $TVN_FIRST - 19
Global Const $TVN_SELCHANGINGW = $TVN_FIRST - 50
Global Const $TVN_SELCHANGEDW = $TVN_FIRST - 51
Global Const $TVN_GETDISPINFOW = $TVN_FIRST - 52
Global Const $TVN_SETDISPINFOW = $TVN_FIRST - 53
Global Const $TVN_ITEMEXPANDINGW = $TVN_FIRST - 54
Global Const $TVN_ITEMEXPANDEDW = $TVN_FIRST - 55
Global Const $TVN_BEGINDRAGW = $TVN_FIRST - 56
Global Const $TVN_BEGINRDRAGW = $TVN_FIRST - 57
Global Const $TVN_DELETEITEMW = $TVN_FIRST - 58
Global Const $TVN_BEGINLABELEDITW = $TVN_FIRST - 59
Global Const $TVN_ENDLABELEDITW = $TVN_FIRST - 60
Global Const $UDS_WRAP = 0x0001
Global Const $UDS_SETBUDDYINT = 0x0002
Global Const $UDS_ALIGNRIGHT = 0x0004
Global Const $UDS_ALIGNLEFT = 0x0008
Global Const $UDS_ARROWKEYS = 0x0020
Global Const $UDS_HORZ = 0x0040
Global Const $UDS_NOTHOUSANDS = 0x0080
Global Const $GUI_SS_DEFAULT_UPDOWN = $UDS_ALIGNLEFT
Global Const $WC_ANIMATE = 'SysAnimate32'
Global Const $WC_BUTTON = 'Button'
Global Const $WC_COMBOBOX = 'ComboBox'
Global Const $WC_COMBOBOXEX = 'ComboBoxEx32'
Global Const $WC_DATETIMEPICK = 'SysDateTimePick32'
Global Const $WC_EDIT = 'Edit'
Global Const $WC_HEADER = 'SysHeader32'
Global Const $WC_HOTKEY = 'msctls_hotkey32'
Global Const $WC_IPADDRESS = 'SysIPAddress32'
Global Const $WC_LINK = 'SysLink'
Global Const $WC_LISTBOX = 'ListBox'
Global Const $WC_LISTVIEW = 'SysListView32'
Global Const $WC_MONTHCAL = 'SysMonthCal32'
Global Const $WC_NATIVEFONTCTL = 'NativeFontCtl'
Global Const $WC_PAGESCROLLER = 'SysPager'
Global Const $WC_PROGRESS = 'msctls_progress32'
Global Const $WC_REBAR = 'ReBarWindow32'
Global Const $WC_SCROLLBAR = 'ScrollBar'
Global Const $WC_STATIC = 'Static'
Global Const $WC_STATUSBAR = 'msctls_statusbar32'
Global Const $WC_TABCONTROL = 'SysTabControl32'
Global Const $WC_TOOLBAR = 'ToolbarWindow32'
Global Const $WC_TOOLTIPS = 'tooltips_class32'
Global Const $WC_TRACKBAR = 'msctls_trackbar32'
Global Const $WC_TREEVIEW = 'SysTreeView32'
Global Const $WC_UPDOWN = 'msctls_updown32'
Global Const $WS_OVERLAPPED = 0
Global Const $WS_TILED = $WS_OVERLAPPED
Global Const $WS_MAXIMIZEBOX = 0x00010000
Global Const $WS_MINIMIZEBOX = 0x00020000
Global Const $WS_TABSTOP = 0x00010000
Global Const $WS_GROUP = 0x00020000
Global Const $WS_SIZEBOX = 0x00040000
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 0x00080000
Global Const $WS_HSCROLL = 0x00100000
Global Const $WS_VSCROLL = 0x00200000
Global Const $WS_DLGFRAME = 0x00400000
Global Const $WS_BORDER = 0x00800000
Global Const $WS_CAPTION = 0x00C00000
Global Const $WS_OVERLAPPEDWINDOW = BitOR($WS_CAPTION, $WS_MAXIMIZEBOX, $WS_MINIMIZEBOX, $WS_OVERLAPPED, $WS_SYSMENU, $WS_THICKFRAME)
Global Const $WS_TILEDWINDOW = $WS_OVERLAPPEDWINDOW
Global Const $WS_MAXIMIZE = 0x01000000
Global Const $WS_CLIPCHILDREN = 0x02000000
Global Const $WS_CLIPSIBLINGS = 0x04000000
Global Const $WS_DISABLED = 0x08000000
Global Const $WS_VISIBLE = 0x10000000
Global Const $WS_MINIMIZE = 0x20000000
Global Const $WS_ICONIC = $WS_MINIMIZE
Global Const $WS_CHILD = 0x40000000
Global Const $WS_CHILDWINDOW = $WS_CHILD
Global Const $WS_POPUP = 0x80000000
Global Const $WS_POPUPWINDOW = 0x80880000
Global Const $DS_3DLOOK = 0x0004
Global Const $DS_ABSALIGN = 0x0001
Global Const $DS_CENTER = 0x0800
Global Const $DS_CENTERMOUSE = 0x1000
Global Const $DS_CONTEXTHELP = 0x2000
Global Const $DS_CONTROL = 0x0400
Global Const $DS_FIXEDSYS = 0x0008
Global Const $DS_LOCALEDIT = 0x0020
Global Const $DS_MODALFRAME = 0x0080
Global Const $DS_NOFAILCREATE = 0x0010
Global Const $DS_NOIDLEMSG = 0x0100
Global Const $DS_SETFONT = 0x0040
Global Const $DS_SETFOREGROUND = 0x0200
Global Const $DS_SHELLFONT = BitOR($DS_FIXEDSYS, $DS_SETFONT)
Global Const $DS_SYSMODAL = 0x0002
Global Const $WS_EX_ACCEPTFILES = 0x00000010
Global Const $WS_EX_APPWINDOW = 0x00040000
Global Const $WS_EX_COMPOSITED = 0x02000000
Global Const $WS_EX_CONTROLPARENT = 0x10000
Global Const $WS_EX_CLIENTEDGE = 0x00000200
Global Const $WS_EX_CONTEXTHELP = 0x00000400
Global Const $WS_EX_DLGMODALFRAME = 0x00000001
Global Const $WS_EX_LAYERED = 0x00080000
Global Const $WS_EX_LAYOUTRTL = 0x400000
Global Const $WS_EX_LEFT = 0x00000000
Global Const $WS_EX_LEFTSCROLLBAR = 0x00004000
Global Const $WS_EX_LTRREADING = 0x00000000
Global Const $WS_EX_MDICHILD = 0x00000040
Global Const $WS_EX_NOACTIVATE = 0x08000000
Global Const $WS_EX_NOINHERITLAYOUT = 0x00100000
Global Const $WS_EX_NOPARENTNOTIFY = 0x00000004
Global Const $WS_EX_RIGHT = 0x00001000
Global Const $WS_EX_RIGHTSCROLLBAR = 0x00000000
Global Const $WS_EX_RTLREADING = 0x2000
Global Const $WS_EX_STATICEDGE = 0x00020000
Global Const $WS_EX_TOOLWINDOW = 0x00000080
Global Const $WS_EX_TOPMOST = 0x00000008
Global Const $WS_EX_TRANSPARENT = 0x00000020
Global Const $WS_EX_WINDOWEDGE = 0x00000100
Global Const $WS_EX_OVERLAPPEDWINDOW = BitOR($WS_EX_CLIENTEDGE, $WS_EX_WINDOWEDGE)
Global Const $WS_EX_PALETTEWINDOW = BitOR($WS_EX_TOOLWINDOW, $WS_EX_TOPMOST, $WS_EX_WINDOWEDGE)
Global Const $WM_NULL = 0x0000
Global Const $WM_CREATE = 0x0001
Global Const $WM_DESTROY = 0x0002
Global Const $WM_MOVE = 0x0003
Global Const $WM_SIZEWAIT = 0x0004
Global Const $WM_SIZE = 0x0005
Global Const $WM_ACTIVATE = 0x0006
Global Const $WM_SETFOCUS = 0x0007
Global Const $WM_KILLFOCUS = 0x0008
Global Const $WM_SETVISIBLE = 0x0009
Global Const $WM_ENABLE = 0x000A
Global Const $WM_SETREDRAW = 0x000B
Global Const $WM_SETTEXT = 0x000C
Global Const $WM_GETTEXT = 0x000D
Global Const $WM_GETTEXTLENGTH = 0x000E
Global Const $WM_PAINT = 0x000F
Global Const $WM_CLOSE = 0x0010
Global Const $WM_QUERYENDSESSION = 0x0011
Global Const $WM_QUIT = 0x0012
Global Const $WM_ERASEBKGND = 0x0014
Global Const $WM_QUERYOPEN = 0x0013
Global Const $WM_SYSCOLORCHANGE = 0x0015
Global Const $WM_ENDSESSION = 0x0016
Global Const $WM_SYSTEMERROR = 0x0017
Global Const $WM_SHOWWINDOW = 0x0018
Global Const $WM_CTLCOLOR = 0x0019
Global Const $WM_SETTINGCHANGE = 0x001A
Global Const $WM_WININICHANGE = 0x001A
Global Const $WM_DEVMODECHANGE = 0x001B
Global Const $WM_ACTIVATEAPP = 0x001C
Global Const $WM_FONTCHANGE = 0x001D
Global Const $WM_TIMECHANGE = 0x001E
Global Const $WM_CANCELMODE = 0x001F
Global Const $WM_SETCURSOR = 0x0020
Global Const $WM_MOUSEACTIVATE = 0x0021
Global Const $WM_CHILDACTIVATE = 0x0022
Global Const $WM_QUEUESYNC = 0x0023
Global Const $WM_GETMINMAXINFO = 0x0024
Global Const $WM_LOGOFF = 0x0025
Global Const $WM_PAINTICON = 0x0026
Global Const $WM_ICONERASEBKGND = 0x0027
Global Const $WM_NEXTDLGCTL = 0x0028
Global Const $WM_ALTTABACTIVE = 0x0029
Global Const $WM_SPOOLERSTATUS = 0x002A
Global Const $WM_DRAWITEM = 0x002B
Global Const $WM_MEASUREITEM = 0x002C
Global Const $WM_DELETEITEM = 0x002D
Global Const $WM_VKEYTOITEM = 0x002E
Global Const $WM_CHARTOITEM = 0x002F
Global Const $WM_SETFONT = 0x0030
Global Const $WM_GETFONT = 0x0031
Global Const $WM_SETHOTKEY = 0x0032
Global Const $WM_GETHOTKEY = 0x0033
Global Const $WM_FILESYSCHANGE = 0x0034
Global Const $WM_ISACTIVEICON = 0x0035
Global Const $WM_QUERYPARKICON = 0x0036
Global Const $WM_QUERYDRAGICON = 0x0037
Global Const $WM_WINHELP = 0x0038
Global Const $WM_COMPAREITEM = 0x0039
Global Const $WM_FULLSCREEN = 0x003A
Global Const $WM_CLIENTSHUTDOWN = 0x003B
Global Const $WM_DDEMLEVENT = 0x003C
Global Const $WM_GETOBJECT = 0x003D
Global Const $WM_CALCSCROLL = 0x003F
Global Const $WM_TESTING = 0x0040
Global Const $WM_COMPACTING = 0x0041
Global Const $WM_OTHERWINDOWCREATED = 0x0042
Global Const $WM_OTHERWINDOWDESTROYED = 0x0043
Global Const $WM_COMMNOTIFY = 0x0044
Global Const $WM_MEDIASTATUSCHANGE = 0x0045
Global Const $WM_WINDOWPOSCHANGING = 0x0046
Global Const $WM_WINDOWPOSCHANGED = 0x0047
Global Const $WM_POWER = 0x0048
Global Const $WM_COPYGLOBALDATA = 0x0049
Global Const $WM_COPYDATA = 0x004A
Global Const $WM_CANCELJOURNAL = 0x004B
Global Const $WM_LOGONNOTIFY = 0x004C
Global Const $WM_KEYF1 = 0x004D
Global Const $WM_NOTIFY = 0x004E
Global Const $WM_ACCESS_WINDOW = 0x004F
Global Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
Global Const $WM_INPUTLANGCHANGE = 0x0051
Global Const $WM_TCARD = 0x0052
Global Const $WM_HELP = 0x0053
Global Const $WM_USERCHANGED = 0x0054
Global Const $WM_NOTIFYFORMAT = 0x0055
Global Const $WM_QM_ACTIVATE = 0x0060
Global Const $WM_HOOK_DO_CALLBACK = 0x0061
Global Const $WM_SYSCOPYDATA = 0x0062
Global Const $WM_FINALDESTROY = 0x0070
Global Const $WM_MEASUREITEM_CLIENTDATA = 0x0071
Global Const $WM_CONTEXTMENU = 0x007B
Global Const $WM_STYLECHANGING = 0x007C
Global Const $WM_STYLECHANGED = 0x007D
Global Const $WM_DISPLAYCHANGE = 0x007E
Global Const $WM_GETICON = 0x007F
Global Const $WM_SETICON = 0x0080
Global Const $WM_NCCREATE = 0x0081
Global Const $WM_NCDESTROY = 0x0082
Global Const $WM_NCCALCSIZE = 0x0083
Global Const $WM_NCHITTEST = 0x0084
Global Const $WM_NCPAINT = 0x0085
Global Const $WM_NCACTIVATE = 0x0086
Global Const $WM_GETDLGCODE = 0x0087
Global Const $WM_SYNCPAINT = 0x0088
Global Const $WM_SYNCTASK = 0x0089
Global Const $WM_KLUDGEMINRECT = 0x008B
Global Const $WM_LPKDRAWSWITCHWND = 0x008C
Global Const $WM_UAHDESTROYWINDOW = 0x0090
Global Const $WM_UAHDRAWMENU = 0x0091
Global Const $WM_UAHDRAWMENUITEM = 0x0092
Global Const $WM_UAHINITMENU = 0x0093
Global Const $WM_UAHMEASUREMENUITEM = 0x0094
Global Const $WM_UAHNCPAINTMENUPOPUP = 0x0095
Global Const $WM_NCMOUSEMOVE = 0x00A0
Global Const $WM_NCLBUTTONDOWN = 0x00A1
Global Const $WM_NCLBUTTONUP = 0x00A2
Global Const $WM_NCLBUTTONDBLCLK = 0x00A3
Global Const $WM_NCRBUTTONDOWN = 0x00A4
Global Const $WM_NCRBUTTONUP = 0x00A5
Global Const $WM_NCRBUTTONDBLCLK = 0x00A6
Global Const $WM_NCMBUTTONDOWN = 0x00A7
Global Const $WM_NCMBUTTONUP = 0x00A8
Global Const $WM_NCMBUTTONDBLCLK = 0x00A9
Global Const $WM_NCXBUTTONDOWN = 0x00AB
Global Const $WM_NCXBUTTONUP = 0x00AC
Global Const $WM_NCXBUTTONDBLCLK = 0x00AD
Global Const $WM_NCUAHDRAWCAPTION = 0x00AE
Global Const $WM_NCUAHDRAWFRAME = 0x00AF
Global Const $WM_INPUT_DEVICE_CHANGE = 0x00FE
Global Const $WM_INPUT = 0x00FF
Global Const $WM_KEYDOWN = 0x0100
Global Const $WM_KEYFIRST = 0x0100
Global Const $WM_KEYUP = 0x0101
Global Const $WM_CHAR = 0x0102
Global Const $WM_DEADCHAR = 0x0103
Global Const $WM_SYSKEYDOWN = 0x0104
Global Const $WM_SYSKEYUP = 0x0105
Global Const $WM_SYSCHAR = 0x0106
Global Const $WM_SYSDEADCHAR = 0x0107
Global Const $WM_YOMICHAR = 0x0108
Global Const $WM_KEYLAST = 0x0109
Global Const $WM_UNICHAR = 0x0109
Global Const $WM_CONVERTREQUEST = 0x010A
Global Const $WM_CONVERTRESULT = 0x010B
Global Const $WM_IM_INFO = 0x010C
Global Const $WM_IME_STARTCOMPOSITION = 0x010D
Global Const $WM_IME_ENDCOMPOSITION = 0x010E
Global Const $WM_IME_COMPOSITION = 0x010F
Global Const $WM_IME_KEYLAST = 0x010F
Global Const $WM_INITDIALOG = 0x0110
Global Const $WM_COMMAND = 0x0111
Global Const $WM_SYSCOMMAND = 0x0112
Global Const $WM_TIMER = 0x0113
Global Const $WM_HSCROLL = 0x0114
Global Const $WM_VSCROLL = 0x0115
Global Const $WM_INITMENU = 0x0116
Global Const $WM_INITMENUPOPUP = 0x0117
Global Const $WM_SYSTIMER = 0x0118
Global Const $WM_GESTURE = 0x0119
Global Const $WM_GESTURENOTIFY = 0x011A
Global Const $WM_GESTUREINPUT = 0x011B
Global Const $WM_GESTURENOTIFIED = 0x011C
Global Const $WM_MENUSELECT = 0x011F
Global Const $WM_MENUCHAR = 0x0120
Global Const $WM_ENTERIDLE = 0x0121
Global Const $WM_MENURBUTTONUP = 0x0122
Global Const $WM_MENUDRAG = 0x0123
Global Const $WM_MENUGETOBJECT = 0x0124
Global Const $WM_UNINITMENUPOPUP = 0x0125
Global Const $WM_MENUCOMMAND = 0x0126
Global Const $WM_CHANGEUISTATE = 0x0127
Global Const $WM_UPDATEUISTATE = 0x0128
Global Const $WM_QUERYUISTATE = 0x0129
Global Const $WM_LBTRACKPOINT = 0x0131
Global Const $WM_CTLCOLORMSGBOX = 0x0132
Global Const $WM_CTLCOLOREDIT = 0x0133
Global Const $WM_CTLCOLORLISTBOX = 0x0134
Global Const $WM_CTLCOLORBTN = 0x0135
Global Const $WM_CTLCOLORDLG = 0x0136
Global Const $WM_CTLCOLORSCROLLBAR = 0x0137
Global Const $WM_CTLCOLORSTATIC = 0x0138
Global Const $MN_GETHMENU = 0x01E1
Global Const $WM_PARENTNOTIFY = 0x0210
Global Const $WM_ENTERMENULOOP = 0x0211
Global Const $WM_EXITMENULOOP = 0x0212
Global Const $WM_NEXTMENU = 0x0213
Global Const $WM_SIZING = 0x0214
Global Const $WM_CAPTURECHANGED = 0x0215
Global Const $WM_MOVING = 0x0216
Global Const $WM_POWERBROADCAST = 0x0218
Global Const $WM_DEVICECHANGE = 0x0219
Global Const $WM_MDICREATE = 0x0220
Global Const $WM_MDIDESTROY = 0x0221
Global Const $WM_MDIACTIVATE = 0x0222
Global Const $WM_MDIRESTORE = 0x0223
Global Const $WM_MDINEXT = 0x0224
Global Const $WM_MDIMAXIMIZE = 0x0225
Global Const $WM_MDITILE = 0x0226
Global Const $WM_MDICASCADE = 0x0227
Global Const $WM_MDIICONARRANGE = 0x0228
Global Const $WM_MDIGETACTIVE = 0x0229
Global Const $WM_DROPOBJECT = 0x022A
Global Const $WM_QUERYDROPOBJECT = 0x022B
Global Const $WM_BEGINDRAG = 0x022C
Global Const $WM_DRAGLOOP = 0x022D
Global Const $WM_DRAGSELECT = 0x022E
Global Const $WM_DRAGMOVE = 0x022F
Global Const $WM_MDISETMENU = 0x0230
Global Const $WM_ENTERSIZEMOVE = 0x0231
Global Const $WM_EXITSIZEMOVE = 0x0232
Global Const $WM_DROPFILES = 0x0233
Global Const $WM_MDIREFRESHMENU = 0x0234
Global Const $WM_TOUCH = 0x0240
Global Const $WM_IME_SETCONTEXT = 0x0281
Global Const $WM_IME_NOTIFY = 0x0282
Global Const $WM_IME_CONTROL = 0x0283
Global Const $WM_IME_COMPOSITIONFULL = 0x0284
Global Const $WM_IME_SELECT = 0x0285
Global Const $WM_IME_CHAR = 0x0286
Global Const $WM_IME_SYSTEM = 0x0287
Global Const $WM_IME_REQUEST = 0x0288
Global Const $WM_IME_KEYDOWN = 0x0290
Global Const $WM_IME_KEYUP = 0x0291
Global Const $WM_NCMOUSEHOVER = 0x02A0
Global Const $WM_MOUSEHOVER = 0x02A1
Global Const $WM_NCMOUSELEAVE = 0x02A2
Global Const $WM_MOUSELEAVE = 0x02A3
Global Const $WM_WTSSESSION_CHANGE = 0x02B1
Global Const $WM_TABLET_FIRST = 0x02C0
Global Const $WM_TABLET_LAST = 0x02DF
Global Const $WM_CUT = 0x0300
Global Const $WM_COPY = 0x0301
Global Const $WM_PASTE = 0x0302
Global Const $WM_CLEAR = 0x0303
Global Const $WM_UNDO = 0x0304
Global Const $WM_PALETTEISCHANGING = 0x0310
Global Const $WM_HOTKEY = 0x0312
Global Const $WM_PALETTECHANGED = 0x0311
Global Const $WM_SYSMENU = 0x0313
Global Const $WM_HOOKMSG = 0x0314
Global Const $WM_EXITPROCESS = 0x0315
Global Const $WM_WAKETHREAD = 0x0316
Global Const $WM_PRINT = 0x0317
Global Const $WM_PRINTCLIENT = 0x0318
Global Const $WM_APPCOMMAND = 0x0319
Global Const $WM_QUERYNEWPALETTE = 0x030F
Global Const $WM_THEMECHANGED = 0x031A
Global Const $WM_UAHINIT = 0x031B
Global Const $WM_DESKTOPNOTIFY = 0x031C
Global Const $WM_CLIPBOARDUPDATE = 0x031D
Global Const $WM_DWMCOMPOSITIONCHANGED = 0x031E
Global Const $WM_DWMNCRENDERINGCHANGED = 0x031F
Global Const $WM_DWMCOLORIZATIONCOLORCHANGED = 0x0320
Global Const $WM_DWMWINDOWMAXIMIZEDCHANGE = 0x0321
Global Const $WM_DWMEXILEFRAME = 0x0322
Global Const $WM_DWMSENDICONICTHUMBNAIL = 0x0323
Global Const $WM_MAGNIFICATION_STARTED = 0x0324
Global Const $WM_MAGNIFICATION_ENDED = 0x0325
Global Const $WM_DWMSENDICONICLIVEPREVIEWBITMAP = 0x0326
Global Const $WM_DWMTHUMBNAILSIZECHANGED = 0x0327
Global Const $WM_MAGNIFICATION_OUTPUT = 0x0328
Global Const $WM_MEASURECONTROL = 0x0330
Global Const $WM_GETACTIONTEXT = 0x0331
Global Const $WM_FORWARDKEYDOWN = 0x0333
Global Const $WM_FORWARDKEYUP = 0x0334
Global Const $WM_GETTITLEBARINFOEX = 0x033F
Global Const $WM_NOTIFYWOW = 0x0340
Global Const $WM_HANDHELDFIRST = 0x0358
Global Const $WM_HANDHELDLAST = 0x035F
Global Const $WM_AFXFIRST = 0x0360
Global Const $WM_AFXLAST = 0x037F
Global Const $WM_PENWINFIRST = 0x0380
Global Const $WM_PENWINLAST = 0x038F
Global Const $WM_DDE_INITIATE = 0x03E0
Global Const $WM_DDE_TERMINATE = 0x03E1
Global Const $WM_DDE_ADVISE = 0x03E2
Global Const $WM_DDE_UNADVISE = 0x03E3
Global Const $WM_DDE_ACK = 0x03E4
Global Const $WM_DDE_DATA = 0x03E5
Global Const $WM_DDE_REQUEST = 0x03E6
Global Const $WM_DDE_POKE = 0x03E7
Global Const $WM_DDE_EXECUTE = 0x03E8
Global Const $WM_DBNOTIFICATION = 0x03FD
Global Const $WM_NETCONNECT = 0x03FE
Global Const $WM_HIBERNATE = 0x03FF
Global Const $WM_USER = 0x0400
Global Const $WM_APP = 0x8000
Global Const $NM_FIRST = 0
Global Const $NM_OUTOFMEMORY = $NM_FIRST - 1
Global Const $NM_CLICK = $NM_FIRST - 2
Global Const $NM_DBLCLK = $NM_FIRST - 3
Global Const $NM_RETURN = $NM_FIRST - 4
Global Const $NM_RCLICK = $NM_FIRST - 5
Global Const $NM_RDBLCLK = $NM_FIRST - 6
Global Const $NM_SETFOCUS = $NM_FIRST - 7
Global Const $NM_KILLFOCUS = $NM_FIRST - 8
Global Const $NM_CUSTOMDRAW = $NM_FIRST - 12
Global Const $NM_HOVER = $NM_FIRST - 13
Global Const $NM_NCHITTEST = $NM_FIRST - 14
Global Const $NM_KEYDOWN = $NM_FIRST - 15
Global Const $NM_RELEASEDCAPTURE = $NM_FIRST - 16
Global Const $NM_SETCURSOR = $NM_FIRST - 17
Global Const $NM_CHAR = $NM_FIRST - 18
Global Const $NM_TOOLTIPSCREATED = $NM_FIRST - 19
Global Const $NM_LDOWN = $NM_FIRST - 20
Global Const $NM_RDOWN = $NM_FIRST - 21
Global Const $NM_THEMECHANGED = $NM_FIRST - 22
Global Const $WM_MOUSEFIRST = 0x0200
Global Const $WM_MOUSEMOVE = 0x0200
Global Const $WM_LBUTTONDOWN = 0x0201
Global Const $WM_LBUTTONUP = 0x0202
Global Const $WM_LBUTTONDBLCLK = 0x0203
Global Const $WM_RBUTTONDOWN = 0x0204
Global Const $WM_RBUTTONUP = 0x0205
Global Const $WM_RBUTTONDBLCLK = 0x0206
Global Const $WM_MBUTTONDOWN = 0x0207
Global Const $WM_MBUTTONUP = 0x0208
Global Const $WM_MBUTTONDBLCLK = 0x0209
Global Const $WM_MOUSEWHEEL = 0x020A
Global Const $WM_XBUTTONDOWN = 0x020B
Global Const $WM_XBUTTONUP = 0x020C
Global Const $WM_XBUTTONDBLCLK = 0x020D
Global Const $WM_MOUSEHWHEEL = 0x020E
Global Const $PS_SOLID = 0
Global Const $PS_DASH = 1
Global Const $PS_DOT = 2
Global Const $PS_DASHDOT = 3
Global Const $PS_DASHDOTDOT = 4
Global Const $PS_NULL = 5
Global Const $PS_INSIDEFRAME = 6
Global Const $PS_USERSTYLE = 7
Global Const $PS_ALTERNATE = 8
Global Const $PS_ENDCAP_ROUND = 0x00000000
Global Const $PS_ENDCAP_SQUARE = 0x00000100
Global Const $PS_ENDCAP_FLAT = 0x00000200
Global Const $PS_JOIN_BEVEL = 0x00001000
Global Const $PS_JOIN_MITER = 0x00002000
Global Const $PS_JOIN_ROUND = 0x00000000
Global Const $PS_GEOMETRIC = 0x00010000
Global Const $PS_COSMETIC = 0x00000000
Global Const $LWA_ALPHA = 0x2
Global Const $LWA_COLORKEY = 0x1
Global Const $RGN_AND = 1
Global Const $RGN_OR = 2
Global Const $RGN_XOR = 3
Global Const $RGN_DIFF = 4
Global Const $RGN_COPY = 5
Global Const $ERRORREGION = 0
Global Const $NULLREGION = 1
Global Const $SIMPLEREGION = 2
Global Const $COMPLEXREGION = 3
Global Const $TRANSPARENT = 1
Global Const $OPAQUE = 2
Global Const $CCM_FIRST = 0x2000
Global Const $CCM_GETUNICODEFORMAT = ($CCM_FIRST + 6)
Global Const $CCM_SETUNICODEFORMAT = ($CCM_FIRST + 5)
Global Const $CCM_SETBKCOLOR = $CCM_FIRST + 1
Global Const $CCM_SETCOLORSCHEME = $CCM_FIRST + 2
Global Const $CCM_GETCOLORSCHEME = $CCM_FIRST + 3
Global Const $CCM_GETDROPTARGET = $CCM_FIRST + 4
Global Const $CCM_SETWINDOWTHEME = $CCM_FIRST + 11
Global Const $GA_PARENT = 1
Global Const $GA_ROOT = 2
Global Const $GA_ROOTOWNER = 3
Global Const $SM_CXSCREEN = 0
Global Const $SM_CYSCREEN = 1
Global Const $SM_CXVSCROLL = 2
Global Const $SM_CYHSCROLL = 3
Global Const $SM_CYCAPTION = 4
Global Const $SM_CXBORDER = 5
Global Const $SM_CYBORDER = 6
Global Const $SM_CXFIXEDFRAME = 7
Global Const $SM_CXDLGFRAME = $SM_CXFIXEDFRAME
Global Const $SM_CYFIXEDFRAME = 8
Global Const $SM_CYDLGFRAME = $SM_CYFIXEDFRAME
Global Const $SM_CYVTHUMB = 9
Global Const $SM_CXHTHUMB = 10
Global Const $SM_CXICON = 11
Global Const $SM_CYICON = 12
Global Const $SM_CXCURSOR = 13
Global Const $SM_CYCURSOR = 14
Global Const $SM_CYMENU = 15
Global Const $SM_CXFULLSCREEN = 16
Global Const $SM_CYFULLSCREEN = 17
Global Const $SM_CYKANJIWINDOW = 18
Global Const $SM_MOUSEPRESENT = 19
Global Const $SM_CYVSCROLL = 20
Global Const $SM_CXHSCROLL = 21
Global Const $SM_DEBUG = 22
Global Const $SM_SWAPBUTTON = 23
Global Const $SM_RESERVED1 = 24
Global Const $SM_RESERVED2 = 25
Global Const $SM_RESERVED3 = 26
Global Const $SM_RESERVED4 = 27
Global Const $SM_CXMIN = 28
Global Const $SM_CYMIN = 29
Global Const $SM_CXSIZE = 30
Global Const $SM_CYSIZE = 31
Global Const $SM_CXSIZEFRAME = 32
Global Const $SM_CXFRAME = $SM_CXSIZEFRAME
Global Const $SM_CYSIZEFRAME = 33
Global Const $SM_CYFRAME = $SM_CYSIZEFRAME
Global Const $SM_CXMINTRACK = 34
Global Const $SM_CYMINTRACK = 35
Global Const $SM_CXDOUBLECLK = 36
Global Const $SM_CYDOUBLECLK = 37
Global Const $SM_CXICONSPACING = 38
Global Const $SM_CYICONSPACING = 39
Global Const $SM_MENUDROPALIGNMENT = 40
Global Const $SM_PENWINDOWS = 41
Global Const $SM_DBCSENABLED = 42
Global Const $SM_CMOUSEBUTTONS = 43
Global Const $SM_SECURE = 44
Global Const $SM_CXEDGE = 45
Global Const $SM_CYEDGE = 46
Global Const $SM_CXMINSPACING = 47
Global Const $SM_CYMINSPACING = 48
Global Const $SM_CXSMICON = 49
Global Const $SM_CYSMICON = 50
Global Const $SM_CYSMCAPTION = 51
Global Const $SM_CXSMSIZE = 52
Global Const $SM_CYSMSIZE = 53
Global Const $SM_CXMENUSIZE = 54
Global Const $SM_CYMENUSIZE = 55
Global Const $SM_ARRANGE = 56
Global Const $SM_CXMINIMIZED = 57
Global Const $SM_CYMINIMIZED = 58
Global Const $SM_CXMAXTRACK = 59
Global Const $SM_CYMAXTRACK = 60
Global Const $SM_CXMAXIMIZED = 61
Global Const $SM_CYMAXIMIZED = 62
Global Const $SM_NETWORK = 63
Global Const $SM_CLEANBOOT = 67
Global Const $SM_CXDRAG = 68
Global Const $SM_CYDRAG = 69
Global Const $SM_SHOWSOUNDS = 70
Global Const $SM_CXMENUCHECK = 71
Global Const $SM_CYMENUCHECK = 72
Global Const $SM_SLOWMACHINE = 73
Global Const $SM_MIDEASTENABLED = 74
Global Const $SM_MOUSEWHEELPRESENT = 75
Global Const $SM_XVIRTUALSCREEN = 76
Global Const $SM_YVIRTUALSCREEN = 77
Global Const $SM_CXVIRTUALSCREEN = 78
Global Const $SM_CYVIRTUALSCREEN = 79
Global Const $SM_CMONITORS = 80
Global Const $SM_SAMEDISPLAYFORMAT = 81
Global Const $SM_IMMENABLED = 82
Global Const $SM_CXFOCUSBORDER = 83
Global Const $SM_CYFOCUSBORDER = 84
Global Const $SM_TABLETPC = 86
Global Const $SM_MEDIACENTER = 87
Global Const $SM_STARTER = 88
Global Const $SM_SERVERR2 = 89
Global Const $SM_CMETRICS = 90
Global Const $SM_REMOTESESSION = 0x1000
Global Const $SM_SHUTTINGDOWN = 0x2000
Global Const $SM_REMOTECONTROL = 0x2001
Global Const $SM_CARETBLINKINGENABLED = 0x2002
Global Const $BLACKNESS = 0x00000042
Global Const $CAPTUREBLT = 0X40000000
Global Const $DSTINVERT = 0x00550009
Global Const $MERGECOPY = 0x00C000CA
Global Const $MERGEPAINT = 0x00BB0226
Global Const $NOMIRRORBITMAP = 0X80000000
Global Const $NOTSRCCOPY = 0x00330008
Global Const $NOTSRCERASE = 0x001100A6
Global Const $PATCOPY = 0x00F00021
Global Const $PATINVERT = 0x005A0049
Global Const $PATPAINT = 0x00FB0A09
Global Const $SRCAND = 0x008800C6
Global Const $SRCCOPY = 0x00CC0020
Global Const $SRCERASE = 0x00440328
Global Const $SRCINVERT = 0x00660046
Global Const $SRCPAINT = 0x00EE0086
Global Const $WHITENESS = 0x00FF0062
Global Const $DT_BOTTOM = 0x8
Global Const $DT_CALCRECT = 0x400
Global Const $DT_CENTER = 0x1
Global Const $DT_EDITCONTROL = 0x2000
Global Const $DT_END_ELLIPSIS = 0x8000
Global Const $DT_EXPANDTABS = 0x40
Global Const $DT_EXTERNALLEADING = 0x200
Global Const $DT_HIDEPREFIX = 0x100000
Global Const $DT_INTERNAL = 0x1000
Global Const $DT_LEFT = 0x0
Global Const $DT_MODIFYSTRING = 0x10000
Global Const $DT_NOCLIP = 0x100
Global Const $DT_NOFULLWIDTHCHARBREAK = 0x80000
Global Const $DT_NOPREFIX = 0x800
Global Const $DT_PATH_ELLIPSIS = 0x4000
Global Const $DT_PREFIXONLY = 0x200000
Global Const $DT_RIGHT = 0x2
Global Const $DT_RTLREADING = 0x20000
Global Const $DT_SINGLELINE = 0x20
Global Const $DT_TABSTOP = 0x80
Global Const $DT_TOP = 0x0
Global Const $DT_VCENTER = 0x4
Global Const $DT_WORDBREAK = 0x10
Global Const $DT_WORD_ELLIPSIS = 0x40000
Global Const $RDW_ERASE = 0x0004
Global Const $RDW_FRAME = 0x0400
Global Const $RDW_INTERNALPAINT = 0x0002
Global Const $RDW_INVALIDATE = 0x0001
Global Const $RDW_NOERASE = 0x0020
Global Const $RDW_NOFRAME = 0x0800
Global Const $RDW_NOINTERNALPAINT = 0x0010
Global Const $RDW_VALIDATE = 0x0008
Global Const $RDW_ERASENOW = 0x0200
Global Const $RDW_UPDATENOW = 0x0100
Global Const $RDW_ALLCHILDREN = 0x0080
Global Const $RDW_NOCHILDREN = 0x0040
Global Const $WM_RENDERFORMAT = 0x0305
Global Const $WM_RENDERALLFORMATS = 0x0306
Global Const $WM_DESTROYCLIPBOARD = 0x0307
Global Const $WM_DRAWCLIPBOARD = 0x0308
Global Const $WM_PAINTCLIPBOARD = 0x0309
Global Const $WM_VSCROLLCLIPBOARD = 0x030A
Global Const $WM_SIZECLIPBOARD = 0x030B
Global Const $WM_ASKCBFORMATNAME = 0x030C
Global Const $WM_CHANGECBCHAIN = 0x030D
Global Const $WM_HSCROLLCLIPBOARD = 0x030E
Global Const $HTERROR = -2
Global Const $HTTRANSPARENT = -1
Global Const $HTNOWHERE = 0
Global Const $HTCLIENT = 1
Global Const $HTCAPTION = 2
Global Const $HTSYSMENU = 3
Global Const $HTGROWBOX = 4
Global Const $HTSIZE = $HTGROWBOX
Global Const $HTMENU = 5
Global Const $HTHSCROLL = 6
Global Const $HTVSCROLL = 7
Global Const $HTMINBUTTON = 8
Global Const $HTMAXBUTTON = 9
Global Const $HTLEFT = 10
Global Const $HTRIGHT = 11
Global Const $HTTOP = 12
Global Const $HTTOPLEFT = 13
Global Const $HTTOPRIGHT = 14
Global Const $HTBOTTOM = 15
Global Const $HTBOTTOMLEFT = 16
Global Const $HTBOTTOMRIGHT = 17
Global Const $HTBORDER = 18
Global Const $HTREDUCE = $HTMINBUTTON
Global Const $HTZOOM = $HTMAXBUTTON
Global Const $HTSIZEFIRST = $HTLEFT
Global Const $HTSIZELAST = $HTBOTTOMRIGHT
Global Const $HTOBJECT = 19
Global Const $HTCLOSE = 20
Global Const $HTHELP = 21
Global Const $COLOR_SCROLLBAR = 0
Global Const $COLOR_BACKGROUND = 1
Global Const $COLOR_ACTIVECAPTION = 2
Global Const $COLOR_INACTIVECAPTION = 3
Global Const $COLOR_MENU = 4
Global Const $COLOR_WINDOW = 5
Global Const $COLOR_WINDOWFRAME = 6
Global Const $COLOR_MENUTEXT = 7
Global Const $COLOR_WINDOWTEXT = 8
Global Const $COLOR_CAPTIONTEXT = 9
Global Const $COLOR_ACTIVEBORDER = 10
Global Const $COLOR_INACTIVEBORDER = 11
Global Const $COLOR_APPWORKSPACE = 12
Global Const $COLOR_HIGHLIGHT = 13
Global Const $COLOR_HIGHLIGHTTEXT = 14
Global Const $COLOR_BTNFACE = 15
Global Const $COLOR_BTNSHADOW = 16
Global Const $COLOR_GRAYTEXT = 17
Global Const $COLOR_BTNTEXT = 18
Global Const $COLOR_INACTIVECAPTIONTEXT = 19
Global Const $COLOR_BTNHIGHLIGHT = 20
Global Const $COLOR_3DDKSHADOW = 21
Global Const $COLOR_3DLIGHT = 22
Global Const $COLOR_INFOTEXT = 23
Global Const $COLOR_INFOBK = 24
Global Const $COLOR_HOTLIGHT = 26
Global Const $COLOR_GRADIENTACTIVECAPTION = 27
Global Const $COLOR_GRADIENTINACTIVECAPTION = 28
Global Const $COLOR_MENUHILIGHT = 29
Global Const $COLOR_MENUBAR = 30
Global Const $COLOR_DESKTOP = 1
Global Const $COLOR_3DFACE = 15
Global Const $COLOR_3DSHADOW = 16
Global Const $COLOR_3DHIGHLIGHT = 20
Global Const $COLOR_3DHILIGHT = 20
Global Const $COLOR_BTNHILIGHT = 20
Global Const $HINST_COMMCTRL = -1
Global Const $IDB_STD_SMALL_COLOR = 0
Global Const $IDB_STD_LARGE_COLOR = 1
Global Const $IDB_VIEW_SMALL_COLOR = 4
Global Const $IDB_VIEW_LARGE_COLOR = 5
Global Const $IDB_HIST_SMALL_COLOR = 8
Global Const $IDB_HIST_LARGE_COLOR = 9
Global Const $STARTF_FORCEOFFFEEDBACK = 0x80
Global Const $STARTF_FORCEONFEEDBACK = 0x40
Global Const $STARTF_PREVENTPINNING = 0x00002000
Global Const $STARTF_RUNFULLSCREEN = 0x20
Global Const $STARTF_TITLEISAPPID = 0x00001000
Global Const $STARTF_TITLEISLINKNAME = 0x00000800
Global Const $STARTF_USECOUNTCHARS = 0x8
Global Const $STARTF_USEFILLATTRIBUTE = 0x10
Global Const $STARTF_USEHOTKEY = 0x200
Global Const $STARTF_USEPOSITION = 0x4
Global Const $STARTF_USESHOWWINDOW = 0x1
Global Const $STARTF_USESIZE = 0x2
Global Const $STARTF_USESTDHANDLES = 0x100
Global Const $CDDS_PREPAINT = 0x00000001
Global Const $CDDS_POSTPAINT = 0x00000002
Global Const $CDDS_PREERASE = 0x00000003
Global Const $CDDS_POSTERASE = 0x00000004
Global Const $CDDS_ITEM = 0x00010000
Global Const $CDDS_ITEMPREPAINT = 0x00010001
Global Const $CDDS_ITEMPOSTPAINT = 0x00010002
Global Const $CDDS_ITEMPREERASE = 0x00010003
Global Const $CDDS_ITEMPOSTERASE = 0x00010004
Global Const $CDDS_SUBITEM = 0x00020000
Global Const $CDIS_SELECTED = 0x0001
Global Const $CDIS_GRAYED = 0x0002
Global Const $CDIS_DISABLED = 0x0004
Global Const $CDIS_CHECKED = 0x0008
Global Const $CDIS_FOCUS = 0x0010
Global Const $CDIS_DEFAULT = 0x0020
Global Const $CDIS_HOT = 0x0040
Global Const $CDIS_MARKED = 0x0080
Global Const $CDIS_INDETERMINATE = 0x0100
Global Const $CDIS_SHOWKEYBOARDCUES = 0x0200
Global Const $CDIS_NEARHOT = 0x0400
Global Const $CDIS_OTHERSIDEHOT = 0x0800
Global Const $CDIS_DROPHILITED = 0x1000
Global Const $CDRF_DODEFAULT = 0x00000000
Global Const $CDRF_NEWFONT = 0x00000002
Global Const $CDRF_SKIPDEFAULT = 0x00000004
Global Const $CDRF_NOTIFYPOSTPAINT = 0x00000010
Global Const $CDRF_NOTIFYITEMDRAW = 0x00000020
Global Const $CDRF_NOTIFYSUBITEMDRAW = 0x00000020
Global Const $CDRF_NOTIFYPOSTERASE = 0x00000040
Global Const $CDRF_DOERASE = 0x00000008
Global Const $CDRF_SKIPPOSTPAINT = 0x00000100
Global Const $GUI_SS_DEFAULT_GUI = BitOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU)
Global Const $ILC_MASK = 0x00000001
Global Const $ILC_COLOR = 0x00000000
Global Const $ILC_COLORDDB = 0x000000FE
Global Const $ILC_COLOR4 = 0x00000004
Global Const $ILC_COLOR8 = 0x00000008
Global Const $ILC_COLOR16 = 0x00000010
Global Const $ILC_COLOR24 = 0x00000018
Global Const $ILC_COLOR32 = 0x00000020
Global Const $ILC_PALETTE = 0x00000800
Global Const $ILC_MIRROR = 0x00002000
Global Const $ILC_PERITEMMIRROR = 0x00008000
Global Const $ILCF_MOVE = 0x0
Global Const $ILCF_SWAP = 0x1
Global Const $ILD_NORMAL = 0x00000000
Global Const $ILD_TRANSPARENT = 0x00000001
Global Const $ILD_BLEND25 = 0x00000002
Global Const $ILD_BLEND50 = 0x00000004
Global Const $ILD_MASK = 0x00000010
Global Const $ILD_IMAGE = 0x00000020
Global Const $ILD_ROP = 0x00000040
Global Const $ILD_OVERLAYMASK = 0x00000F00
Global Const $ILS_NORMAL = 0x00000000
Global Const $ILS_GLOW = 0x00000001
Global Const $ILS_SHADOW = 0x00000002
Global Const $ILS_SATURATE = 0x00000004
Global Const $ILS_ALPHA = 0x00000008
Global Const $HGDI_ERROR = Ptr(-1)
Global Const $INVALID_HANDLE_VALUE = Ptr(-1)
Global Const $CLR_INVALID = -1
Global Const $MB_PRECOMPOSED = 0x01
Global Const $MB_COMPOSITE = 0x02
Global Const $MB_USEGLYPHCHARS = 0x04
Global Const $ULW_ALPHA = 0x02
Global Const $ULW_COLORKEY = 0x01
Global Const $ULW_OPAQUE = 0x04
Global Const $ULW_EX_NORESIZE = 0x08
Global Const $WH_CALLWNDPROC = 4
Global Const $WH_CALLWNDPROCRET = 12
Global Const $WH_CBT = 5
Global Const $WH_DEBUG = 9
Global Const $WH_FOREGROUNDIDLE = 11
Global Const $WH_GETMESSAGE = 3
Global Const $WH_JOURNALPLAYBACK = 1
Global Const $WH_JOURNALRECORD = 0
Global Const $WH_KEYBOARD = 2
Global Const $WH_KEYBOARD_LL = 13
Global Const $WH_MOUSE = 7
Global Const $WH_MOUSE_LL = 14
Global Const $WH_MSGFILTER = -1
Global Const $WH_SHELL = 10
Global Const $WH_SYSMSGFILTER = 6
Global Const $WPF_ASYNCWINDOWPLACEMENT = 0x04
Global Const $WPF_RESTORETOMAXIMIZED = 0x02
Global Const $WPF_SETMINPOSITION = 0x01
Global Const $KF_EXTENDED = 0x0100
Global Const $KF_ALTDOWN = 0x2000
Global Const $KF_UP = 0x8000
Global Const $LLKHF_EXTENDED = BitShift($KF_EXTENDED, 8)
Global Const $LLKHF_INJECTED = 0x10
Global Const $LLKHF_ALTDOWN = BitShift($KF_ALTDOWN, 8)
Global Const $LLKHF_UP = BitShift($KF_UP, 8)
Global Const $OFN_ALLOWMULTISELECT = 0x00000200
Global Const $OFN_CREATEPROMPT = 0x00002000
Global Const $OFN_DONTADDTORECENT = 0x02000000
Global Const $OFN_ENABLEHOOK = 0x00000020
Global Const $OFN_ENABLEINCLUDENOTIFY = 0x00400000
Global Const $OFN_ENABLESIZING = 0x00800000
Global Const $OFN_ENABLETEMPLATE = 0x00000040
Global Const $OFN_ENABLETEMPLATEHANDLE = 0x00000080
Global Const $OFN_EXPLORER = 0x00080000
Global Const $OFN_EXTENSIONDIFFERENT = 0x00000400
Global Const $OFN_FILEMUSTEXIST = 0x00001000
Global Const $OFN_FORCESHOWHIDDEN = 0x10000000
Global Const $OFN_HIDEREADONLY = 0x00000004
Global Const $OFN_LONGNAMES = 0x00200000
Global Const $OFN_NOCHANGEDIR = 0x00000008
Global Const $OFN_NODEREFERENCELINKS = 0x00100000
Global Const $OFN_NOLONGNAMES = 0x00040000
Global Const $OFN_NONETWORKBUTTON = 0x00020000
Global Const $OFN_NOREADONLYRETURN = 0x00008000
Global Const $OFN_NOTESTFILECREATE = 0x00010000
Global Const $OFN_NOVALIDATE = 0x00000100
Global Const $OFN_OVERWRITEPROMPT = 0x00000002
Global Const $OFN_PATHMUSTEXIST = 0x00000800
Global Const $OFN_READONLY = 0x00000001
Global Const $OFN_SHAREAWARE = 0x00004000
Global Const $OFN_SHOWHELP = 0x00000010
Global Const $OFN_EX_NOPLACESBAR = 0x00000001
Global Const $STD_CUT = 0
Global Const $STD_COPY = 1
Global Const $STD_PASTE = 2
Global Const $STD_UNDO = 3
Global Const $STD_REDOW = 4
Global Const $STD_DELETE = 5
Global Const $STD_FILENEW = 6
Global Const $STD_FILEOPEN = 7
Global Const $STD_FILESAVE = 8
Global Const $STD_PRINTPRE = 9
Global Const $STD_PROPERTIES = 10
Global Const $STD_HELP = 11
Global Const $STD_FIND = 12
Global Const $STD_REPLACE = 13
Global Const $STD_PRINT = 14
Global Const $KB_SENDSPECIAL = 0
Global Const $KB_SENDRAW = 1
Global Const $KB_CAPSOFF = 0
Global Const $KB_CAPSON = 1
Global Const $S_OK = 0x00000000
Global Const $E_ABORT = 0x80004004
Global Const $E_ACCESSDENIED = 0x80070005
Global Const $E_FAIL = 0x80004005
Global Const $E_HANDLE = 0x80070006
Global Const $E_INVALIDARG = 0x80070057
Global Const $E_NOINTERFACE = 0x80004002
Global Const $E_NOTIMPL = 0x80004001
Global Const $E_OUTOFMEMORY = 0x8007000E
Global Const $E_POINTER = 0x80004003
Global Const $E_UNEXPECTED = 0x8000FFFF
Global Const $RT_ACCELERATOR = 9
Global Const $RT_ANICURSOR = 21
Global Const $RT_ANIICON = 22
Global Const $RT_BITMAP = 2
Global Const $RT_CURSOR = 1
Global Const $RT_DIALOG = 5
Global Const $RT_DLGINCLUDE = 17
Global Const $RT_FONT = 8
Global Const $RT_FONTDIR = 7
Global Const $RT_GROUP_CURSOR = 12
Global Const $RT_GROUP_ICON = 14
Global Const $RT_HTML = 23
Global Const $RT_ICON = 3
Global Const $RT_MANIFEST = 24
Global Const $RT_MENU = 4
Global Const $RT_MESSAGETABLE = 11
Global Const $RT_PLUGPLAY = 19
Global Const $RT_RCDATA = 10
Global Const $RT_STRING = 6
Global Const $RT_VERSION = 16
Global Const $RT_VXD = 20
Global Const $FILE_VER_GET_LOCALISED = 0x01
Global Const $FILE_VER_GET_NEUTRAL = 0x02
Global Const $FILE_VER_GET_PREFETCHED = 0x04
Global Const $OBM_TRTYPE = 32732
Global Const $OBM_LFARROWI = 32734
Global Const $OBM_RGARROWI = 32735
Global Const $OBM_DNARROWI = 32736
Global Const $OBM_UPARROWI = 32737
Global Const $OBM_COMBO = 32738
Global Const $OBM_MNARROW = 32739
Global Const $OBM_LFARROWD = 32740
Global Const $OBM_RGARROWD = 32741
Global Const $OBM_DNARROWD = 32742
Global Const $OBM_UPARROWD = 32743
Global Const $OBM_RESTORED = 32744
Global Const $OBM_ZOOMD = 32745
Global Const $OBM_REDUCED = 32746
Global Const $OBM_RESTORE = 32747
Global Const $OBM_ZOOM = 32748
Global Const $OBM_REDUCE = 32749
Global Const $OBM_LFARROW = 32750
Global Const $OBM_RGARROW = 32751
Global Const $OBM_DNARROW = 32752
Global Const $OBM_UPARROW = 32753
Global Const $OBM_CLOSE = 32754
Global Const $OBM_OLD_RESTORE = 32755
Global Const $OBM_OLD_ZOOM = 32756
Global Const $OBM_OLD_REDUCE = 32757
Global Const $OBM_BTNCORNERS = 32758
Global Const $OBM_CHECKBOXES = 32759
Global Const $OBM_CHECK = 32760
Global Const $OBM_BTSIZE = 32761
Global Const $OBM_OLD_LFARROW = 32762
Global Const $OBM_OLD_RGARROW = 32763
Global Const $OBM_OLD_DNARROW = 32764
Global Const $OBM_OLD_UPARROW = 32765
Global Const $OBM_SIZE = 32766
Global Const $OBM_OLD_CLOSE = 32767
Global Const $OIC_SAMPLE = 32512
Global Const $OIC_HAND = 32513
Global Const $OIC_QUES = 32514
Global Const $OIC_BANG = 32515
Global Const $OIC_NOTE = 32516
Global Const $OIC_WINLOGO = 32517
Global Const $OIC_WARNING = $OIC_BANG
Global Const $OIC_ERROR = $OIC_HAND
Global Const $OIC_INFORMATION = $OIC_NOTE
Global Const $DONT_RESOLVE_DLL_REFERENCES = 0x01
Global Const $LOAD_LIBRARY_AS_DATAFILE = 0x02
Global Const $LOAD_WITH_ALTERED_SEARCH_PATH = 0x08
Global Const $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x00000010
Global Const $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x00000040
Global Const $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x00000020
Global Const $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x00000200
Global Const $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000
Global Const $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x00000100
Global Const $LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
Global Const $LOAD_LIBRARY_SEARCH_USER_DIRS = 0x00000400
Global Const $OCR_NORMAL = 32512
Global Const $OCR_IBEAM = 32513
Global Const $OCR_WAIT = 32514
Global Const $OCR_CROSS = 32515
Global Const $OCR_UP = 32516
Global Const $OCR_SIZE = 32640
Global Const $OCR_ICON = 32641
Global Const $OCR_SIZENWSE = 32642
Global Const $OCR_SIZENESW = 32643
Global Const $OCR_SIZEWE = 32644
Global Const $OCR_SIZENS = 32645
Global Const $OCR_SIZEALL = 32646
Global Const $OCR_ICOCUR = 32647
Global Const $OCR_NO = 32648
Global Const $OCR_HAND = 32649
Global Const $OCR_APPSTARTING = 32650
Global Const $OCR_HELP = 32651
Global Const $VS_FF_DEBUG = 0x00000001
Global Const $VS_FF_INFOINFERRED = 0x00000010
Global Const $VS_FF_PATCHED = 0x00000004
Global Const $VS_FF_PRERELEASE = 0x00000002
Global Const $VS_FF_PRIVATEBUILD = 0x00000008
Global Const $VS_FF_SPECIALBUILD = 0x00000020
Global Const $VOS_DOS = 0x00010000
Global Const $VOS_NT = 0x00040000
Global Const $VOS__WINDOWS16 = 0x00000001
Global Const $VOS__WINDOWS32 = 0x00000004
Global Const $VOS_OS216 = 0x00020000
Global Const $VOS_OS232 = 0x00030000
Global Const $VOS__PM16 = 0x00000002
Global Const $VOS__PM32 = 0x00000003
Global Const $VOS_UNKNOWN = 0x00000000
Global Const $VOS_DOS_WINDOWS16 = 0x00010001
Global Const $VOS_DOS_WINDOWS32 = 0x00010004
Global Const $VOS_NT_WINDOWS32 = 0x00040004
Global Const $VOS_OS216_PM16 = 0x00020002
Global Const $VOS_OS232_PM32 = 0x00030003
Global Const $VFT_APP = 0x00000001
Global Const $VFT_DLL = 0x00000002
Global Const $VFT_DRV = 0x00000003
Global Const $VFT_FONT = 0x00000004
Global Const $VFT_STATIC_LIB = 0x00000007
Global Const $VFT_UNKNOWN = 0x00000000
Global Const $VFT_VXD = 0x00000005
Global Const $VFT2_DRV_COMM = 0x0000000A
Global Const $VFT2_DRV_DISPLAY = 0x00000004
Global Const $VFT2_DRV_INSTALLABLE = 0x00000008
Global Const $VFT2_DRV_KEYBOARD = 0x00000002
Global Const $VFT2_DRV_LANGUAGE = 0x00000003
Global Const $VFT2_DRV_MOUSE = 0x00000005
Global Const $VFT2_DRV_NETWORK = 0x00000006
Global Const $VFT2_DRV_PRINTER = 0x00000001
Global Const $VFT2_DRV_SOUND = 0x00000009
Global Const $VFT2_DRV_SYSTEM = 0x00000007
Global Const $VFT2_DRV_VERSIONED_PRINTER = 0x0000000C
Global Const $VFT2_UNKNOWN = 0x00000000
Global Const $VFT2_FONT_RASTER = 0x00000001
Global Const $VFT2_FONT_TRUETYPE = 0x00000003
Global Const $VFT2_FONT_VECTOR = 0x00000002
#Region Global Variables and Constants
Global $__g_vVal
Global Const $tagVS_FIXEDFILEINFO = 'dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_BeginUpdateResource($sFilePath, $bDelete = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'BeginUpdateResourceW', 'wstr', $sFilePath, 'bool', $bDelete)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ClipCursor($tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'ClipCursor', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CopyCursor($hCursor)
Return _WinAPI_CopyIcon($hCursor)
EndFunc
Func _WinAPI_CreateCaret($hWnd, $hBitmap, $iWidth = 0, $iHeight = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'CreateCaret', 'hwnd', $hWnd, 'handle', $hBitmap, 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DestroyCaret()
Local $aRet = DllCall('user32.dll', 'bool', 'DestroyCaret')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DestroyCursor($hCursor)
Local $aRet = DllCall('user32.dll', 'bool', 'DestroyCursor', 'handle', $hCursor)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EndUpdateResource($hUpdate, $bDiscard = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'EndUpdateResourceW', 'handle', $hUpdate, 'bool', $bDiscard)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumResourceLanguages($hModule, $sType, $sName)
Local $iLibrary = 0, $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Dim $__g_vEnum[101] = [0]
Local $hEnumProc = DllCallbackRegister('__EnumResLanguagesProc', 'bool', 'handle;ptr;ptr;word;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceLanguagesW', 'handle', $hModule, $sTypeOfType, $sType,  $sTypeOfName, $sName, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumResourceNames($hModule, $sType)
Local $aRet, $hEnumProc, $iLibrary = 0, $sTypeOfType = 'int'
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
Dim $__g_vEnum[101] = [0]
$hEnumProc = DllCallbackRegister('__EnumResNamesProc', 'bool', 'handle;ptr;ptr;long_ptr')
$aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceNamesW', 'handle', $hModule, $sTypeOfType, $sType,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or (Not $__g_vEnum[0]) Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumResourceTypes($hModule)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Dim $__g_vEnum[101] = [0]
Local $hEnumProc = DllCallbackRegister('__EnumResTypesProc', 'bool', 'handle;ptr;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceTypesW', 'handle', $hModule,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or (Not $__g_vEnum[0]) Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FindResource($hInstance, $sType, $sName)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindResourceW', 'handle', $hInstance, $sTypeOfName, $sName, $sTypeOfType, $sType)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindResourceExW', 'handle', $hInstance, $sTypeOfType, $sType,  $sTypeOfName, $sName, 'ushort', $iLanguage)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FreeResource($hData)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FreeResource', 'handle', $hData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCaretBlinkTime()
Local $aRet = DllCall('user32.dll', 'uint', 'GetCaretBlinkTime')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCaretPos()
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetCaretPos', 'struct*', $tagPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[2]
For $i = 0 To 1
$aResult[$i] = DllStructGetData($tPOINT, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetClipCursor()
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetClipCursor', 'struct*', $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetCursor()
Local $aRet = DllCall('user32.dll', 'handle', 'GetCursor')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetFileVersionInfo($sFilePath, ByRef $pBuffer, $iFlags = 0)
Local $aRet
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeExW', 'dword', BitAND($iFlags, 0x03), 'wstr', $sFilePath,  'ptr', 0)
Else
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFilePath, 'ptr', 0)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $iNbByte = $aRet[0]
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoExW', 'dword', BitAND($iFlags, 0x07), 'wstr', $sFilePath,  'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
Else
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoW', 'wstr', $sFilePath,  'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iNbByte
EndFunc
Func _WinAPI_HideCaret($hWnd)
Local $aRet = DllCall('user32.dll', 'int', 'HideCaret', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadBitmap($hInstance, $sBitmap)
Local $sBitmapType = "int"
If IsString($sBitmap) Then $sBitmapType = "wstr"
Local $aResult = DllCall("user32.dll", "handle", "LoadBitmapW", "handle", $hInstance, $sBitmapType, $sBitmap)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadCursor($hInstance, $sName)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'LoadCursorW', 'handle', $hInstance, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadCursorFromFile($sFilePath)
Local $aRet = DllCall('user32.dll', 'handle', 'LoadCursorFromFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadIndirectString($sStrIn)
Local $aRet = DllCall('shlwapi.dll', 'uint', 'SHLoadIndirectString', 'wstr', $sStrIn, 'wstr', '', 'uint', 4096, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_LoadString($hInstance, $iStringID)
Local $aResult = DllCall("user32.dll", "int", "LoadStringW", "handle", $hInstance, "uint", $iStringID, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return SetExtended($aResult[0], $aResult[3])
EndFunc
Func _WinAPI_LoadLibraryEx($sFileName, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sFileName, "ptr", 0, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadResource($hInstance, $hResource)
Local $aRet = DllCall('kernel32.dll', 'handle', 'LoadResource', 'handle', $hInstance, 'handle', $hResource)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadStringEx($hModule, $iID, $iLanguage = $LOCALE_USER_DEFAULT)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(@error + 20, @extended, '')
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Local $sResult = ''
Local $pData = __ResLoad($hModule, 6, Floor($iID / 16) + 1, $iLanguage)
If Not @error Then
Local $iOffset = 0
For $i = 0 To Mod($iID, 16) - 1
$iOffset += 2 * (DllStructGetData(DllStructCreate('ushort', $pData + $iOffset), 1) + 1)
Next
$sResult = DllStructGetData(DllStructCreate('ushort;wchar[' & DllStructGetData(DllStructCreate('ushort', $pData + $iOffset), 1) & ']', $pData + $iOffset), 2)
If @error Then $sResult = ''
Else
Return SetError(10, 0, '')
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
Return SetError(Number(Not $sResult), 0, $sResult)
EndFunc
Func _WinAPI_LockResource($hData)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'LockResource', 'handle', $hData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetCaretBlinkTime($iDuration)
Local $iPrev = _WinAPI_GetCaretBlinkTime()
If Not $iPrev Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('user32.dll', 'bool', 'SetCaretBlinkTime', 'uint', $iDuration)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iPrev
EndFunc
Func _WinAPI_SetCaretPos($iX, $iY)
Local $aRet = DllCall('user32.dll', 'int', 'SetCaretPos', 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetCursor($hCursor)
Local $aResult = DllCall("user32.dll", "handle", "SetCursor", "handle", $hCursor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetSystemCursor($hCursor, $iID, $bCopy = False)
If $bCopy Then
$hCursor = _WinAPI_CopyCursor($hCursor)
EndIf
Local $aRet = DllCall('user32.dll', 'bool', 'SetSystemCursor', 'handle', $hCursor, 'dword', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShowCaret($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShowCaret', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShowCursor($bShow)
Local $aResult = DllCall("user32.dll", "int", "ShowCursor", "bool", $bShow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SizeOfResource($hInstance, $hResource)
Local $aRet = DllCall('kernel32.dll', 'dword', 'SizeofResource', 'handle', $hInstance, 'handle', $hResource)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateResource($hUpdate, $sType, $sName, $iLanguage, $pData, $iSize)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'UpdateResourceW', 'handle', $hUpdate, $sTypeOfType, $sType, $sTypeOfName, $sName,  'word', $iLanguage, 'ptr', $pData, 'dword', $iSize)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_VerQueryRoot($pData)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, @extended, 0)
Local $tVFFI = DllStructCreate($tagVS_FIXEDFILEINFO)
If Not _WinAPI_MoveMemory($tVFFI, $aRet[3], $aRet[4]) Then Return SetError(@error + 20, @extended, 0)
Return $tVFFI
EndFunc
Func _WinAPI_VerQueryValue($pData, $sValues = '')
$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $sValues Then
$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$sValues = StringSplit($sValues, '|', $STR_NOCOUNT)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0,  'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, 0, 0)
Local $iLength = Floor($aRet[4] / 4)
Local $tLang = DllStructCreate('dword[' & $iLength & ']', $aRet[3])
If @error Then Return SetError(@error + 20, 0, 0)
Local $sCP, $aInfo[101][UBound($sValues) + 1] = [[0]]
For $i = 1 To $iLength
__Inc($aInfo)
$aInfo[$aInfo[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
$sCP = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tLang, 1, $i)), _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))), 8)
For $j = 0 To UBound($sValues) - 1
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $sValues[$j],  'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$aInfo[$aInfo[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$aInfo[$aInfo[0][0]][$j + 1] = ''
EndIf
Next
Next
__Inc($aInfo, -1)
Return $aInfo
EndFunc
Func _WinAPI_VerQueryValueEx($hModule, $sValues = '', $iLanguage = 0x0400)
$__g_vVal = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $__g_vVal Then
$__g_vVal = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$__g_vVal = StringSplit($__g_vVal, '|')
If Not IsArray($__g_vVal) Then Return SetError(1, 0, 0)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then
Return SetError(@error + 10, @extended, 0)
EndIf
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Dim $__g_vEnum[101][$__g_vVal[0] + 1] = [[0]]
Local $hEnumProc = DllCallbackRegister('__EnumVerValuesProc', 'bool', 'ptr;ptr;ptr;word;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceLanguagesW', 'handle', $hModule, 'int', 16, 'int', 1,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', $iLanguage)
Do
If @error Then
$__g_vEnum = @error + 20
Else
If Not $aRet[0] Then
Switch _WinAPI_GetLastError()
Case 0, 15106
ExitLoop
Case Else
$__g_vEnum = 20
EndSwitch
Else
ExitLoop
EndIf
EndIf
Until 1
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then $__g_vEnum = 230
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __EnumResLanguagesProc($hModule, $iType, $iName, $iLanguage, $lParam)
#forceref $hModule, $iType, $iName, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = $iLanguage
Return 1
EndFunc
Func __EnumResNamesProc($hModule, $iType, $iName, $lParam)
#forceref $hModule, $iType, $lParam
Local $iLength = _WinAPI_StrLen($iName)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $iName), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = Number($iName)
EndIf
Return 1
EndFunc
Func __EnumResTypesProc($hModule, $iType, $lParam)
#forceref $hModule, $lParam
Local $iLength = _WinAPI_StrLen($iType)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $iType), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = Number($iType)
EndIf
Return 1
EndFunc
Func __EnumVerValuesProc($hModule, $iType, $iName, $iLanguage, $iDefault)
Local $aRet, $iEnum = 1, $iError = 0
Switch $iDefault
Case -1
Case 0x0400
$iLanguage = 0x0400
$iEnum = 0
Case Else
If $iLanguage <> $iDefault Then
Return 1
EndIf
$iEnum = 0
EndSwitch
Do
Local $pData = __ResLoad($hModule, $iType, $iName, $iLanguage)
If @error Then
$iError = @error + 10
ExitLoop
EndIf
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then
$iError = @error + 20
ExitLoop
EndIf
Local $tData = DllStructCreate('ushort;ushort', $aRet[3])
If @error Then
$iError = @error + 30
ExitLoop
EndIf
Until 1
If Not $iError Then
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData($tData, 1)
Local $sCP = Hex(_WinAPI_MakeLong(DllStructGetData($tData, 2), DllStructGetData($tData, 1)), 8)
For $i = 1 To $__g_vVal[0]
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $__g_vVal[$i],  'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$__g_vEnum[$__g_vEnum[0][0]][$i] = ''
EndIf
Next
Else
$__g_vEnum = @error + 40
EndIf
If $__g_vEnum Then Return SetError($iError, 0, 0)
Return $iEnum
EndFunc
Func __ResLoad($hInstance, $sType, $sName, $iLanguage)
Local $hInfo = _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
If Not $hInfo Then Return SetError(@error + 10, @extended, 0)
Local $iSize = _WinAPI_SizeOfResource($hInstance, $hInfo)
If Not $iSize Then Return SetError(@error + 20, @extended, 0)
Local $hData = _WinAPI_LoadResource($hInstance, $hInfo)
If Not $hData Then Return SetError(@error + 30, @extended, 0)
Local $pData = _WinAPI_LockResource($hData)
If Not $pData Then Return SetError(@error + 40, @extended, 0)
Return SetExtended($iSize, $pData)
EndFunc
#EndRegion Internal Functions
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0
Func _GUIImageList_Add($hWnd, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_Add", "handle", $hWnd, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddMasked($hWnd, $hImage, $iMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_AddMasked", "handle", $hWnd, "handle", $hImage, "dword", $iMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddBitmap($hWnd, $sImage, $sMask = "")
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Local $hImage = _WinAPI_LoadImage(0, $sImage, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hImage = 0 Then Return SetError(_WinAPI_GetLastError(), 1, -1)
Local $hMask = 0
If $sMask <> "" Then
$hMask = _WinAPI_LoadImage(0, $sMask, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hMask = 0 Then Return SetError(_WinAPI_GetLastError(), 2, -1)
EndIf
Local $iRet = _GUIImageList_Add($hWnd, $hImage, $hMask)
_WinAPI_DeleteObject($hImage)
If $hMask <> 0 Then _WinAPI_DeleteObject($hMask)
Return $iRet
EndFunc
Func _GUIImageList_AddIcon($hWnd, $sFilePath, $iIndex = 0, $bLarge = False)
Local $iRet, $tIcon = DllStructCreate("handle Handle")
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, 0, $tIcon, 1)
EndIf
If $iRet <= 0 Then Return SetError(-1, $iRet, -1)
Local $hIcon = DllStructGetData($tIcon, "Handle")
$iRet = _GUIImageList_ReplaceIcon($hWnd, -1, $hIcon)
_WinAPI_DestroyIcon($hIcon)
If $iRet = -1 Then Return SetError(-2, $iRet, -1)
Return $iRet
EndFunc
Func _GUIImageList_BeginDrag($hWnd, $iTrack, $iXHotSpot, $iYHotSpot)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_BeginDrag", "handle", $hWnd, "int", $iTrack, "int", $iXHotSpot, "int", $iYHotSpot)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Copy($hWnd, $iSource, $iDestination)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hWnd, "int", $iDestination, "handle", $hWnd, "int", $iSource, "uint", $ILCF_MOVE)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Create($iCX = 16, $iCY = 16, $iColor = 4, $iOptions = 0, $iInitial = 4, $iGrow = 4)
Local Const $aColor[7] = [$ILC_COLOR, $ILC_COLOR4, $ILC_COLOR8, $ILC_COLOR16, $ILC_COLOR24, $ILC_COLOR32, $ILC_COLORDDB]
Local $iFlags = 0
If BitAND($iOptions, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MASK)
If BitAND($iOptions, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MIRROR)
If BitAND($iOptions, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILC_PERITEMMIRROR)
$iFlags = BitOR($iFlags, $aColor[$iColor])
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", $iCX, "int", $iCY, "uint", $iFlags, "int", $iInitial, "int", $iGrow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Destroy($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DestroyIcon($hIcon)
Return _WinAPI_DestroyIcon($hIcon)
EndFunc
Func _GUIImageList_DragEnter($hWnd, $iX, $iY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragEnter", "hwnd", $hWnd, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragLeave($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragLeave", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragMove($iX, $iY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragMove", "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragShowNolock($bShow)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragShowNolock", "bool", $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Draw($hWnd, $iIndex, $hDC, $iX, $iY, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DrawEx($hWnd, $iIndex, $hDC, $iX, $iY, $iDX = 0, $iDY = 0, $iRGBBk = 0xFFFFFFFF, $iRGBFg = 0xFFFFFFFF, $iStyle = 0)
If $iDX = -1 Then $iDX = 0
If $iDY = -1 Then $iDY = 0
If $iRGBBk = -1 Then $iRGBBk = 0xFFFFFFFF
If $iRGBFg = -1 Then $iRGBFg = 0xFFFFFFFF
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DrawEx", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY,  "int", $iDX, "int", $iDY, "dword", $iRGBBk, "dword", $iRGBFg, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Duplicate($hWnd)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Duplicate", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_EndDrag()
DllCall("comctl32.dll", "none", "ImageList_EndDrag")
If @error Then Return SetError(@error, @extended)
EndFunc
Func _GUIImageList_GetBkColor($hWnd)
Local $aResult = DllCall("comctl32.dll", "dword", "ImageList_GetBkColor", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetIcon($hWnd, $iIndex, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hWnd, "int", $iIndex, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetIconHeight($hWnd)
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Return $aSize[1]
EndFunc
Func _GUIImageList_GetIconSize($hWnd)
Local $aSize[2]
Local $tPoint = _GUIImageList_GetIconSizeEx($hWnd)
$aSize[0] = DllStructGetData($tPoint, "X")
$aSize[1] = DllStructGetData($tPoint, "Y")
Return $aSize
EndFunc
Func _GUIImageList_GetIconSizeEx($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $pPointX = DllStructGetPtr($tPoint, "X")
Local $pPointY = DllStructGetPtr($tPoint, "Y")
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetIconSize", "hwnd", $hWnd, "struct*", $pPointX, "struct*", $pPointY)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tPoint)
EndFunc
Func _GUIImageList_GetIconWidth($hWnd)
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Return $aSize[0]
EndFunc
Func _GUIImageList_GetImageCount($hWnd)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_GetImageCount", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetImageInfoEx($hWnd, $iIndex)
Local $tImage = DllStructCreate($tagIMAGEINFO)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetImageInfo", "handle", $hWnd, "int", $iIndex, "struct*", $tImage)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tImage)
EndFunc
Func _GUIImageList_Merge($hWnd1, $iIndex1, $hWnd2, $iIndex2, $iDX, $iDY)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Merge", "handle", $hWnd1, "int", $iIndex1,  "handle", $hWnd2, "int", $iIndex2, "int", $iDX, "int", $iDY)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Remove($hWnd, $iIndex = -1)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Remove", "handle", $hWnd, "int", $iIndex)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Replace($hWnd, $iIndex, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Replace", "handle", $hWnd, "int", $iIndex, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_ReplaceIcon($hWnd, $iIndex, $hIcon)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hWnd, "int", $iIndex, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_SetBkColor($hWnd, $iClrBk)
Local $aResult = DllCall("comctl32.dll", "dword", "ImageList_SetBkColor", "handle", $hWnd, "dword", $iClrBk)
If @error Then Return SetError(@error, @extended, $CLR_NONE)
Return $aResult[0]
EndFunc
Func _GUIImageList_SetDragCursorImage($hWnd, $iDrag, $iDXHotSpot, $iDYHotSpot)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetDragCursorImage", "handle", $hWnd, "int", $iDrag, "int", $iDXHotSpot, "int", $iDYHotSpot)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetIconSize($hWnd, $iCX, $iCY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetIconSize", "handle", $hWnd, "int", $iCX, "int", $iCY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetImageCount($hWnd, $iNewCount)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetImageCount", "handle", $hWnd, "uint", $iNewCount)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetOverlayImage($hWnd, $iImage, $iOverlay)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hWnd, "int", $iImage, "int", $iOverlay)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Swap($hWnd, $iSource, $iDestination)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hWnd, "int", $iDestination, "handle", $hWnd, "int", $iSource, "uint", $ILCF_SWAP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Global Const $DDL_ARCHIVE = 0x00000020
Global Const $DDL_DIRECTORY = 0x00000010
Global Const $DDL_DRIVES = 0x00004000
Global Const $DDL_EXCLUSIVE = 0x00008000
Global Const $DDL_HIDDEN = 0x00000002
Global Const $DDL_READONLY = 0x00000001
Global Const $DDL_READWRITE = 0x00000000
Global Const $DDL_SYSTEM = 0x00000004
Func _SendMessage($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Func _SendMessageA($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageA", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Global Const $_UDF_GlobalIDs_OFFSET = 2
Global Const $_UDF_GlobalID_MAX_WIN = 16
Global Const $_UDF_STARTID = 10000
Global Const $_UDF_GlobalID_MAX_IDS = 55535
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 0x00010000
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 0x10000000
Global Const $__UDFGUICONSTANT_WS_CHILD = 0x40000000
Global $__g_aUDF_GlobalIDs_Used[$_UDF_GlobalID_MAX_WIN][$_UDF_GlobalID_MAX_IDS + $_UDF_GlobalIDs_OFFSET + 1]
Func __UDF_GetNextGlobalID($hWnd)
Local $nCtrlID, $iUsedIndex = -1, $bAllUsed = True
If Not WinExists($hWnd) Then Return SetError(-1, -1, 0)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] <> 0 Then
If Not WinExists($__g_aUDF_GlobalIDs_Used[$iIndex][0]) Then
For $x = 0 To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Next
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
EndIf
EndIf
Next
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
If $iUsedIndex = -1 Then
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = 0 Then
$__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
EndIf
If $iUsedIndex = -1 And $bAllUsed Then Return SetError(16, 0, 0)
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] = $_UDF_STARTID + $_UDF_GlobalID_MAX_IDS Then
For $iIDIndex = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = 0 Then
$nCtrlID = ($iIDIndex - $_UDF_GlobalIDs_OFFSET) + 10000
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = $nCtrlID
Return $nCtrlID
EndIf
Next
Return SetError(-1, $_UDF_GlobalID_MAX_IDS, 0)
EndIf
$nCtrlID = $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1]
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] += 1
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][($nCtrlID - 10000) + $_UDF_GlobalIDs_OFFSET] = $nCtrlID
Return $nCtrlID
EndFunc
Func __UDF_FreeGlobalID($hWnd, $iGlobalID)
If $iGlobalID - $_UDF_STARTID < 0 Or $iGlobalID - $_UDF_STARTID > $_UDF_GlobalID_MAX_IDS Then Return SetError(-1, 0, False)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
For $x = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][$x] = $iGlobalID Then
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Return True
EndIf
Next
Return SetError(-3, 0, False)
EndIf
Next
Return SetError(-2, 0, False)
EndFunc
#Region Global Variables and Constants
Global $__g_aInProcess_WinAPI[64][2] = [[0, 0]]
Global $__g_aWinList_WinAPI[64][2] = [[0, 0]]
Global Const $GW_HWNDFIRST = 0
Global Const $GW_HWNDLAST = 1
Global Const $GW_HWNDNEXT = 2
Global Const $GW_HWNDPREV = 3
Global Const $GW_OWNER = 4
Global Const $GW_CHILD = 5
Global Const $GW_ENABLEDPOPUP = 6
Global Const $GWL_WNDPROC = 0xFFFFFFFC
Global Const $GWL_HINSTANCE = 0xFFFFFFFA
Global Const $GWL_HWNDPARENT = 0xFFFFFFF8
Global Const $GWL_ID = 0xFFFFFFF4
Global Const $GWL_STYLE = 0xFFFFFFF0
Global Const $GWL_EXSTYLE = 0xFFFFFFEC
Global Const $GWL_USERDATA = 0xFFFFFFEB
Global Const $__WINAPICONSTANT_WM_SETFONT = 0x0030
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateWindowEx($iExStyle, $sClass, $sName, $iStyle, $iX, $iY, $iWidth, $iHeight, $hParent, $hMenu = 0, $hInstance = 0, $pParam = 0)
If $hInstance = 0 Then $hInstance = _WinAPI_GetModuleHandle("")
Local $aResult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iExStyle, "wstr", $sClass, "wstr", $sName,  "dword", $iStyle, "int", $iX, "int", $iY, "int", $iWidth, "int", $iHeight, "hwnd", $hParent, "handle", $hMenu,  "handle", $hInstance, "struct*", $pParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClientRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetDesktopWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_EnableWindow($hWnd, $bEnable = True)
Local $aResult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hWnd, "bool", $bEnable)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_EnumWindows($bVisible = True, $hWnd = Default)
__WinAPI_EnumWindowsInit()
If $hWnd = Default Then $hWnd = _WinAPI_GetDesktopWindow()
__WinAPI_EnumWindowsChild($hWnd, $bVisible)
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_EnumWindowsPopup()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
Local $sClass
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then
$sClass = _WinAPI_GetClassName($hWnd)
If $sClass = "#32768" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "ToolbarWindow32" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "ToolTips_Class32" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "BaseBar" Then
__WinAPI_EnumWindowsChild($hWnd)
EndIf
EndIf
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_EnumWindowsTop()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then __WinAPI_EnumWindowsAdd($hWnd)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_GetClassName($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, '')
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetFocus()
Local $aResult = DllCall("user32.dll", "hwnd", "GetFocus")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetParent($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSysColor($iIndex)
Local $aResult = DllCall("user32.dll", "INT", "GetSysColor", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSystemMetrics($iIndex)
Local $aResult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindow($hWnd, $iCmd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hWnd, "uint", $iCmd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowHeight($hWnd)
Local $tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetWindowLong($hWnd, $iIndex)
Local $sFuncName = "GetWindowLongW"
If @AutoItX64 Then $sFuncName = "GetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetWindowText($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetWindowThreadProcessId($hWnd, ByRef $iPID)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
$iPID = $aResult[2]
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowWidth($hWnd)
Local $tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_InProcess($hWnd, ByRef $hLastWnd)
If $hWnd = $hLastWnd Then Return True
For $iI = $__g_aInProcess_WinAPI[0][0] To 1 Step -1
If $hWnd = $__g_aInProcess_WinAPI[$iI][0] Then
If $__g_aInProcess_WinAPI[$iI][1] Then
$hLastWnd = $hWnd
Return True
Else
Return False
EndIf
EndIf
Next
Local $iPID
_WinAPI_GetWindowThreadProcessId($hWnd, $iPID)
Local $iCount = $__g_aInProcess_WinAPI[0][0] + 1
If $iCount >= 64 Then $iCount = 1
$__g_aInProcess_WinAPI[0][0] = $iCount
$__g_aInProcess_WinAPI[$iCount][0] = $hWnd
$__g_aInProcess_WinAPI[$iCount][1] = ($iPID = @AutoItPID)
Return $__g_aInProcess_WinAPI[$iCount][1]
EndFunc
Func _WinAPI_InvalidateRect($hWnd, $tRECT = 0, $bErase = True)
Local $aResult = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hWnd, "struct*", $tRECT, "bool", $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_IsClassName($hWnd, $sClassName)
Local $sSeparator = Opt("GUIDataSeparatorChar")
Local $aClassName = StringSplit($sClassName, $sSeparator)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sClassCheck = _WinAPI_GetClassName($hWnd)
For $x = 1 To UBound($aClassName) - 1
If StringUpper(StringMid($sClassCheck, 1, StringLen($aClassName[$x]))) = StringUpper($aClassName[$x]) Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_IsWindowVisible($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_MoveWindow($hWnd, $iX, $iY, $iWidth, $iHeight, $bRepaint = True)
Local $aResult = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hWnd, "int", $iX, "int", $iY, "int", $iWidth,  "int", $iHeight, "bool", $bRepaint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFocus($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFont($hWnd, $hFont, $bRedraw = True)
_SendMessage($hWnd, $__WINAPICONSTANT_WM_SETFONT, $hFont, $bRedraw, 0, "hwnd")
EndFunc
Func _WinAPI_SetParent($hWndChild, $hWndParent)
Local $aResult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hWndChild, "hwnd", $hWndParent)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPos($hWnd, $hAfter, $iX, $iY, $iCX, $iCY, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hWnd, "hwnd", $hAfter, "int", $iX, "int", $iY,  "int", $iCX, "int", $iCY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowText($hWnd, $sText)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hWnd, "wstr", $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowWindow($hWnd, $iCmdShow = 5)
Local $aResult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hWnd, "int", $iCmdShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __WinAPI_EnumWindowsAdd($hWnd, $sClass = "")
If $sClass = "" Then $sClass = _WinAPI_GetClassName($hWnd)
$__g_aWinList_WinAPI[0][0] += 1
Local $iCount = $__g_aWinList_WinAPI[0][0]
If $iCount >= $__g_aWinList_WinAPI[0][1] Then
ReDim $__g_aWinList_WinAPI[$iCount + 64][2]
$__g_aWinList_WinAPI[0][1] += 64
EndIf
$__g_aWinList_WinAPI[$iCount][0] = $hWnd
$__g_aWinList_WinAPI[$iCount][1] = $sClass
EndFunc
Func __WinAPI_EnumWindowsChild($hWnd, $bVisible = True)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_CHILD)
While $hWnd <> 0
If (Not $bVisible) Or _WinAPI_IsWindowVisible($hWnd) Then
__WinAPI_EnumWindowsAdd($hWnd)
__WinAPI_EnumWindowsChild($hWnd, $bVisible)
EndIf
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
EndFunc
Func __WinAPI_EnumWindowsInit()
ReDim $__g_aWinList_WinAPI[64][2]
$__g_aWinList_WinAPI[0][0] = 0
$__g_aWinList_WinAPI[0][1] = 64
EndFunc
#EndRegion Internal Functions
Global $__g_hLBLastWnd
Global Const $__LISTBOXCONSTANT_ClassName = "ListBox"
Global Const $__LISTBOXCONSTANT_ClassNames = $__LISTBOXCONSTANT_ClassName & "|TListbox"
Global Const $__LISTBOXCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__LISTBOXCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__LISTBOXCONSTANT_WM_GETFONT = 0x0031
Func _GUICtrlListBox_AddFile($hWnd, $sFilePath)
If Not IsString($sFilePath) Then $sFilePath = String($sFilePath)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_ADDFILE, 0, $sFilePath, 0, "wparam", "wstr")
Else
Return GUICtrlSendMsg($hWnd, $LB_ADDFILE, 0, $sFilePath)
EndIf
EndFunc
Func _GUICtrlListBox_AddString($hWnd, $sText)
If Not IsString($sText) Then $sText = String($sText)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_ADDSTRING, 0, $sText, 0, "wparam", "wstr")
Else
Return GUICtrlSendMsg($hWnd, $LB_ADDSTRING, 0, $sText)
EndIf
EndFunc
Func _GUICtrlListBox_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__LISTBOXCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlListBox_ClickItem($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 0)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = _GUICtrlListBox_GetItemRectEx($hWnd, $iIndex)
Local $tPoint = _WinAPI_PointFromRect($tRECT)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
Local $iX, $iY
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
If Not $bMove Then
Local $aPos = MouseGetPos()
_WinAPI_ShowCursor(False)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
MouseMove($aPos[0], $aPos[1], 0)
_WinAPI_ShowCursor(True)
Else
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
EndIf
Opt("MouseCoordMode", $iMode)
EndFunc
Func _GUICtrlListBox_Create($hWnd, $sText, $iX, $iY, $iWidth = 100, $iHeight = 200, $iStyle = 0x00B00002, $iExStyle = 0x00000200)
If Not IsHWnd($hWnd) Then
Return SetError(1, 0, 0)
EndIf
If Not IsString($sText) Then
Return SetError(2, 0, 0)
EndIf
If $iWidth = -1 Then $iWidth = 100
If $iHeight = -1 Then $iHeight = 200
Local Const $WS_VSCROLL = 0x00200000, $WS_HSCROLL = 0x00100000, $WS_BORDER = 0x00800000
If $iStyle = -1 Then $iStyle = BitOR($WS_BORDER, $WS_VSCROLL, $WS_HSCROLL, $LBS_SORT)
If $iExStyle = -1 Then $iExStyle = 0x00000200
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_CHILD, $LBS_NOTIFY)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hList = _WinAPI_CreateWindowEx($iExStyle, $__LISTBOXCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hList, _WinAPI_GetStockObject($__LISTBOXCONSTANT_DEFAULT_GUI_FONT))
If StringLen($sText) Then _GUICtrlListBox_AddString($hList, $sText)
Return $hList
EndFunc
Func _GUICtrlListBox_DeleteString($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_DELETESTRING, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LB_DELETESTRING, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListBox_Destroy(ByRef $hWnd)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLBLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlListBox_Dir($hWnd, $sFilePath, $iAttributes = 0, $bBrackets = True)
If Not IsString($sFilePath) Then $sFilePath = String($sFilePath)
If BitAND($iAttributes, $DDL_DRIVES) = $DDL_DRIVES And Not $bBrackets Then
Local $sText
Local $hGui_no_brackets = GUICreate("no brackets")
Local $idList_no_brackets = GUICtrlCreateList("", 240, 40, 120, 120)
Local $iRet = GUICtrlSendMsg($idList_no_brackets, $LB_DIR, $iAttributes, $sFilePath)
For $i = 0 To _GUICtrlListBox_GetCount($idList_no_brackets) - 1
$sText = _GUICtrlListBox_GetText($idList_no_brackets, $i)
$sText = StringReplace(StringReplace(StringReplace($sText, "[", ""), "]", ":"), "-", "")
_GUICtrlListBox_InsertString($hWnd, $sText)
Next
GUIDelete($hGui_no_brackets)
Return $iRet
Else
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_DIR, $iAttributes, $sFilePath, 0, "wparam", "wstr")
Else
Return GUICtrlSendMsg($hWnd, $LB_DIR, $iAttributes, $sFilePath)
EndIf
EndIf
EndFunc
Func _GUICtrlListBox_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__LISTBOXCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlListBox_FindString($hWnd, $sText, $bExact = False)
If Not IsString($sText) Then $sText = String($sText)
If IsHWnd($hWnd) Then
If ($bExact) Then
Return _SendMessage($hWnd, $LB_FINDSTRINGEXACT, -1, $sText, 0, "wparam", "wstr")
Else
Return _SendMessage($hWnd, $LB_FINDSTRING, -1, $sText, 0, "wparam", "wstr")
EndIf
Else
If ($bExact) Then
Return GUICtrlSendMsg($hWnd, $LB_FINDSTRINGEXACT, -1, $sText)
Else
Return GUICtrlSendMsg($hWnd, $LB_FINDSTRING, -1, $sText)
EndIf
EndIf
EndFunc
Func _GUICtrlListBox_FindInText($hWnd, $sText, $iStart = -1, $bWrapOK = True)
Local $sList
Local $iCount = _GUICtrlListBox_GetCount($hWnd)
For $iI = $iStart + 1 To $iCount - 1
$sList = _GUICtrlListBox_GetText($hWnd, $iI)
If StringInStr($sList, $sText) Then Return $iI
Next
If ($iStart = -1) Or Not $bWrapOK Then Return -1
For $iI = 0 To $iStart - 1
$sList = _GUICtrlListBox_GetText($hWnd, $iI)
If StringInStr($sList, $sText) Then Return $iI
Next
Return -1
EndFunc
Func _GUICtrlListBox_GetAnchorIndex($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETANCHORINDEX)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETANCHORINDEX, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetCaretIndex($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETCARETINDEX)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETCARETINDEX, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetCurSel($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETCURSEL)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETCURSEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetHorizontalExtent($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETHORIZONTALEXTENT)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETHORIZONTALEXTENT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetItemData($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETITEMDATA, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETITEMDATA, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetItemHeight($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETITEMHEIGHT)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETITEMHEIGHT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlListBox_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListBox_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LB_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
GUICtrlSendMsg($hWnd, $LB_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlListBox_GetListBoxInfo($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETLISTBOXINFO)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETLISTBOXINFO, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetLocale($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETLOCALE)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETLOCALE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetLocaleCountry($hWnd)
Return _WinAPI_HiWord(_GUICtrlListBox_GetLocale($hWnd))
EndFunc
Func _GUICtrlListBox_GetLocaleLang($hWnd)
Return _WinAPI_LoWord(_GUICtrlListBox_GetLocale($hWnd))
EndFunc
Func _GUICtrlListBox_GetLocalePrimLang($hWnd)
Return _WinAPI_PrimaryLangId(_GUICtrlListBox_GetLocaleLang($hWnd))
EndFunc
Func _GUICtrlListBox_GetLocaleSubLang($hWnd)
Return _WinAPI_SubLangId(_GUICtrlListBox_GetLocaleLang($hWnd))
EndFunc
Func _GUICtrlListBox_GetSel($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETSEL, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LB_GETSEL, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListBox_GetSelCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETSELCOUNT)
EndIf
If IsHWnd(GUICtrlGetHandle($hWnd)) Then
Return GUICtrlSendMsg($hWnd, $LB_GETSELCOUNT, 0, 0)
EndIf
Return -1
EndFunc
Func _GUICtrlListBox_GetSelItems($hWnd)
Local $aArray[1] = [0]
Local $iCount = _GUICtrlListBox_GetSelCount($hWnd)
If $iCount > 0 Then
ReDim $aArray[$iCount + 1]
Local $tArray = DllStructCreate("int[" & $iCount & "]")
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LB_GETSELITEMS, $iCount, $tArray, 0, "wparam", "struct*")
Else
GUICtrlSendMsg($hWnd, $LB_GETSELITEMS, $iCount, DllStructGetPtr($tArray))
EndIf
$aArray[0] = $iCount
For $iI = 1 To $iCount
$aArray[$iI] = DllStructGetData($tArray, 1, $iI)
Next
EndIf
Return $aArray
EndFunc
Func _GUICtrlListBox_GetSelItemsText($hWnd)
Local $aText[1] = [0], $iCount = _GUICtrlListBox_GetSelCount($hWnd)
If $iCount > 0 Then
Local $aIndices = _GUICtrlListBox_GetSelItems($hWnd)
ReDim $aText[UBound($aIndices)]
$aText[0] = $aIndices[0]
For $i = 1 To $aIndices[0]
$aText[$i] = _GUICtrlListBox_GetText($hWnd, $aIndices[$i])
Next
EndIf
Return $aText
EndFunc
Func _GUICtrlListBox_GetText($hWnd, $iIndex)
Local $tText = DllStructCreate("wchar Text[" & _GUICtrlListBox_GetTextLen($hWnd, $iIndex) + 1 & "]")
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $LB_GETTEXT, $iIndex, $tText, 0, "wparam", "struct*")
Return DllStructGetData($tText, "Text")
EndFunc
Func _GUICtrlListBox_GetTextLen($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETTEXTLEN, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETTEXTLEN, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListBox_GetTopIndex($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_GETTOPINDEX)
Else
Return GUICtrlSendMsg($hWnd, $LB_GETTOPINDEX, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_InitStorage($hWnd, $iItems, $iBytes)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_INITSTORAGE, $iItems, $iBytes)
Else
Return GUICtrlSendMsg($hWnd, $LB_INITSTORAGE, $iItems, $iBytes)
EndIf
EndFunc
Func _GUICtrlListBox_InsertString($hWnd, $sText, $iIndex = -1)
If Not IsString($sText) Then $sText = String($sText)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_INSERTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
Else
Return GUICtrlSendMsg($hWnd, $LB_INSERTSTRING, $iIndex, $sText)
EndIf
EndFunc
Func _GUICtrlListBox_ItemFromPoint($hWnd, $iX, $iY)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LB_ITEMFROMPOINT, 0, _WinAPI_MakeLong($iX, $iY))
Else
$iRet = GUICtrlSendMsg($hWnd, $LB_ITEMFROMPOINT, 0, _WinAPI_MakeLong($iX, $iY))
EndIf
If _WinAPI_HiWord($iRet) <> 0 Then $iRet = -1
Return $iRet
EndFunc
Func _GUICtrlListBox_ReplaceString($hWnd, $iIndex, $sText)
If (_GUICtrlListBox_DeleteString($hWnd, $iIndex) == $LB_ERR) Then Return SetError($LB_ERR, $LB_ERR, False)
If (_GUICtrlListBox_InsertString($hWnd, $sText, $iIndex) == $LB_ERR) Then Return SetError($LB_ERR, $LB_ERR, False)
Return True
EndFunc
Func _GUICtrlListBox_ResetContent($hWnd)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LB_RESETCONTENT)
Else
GUICtrlSendMsg($hWnd, $LB_RESETCONTENT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListBox_SelectString($hWnd, $sText, $iIndex = -1)
If Not IsString($sText) Then $sText = String($sText)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SELECTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
Else
Return GUICtrlSendMsg($hWnd, $LB_SELECTSTRING, $iIndex, $sText)
EndIf
EndFunc
Func _GUICtrlListBox_SelItemRange($hWnd, $iFirst, $iLast, $bSelect = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SELITEMRANGE, $bSelect, _WinAPI_MakeLong($iFirst, $iLast)) = 0
Else
Return GUICtrlSendMsg($hWnd, $LB_SELITEMRANGE, $bSelect, _WinAPI_MakeLong($iFirst, $iLast)) = 0
EndIf
EndFunc
Func _GUICtrlListBox_SelItemRangeEx($hWnd, $iFirst, $iLast)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SELITEMRANGEEX, $iFirst, $iLast) = 0
Else
Return GUICtrlSendMsg($hWnd, $LB_SELITEMRANGEEX, $iFirst, $iLast) = 0
EndIf
EndFunc
Func _GUICtrlListBox_SetAnchorIndex($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SETANCHORINDEX, $iIndex) = 0
Else
Return GUICtrlSendMsg($hWnd, $LB_SETANCHORINDEX, $iIndex, 0) = 0
EndIf
EndFunc
Func _GUICtrlListBox_SetCaretIndex($hWnd, $iIndex, $bPartial = False)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SETCARETINDEX, $iIndex, $bPartial) = 0
Else
Return GUICtrlSendMsg($hWnd, $LB_SETCARETINDEX, $iIndex, $bPartial) = 0
EndIf
EndFunc
Func _GUICtrlListBox_SetColumnWidth($hWnd, $iWidth)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LB_SETCOLUMNWIDTH, $iWidth)
Else
GUICtrlSendMsg($hWnd, $LB_SETCOLUMNWIDTH, $iWidth, 0)
EndIf
EndFunc
Func _GUICtrlListBox_SetCurSel($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SETCURSEL, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LB_SETCURSEL, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListBox_SetHorizontalExtent($hWnd, $iWidth)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LB_SETHORIZONTALEXTENT, $iWidth)
Else
GUICtrlSendMsg($hWnd, $LB_SETHORIZONTALEXTENT, $iWidth, 0)
EndIf
EndFunc
Func _GUICtrlListBox_SetItemData($hWnd, $iIndex, $iValue)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SETITEMDATA, $iIndex, $iValue) <> -1
Else
Return GUICtrlSendMsg($hWnd, $LB_SETITEMDATA, $iIndex, $iValue) <> -1
EndIf
EndFunc
Func _GUICtrlListBox_SetItemHeight($hWnd, $iHeight, $iIndex = 0)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LB_SETITEMHEIGHT, $iIndex, $iHeight)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LB_SETITEMHEIGHT, $iIndex, $iHeight)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> -1
EndFunc
Func _GUICtrlListBox_SetLocale($hWnd, $iLocal)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SETLOCALE, $iLocal)
Else
Return GUICtrlSendMsg($hWnd, $LB_SETLOCALE, $iLocal, 0)
EndIf
EndFunc
Func _GUICtrlListBox_SetSel($hWnd, $iIndex = -1, $iSelect = -1)
Local $i_Ret = 1
If IsHWnd($hWnd) Then
If $iIndex == -1 Then
For $iIndex = 0 To _GUICtrlListBox_GetCount($hWnd) - 1
$i_Ret = _GUICtrlListBox_GetSel($hWnd, $iIndex)
If ($i_Ret == $LB_ERR) Then Return SetError($LB_ERR, $LB_ERR, False)
If ($i_Ret > 0) Then
$i_Ret = _SendMessage($hWnd, $LB_SETSEL, False, $iIndex) <> -1
Else
$i_Ret = _SendMessage($hWnd, $LB_SETSEL, True, $iIndex) <> -1
EndIf
If ($i_Ret == False) Then Return SetError($LB_ERR, $LB_ERR, False)
Next
ElseIf $iSelect == -1 Then
If _GUICtrlListBox_GetSel($hWnd, $iIndex) Then
Return _SendMessage($hWnd, $LB_SETSEL, False, $iIndex) <> -1
Else
Return _SendMessage($hWnd, $LB_SETSEL, True, $iIndex) <> -1
EndIf
Else
Return _SendMessage($hWnd, $LB_SETSEL, $iSelect, $iIndex) <> -1
EndIf
Else
If $iIndex == -1 Then
For $iIndex = 0 To _GUICtrlListBox_GetCount($hWnd) - 1
$i_Ret = _GUICtrlListBox_GetSel($hWnd, $iIndex)
If ($i_Ret == $LB_ERR) Then Return SetError($LB_ERR, $LB_ERR, False)
If ($i_Ret > 0) Then
$i_Ret = GUICtrlSendMsg($hWnd, $LB_SETSEL, False, $iIndex) <> -1
Else
$i_Ret = GUICtrlSendMsg($hWnd, $LB_SETSEL, True, $iIndex) <> -1
EndIf
If ($i_Ret == 0) Then Return SetError($LB_ERR, $LB_ERR, False)
Next
ElseIf $iSelect == -1 Then
If _GUICtrlListBox_GetSel($hWnd, $iIndex) Then
Return GUICtrlSendMsg($hWnd, $LB_SETSEL, False, $iIndex) <> -1
Else
Return GUICtrlSendMsg($hWnd, $LB_SETSEL, True, $iIndex) <> -1
EndIf
Else
Return GUICtrlSendMsg($hWnd, $LB_SETSEL, $iSelect, $iIndex) <> -1
EndIf
EndIf
Return $i_Ret <> 0
EndFunc
Func _GUICtrlListBox_SetTabStops($hWnd, $aTabStops)
Local $iCount = $aTabStops[0]
Local $tTabStops = DllStructCreate("int[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tTabStops, 1, $aTabStops[$iI], $iI)
Next
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SETTABSTOPS, $iCount, $tTabStops, 0, "wparam", "struct*") = 0
Else
Return GUICtrlSendMsg($hWnd, $LB_SETTABSTOPS, $iCount, DllStructGetPtr($tTabStops)) = 0
EndIf
EndFunc
Func _GUICtrlListBox_SetTopIndex($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LB_SETTOPINDEX, $iIndex) <> -1
Else
Return GUICtrlSendMsg($hWnd, $LB_SETTOPINDEX, $iIndex, 0) <> -1
EndIf
EndFunc
Func _GUICtrlListBox_Sort($hWnd)
Local $sBak = _GUICtrlListBox_GetText($hWnd, 0)
If ($sBak == -1) Then Return SetError($LB_ERR, $LB_ERR, False)
If (_GUICtrlListBox_DeleteString($hWnd, 0) == -1) Then Return SetError($LB_ERR, $LB_ERR, False)
Return _GUICtrlListBox_AddString($hWnd, $sBak) <> -1
EndFunc
Func _GUICtrlListBox_SwapString($hWnd, $iIndexA, $iIndexB)
Local $sItemA = _GUICtrlListBox_GetText($hWnd, $iIndexA)
Local $sItemB = _GUICtrlListBox_GetText($hWnd, $iIndexB)
If (_GUICtrlListBox_DeleteString($hWnd, $iIndexA) == -1) Then Return SetError($LB_ERR, $LB_ERR, False)
If (_GUICtrlListBox_InsertString($hWnd, $sItemB, $iIndexA) == -1) Then Return SetError($LB_ERR, $LB_ERR, False)
If (_GUICtrlListBox_DeleteString($hWnd, $iIndexB) == -1) Then Return SetError($LB_ERR, $LB_ERR, False)
If (_GUICtrlListBox_InsertString($hWnd, $sItemA, $iIndexB) == -1) Then Return SetError($LB_ERR, $LB_ERR, False)
Return True
EndFunc
Func _GUICtrlListBox_UpdateHScroll($hWnd)
Local $hDC, $hFont, $tSize, $sText
Local $iMax = 0
If IsHWnd($hWnd) Then
$hFont = _SendMessage($hWnd, $__LISTBOXCONSTANT_WM_GETFONT)
$hDC = _WinAPI_GetDC($hWnd)
_WinAPI_SelectObject($hDC, $hFont)
For $iI = 0 To _GUICtrlListBox_GetCount($hWnd) - 1
$sText = _GUICtrlListBox_GetText($hWnd, $iI)
$tSize = _WinAPI_GetTextExtentPoint32($hDC, $sText & "W")
If DllStructGetData($tSize, "X") > $iMax Then
$iMax = DllStructGetData($tSize, "X")
EndIf
Next
_GUICtrlListBox_SetHorizontalExtent($hWnd, $iMax)
_WinAPI_SelectObject($hDC, $hFont)
_WinAPI_ReleaseDC($hWnd, $hDC)
Else
$hFont = GUICtrlSendMsg($hWnd, $__LISTBOXCONSTANT_WM_GETFONT, 0, 0)
Local $hWnd_t = GUICtrlGetHandle($hWnd)
$hDC = _WinAPI_GetDC($hWnd_t)
_WinAPI_SelectObject($hDC, $hFont)
For $iI = 0 To _GUICtrlListBox_GetCount($hWnd) - 1
$sText = _GUICtrlListBox_GetText($hWnd, $iI)
$tSize = _WinAPI_GetTextExtentPoint32($hDC, $sText & "W")
If DllStructGetData($tSize, "X") > $iMax Then
$iMax = DllStructGetData($tSize, "X")
EndIf
Next
_GUICtrlListBox_SetHorizontalExtent($hWnd, $iMax)
_WinAPI_SelectObject($hDC, $hFont)
_WinAPI_ReleaseDC($hWnd_t, $hDC)
EndIf
EndFunc
Global Const $HDF_LEFT = 0x00000000
Global Const $HDF_RIGHT = 0x00000001
Global Const $HDF_CENTER = 0x00000002
Global Const $HDF_JUSTIFYMASK = 0x00000003
Global Const $HDF_BITMAP_ON_RIGHT = 0x00001000
Global Const $HDF_BITMAP = 0x00002000
Global Const $HDF_STRING = 0x00004000
Global Const $HDF_OWNERDRAW = 0x00008000
Global Const $HDF_DISPLAYMASK = 0x0000F000
Global Const $HDF_RTLREADING = 0x00000004
Global Const $HDF_SORTDOWN = 0x00000200
Global Const $HDF_IMAGE = 0x00000800
Global Const $HDF_SORTUP = 0x00000400
Global Const $HDF_FLAGMASK = 0x00000E04
Global Const $HDI_WIDTH = 0x00000001
Global Const $HDI_TEXT = 0x00000002
Global Const $HDI_FORMAT = 0x00000004
Global Const $HDI_PARAM = 0x00000008
Global Const $HDI_BITMAP = 0x00000010
Global Const $HDI_IMAGE = 0x00000020
Global Const $HDI_DI_SETITEM = 0x00000040
Global Const $HDI_ORDER = 0x00000080
Global Const $HDI_FILTER = 0x00000100
Global Const $HHT_NOWHERE = 0x00000001
Global Const $HHT_ONHEADER = 0x00000002
Global Const $HHT_ONDIVIDER = 0x00000004
Global Const $HHT_ONDIVOPEN = 0x00000008
Global Const $HHT_ONFILTER = 0x00000010
Global Const $HHT_ONFILTERBUTTON = 0x00000020
Global Const $HHT_ABOVE = 0x00000100
Global Const $HHT_BELOW = 0x00000200
Global Const $HHT_TORIGHT = 0x00000400
Global Const $HHT_TOLEFT = 0x00000800
Global Const $HDM_FIRST = 0x1200
Global Const $HDM_CLEARFILTER = $HDM_FIRST + 24
Global Const $HDM_CREATEDRAGIMAGE = $HDM_FIRST + 16
Global Const $HDM_DELETEITEM = $HDM_FIRST + 2
Global Const $HDM_EDITFILTER = $HDM_FIRST + 23
Global Const $HDM_GETBITMAPMARGIN = $HDM_FIRST + 21
Global Const $HDM_GETFOCUSEDITEM = $HDM_FIRST + 27
Global Const $HDM_GETIMAGELIST = $HDM_FIRST + 9
Global Const $HDM_GETITEMA = $HDM_FIRST + 3
Global Const $HDM_GETITEMW = $HDM_FIRST + 11
Global Const $HDM_GETITEMCOUNT = $HDM_FIRST + 0
Global Const $HDM_GETITEMDROPDOWNRECT = $HDM_FIRST + 25
Global Const $HDM_GETITEMRECT = $HDM_FIRST + 7
Global Const $HDM_GETORDERARRAY = $HDM_FIRST + 17
Global Const $HDM_GETOVERFLOWRECT = $HDM_FIRST + 26
Global Const $HDM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $HDM_HITTEST = $HDM_FIRST + 6
Global Const $HDM_INSERTITEMA = $HDM_FIRST + 1
Global Const $HDM_INSERTITEMW = $HDM_FIRST + 10
Global Const $HDM_LAYOUT = $HDM_FIRST + 5
Global Const $HDM_ORDERTOINDEX = $HDM_FIRST + 15
Global Const $HDM_SETBITMAPMARGIN = $HDM_FIRST + 20
Global Const $HDM_SETFILTERCHANGETIMEOUT = $HDM_FIRST + 22
Global Const $HDM_SETFOCUSEDITEM = $HDM_FIRST + 28
Global Const $HDM_SETHOTDIVIDER = $HDM_FIRST + 19
Global Const $HDM_SETIMAGELIST = $HDM_FIRST + 8
Global Const $HDM_SETITEMA = $HDM_FIRST + 4
Global Const $HDM_SETITEMW = $HDM_FIRST + 12
Global Const $HDM_SETORDERARRAY = $HDM_FIRST + 18
Global Const $HDM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $HDN_FIRST = -300
Global Const $HDN_BEGINDRAG = $HDN_FIRST - 10
Global Const $HDN_BEGINTRACK = $HDN_FIRST - 6
Global Const $HDN_DIVIDERDBLCLICK = $HDN_FIRST - 5
Global Const $HDN_ENDDRAG = $HDN_FIRST - 11
Global Const $HDN_ENDTRACK = $HDN_FIRST - 7
Global Const $HDN_FILTERBTNCLICK = $HDN_FIRST - 13
Global Const $HDN_FILTERCHANGE = $HDN_FIRST - 12
Global Const $HDN_GETDISPINFO = $HDN_FIRST - 9
Global Const $HDN_ITEMCHANGED = $HDN_FIRST - 1
Global Const $HDN_ITEMCHANGING = $HDN_FIRST - 0
Global Const $HDN_ITEMCLICK = $HDN_FIRST - 2
Global Const $HDN_ITEMDBLCLICK = $HDN_FIRST - 3
Global Const $HDN_TRACK = $HDN_FIRST - 8
Global Const $HDN_BEGINTRACKW = $HDN_FIRST - 26
Global Const $HDN_DIVIDERDBLCLICKW = $HDN_FIRST - 25
Global Const $HDN_ENDTRACKW = $HDN_FIRST - 27
Global Const $HDN_GETDISPINFOW = $HDN_FIRST - 29
Global Const $HDN_ITEMCHANGEDW = $HDN_FIRST - 21
Global Const $HDN_ITEMCHANGINGW = $HDN_FIRST - 20
Global Const $HDN_ITEMCLICKW = $HDN_FIRST - 22
Global Const $HDN_ITEMDBLCLICKW = $HDN_FIRST - 23
Global Const $HDN_TRACKW = $HDN_FIRST - 28
Global Const $HDS_BUTTONS = 0x00000002
Global Const $HDS_CHECKBOXES = 0x00000400
Global Const $HDS_DRAGDROP = 0x00000040
Global Const $HDS_FILTERBAR = 0x00000100
Global Const $HDS_FLAT = 0x00000200
Global Const $HDS_FULLDRAG = 0x00000080
Global Const $HDS_HIDDEN = 0x00000008
Global Const $HDS_HORZ = 0x00000000
Global Const $HDS_HOTTRACK = 0x00000004
Global Const $HDS_NOSIZING = 0x0800
Global Const $HDS_OVERFLOW = 0x1000
Global Const $HDS_DEFAULT = 0x00000046
Global $__g_hHDRLastWnd
Global Const $__HEADERCONSTANT_ClassName = "SysHeader32"
Global Const $__HEADERCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__HEADERCONSTANT_SWP_SHOWWINDOW = 0x0040
Global Const $tagHDHITTESTINFO = $tagPOINT & ";uint Flags;int Item"
Global Const $tagHDLAYOUT = "ptr Rect;ptr WindowPos"
Global Const $tagHDTEXTFILTER = "ptr Text;int TextMax"
Func _GUICtrlHeader_AddItem($hWnd, $sText, $iWidth = 50, $iAlign = 0, $iImage = -1, $bOnRight = False)
Return _GUICtrlHeader_InsertItem($hWnd, _GUICtrlHeader_GetItemCount($hWnd), $sText, $iWidth, $iAlign, $iImage, $bOnRight)
EndFunc
Func _GUICtrlHeader_ClearFilter($hWnd, $iIndex)
Return _SendMessage($hWnd, $HDM_CLEARFILTER, $iIndex) <> 0
EndFunc
Func _GUICtrlHeader_ClearFilterAll($hWnd)
Return _SendMessage($hWnd, $HDM_CLEARFILTER, -1) <> 0
EndFunc
Func _GUICtrlHeader_Create($hWnd, $iStyle = 0x00000046)
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hHeader = _WinAPI_CreateWindowEx(0, $__HEADERCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
Local $tWindowPos = _GUICtrlHeader_Layout($hHeader, $tRECT)
Local $iFlags = BitOR(DllStructGetData($tWindowPos, "Flags"), $__HEADERCONSTANT_SWP_SHOWWINDOW)
_WinAPI_SetWindowPos($hHeader, DllStructGetData($tWindowPos, "InsertAfter"),  DllStructGetData($tWindowPos, "X"), DllStructGetData($tWindowPos, "Y"),  DllStructGetData($tWindowPos, "CX"), DllStructGetData($tWindowPos, "CY"), $iFlags)
_WinAPI_SetFont($hHeader, _WinAPI_GetStockObject($__HEADERCONSTANT_DEFAULT_GUI_FONT))
Return $hHeader
EndFunc
Func _GUICtrlHeader_CreateDragImage($hWnd, $iIndex)
Return Ptr(_SendMessage($hWnd, $HDM_CREATEDRAGIMAGE, $iIndex))
EndFunc
Func _GUICtrlHeader_DeleteItem($hWnd, $iIndex)
Return _SendMessage($hWnd, $HDM_DELETEITEM, $iIndex) <> 0
EndFunc
Func _GUICtrlHeader_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__HEADERCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlHeader_EditFilter($hWnd, $iIndex, $bDiscard = True)
Return _SendMessage($hWnd, $HDM_EDITFILTER, $iIndex, $bDiscard) <> 0
EndFunc
Func _GUICtrlHeader_GetBitmapMargin($hWnd)
Return _SendMessage($hWnd, $HDM_GETBITMAPMARGIN)
EndFunc
Func _GUICtrlHeader_GetImageList($hWnd)
Return Ptr(_SendMessage($hWnd, $HDM_GETIMAGELIST))
EndFunc
Func _GUICtrlHeader_GetItem($hWnd, $iIndex, ByRef $tItem)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_GETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_GetItemAlign($hWnd, $iIndex)
Switch BitAND(_GUICtrlHeader_GetItemFormat($hWnd, $iIndex), $HDF_JUSTIFYMASK)
Case $HDF_LEFT
Return 0
Case $HDF_RIGHT
Return 1
Case $HDF_CENTER
Return 2
Case Else
Return -1
EndSwitch
EndFunc
Func _GUICtrlHeader_GetItemBitmap($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_BITMAP)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "hBmp")
EndFunc
Func _GUICtrlHeader_GetItemCount($hWnd)
Return _SendMessage($hWnd, $HDM_GETITEMCOUNT)
EndFunc
Func _GUICtrlHeader_GetItemDisplay($hWnd, $iIndex)
Local $iRet = 0
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
If BitAND($iFormat, $HDF_BITMAP) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFormat, $HDF_BITMAP_ON_RIGHT) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFormat, $HDF_OWNERDRAW) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFormat, $HDF_STRING) <> 0 Then $iRet = BitOR($iRet, 8)
Return $iRet
EndFunc
Func _GUICtrlHeader_GetItemFlags($hWnd, $iIndex)
Local $iRet = 0
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
If BitAND($iFormat, $HDF_IMAGE) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFormat, $HDF_RTLREADING) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFormat, $HDF_SORTDOWN) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFormat, $HDF_SORTUP) <> 0 Then $iRet = BitOR($iRet, 8)
Return $iRet
EndFunc
Func _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FORMAT)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Fmt")
EndFunc
Func _GUICtrlHeader_GetItemImage($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_IMAGE)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlHeader_GetItemOrder($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_ORDER)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Order")
EndFunc
Func _GUICtrlHeader_GetItemParam($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_PARAM)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlHeader_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlHeader_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlHeader_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
_SendMessage($hWnd, $HDM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT)
_SendMessage($hWnd, $HDM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Return $tRECT
EndFunc
Func _GUICtrlHeader_GetItemText($hWnd, $iIndex)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_TEXT)
DllStructSetData($tItem, "TextMax", 4096)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + DllStructGetSize($tBuffer), $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
_SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $HDM_GETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pText, $tBuffer, DllStructGetSize($tBuffer))
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlHeader_GetItemWidth($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_WIDTH)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "XY")
EndFunc
Func _GUICtrlHeader_GetOrderArray($hWnd)
Local $iItems = _GUICtrlHeader_GetItemCount($hWnd)
Local $tBuffer = DllStructCreate("int[" & $iItems & "]")
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
_SendMessage($hWnd, $HDM_GETORDERARRAY, $iItems, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $HDM_GETORDERARRAY, $iItems, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Local $aBuffer[$iItems + 1]
$aBuffer[0] = $iItems
For $iI = 1 To $iItems
$aBuffer[$iI] = DllStructGetData($tBuffer, 1, $iI)
Next
Return $aBuffer
EndFunc
Func _GUICtrlHeader_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $HDM_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlHeader_HitTest($hWnd, $iX, $iY)
Local $tTest = DllStructCreate($tagHDHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
Local $aTest[11]
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$aTest[0] = _SendMessage($hWnd, $HDM_HITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
Local $iTest = DllStructGetSize($tTest)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest)
$aTest[0] = _SendMessage($hWnd, $HDM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Local $iFlags = DllStructGetData($tTest, "Flags")
$aTest[1] = BitAND($iFlags, $HHT_NOWHERE) <> 0
$aTest[2] = BitAND($iFlags, $HHT_ONHEADER) <> 0
$aTest[3] = BitAND($iFlags, $HHT_ONDIVIDER) <> 0
$aTest[4] = BitAND($iFlags, $HHT_ONDIVOPEN) <> 0
$aTest[5] = BitAND($iFlags, $HHT_ONFILTER) <> 0
$aTest[6] = BitAND($iFlags, $HHT_ONFILTERBUTTON) <> 0
$aTest[7] = BitAND($iFlags, $HHT_ABOVE) <> 0
$aTest[8] = BitAND($iFlags, $HHT_BELOW) <> 0
$aTest[9] = BitAND($iFlags, $HHT_TORIGHT) <> 0
$aTest[10] = BitAND($iFlags, $HHT_TOLEFT) <> 0
Return $aTest
EndFunc
Func _GUICtrlHeader_InsertItem($hWnd, $iIndex, $sText, $iWidth = 50, $iAlign = 0, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $pBuffer, $iBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
$pBuffer = DllStructGetPtr($tBuffer)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
Local $iFmt = $aAlign[$iAlign]
Local $iMask = BitOR($HDI_WIDTH, $HDI_FORMAT)
If $sText <> "" Then
$iMask = BitOR($iMask, $HDI_TEXT)
$iFmt = BitOR($iFmt, $HDF_STRING)
EndIf
If $iImage <> -1 Then
$iMask = BitOR($iMask, $HDI_IMAGE)
$iFmt = BitOR($iFmt, $HDF_IMAGE)
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $HDF_BITMAP_ON_RIGHT)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "XY", $iWidth)
DllStructSetData($tItem, "Fmt", $iFmt)
DllStructSetData($tItem, "Image", $iImage)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tItem, "Text", -1)
EndIf
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUICtrlHeader_Layout($hWnd, ByRef $tRECT)
Local $tLayout = DllStructCreate($tagHDLAYOUT)
Local $tWindowPos = DllStructCreate($tagWINDOWPOS)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tLayout, "Rect", DllStructGetPtr($tRECT))
DllStructSetData($tLayout, "WindowPos", DllStructGetPtr($tWindowPos))
_SendMessage($hWnd, $HDM_LAYOUT, 0, $tLayout, 0, "wparam", "struct*")
Else
Local $iLayout = DllStructGetSize($tLayout)
Local $iRect = DllStructGetSize($tRECT)
Local $iWindowPos = DllStructGetSize($tWindowPos)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iLayout + $iRect + $iWindowPos, $tMemMap)
DllStructSetData($tLayout, "Rect", $pMemory + $iLayout)
DllStructSetData($tLayout, "WindowPos", $pMemory + $iLayout + $iRect)
_MemWrite($tMemMap, $tLayout, $pMemory, $iLayout)
_MemWrite($tMemMap, $tRECT, $pMemory + $iLayout, $iRect)
_SendMessage($hWnd, $HDM_LAYOUT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory + $iLayout + $iRect, $tWindowPos, $iWindowPos)
_MemFree($tMemMap)
EndIf
Return $tWindowPos
EndFunc
Func _GUICtrlHeader_OrderToIndex($hWnd, $iOrder)
Return _SendMessage($hWnd, $HDM_ORDERTOINDEX, $iOrder)
EndFunc
Func _GUICtrlHeader_SetBitmapMargin($hWnd, $iWidth)
Return _SendMessage($hWnd, $HDM_SETBITMAPMARGIN, $iWidth)
EndFunc
Func _GUICtrlHeader_SetFilterChangeTimeout($hWnd, $iTimeOut)
Return _SendMessage($hWnd, $HDM_SETFILTERCHANGETIMEOUT, 0, $iTimeOut)
EndFunc
Func _GUICtrlHeader_SetHotDivider($hWnd, $iFlag, $iInputValue)
Return _SendMessage($hWnd, $HDM_SETHOTDIVIDER, $iFlag, $iInputValue)
EndFunc
Func _GUICtrlHeader_SetImageList($hWnd, $hImage)
Return _SendMessage($hWnd, $HDM_SETIMAGELIST, 0, $hImage, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlHeader_SetItem($hWnd, $iIndex, ByRef $tItem)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_SETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetItemAlign($hWnd, $iIndex, $iAlign)
Local $aAlign[3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
$iFormat = BitAND($iFormat, BitNOT($HDF_JUSTIFYMASK))
$iFormat = BitOR($iFormat, $aAlign[$iAlign])
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemBitmap($hWnd, $iIndex, $hBitmap)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", BitOR($HDI_FORMAT, $HDI_BITMAP))
DllStructSetData($tItem, "Fmt", $HDF_BITMAP)
DllStructSetData($tItem, "hBMP", $hBitmap)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemDisplay($hWnd, $iIndex, $iDisplay)
Local $iFormat = BitAND(_GUICtrlHeader_GetItemFormat($hWnd, $iIndex), Not $HDF_DISPLAYMASK)
If BitAND($iDisplay, 1) <> 0 Then $iFormat = BitOR($iFormat, $HDF_BITMAP)
If BitAND($iDisplay, 2) <> 0 Then $iFormat = BitOR($iFormat, $HDF_BITMAP_ON_RIGHT)
If BitAND($iDisplay, 4) <> 0 Then $iFormat = BitOR($iFormat, $HDF_OWNERDRAW)
If BitAND($iDisplay, 8) <> 0 Then $iFormat = BitOR($iFormat, $HDF_STRING)
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemFlags($hWnd, $iIndex, $iFlags)
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
$iFormat = BitAND($iFormat, BitNOT($HDF_FLAGMASK))
If BitAND($iFlags, 1) <> 0 Then $iFormat = BitOR($iFormat, $HDF_IMAGE)
If BitAND($iFlags, 2) <> 0 Then $iFormat = BitOR($iFormat, $HDF_RTLREADING)
If BitAND($iFlags, 4) <> 0 Then $iFormat = BitOR($iFormat, $HDF_SORTDOWN)
If BitAND($iFlags, 8) <> 0 Then $iFormat = BitOR($iFormat, $HDF_SORTUP)
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FORMAT)
DllStructSetData($tItem, "Fmt", $iFormat)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemImage($hWnd, $iIndex, $iImage)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_IMAGE)
DllStructSetData($tItem, "Image", $iImage)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemOrder($hWnd, $iIndex, $iOrder)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_ORDER)
DllStructSetData($tItem, "Order", $iOrder)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemParam($hWnd, $iIndex, $iParam)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_PARAM)
DllStructSetData($tItem, "Param", $iParam)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemText($hWnd, $iIndex, $sText)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iBuffer, $pBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
$pBuffer = DllStructGetPtr($tBuffer)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_TEXT)
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tItem, "Text", -1)
EndIf
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_SETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetItemWidth($hWnd, $iIndex, $iWidth)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_WIDTH)
DllStructSetData($tItem, "XY", $iWidth)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetOrderArray($hWnd, ByRef $aOrder)
Local $tBuffer = DllStructCreate("int[" & $aOrder[0] & "]")
For $iI = 1 To $aOrder[0]
DllStructSetData($tBuffer, 1, $aOrder[$iI], $iI)
Next
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_SETORDERARRAY, $aOrder[0], $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer)
$iRet = _SendMessage($hWnd, $HDM_SETORDERARRAY, $aOrder[0], $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetUnicodeFormat($hWnd, $bUnicode)
Return _SendMessage($hWnd, $HDM_SETUNICODEFORMAT, $bUnicode)
EndFunc
Global $__g_hLVLastWnd
Global Const $__LISTVIEWCONSTANT_SORTINFOSIZE = 11
Global $__g_aListViewSortInfo[1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
Global Const $__LISTVIEWCONSTANT_ClassName = "SysListView32"
Global Const $__LISTVIEWCONSTANT_WS_MAXIMIZEBOX = 0x00010000
Global Const $__LISTVIEWCONSTANT_WS_MINIMIZEBOX = 0x00020000
Global Const $__LISTVIEWCONSTANT_GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $__LISTVIEWCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__LISTVIEWCONSTANT_WM_SETFONT = 0x0030
Global Const $__LISTVIEWCONSTANT_WM_NOTIFY = 0x004E
Global Const $__LISTVIEWCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__LISTVIEWCONSTANT_ILD_TRANSPARENT = 0x00000001
Global Const $__LISTVIEWCONSTANT_ILD_BLEND25 = 0x00000002
Global Const $__LISTVIEWCONSTANT_ILD_BLEND50 = 0x00000004
Global Const $__LISTVIEWCONSTANT_ILD_MASK = 0x00000010
Global Const $__LISTVIEWCONSTANT_VK_DOWN = 0x28
Global Const $__LISTVIEWCONSTANT_VK_END = 0x23
Global Const $__LISTVIEWCONSTANT_VK_HOME = 0x24
Global Const $__LISTVIEWCONSTANT_VK_LEFT = 0x25
Global Const $__LISTVIEWCONSTANT_VK_NEXT = 0x22
Global Const $__LISTVIEWCONSTANT_VK_PRIOR = 0x21
Global Const $__LISTVIEWCONSTANT_VK_RIGHT = 0x27
Global Const $__LISTVIEWCONSTANT_VK_UP = 0x26
Global Const $tagLVBKIMAGE = "ulong Flags;hwnd hBmp;ptr Image;uint ImageMax;int XOffPercent;int YOffPercent"
Global Const $tagLVCOLUMN = "uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal"
Global Const $tagLVGROUP = "uint Size;uint Mask;ptr Header;int HeaderMax;ptr Footer;int FooterMax;int GroupID;uint StateMask;uint State;uint Align;" &  "ptr  pszSubtitle;uint cchSubtitle;ptr pszTask;uint cchTask;ptr pszDescriptionTop;uint cchDescriptionTop;ptr pszDescriptionBottom;" &  "uint cchDescriptionBottom;int iTitleImage;int iExtendedImage;int iFirstItem;uint cItems;ptr pszSubsetTitle;uint cchSubsetTitle"
Global Const $tagLVINSERTMARK = "uint Size;dword Flags;int Item;dword Reserved"
Global Const $tagLVSETINFOTIP = "uint Size;dword Flags;ptr Text;int Item;int SubItem"
Func _GUICtrlListView_AddArray($hWnd, ByRef $aItems)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tItem = DllStructCreate($tagLVITEM)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", 4096)
Local $iLastItem = _GUICtrlListView_GetItemCount($hWnd)
_GUICtrlListView_BeginUpdate($hWnd)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
_SendMessage($hWnd, $LVM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
_SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Next
Next
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI + $iLastItem)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
_SendMessage($hWnd, $LVM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
_SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
Next
Next
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI + $iLastItem)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_INSERTITEMW, 0, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_INSERTITEMA, 0, $pItem)
EndIf
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
Next
Next
EndIf
_GUICtrlListView_EndUpdate($hWnd)
EndFunc
Func _GUICtrlListView_AddColumn($hWnd, $sText, $iWidth = 50, $iAlign = -1, $iImage = -1, $bOnRight = False)
Return _GUICtrlListView_InsertColumn($hWnd, _GUICtrlListView_GetColumnCount($hWnd), $sText, $iWidth, $iAlign, $iImage, $bOnRight)
EndFunc
Func _GUICtrlListView_AddItem($hWnd, $sText, $iImage = -1, $iParam = 0)
Return _GUICtrlListView_InsertItem($hWnd, $sText, -1, $iImage, $iParam)
EndFunc
Func _GUICtrlListView_AddSubItem($hWnd, $iIndex, $sText, $iSubItem, $iImage = -1)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
Local $iMask = $LVIF_TEXT
If $iImage <> -1 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_ApproximateViewHeight($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
If IsHWnd($hWnd) Then
Return BitShift((_SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 16)
Else
Return BitShift((GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 16)
EndIf
EndFunc
Func _GUICtrlListView_ApproximateViewRect($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
Local $iView
If IsHWnd($hWnd) Then
$iView = _SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))
Else
$iView = GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))
EndIf
Local $aView[2]
$aView[0] = BitAND($iView, 0xFFFF)
$aView[1] = BitShift($iView, 16)
Return $aView
EndFunc
Func _GUICtrlListView_ApproximateViewWidth($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
If IsHWnd($hWnd) Then
Return BitAND((_SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 0xFFFF)
Else
Return BitAND((GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 0xFFFF)
EndIf
EndFunc
Func _GUICtrlListView_Arrange($hWnd, $iArrange = 0)
Local $aArrange[4] = [$LVA_DEFAULT, $LVA_ALIGNLEFT, $LVA_ALIGNTOP, $LVA_SNAPTOGRID]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ARRANGE, $aArrange[$iArrange]) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ARRANGE, $aArrange[$iArrange], 0) <> 0
EndIf
EndFunc
Func __GUICtrlListView_ArrayDelete(ByRef $avArray, $iElement)
If Not IsArray($avArray) Then Return SetError(1, 0, "")
Local $iUpper = UBound($avArray)
If $iUpper = 1 Then
SetError(2)
Return ""
EndIf
Local $avNewArray[$iUpper - 1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
$avNewArray[0][0] = $avArray[0][0]
If $iElement < 0 Then
$iElement = 0
EndIf
If $iElement > ($iUpper - 1) Then
$iElement = ($iUpper - 1)
EndIf
If $iElement > 0 Then
For $iCntr = 0 To $iElement - 1
For $x = 1 To $__LISTVIEWCONSTANT_SORTINFOSIZE - 1
$avNewArray[$iCntr][$x] = $avArray[$iCntr][$x]
Next
Next
EndIf
If $iElement < ($iUpper - 1) Then
For $iCntr = ($iElement + 1) To ($iUpper - 1)
For $x = 1 To $__LISTVIEWCONSTANT_SORTINFOSIZE - 1
$avNewArray[$iCntr - 1][$x] = $avArray[$iCntr][$x]
Next
Next
EndIf
$avArray = $avNewArray
SetError(0)
Return 1
EndFunc
Func _GUICtrlListView_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlListView_CancelEditLabel($hWnd)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_CANCELEDITLABEL)
Else
GUICtrlSendMsg($hWnd, $LVM_CANCELEDITLABEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_ClickItem($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_GUICtrlListView_EnsureVisible($hWnd, $iIndex, False)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $LVIR_LABEL)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
Local $iX, $iY
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
If Not $bMove Then
Local $aPos = MouseGetPos()
_WinAPI_ShowCursor(False)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
MouseMove($aPos[0], $aPos[1], 0)
_WinAPI_ShowCursor(True)
Else
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
EndIf
Opt("MouseCoordMode", $iMode)
EndFunc
Func _GUICtrlListView_CopyItems($hWnd_Source, $hWnd_Destination, $bDelFlag = False)
Local $a_Indices, $tItem = DllStructCreate($tagLVITEM), $iIndex
Local $iCols = _GUICtrlListView_GetColumnCount($hWnd_Source)
Local $iItems = _GUICtrlListView_GetItemCount($hWnd_Source)
_GUICtrlListView_BeginUpdate($hWnd_Source)
_GUICtrlListView_BeginUpdate($hWnd_Destination)
If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hWnd_Source), $LVS_EX_CHECKBOXES) == $LVS_EX_CHECKBOXES Then
For $i = 0 To $iItems - 1
If (_GUICtrlListView_GetItemChecked($hWnd_Source, $i)) Then
If IsArray($a_Indices) Then
ReDim $a_Indices[UBound($a_Indices) + 1]
Else
Local $a_Indices[2]
EndIf
$a_Indices[0] = $a_Indices[0] + 1
$a_Indices[UBound($a_Indices) - 1] = $i
EndIf
Next
If (IsArray($a_Indices)) Then
For $i = 1 To $a_Indices[0]
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
$iIndex = _GUICtrlListView_AddItem($hWnd_Destination, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], 0), DllStructGetData($tItem, "Image"))
_GUICtrlListView_SetItemChecked($hWnd_Destination, $iIndex)
For $x = 1 To $iCols - 1
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", $x)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
_GUICtrlListView_AddSubItem($hWnd_Destination, $iIndex, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], $x), $x, DllStructGetData($tItem, "Image"))
Next
Next
If $bDelFlag Then
For $i = $a_Indices[0] To 1 Step -1
_GUICtrlListView_DeleteItem($hWnd_Source, $a_Indices[$i])
Next
EndIf
EndIf
EndIf
If (_GUICtrlListView_GetSelectedCount($hWnd_Source)) Then
$a_Indices = _GUICtrlListView_GetSelectedIndices($hWnd_Source, 1)
For $i = 1 To $a_Indices[0]
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
$iIndex = _GUICtrlListView_AddItem($hWnd_Destination, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], 0), DllStructGetData($tItem, "Image"))
For $x = 1 To $iCols - 1
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", $x)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
_GUICtrlListView_AddSubItem($hWnd_Destination, $iIndex, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], $x), $x, DllStructGetData($tItem, "Image"))
Next
Next
_GUICtrlListView_SetItemSelected($hWnd_Source, -1, False)
If $bDelFlag Then
For $i = $a_Indices[0] To 1 Step -1
_GUICtrlListView_DeleteItem($hWnd_Source, $a_Indices[$i])
Next
EndIf
EndIf
_GUICtrlListView_EndUpdate($hWnd_Source)
_GUICtrlListView_EndUpdate($hWnd_Destination)
EndFunc
Func _GUICtrlListView_Create($hWnd, $sHeaderText, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x0000000D, $iExStyle = 0x00000000, $bCoInit = False)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sHeaderText) Then Return SetError(2, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = $LVS_DEFAULT
If $iExStyle = -1 Then $iExStyle = 0x00000000
Local Const $S_OK = 0x0
Local Const $S_FALSE = 0x1
Local Const $RPC_E_CHANGED_MODE = 0x80010106
Local Const $E_INVALIDARG = 0x80070057
Local Const $E_OUTOFMEMORY = 0x8007000E
Local Const $E_UNEXPECTED = 0x8000FFFF
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local Const $COINIT_APARTMENTTHREADED = 0x02
Local $iStr_len = StringLen($sHeaderText)
If $iStr_len Then $sHeaderText = StringSplit($sHeaderText, $sSeparatorChar)
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $iStyle)
If $bCoInit Then
Local $aResult = DllCall('ole32.dll', 'long', 'CoInitializeEx', 'ptr', 0, 'dword', $COINIT_APARTMENTTHREADED)
If @error Then Return SetError(@error, @extended, 0)
Switch $aResult[0]
Case $S_OK
Case $S_FALSE
Case $RPC_E_CHANGED_MODE
Case $E_INVALIDARG
Case $E_OUTOFMEMORY
Case $E_UNEXPECTED
EndSwitch
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hList = _WinAPI_CreateWindowEx($iExStyle, $__LISTVIEWCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hList, $__LISTVIEWCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__LISTVIEWCONSTANT_DEFAULT_GUI_FONT), True)
If $iStr_len Then
For $x = 1 To $sHeaderText[0]
_GUICtrlListView_InsertColumn($hList, $x - 1, $sHeaderText[$x], 75)
Next
EndIf
Return $hList
EndFunc
Func _GUICtrlListView_CreateDragImage($hWnd, $iIndex)
Local $aDrag[3]
Local $tPoint = DllStructCreate($tagPOINT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aDrag[0] = _SendMessage($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, $tPoint, 0, "wparam", "struct*", "handle")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
$aDrag[0] = _SendMessage($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, $pMemory, 0, "wparam", "ptr", "handle")
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$aDrag[0] = Ptr(GUICtrlSendMsg($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, DllStructGetPtr($tPoint)))
EndIf
$aDrag[1] = DllStructGetData($tPoint, "X")
$aDrag[2] = DllStructGetData($tPoint, "Y")
Return $aDrag
EndFunc
Func _GUICtrlListView_CreateSolidBitMap($hWnd, $iColor, $iWidth, $iHeight)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight)
EndFunc
Func _GUICtrlListView_DeleteAllItems($hWnd)
If _GUICtrlListView_GetItemCount($hWnd) = 0 Then Return True
Local $vCID = 0
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
If $vCID < $_UDF_STARTID Then
Local $iParam = 0
For $iIndex = _GUICtrlListView_GetItemCount($hWnd) - 1 To 0 Step -1
$iParam = _GUICtrlListView_GetItemParam($hWnd, $iIndex)
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
GUICtrlDelete($iParam)
EndIf
Next
If _GUICtrlListView_GetItemCount($hWnd) = 0 Then Return True
EndIf
Return _SendMessage($hWnd, $LVM_DELETEALLITEMS) <> 0
EndFunc
Func _GUICtrlListView_DeleteColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_DELETECOLUMN, $iCol) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_DELETECOLUMN, $iCol, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_DeleteItem($hWnd, $iIndex)
Local $vCID = 0
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
If $vCID < $_UDF_STARTID Then
Local $iParam = _GUICtrlListView_GetItemParam($hWnd, $iIndex)
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
If GUICtrlDelete($iParam) Then
Return True
EndIf
EndIf
EndIf
Return _SendMessage($hWnd, $LVM_DELETEITEM, $iIndex) <> 0
EndFunc
Func _GUICtrlListView_DeleteItemsSelected($hWnd)
Local $iItemCount = _GUICtrlListView_GetItemCount($hWnd)
If _GUICtrlListView_GetSelectedCount($hWnd) = $iItemCount Then
Return _GUICtrlListView_DeleteAllItems($hWnd)
Else
Local $aSelected = _GUICtrlListView_GetSelectedIndices($hWnd, True)
If Not IsArray($aSelected) Then Return SetError($LV_ERR, $LV_ERR, 0)
_GUICtrlListView_SetItemSelected($hWnd, -1, False)
Local $vCID = 0, $iNative_Delete, $iUDF_Delete
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
For $iIndex = $aSelected[0] To 1 Step -1
If $vCID < $_UDF_STARTID Then
Local $iParam = _GUICtrlListView_GetItemParam($hWnd, $aSelected[$iIndex])
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
$iNative_Delete = GUICtrlDelete($iParam)
If $iNative_Delete Then ContinueLoop
EndIf
EndIf
$iUDF_Delete = _SendMessage($hWnd, $LVM_DELETEITEM, $aSelected[$iIndex])
If $iNative_Delete + $iUDF_Delete = 0 Then
ExitLoop
EndIf
Next
Return Not $iIndex
EndIf
EndFunc
Func _GUICtrlListView_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__LISTVIEWCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func __GUICtrlListView_Draw($hWnd, $iIndex, $hDC, $iX, $iY, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlListView_DrawDragImage(ByRef $hWnd, ByRef $aDrag)
Local $hDC = _WinAPI_GetWindowDC($hWnd)
Local $tPoint = _WinAPI_GetMousePos(True, $hWnd)
_WinAPI_InvalidateRect($hWnd)
__GUICtrlListView_Draw($aDrag[0], 0, $hDC, DllStructGetData($tPoint, "X"), DllStructGetData($tPoint, "Y"))
_WinAPI_ReleaseDC($hWnd, $hDC)
EndFunc
Func _GUICtrlListView_EditLabel($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $aResult
If IsHWnd($hWnd) Then
$aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
If $aResult = 0 Then Return 0
If $bUnicode Then
Return _SendMessage($hWnd, $LVM_EDITLABELW, $iIndex, 0, 0, "wparam", "lparam", "hwnd")
Else
Return _SendMessage($hWnd, $LVM_EDITLABEL, $iIndex, 0, 0, "wparam", "lparam", "hwnd")
EndIf
Else
$aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", GUICtrlGetHandle($hWnd))
If @error Then Return SetError(@error, @extended, 0)
If $aResult = 0 Then Return 0
If $bUnicode Then
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_EDITLABELW, $iIndex, 0))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_EDITLABEL, $iIndex, 0))
EndIf
EndIf
EndFunc
Func _GUICtrlListView_EnableGroupView($hWnd, $bEnable = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ENABLEGROUPVIEW, $bEnable)
Else
Return GUICtrlSendMsg($hWnd, $LVM_ENABLEGROUPVIEW, $bEnable, 0)
EndIf
EndFunc
Func _GUICtrlListView_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlListView_EnsureVisible($hWnd, $iIndex, $bPartialOK = False)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ENSUREVISIBLE, $iIndex, $bPartialOK)
Else
Return GUICtrlSendMsg($hWnd, $LVM_ENSUREVISIBLE, $iIndex, $bPartialOK)
EndIf
EndFunc
Func _GUICtrlListView_FindInText($hWnd, $sText, $iStart = -1, $bWrapOK = True, $bReverse = False)
Local $iCount = _GUICtrlListView_GetItemCount($hWnd)
Local $iColumns = _GUICtrlListView_GetColumnCount($hWnd)
If $iColumns = 0 Then $iColumns = 1
If $bReverse And $iStart = -1 Then Return -1
Local $sList
If $bReverse Then
For $iI = $iStart - 1 To 0 Step -1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
Else
For $iI = $iStart + 1 To $iCount - 1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
EndIf
If (($iStart = -1) Or Not $bWrapOK) And Not $bReverse Then Return -1
If $bReverse And $bWrapOK Then
For $iI = $iCount - 1 To $iStart + 1 Step -1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
Else
For $iI = 0 To $iStart - 1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
EndIf
Return -1
EndFunc
Func _GUICtrlListView_FindItem($hWnd, $iStart, ByRef $tFindInfo, $sText = "")
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
Local $pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tFindInfo, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_FINDITEM, $iStart, $tFindInfo, 0, "wparam", "struct*")
Else
Local $iFindInfo = DllStructGetSize($tFindInfo)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iFindInfo + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iFindInfo
DllStructSetData($tFindInfo, "Text", $pText)
_MemWrite($tMemMap, $tFindInfo, $pMemory, $iFindInfo)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_FINDITEM, $iStart, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tFindInfo, "Text", $pBuffer)
$iRet = GUICtrlSendMsg($hWnd, $LVM_FINDITEM, $iStart, DllStructGetPtr($tFindInfo))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_FindNearest($hWnd, $iX, $iY, $iDir = 0, $iStart = -1, $bWrapOK = True)
Local $aDir[8] = [$__LISTVIEWCONSTANT_VK_LEFT, $__LISTVIEWCONSTANT_VK_RIGHT, $__LISTVIEWCONSTANT_VK_UP, $__LISTVIEWCONSTANT_VK_DOWN, $__LISTVIEWCONSTANT_VK_HOME, $__LISTVIEWCONSTANT_VK_END, $__LISTVIEWCONSTANT_VK_PRIOR, $__LISTVIEWCONSTANT_VK_NEXT]
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
Local $iFlags = $LVFI_NEARESTXY
If $bWrapOK Then $iFlags = BitOR($iFlags, $LVFI_WRAP)
DllStructSetData($tFindInfo, "Flags", $iFlags)
DllStructSetData($tFindInfo, "X", $iX)
DllStructSetData($tFindInfo, "Y", $iY)
DllStructSetData($tFindInfo, "Direction", $aDir[$iDir])
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo)
EndFunc
Func _GUICtrlListView_FindParam($hWnd, $iParam, $iStart = -1)
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
DllStructSetData($tFindInfo, "Flags", $LVFI_PARAM)
DllStructSetData($tFindInfo, "Param", $iParam)
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo)
EndFunc
Func _GUICtrlListView_FindText($hWnd, $sText, $iStart = -1, $bPartialOK = True, $bWrapOK = True)
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
Local $iFlags = $LVFI_STRING
If $bPartialOK Then $iFlags = BitOR($iFlags, $LVFI_PARTIAL)
If $bWrapOK Then $iFlags = BitOR($iFlags, $LVFI_WRAP)
DllStructSetData($tFindInfo, "Flags", $iFlags)
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo, $sText)
EndFunc
Func _GUICtrlListView_GetBkColor($hWnd)
Local $i_Color
If IsHWnd($hWnd) Then
$i_Color = _SendMessage($hWnd, $LVM_GETBKCOLOR)
Else
$i_Color = GUICtrlSendMsg($hWnd, $LVM_GETBKCOLOR, 0, 0)
EndIf
Return __GUICtrlListView_ReverseColorOrder($i_Color)
EndFunc
Func _GUICtrlListView_GetBkImage($hWnd)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tImage = DllStructCreate($tagLVBKIMAGE)
DllStructSetData($tImage, "ImageMax", 4096)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tImage, "Image", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEW, 0, $tImage, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iImage = DllStructGetSize($tImage)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iImage + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iImage
DllStructSetData($tImage, "Image", $pText)
_MemWrite($tMemMap, $tImage, $pMemory, $iImage)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tImage, $iImage)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pImage = DllStructGetPtr($tImage)
DllStructSetData($tImage, "Image", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETBKIMAGEW, 0, $pImage)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETBKIMAGEA, 0, $pImage)
EndIf
EndIf
Local $aImage[4]
Switch BitAND(DllStructGetData($tImage, "Flags"), $LVBKIF_SOURCE_MASK)
Case $LVBKIF_SOURCE_HBITMAP
$aImage[0] = 1
Case $LVBKIF_SOURCE_URL
$aImage[0] = 2
EndSwitch
$aImage[1] = DllStructGetData($tBuffer, "Text")
$aImage[2] = DllStructGetData($tImage, "XOffPercent")
$aImage[3] = DllStructGetData($tImage, "YOffPercent")
Return SetError($iRet <> 0, 0, $aImage)
EndFunc
Func _GUICtrlListView_GetCallbackMask($hWnd)
Local $iFlags = 0
Local $iMask = _SendMessage($hWnd, $LVM_GETCALLBACKMASK)
If BitAND($iMask, $LVIS_CUT) <> 0 Then $iFlags = BitOR($iFlags, 1)
If BitAND($iMask, $LVIS_DROPHILITED) <> 0 Then $iFlags = BitOR($iFlags, 2)
If BitAND($iMask, $LVIS_FOCUSED) <> 0 Then $iFlags = BitOR($iFlags, 4)
If BitAND($iMask, $LVIS_SELECTED) <> 0 Then $iFlags = BitOR($iFlags, 8)
If BitAND($iMask, $LVIS_OVERLAYMASK) <> 0 Then $iFlags = BitOR($iFlags, 16)
If BitAND($iMask, $LVIS_STATEIMAGEMASK) <> 0 Then $iFlags = BitOR($iFlags, 32)
Return $iFlags
EndFunc
Func _GUICtrlListView_GetColumn($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
DllStructSetData($tColumn, "Mask", $LVCF_ALLDATA)
DllStructSetData($tColumn, "TextMax", 4096)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tColumn, $iColumn)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Local $aColumn[9]
Switch BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_JUSTIFYMASK)
Case $LVCFMT_RIGHT
$aColumn[0] = 1
Case $LVCFMT_CENTER
$aColumn[0] = 2
Case Else
$aColumn[0] = 0
EndSwitch
$aColumn[1] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_IMAGE) <> 0
$aColumn[2] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_BITMAP_ON_RIGHT) <> 0
$aColumn[3] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_COL_HAS_IMAGES) <> 0
$aColumn[4] = DllStructGetData($tColumn, "CX")
$aColumn[5] = DllStructGetData($tBuffer, "Text")
$aColumn[6] = DllStructGetData($tColumn, "SubItem")
$aColumn[7] = DllStructGetData($tColumn, "Image")
$aColumn[8] = DllStructGetData($tColumn, "Order")
Return SetError($iRet = 0, 0, $aColumn)
EndFunc
Func _GUICtrlListView_GetColumnCount($hWnd)
Return _SendMessage(_GUICtrlListView_GetHeader($hWnd), 0x1200)
EndFunc
Func _GUICtrlListView_GetColumnOrder($hWnd)
Local $a_Cols = _GUICtrlListView_GetColumnOrderArray($hWnd), $s_Cols = ""
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
For $i = 1 To $a_Cols[0]
$s_Cols &= $a_Cols[$i] & $sSeparatorChar
Next
$s_Cols = StringTrimRight($s_Cols, 1)
Return $s_Cols
EndFunc
Func _GUICtrlListView_GetColumnOrderArray($hWnd)
Local $iColumns = _GUICtrlListView_GetColumnCount($hWnd)
Local $tBuffer = DllStructCreate("int[" & $iColumns & "]")
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, DllStructGetPtr($tBuffer))
EndIf
Local $aBuffer[$iColumns + 1]
$aBuffer[0] = $iColumns
For $iI = 1 To $iColumns
$aBuffer[$iI] = DllStructGetData($tBuffer, 1, $iI)
Next
Return $aBuffer
EndFunc
Func _GUICtrlListView_GetColumnWidth($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETCOLUMNWIDTH, $iCol)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNWIDTH, $iCol, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetCounterPage($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETCOUNTPERPAGE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETCOUNTPERPAGE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetEditControl($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETEDITCONTROL))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETEDITCONTROL, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetEmptyText($hWnd)
Local $tText = DllStructCreate("char[4096]")
Local $iRet
If IsHWnd($hWnd) Then
Local $iText = DllStructGetSize($tText)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iText + 4096, $tMemMap)
Local $pText = $pMemory + $iText
DllStructSetData($tText, "Text", $pText)
_MemWrite($tMemMap, $pText, $pMemory, $iText)
$iRet = _SendMessage($hWnd, $LVM_GETEMPTYTEXT, 4096, $pMemory)
_MemRead($tMemMap, $pText, $tText, 4096)
_MemFree($tMemMap)
If $iRet = 0 Then Return SetError(-1, 0, "")
Return DllStructGetData($tText, 1)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETEMPTYTEXT, 4096, DllStructGetPtr($tText))
If $iRet = 0 Then Return SetError(-1, 0, "")
Return DllStructGetData($tText, 1)
EndIf
EndFunc
Func _GUICtrlListView_GetExtendedListViewStyle($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETEXTENDEDLISTVIEWSTYLE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetFocusedGroup($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETFOCUSEDGROUP)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETFOCUSEDGROUP, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETGROUPCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETGROUPCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupInfo($hWnd, $iGroupID)
Local $tGroup = __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, BitOR($LVGF_HEADER, $LVGF_ALIGN))
Local $iErr = @error
Local $aGroup[2]
$aGroup[0] = _WinAPI_WideCharToMultiByte(DllStructGetData($tGroup, "Header"))
Select
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_CENTER) <> 0
$aGroup[1] = 1
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_RIGHT) <> 0
$aGroup[1] = 2
Case Else
$aGroup[1] = 0
EndSelect
Return SetError($iErr, 0, $aGroup)
EndFunc
Func __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, $iMask)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFO, $iGroupID, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFO, $iGroupID, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPINFO, $iGroupID, DllStructGetPtr($tGroup))
EndIf
Return SetError($iRet <> $iGroupID, 0, $tGroup)
EndFunc
Func _GUICtrlListView_GetGroupInfoByIndex($hWnd, $iIndex)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID))
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, DllStructGetPtr($tGroup))
EndIf
Local $aGroup[3]
$aGroup[0] = _WinAPI_WideCharToMultiByte(DllStructGetData($tGroup, "Header"))
Select
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_CENTER) <> 0
$aGroup[1] = 1
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_RIGHT) <> 0
$aGroup[1] = 2
Case Else
$aGroup[1] = 0
EndSelect
$aGroup[2] = DllStructGetData($tGroup, "GroupID")
Return SetError($iRet = 0, 0, $aGroup)
EndFunc
Func _GUICtrlListView_GetGroupRect($hWnd, $iGroupID, $iGet = $LVGGR_GROUP)
Local $tGroup = DllStructCreate($tagRECT)
DllStructSetData($tGroup, "Top", $iGet)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPRECT, $iGroupID, $tGroup, 0, "wparam", "struct*")
Else
Local $iGroup = DllStructGetSize($tGroup)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPRECT, $iGroupID, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPRECT, $iGroupID, DllStructGetPtr($tGroup))
EndIf
Local $aGroup[4]
For $x = 0 To 3
$aGroup[$x] = DllStructGetData($tGroup, $x + 1)
Next
Return SetError($iRet = 0, 0, $aGroup)
EndFunc
Func _GUICtrlListView_GetGroupState($hWnd, $iGroupID, $iMask)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETGROUPSTATE, $iGroupID, $iMask)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETGROUPSTATE, $iGroupID, $iMask)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupViewEnabled($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ISGROUPVIEWENABLED) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ISGROUPVIEWENABLED, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_GetHeader($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETHEADER))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETHEADER, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetHotCursor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOTCURSOR, 0, 0, 0, "wparam", "lparam", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_GETHOTCURSOR, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetHotItem($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOTITEM)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETHOTITEM, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetHoverTime($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOVERTIME)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETHOVERTIME, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetImageList($hWnd, $iImageList)
Local $aImageList[3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETIMAGELIST, $aImageList[$iImageList], 0, 0, "wparam", "lparam", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_GETIMAGELIST, $aImageList[$iImageList], 0))
EndIf
EndFunc
Func _GUICtrlListView_GetInsertMark($hWnd)
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tMark, "Size", $iMark)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETINSERTMARK, 0, $tMark, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMark, $tMemMap)
_MemWrite($tMemMap, $tMark)
$iRet = _SendMessage($hWnd, $LVM_GETINSERTMARK, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tMark, $iMark)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARK, 0, DllStructGetPtr($tMark))
EndIf
Local $aMark[2]
$aMark[0] = DllStructGetData($tMark, "Flags") = $LVIM_AFTER
$aMark[1] = DllStructGetData($tMark, "Item")
Return SetError($iRet = 0, 0, $aMark)
EndFunc
Func _GUICtrlListView_GetInsertMarkColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetInsertMarkRect($hWnd)
Local $aRect[5]
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aRect[0] = _SendMessage($hWnd, $LVM_GETINSERTMARKRECT, 0, $tRECT, 0, "wparam", "struct*") <> 0
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
$aRect[0] = _SendMessage($hWnd, $LVM_GETINSERTMARKRECT, 0, $pMemory, 0, "wparam", "ptr") <> 0
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
$aRect[0] = GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARKRECT, 0, DllStructGetPtr($tRECT)) <> 0
EndIf
$aRect[1] = DllStructGetData($tRECT, "Left")
$aRect[2] = DllStructGetData($tRECT, "Top")
$aRect[3] = DllStructGetData($tRECT, "Right")
$aRect[4] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetISearchString($hWnd)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer
If IsHWnd($hWnd) Then
If $bUnicode Then
$iBuffer = _SendMessage($hWnd, $LVM_GETISEARCHSTRINGW) + 1
Else
$iBuffer = _SendMessage($hWnd, $LVM_GETISEARCHSTRINGA) + 1
EndIf
Else
If $bUnicode Then
$iBuffer = GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGW, 0, 0) + 1
Else
$iBuffer = GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGA, 0, 0) + 1
EndIf
EndIf
If $iBuffer = 1 Then Return ""
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGW, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGW, 0, $pMemory)
Else
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGA, 0, $pMemory)
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pBuffer = DllStructGetPtr($tBuffer)
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGW, 0, $pBuffer)
Else
GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGA, 0, $pBuffer)
EndIf
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlListView_GetItem($hWnd, $iIndex, $iSubItem = 0)
Local $aItem[8]
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Local $iState = DllStructGetData($tItem, "State")
If BitAND($iState, $LVIS_CUT) <> 0 Then $aItem[0] = BitOR($aItem[0], 1)
If BitAND($iState, $LVIS_DROPHILITED) <> 0 Then $aItem[0] = BitOR($aItem[0], 2)
If BitAND($iState, $LVIS_FOCUSED) <> 0 Then $aItem[0] = BitOR($aItem[0], 4)
If BitAND($iState, $LVIS_SELECTED) <> 0 Then $aItem[0] = BitOR($aItem[0], 8)
$aItem[1] = __GUICtrlListView_OverlayImageMaskToIndex($iState)
$aItem[2] = __GUICtrlListView_StateImageMaskToIndex($iState)
$aItem[3] = _GUICtrlListView_GetItemText($hWnd, $iIndex, $iSubItem)
$aItem[4] = DllStructGetData($tItem, "Image")
$aItem[5] = DllStructGetData($tItem, "Param")
$aItem[6] = DllStructGetData($tItem, "Indent")
$aItem[7] = DllStructGetData($tItem, "GroupID")
Return $aItem
EndFunc
Func _GUICtrlListView_GetItemChecked($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tLVITEM = DllStructCreate($tagLVITEM)
Local $iSize = DllStructGetSize($tLVITEM)
If @error Then Return SetError($LV_ERR, $LV_ERR, False)
DllStructSetData($tLVITEM, "Mask", $LVIF_STATE)
DllStructSetData($tLVITEM, "Item", $iIndex)
DllStructSetData($tLVITEM, "StateMask", 0xffff)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $tLVITEM, 0, "wparam", "struct*") <> 0
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tLVITEM)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $pMemory, 0, "wparam", "ptr") <> 0
Else
$iRet = _SendMessage($hWnd, $LVM_GETITEMA, 0, $pMemory, 0, "wparam", "ptr") <> 0
EndIf
_MemRead($tMemMap, $pMemory, $tLVITEM, $iSize)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tLVITEM)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMW, 0, $pItem) <> 0
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMA, 0, $pItem) <> 0
EndIf
EndIf
If Not $iRet Then Return SetError($LV_ERR, $LV_ERR, False)
Return BitAND(DllStructGetData($tLVITEM, "State"), 0x2000) <> 0
EndFunc
Func _GUICtrlListView_GetItemCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETITEMCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETITEMCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetItemCut($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_CUT) <> 0
EndFunc
Func _GUICtrlListView_GetItemDropHilited($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_DROPHILITED) <> 0
EndFunc
Func _GUICtrlListView_GetItemEx($hWnd, ByRef $tItem)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_GETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_GetItemFocused($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_FOCUSED) <> 0
EndFunc
Func _GUICtrlListView_GetItemGroupID($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_GROUPID)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "GroupID")
EndFunc
Func _GUICtrlListView_GetItemImage($hWnd, $iIndex, $iSubItem = 0)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_IMAGE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlListView_GetItemIndent($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_INDENT)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Indent")
EndFunc
Func __GUICtrlListView_GetItemOverlayImage($hWnd, $iIndex)
Return BitShift(_GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_OVERLAYMASK), 8)
EndFunc
Func _GUICtrlListView_GetItemParam($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_PARAM)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Local $aPoint[2], $iRet
Local $tPoint = DllStructCreate($tagPOINT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
If Not _SendMessage($hWnd, $LVM_GETITEMPOSITION, $iIndex, $tPoint, 0, "wparam", "struct*") Then Return $aPoint
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
If Not _SendMessage($hWnd, $LVM_GETITEMPOSITION, $iIndex, $pMemory, 0, "wparam", "ptr") Then Return $aPoint
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMPOSITION, $iIndex, DllStructGetPtr($tPoint))
If Not $iRet Then Return $aPoint
EndIf
$aPoint[0] = DllStructGetData($tPoint, "X")
$aPoint[1] = DllStructGetData($tPoint, "Y")
Return $aPoint
EndFunc
Func _GUICtrlListView_GetItemPositionX($hWnd, $iIndex)
Local $aPoint = _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Return $aPoint[0]
EndFunc
Func _GUICtrlListView_GetItemPositionY($hWnd, $iIndex)
Local $aPoint = _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Return $aPoint[1]
EndFunc
Func _GUICtrlListView_GetItemRect($hWnd, $iIndex, $iPart = 3)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart = 3)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iPart)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlListView_GetItemSelected($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_SELECTED) <> 0
EndFunc
Func _GUICtrlListView_GetItemSpacing($hWnd, $bSmall = False)
Local $iSpace
If IsHWnd($hWnd) Then
$iSpace = _SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall)
Else
$iSpace = GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0)
EndIf
Local $aSpace[2]
$aSpace[0] = BitAND($iSpace, 0xFFFF)
$aSpace[1] = BitShift($iSpace, 16)
Return $aSpace
EndFunc
Func _GUICtrlListView_GetItemSpacingX($hWnd, $bSmall = False)
If IsHWnd($hWnd) Then
Return BitAND(_SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 0xFFFF)
Else
Return BitAND(GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 0xFFFF)
EndIf
EndFunc
Func _GUICtrlListView_GetItemSpacingY($hWnd, $bSmall = False)
If IsHWnd($hWnd) Then
Return BitShift(_SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 16)
Else
Return BitShift(GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 16)
EndIf
EndFunc
Func _GUICtrlListView_GetItemState($hWnd, $iIndex, $iMask)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETITEMSTATE, $iIndex, $iMask)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETITEMSTATE, $iIndex, $iMask)
EndIf
EndFunc
Func _GUICtrlListView_GetItemStateImage($hWnd, $iIndex)
Return BitShift(_GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlListView_GetItemText($hWnd, $iIndex, $iSubItem = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "TextMax", 4096)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
_SendMessage($hWnd, $LVM_GETITEMTEXTW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + 4096, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETITEMTEXTW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_GETITEMTEXTA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pText, $tBuffer, 4096)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_GETITEMTEXTW, $iIndex, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMTEXTA, $iIndex, $pItem)
EndIf
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlListView_GetItemTextArray($hWnd, $iItem = -1)
Local $sItems = _GUICtrlListView_GetItemTextString($hWnd, $iItem)
If $sItems = "" Then
Local $aItems[1] = [0]
Return SetError($LV_ERR, $LV_ERR, $aItems)
EndIf
Return StringSplit($sItems, Opt('GUIDataSeparatorChar'))
EndFunc
Func _GUICtrlListView_GetItemTextString($hWnd, $iItem = -1)
Local $sRow = "", $sSeparatorChar = Opt('GUIDataSeparatorChar'), $iSelected
If $iItem = -1 Then
$iSelected = _GUICtrlListView_GetNextItem($hWnd)
Else
$iSelected = $iItem
EndIf
For $x = 0 To _GUICtrlListView_GetColumnCount($hWnd) - 1
$sRow &= _GUICtrlListView_GetItemText($hWnd, $iSelected, $x) & $sSeparatorChar
Next
Return StringTrimRight($sRow, 1)
EndFunc
Func _GUICtrlListView_GetNextItem($hWnd, $iStart = -1, $iSearch = 0, $iState = 8)
Local $aSearch[5] = [$LVNI_ALL, $LVNI_ABOVE, $LVNI_BELOW, $LVNI_TOLEFT, $LVNI_TORIGHT]
Local $iFlags = $aSearch[$iSearch]
If BitAND($iState, 1) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_CUT)
If BitAND($iState, 2) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_DROPHILITED)
If BitAND($iState, 4) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_FOCUSED)
If BitAND($iState, 8) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_SELECTED)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETNEXTITEM, $iStart, $iFlags)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETNEXTITEM, $iStart, $iFlags)
EndIf
EndFunc
Func _GUICtrlListView_GetNumberOfWorkAreas($hWnd)
Local $tBuffer = DllStructCreate("int Data")
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, DllStructGetPtr($tBuffer))
EndIf
Return DllStructGetData($tBuffer, "Data")
EndFunc
Func _GUICtrlListView_GetOrigin($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETORIGIN, 0, $tPoint, 0, "wparam", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
$iRet = _SendMessage($hWnd, $LVM_GETORIGIN, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETORIGIN, 0, DllStructGetPtr($tPoint))
EndIf
Local $aOrigin[2]
$aOrigin[0] = DllStructGetData($tPoint, "X")
$aOrigin[1] = DllStructGetData($tPoint, "Y")
Return SetError(@error, $iRet = 1, $aOrigin)
EndFunc
Func _GUICtrlListView_GetOriginX($hWnd)
Local $aOrigin = _GUICtrlListView_GetOrigin($hWnd)
Return $aOrigin[0]
EndFunc
Func _GUICtrlListView_GetOriginY($hWnd)
Local $aOrigin = _GUICtrlListView_GetOrigin($hWnd)
Return $aOrigin[1]
EndFunc
Func _GUICtrlListView_GetOutlineColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETOUTLINECOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETOUTLINECOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetSelectedColumn($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTEDCOLUMN)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTEDCOLUMN, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetSelectedCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTEDCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTEDCOUNT, 0, 0)
EndIf
EndFunc
Func __GUICtrlListView_GetCheckedIndices($hWnd)
Local $iCount = _GUICtrlListView_GetItemCount($hWnd)
Local $aSelected[$iCount + 1] = [0]
For $i = 0 To $iCount - 1
If _GUICtrlListView_GetItemChecked($hWnd, $i) Then
$aSelected[0] += 1
$aSelected[$aSelected[0]] = $i
EndIf
Next
ReDim $aSelected[$aSelected[0] + 1]
Return $aSelected
EndFunc
Func _GUICtrlListView_GetSelectedIndices($hWnd, $bArray = False)
Local $sIndices, $aIndices[1] = [0]
Local $iRet, $iCount = _GUICtrlListView_GetItemCount($hWnd)
For $iItem = 0 To $iCount
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMSTATE, $iItem, $LVIS_SELECTED)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMSTATE, $iItem, $LVIS_SELECTED)
EndIf
If $iRet Then
If (Not $bArray) Then
If StringLen($sIndices) Then
$sIndices &= "|" & $iItem
Else
$sIndices = $iItem
EndIf
Else
ReDim $aIndices[UBound($aIndices) + 1]
$aIndices[0] = UBound($aIndices) - 1
$aIndices[UBound($aIndices) - 1] = $iItem
EndIf
EndIf
Next
If (Not $bArray) Then
Return String($sIndices)
Else
Return $aIndices
EndIf
EndFunc
Func _GUICtrlListView_GetSelectionMark($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTIONMARK)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTIONMARK, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetStringWidth($hWnd, $sString)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sString) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sString)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHW, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer, $pMemory, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pBuffer = DllStructGetPtr($tBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETSTRINGWIDTHW, 0, $pBuffer)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETSTRINGWIDTHA, 0, $pBuffer)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_GetSubItemRect($hWnd, $iIndex, $iSubItem, $iPart = 0)
Local $aPart[2] = [$LVIR_BOUNDS, $LVIR_ICON]
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Top", $iSubItem)
DllStructSetData($tRECT, "Left", $aPart[$iPart])
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETSUBITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETSUBITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETSUBITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetTextBkColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTEXTBKCOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTEXTBKCOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetTextColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTEXTCOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTEXTCOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetToolTips($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETTOOLTIPS))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETTOOLTIPS, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetTopIndex($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTOPINDEX)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTOPINDEX, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetUnicodeFormat($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_GetView($hWnd)
Local $iView
If IsHWnd($hWnd) Then
$iView = _SendMessage($hWnd, $LVM_GETVIEW)
Else
$iView = GUICtrlSendMsg($hWnd, $LVM_GETVIEW, 0, 0)
EndIf
Switch $iView
Case $LV_VIEW_ICON
Return Int($LV_VIEW_ICON)
Case $LV_VIEW_DETAILS
Return Int($LV_VIEW_DETAILS)
Case $LV_VIEW_LIST
Return Int($LV_VIEW_LIST)
Case $LV_VIEW_SMALLICON
Return Int($LV_VIEW_SMALLICON)
Case $LV_VIEW_TILE
Return Int($LV_VIEW_TILE)
Case Else
Return -1
EndSwitch
EndFunc
Func _GUICtrlListView_GetViewDetails($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_DETAILS
EndFunc
Func _GUICtrlListView_GetViewLarge($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_ICON
EndFunc
Func _GUICtrlListView_GetViewList($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_LIST
EndFunc
Func _GUICtrlListView_GetViewSmall($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_SMALLICON
EndFunc
Func _GUICtrlListView_GetViewTile($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_TILE
EndFunc
Func _GUICtrlListView_GetViewRect($hWnd)
Local $aRect[4] = [0, 0, 0, 0]
Local $iView = _GUICtrlListView_GetView($hWnd)
If ($iView <> 1) And ($iView <> 3) Then Return $aRect
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETVIEWRECT, 0, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $LVM_GETVIEWRECT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETVIEWRECT, 0, DllStructGetPtr($tRECT))
EndIf
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_HideColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCOLUMNWIDTH, $iCol) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_HitTest($hWnd, $iX = -1, $iY = -1)
Local $aTest[10]
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] = 0 Then Return 0
If $iX = -1 Then $iX = DllStructGetData($tPoint, "X")
If $iY = -1 Then $iY = DllStructGetData($tPoint, "Y")
Local $tTest = DllStructCreate($tagLVHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aTest[0] = _SendMessage($hWnd, $LVM_HITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
Local $iTest = DllStructGetSize($tTest)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest, $pMemory, $iTest)
$aTest[0] = _SendMessage($hWnd, $LVM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Else
$aTest[0] = GUICtrlSendMsg($hWnd, $LVM_HITTEST, 0, DllStructGetPtr($tTest))
EndIf
Local $iFlags = DllStructGetData($tTest, "Flags")
$aTest[1] = BitAND($iFlags, $LVHT_NOWHERE) <> 0
$aTest[2] = BitAND($iFlags, $LVHT_ONITEMICON) <> 0
$aTest[3] = BitAND($iFlags, $LVHT_ONITEMLABEL) <> 0
$aTest[4] = BitAND($iFlags, $LVHT_ONITEMSTATEICON) <> 0
$aTest[5] = BitAND($iFlags, $LVHT_ONITEM) <> 0
$aTest[6] = BitAND($iFlags, $LVHT_ABOVE) <> 0
$aTest[7] = BitAND($iFlags, $LVHT_BELOW) <> 0
$aTest[8] = BitAND($iFlags, $LVHT_TOLEFT) <> 0
$aTest[9] = BitAND($iFlags, $LVHT_TORIGHT) <> 0
Return $aTest
EndFunc
Func __GUICtrlListView_IndexToOverlayImageMask($iIndex)
Return BitShift($iIndex, -8)
EndFunc
Func __GUICtrlListView_IndexToStateImageMask($iIndex)
Return BitShift($iIndex, -12)
EndFunc
Func _GUICtrlListView_InsertColumn($hWnd, $iIndex, $sText, $iWidth = 50, $iAlign = -1, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
Local $iMask = BitOR($LVCF_FMT, $LVCF_WIDTH, $LVCF_TEXT)
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $iFmt = $aAlign[$iAlign]
If $iImage <> -1 Then
$iMask = BitOR($iMask, $LVCF_IMAGE)
$iFmt = BitOR($iFmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $LVCFMT_BITMAP_ON_RIGHT)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
DllStructSetData($tColumn, "CX", $iWidth)
DllStructSetData($tColumn, "TextMax", $iBuffer)
DllStructSetData($tColumn, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
If $iAlign > 0 Then _GUICtrlListView_SetColumn($hWnd, $iRet, $sText, $iWidth, $iAlign, $iImage, $bOnRight)
Return $iRet
EndFunc
Func _GUICtrlListView_InsertGroup($hWnd, $iIndex, $iGroupID, $sHeader, $iAlign = 0)
Local $aAlign[3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $tHeader = _WinAPI_MultiByteToWideChar($sHeader)
Local $pHeader = DllStructGetPtr($tHeader)
Local $iHeader = StringLen($sHeader)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
Local $iMask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
DllStructSetData($tGroup, "HeaderMax", $iHeader)
DllStructSetData($tGroup, "GroupID", $iGroupID)
DllStructSetData($tGroup, "Align", $aAlign[$iAlign])
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = _SendMessage($hWnd, $LVM_INSERTGROUP, $iIndex, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup + $iHeader, $tMemMap)
Local $pText = $pMemory + $iGroup
DllStructSetData($tGroup, "Header", $pText)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
_MemWrite($tMemMap, $tHeader, $pText, $iHeader)
$iRet = _SendMessage($hWnd, $LVM_INSERTGROUP, $iIndex, $tGroup, 0, "wparam", "struct*")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTGROUP, $iIndex, DllStructGetPtr($tGroup))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_InsertItem($hWnd, $sText, $iIndex = -1, $iImage = -1, $iParam = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer, $tBuffer, $iRet
If $iIndex = -1 Then $iIndex = 999999999
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Param", $iParam)
$iBuffer = StringLen($sText) + 1
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iMask = BitOR($LVIF_TEXT, $LVIF_PARAM)
If $iImage >= 0 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Image", $iImage)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Or ($sText = -1) Then
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_InsertMarkHitTest($hWnd, $iX = -1, $iY = -1)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] = 0 Then Return 0
If $iX = -1 Then $iX = DllStructGetData($tPoint, "X")
If $iY = -1 Then $iY = DllStructGetData($tPoint, "Y")
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tPoint, "X", $iX)
DllStructSetData($tPoint, "Y", $iY)
DllStructSetData($tMark, "Size", $iMark)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_INSERTMARKHITTEST, $tPoint, $tMark, 0, "struct*", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemM = _MemInit($hWnd, $iPoint + $iMark, $tMemMap)
Local $pMemP = $pMemM + $iPoint
_MemWrite($tMemMap, $tMark, $pMemM, $iMark)
_MemWrite($tMemMap, $tPoint, $pMemP, $iPoint)
_SendMessage($hWnd, $LVM_INSERTMARKHITTEST, $pMemP, $pMemM, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemM, $tMark, $iMark)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_INSERTMARKHITTEST, DllStructGetPtr($tPoint), DllStructGetPtr($tMark))
EndIf
Local $aTest[2]
$aTest[0] = DllStructGetData($tMark, "Flags") = $LVIM_AFTER
$aTest[1] = DllStructGetData($tMark, "Item")
Return $aTest
EndFunc
Func _GUICtrlListView_IsItemVisible($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ISITEMVISIBLE, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ISITEMVISIBLE, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_JustifyColumn($hWnd, $iIndex, $iAlign = -1)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $iMask = $LVCF_FMT
Local $iFmt = $aAlign[$iAlign]
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn, $tMemMap)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_MapIDToIndex($hWnd, $iID)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MAPIDTOINDEX, $iID)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MAPIDTOINDEX, $iID, 0)
EndIf
EndFunc
Func _GUICtrlListView_MapIndexToID($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MAPINDEXTOID, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MAPINDEXTOID, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListView_MoveGroup($hWnd, $iGroupID, $iIndex = -1)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MOVEGROUP, $iGroupID, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MOVEGROUP, $iGroupID, $iIndex)
EndIf
EndFunc
Func __GUICtrlListView_OverlayImageMaskToIndex($iMask)
Return BitShift(BitAND($LVIS_OVERLAYMASK, $iMask), 8)
EndFunc
Func _GUICtrlListView_RedrawItems($hWnd, $iFirst, $iLast)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_REDRAWITEMS, $iFirst, $iLast) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_REDRAWITEMS, $iFirst, $iLast) <> 0
EndIf
EndFunc
Func _GUICtrlListView_RegisterSortCallBack($hWnd, $vCompareType = 1, $bArrows = True, $sPrivateCallback = "__GUICtrlListView_Sort")
#Au3Stripper_Ignore_Funcs=$sPrivateCallback
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If IsBool($vCompareType) Then $vCompareType = ($vCompareType) ? 1 : 0
Local $hHeader = _GUICtrlListView_GetHeader($hWnd)
ReDim $__g_aListViewSortInfo[UBound($__g_aListViewSortInfo) + 1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
$__g_aListViewSortInfo[0][0] = UBound($__g_aListViewSortInfo) - 1
Local $iIndex = $__g_aListViewSortInfo[0][0]
$__g_aListViewSortInfo[$iIndex][1] = $hWnd
$__g_aListViewSortInfo[$iIndex][2] =  DllCallbackRegister($sPrivateCallback, "int", "int;int;hwnd")
$__g_aListViewSortInfo[$iIndex][3] = -1
$__g_aListViewSortInfo[$iIndex][4] = -1
$__g_aListViewSortInfo[$iIndex][5] = 1
$__g_aListViewSortInfo[$iIndex][6] = -1
$__g_aListViewSortInfo[$iIndex][7] = 0
$__g_aListViewSortInfo[$iIndex][8] = $vCompareType
$__g_aListViewSortInfo[$iIndex][9] = $bArrows
$__g_aListViewSortInfo[$iIndex][10] = $hHeader
Return $__g_aListViewSortInfo[$iIndex][2] <> 0
EndFunc
Func _GUICtrlListView_RemoveAllGroups($hWnd)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_REMOVEALLGROUPS)
Else
GUICtrlSendMsg($hWnd, $LVM_REMOVEALLGROUPS, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_RemoveGroup($hWnd, $iGroupID)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_REMOVEGROUP, $iGroupID)
Else
Return GUICtrlSendMsg($hWnd, $LVM_REMOVEGROUP, $iGroupID, 0)
EndIf
EndFunc
Func __GUICtrlListView_ReverseColorOrder($iColor)
Local $sH = Hex(String($iColor), 6)
Return '0x' & StringMid($sH, 5, 2) & StringMid($sH, 3, 2) & StringMid($sH, 1, 2)
EndFunc
Func _GUICtrlListView_Scroll($hWnd, $iDX, $iDY)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SCROLL, $iDX, $iDY) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SCROLL, $iDX, $iDY) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetBkColor($hWnd, $iColor)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETBKCOLOR, 0, $iColor)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKCOLOR, 0, $iColor)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetBkImage($hWnd, $sURL = "", $iStyle = 0, $iXOffset = 0, $iYOffset = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
If Not IsHWnd($hWnd) Then Return SetError($LV_ERR, $LV_ERR, False)
Local $aStyle[2] = [$LVBKIF_STYLE_NORMAL, $LVBKIF_STYLE_TILE]
Local $iBuffer = StringLen($sURL) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
If @error Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tImage = DllStructCreate($tagLVBKIMAGE)
Local $iRet = 0
If $sURL <> "" Then $iRet = $LVBKIF_SOURCE_URL
$iRet = BitOR($iRet, $aStyle[$iStyle])
DllStructSetData($tBuffer, "Text", $sURL)
DllStructSetData($tImage, "Flags", $iRet)
DllStructSetData($tImage, "XOffPercent", $iXOffset)
DllStructSetData($tImage, "YOffPercent", $iYOffset)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tImage, "Image", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEW, 0, $tImage, 0, "wparam", "struct*")
Else
Local $iImage = DllStructGetSize($tImage)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iImage + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iImage
DllStructSetData($tImage, "Image", $pText)
_MemWrite($tMemMap, $tImage, $pMemory, $iImage)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pImage = DllStructGetPtr($tImage)
DllStructSetData($tImage, "Image", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKIMAGEW, 0, $pImage)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKIMAGEA, 0, $pImage)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetCallBackMask($hWnd, $iMask)
Local $iFlags = 0
If BitAND($iMask, 1) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_CUT)
If BitAND($iMask, 2) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_DROPHILITED)
If BitAND($iMask, 4) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_FOCUSED)
If BitAND($iMask, 8) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_SELECTED)
If BitAND($iMask, 16) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_OVERLAYMASK)
If BitAND($iMask, 32) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_STATEIMAGEMASK)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCALLBACKMASK, $iFlags) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCALLBACKMASK, $iFlags, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetColumn($hWnd, $iIndex, $sText, $iWidth = -1, $iAlign = -1, $iImage = -1, $bOnRight = False)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
Local $iMask = $LVCF_TEXT
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
$iMask = BitOR($iMask, $LVCF_FMT)
Local $iFmt = $aAlign[$iAlign]
If $iWidth <> -1 Then $iMask = BitOR($iMask, $LVCF_WIDTH)
If $iImage <> -1 Then
$iMask = BitOR($iMask, $LVCF_IMAGE)
$iFmt = BitOR($iFmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
Else
$iImage = 0
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $LVCFMT_BITMAP_ON_RIGHT)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
DllStructSetData($tColumn, "CX", $iWidth)
DllStructSetData($tColumn, "TextMax", $iBuffer)
DllStructSetData($tColumn, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetColumnOrder($hWnd, $sOrder)
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Return _GUICtrlListView_SetColumnOrderArray($hWnd, StringSplit($sOrder, $sSeparatorChar))
EndFunc
Func _GUICtrlListView_SetColumnOrderArray($hWnd, $aOrder)
Local $tBuffer = DllStructCreate("int[" & $aOrder[0] & "]")
For $iI = 1 To $aOrder[0]
DllStructSetData($tBuffer, 1, $aOrder[$iI], $iI)
Next
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer, $pMemory, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], DllStructGetPtr($tBuffer))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetColumnWidth($hWnd, $iCol, $iWidth)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, $iWidth)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, $iWidth)
EndIf
EndFunc
Func _GUICtrlListView_SetExtendedListViewStyle($hWnd, $iExStyle, $iExMask = 0)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iExMask, $iExStyle)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iExMask, $iExStyle)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_SetGroupInfo($hWnd, $iGroupID, $sHeader, $iAlign = 0, $iState = $LVGS_NORMAL)
Local $tGroup = 0
If BitAND($iState, $LVGS_SELECTED) Then
$tGroup = __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, BitOR($LVGF_GROUPID, $LVGF_ITEMS))
If DllStructGetData($tGroup, "GroupId") <> $iGroupID Or DllStructGetData($tGroup, "cItems") = 0 Then Return False
EndIf
Local $aAlign[3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $tHeader = _WinAPI_MultiByteToWideChar($sHeader)
Local $pHeader = DllStructGetPtr($tHeader)
Local $iHeader = StringLen($sHeader)
$tGroup = DllStructCreate($tagLVGROUP)
Local $pGroup = DllStructGetPtr($tGroup)
Local $iGroup = DllStructGetSize($tGroup)
Local $iMask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_STATE)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
DllStructSetData($tGroup, "HeaderMax", $iHeader)
DllStructSetData($tGroup, "Align", $aAlign[$iAlign])
DllStructSetData($tGroup, "State", $iState)
DllStructSetData($tGroup, "StateMask", $iState)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = _SendMessage($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pGroup)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
_SendMessage($hWnd, $LVM_SETGROUPINFO, 0, $pGroup)
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup + $iHeader, $tMemMap)
Local $pText = $pMemory + $iGroup
DllStructSetData($tGroup, "Header", $pText)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
_MemWrite($tMemMap, $tHeader, $pText, $iHeader)
$iRet = _SendMessage($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pMemory)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
_SendMessage($hWnd, $LVM_SETGROUPINFO, 0, $pMemory)
_MemFree($tMemMap)
EndIf
_WinAPI_InvalidateRect($hWnd)
Else
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pGroup)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
GUICtrlSendMsg($hWnd, $LVM_SETGROUPINFO, 0, $pGroup)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetHotCursor($hWnd, $hCursor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOTCURSOR, 0, $hCursor, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_SETHOTCURSOR, 0, $hCursor))
EndIf
EndFunc
Func _GUICtrlListView_SetHotItem($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOTITEM, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETHOTITEM, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListView_SetHoverTime($hWnd, $iTime)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOVERTIME, 0, $iTime)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETHOVERTIME, 0, $iTime)
EndIf
EndFunc
Func _GUICtrlListView_SetIconSpacing($hWnd, $iCX, $iCY)
Local $iRet, $aPadding[2]
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETICONSPACING, 0, _WinAPI_MakeLong($iCX, $iCY))
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETICONSPACING, 0, _WinAPI_MakeLong($iCX, $iCY))
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
$aPadding[0] = BitAND($iRet, 0xFFFF)
$aPadding[1] = BitShift($iRet, 16)
Return $aPadding
EndFunc
Func _GUICtrlListView_SetImageList($hWnd, $hHandle, $iType = 0)
Local $aType[3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETIMAGELIST, $aType[$iType], $hHandle, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_SETIMAGELIST, $aType[$iType], $hHandle))
EndIf
EndFunc
Func _GUICtrlListView_SetInfoTip($hWnd, $iIndex, $sText, $iSubItem = 0)
Local $tBuffer = _WinAPI_MultiByteToWideChar($sText)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $iBuffer = StringLen($sText)
Local $tInfo = DllStructCreate($tagLVSETINFOTIP)
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
DllStructSetData($tInfo, "Item", $iIndex)
DllStructSetData($tInfo, "SubItem", $iSubItem)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tInfo, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETINFOTIP, 0, $tInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iInfo + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iInfo
DllStructSetData($tInfo, "Text", $pText)
_MemWrite($tMemMap, $tInfo, $pMemory, $iInfo)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETINFOTIP, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tInfo, "Text", $pBuffer)
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETINFOTIP, 0, DllStructGetPtr($tInfo))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetInsertMark($hWnd, $iIndex, $bAfter = False)
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tMark, "Size", $iMark)
If $bAfter Then DllStructSetData($tMark, "Flags", $LVIM_AFTER)
DllStructSetData($tMark, "Item", $iIndex)
DllStructSetData($tMark, "Reserved", 0)
Local $iRet
If IsHWnd($hWnd) Then
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMark, $tMemMap)
_MemWrite($tMemMap, $tMark, $pMemory, $iMark)
$iRet = _SendMessage($hWnd, $LVM_SETINSERTMARK, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETINSERTMARK, 0, DllStructGetPtr($tMark))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetInsertMarkColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETINSERTMARKCOLOR, 0, $iColor)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETINSERTMARKCOLOR, 0, $iColor)
EndIf
EndFunc
Func _GUICtrlListView_SetItem($hWnd, $sText, $iIndex = 0, $iSubItem = 0, $iImage = -1, $iParam = -1, $iIndent = -1)
Local $pBuffer, $iBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
$pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagLVITEM)
Local $iMask = $LVIF_TEXT
If $iImage <> -1 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
If $iParam <> -1 Then $iMask = BitOR($iMask, $LVIF_PARAM)
If $iIndent <> -1 Then $iMask = BitOR($iMask, $LVIF_INDENT)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Text", $pBuffer)
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
DllStructSetData($tItem, "Indent", $iIndent)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemChecked($hWnd, $iIndex, $bCheck = True)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $pMemory, $tMemMap, $iRet
Local $tItem = DllStructCreate($tagLVITEM)
Local $pItem = DllStructGetPtr($tItem)
Local $iItem = DllStructGetSize($tItem)
If @error Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
If $iIndex <> -1 Then
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
If ($bCheck) Then
DllStructSetData($tItem, "State", 0x2000)
Else
DllStructSetData($tItem, "State", 0x1000)
EndIf
DllStructSetData($tItem, "StateMask", 0xf000)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*") <> 0
Else
$pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
Return $iRet <> 0
EndIf
Else
If $bUnicode Then
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem) <> 0
EndIf
EndIf
Else
For $x = 0 To _GUICtrlListView_GetItemCount($hWnd) - 1
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $x)
If ($bCheck) Then
DllStructSetData($tItem, "State", 0x2000)
Else
DllStructSetData($tItem, "State", 0x1000)
EndIf
DllStructSetData($tItem, "StateMask", 0xf000)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
If Not _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*") <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Else
$pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
If Not $iRet <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
EndIf
Else
If $bUnicode Then
If Not GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem) <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Else
If Not GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem) <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
EndIf
EndIf
Next
Return True
EndIf
Return False
EndFunc
Func _GUICtrlListView_SetItemCount($hWnd, $iItems)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMCOUNT, $iItems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMCOUNT, $iItems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetItemCut($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_CUT
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_CUT)
EndFunc
Func _GUICtrlListView_SetItemDropHilited($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_DROPHILITED
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_DROPHILITED)
EndFunc
Func _GUICtrlListView_SetItemEx($hWnd, ByRef $tItem)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If IsHWnd($hWnd) Then
Local $iItem = DllStructGetSize($tItem)
Local $iBuffer = DllStructGetData($tItem, "TextMax")
Local $pBuffer = DllStructGetData($tItem, "Text")
If $bUnicode Then $iBuffer *= 2
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $pBuffer <> 0 Then _MemWrite($tMemMap, $pBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemFocused($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_FOCUSED
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_FOCUSED)
EndFunc
Func _GUICtrlListView_SetItemGroupID($hWnd, $iIndex, $iGroupID)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_GROUPID)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "GroupID", $iGroupID)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemImage($hWnd, $iIndex, $iImage, $iSubItem = 0)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_IMAGE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", $iImage)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemIndent($hWnd, $iIndex, $iIndent)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_INDENT)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Indent", $iIndent)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func __GUICtrlListView_SetItemOverlayImage($hWnd, $iIndex, $iImage)
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, __GUICtrlListView_IndexToOverlayImageMask($iImage), $LVIS_OVERLAYMASK)
EndFunc
Func _GUICtrlListView_SetItemParam($hWnd, $iIndex, $iParam)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_PARAM)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Param", $iParam)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemPosition($hWnd, $iIndex, $iCX, $iCY)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMPOSITION, $iIndex, _WinAPI_MakeLong($iCX, $iCY)) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMPOSITION, $iIndex, _WinAPI_MakeLong($iCX, $iCY)) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetItemPosition32($hWnd, $iIndex, $iCX, $iCY)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iCX)
DllStructSetData($tPoint, "Y", $iCY)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMPOSITION32, $iIndex, $tPoint, 0, "wparam", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
_MemWrite($tMemMap, $tPoint)
$iRet = _SendMessage($hWnd, $LVM_SETITEMPOSITION32, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMPOSITION32, $iIndex, DllStructGetPtr($tPoint))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemSelected($hWnd, $iIndex, $bSelected = True, $bFocused = False)
Local $tStruct = DllStructCreate($tagLVITEM)
Local $iRet, $iSelected = 0, $iFocused = 0, $iSize, $tMemMap, $pMemory
If ($bSelected = True) Then $iSelected = $LVIS_SELECTED
If ($bFocused = True And $iIndex <> -1) Then $iFocused = $LVIS_FOCUSED
DllStructSetData($tStruct, "Mask", $LVIF_STATE)
DllStructSetData($tStruct, "Item", $iIndex)
DllStructSetData($tStruct, "State", BitOR($iSelected, $iFocused))
DllStructSetData($tStruct, "StateMask", BitOR($LVIS_SELECTED, $iFocused))
$iSize = DllStructGetSize($tStruct)
If IsHWnd($hWnd) Then
$pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tStruct, $pMemory, $iSize)
$iRet = _SendMessage($hWnd, $LVM_SETITEMSTATE, $iIndex, $pMemory)
_MemFree($tMemMap)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMSTATE, $iIndex, DllStructGetPtr($tStruct))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $iStateMask)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "State", $iState)
DllStructSetData($tItem, "StateMask", $iStateMask)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem) <> 0
EndFunc
Func _GUICtrlListView_SetItemStateImage($hWnd, $iIndex, $iImage)
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, BitShift($iImage, -12), $LVIS_STATEIMAGEMASK)
EndFunc
Func _GUICtrlListView_SetItemText($hWnd, $iIndex, $sText, $iSubItem = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If $iSubItem = -1 Then
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local $i_Cols = _GUICtrlListView_GetColumnCount($hWnd)
Local $a_Text = StringSplit($sText, $sSeparatorChar)
If $i_Cols > $a_Text[0] Then $i_Cols = $a_Text[0]
For $i = 1 To $i_Cols
$iRet = _GUICtrlListView_SetItemText($hWnd, $iIndex, $a_Text[$i], $i - 1)
If Not $iRet Then ExitLoop
Next
Return $iRet
EndIf
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetOutlineColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETOUTLINECOLOR, 0, $iColor)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETOUTLINECOLOR, 0, $iColor)
EndIf
EndFunc
Func _GUICtrlListView_SetSelectedColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_SETSELECTEDCOLUMN, $iCol)
_WinAPI_InvalidateRect($hWnd)
Else
GUICtrlSendMsg($hWnd, $LVM_SETSELECTEDCOLUMN, $iCol, 0)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
EndFunc
Func _GUICtrlListView_SetSelectionMark($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETSELECTIONMARK, 0, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETSELECTIONMARK, 0, $iIndex)
EndIf
EndFunc
Func _GUICtrlListView_SetTextBkColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETTEXTBKCOLOR, 0, $iColor) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETTEXTBKCOLOR, 0, $iColor) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetTextColor($hWnd, $iColor)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETTEXTCOLOR, 0, $iColor)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETTEXTCOLOR, 0, $iColor)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetToolTips($hWnd, $hToolTip)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETTOOLTIPS, 0, $hToolTip, 0, "wparam", "hwnd", "hwnd")
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_SETTOOLTIPS, 0, $hToolTip))
EndIf
EndFunc
Func _GUICtrlListView_SetUnicodeFormat($hWnd, $bUnicode)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETUNICODEFORMAT, $bUnicode)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETUNICODEFORMAT, $bUnicode, 0)
EndIf
EndFunc
Func _GUICtrlListView_SetView($hWnd, $iView)
Local $aView[5] = [$LV_VIEW_ICON, $LV_VIEW_DETAILS, $LV_VIEW_LIST, $LV_VIEW_SMALLICON, $LV_VIEW_TILE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETVIEW, $aView[$iView]) <> -1
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETVIEW, $aView[$iView], 0) <> -1
EndIf
EndFunc
Func _GUICtrlListView_SetWorkAreas($hWnd, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_SETWORKAREAS, 1, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_SETWORKAREAS, 1, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_SETWORKAREAS, 1, DllStructGetPtr($tRECT))
EndIf
EndFunc
Func _GUICtrlListView_SimpleSort($hWnd, ByRef $vSortSense, $iCol, $bToggleSense = True)
Local $iItemCount = _GUICtrlListView_GetItemCount($hWnd)
If $iItemCount Then
Local $iDescending = 0
If UBound($vSortSense) Then
$iDescending = $vSortSense[$iCol]
Else
$iDescending = $vSortSense
EndIf
Local $vSeparatorChar = Opt('GUIDataSeparatorChar')
Local $iColumnCount = _GUICtrlListView_GetColumnCount($hWnd)
Local Enum $iIndexValue = $iColumnCount, $iItemParam
Local $aListViewItems[$iItemCount][$iColumnCount + 2]
Local $aSelectedItems = StringSplit(_GUICtrlListView_GetSelectedIndices($hWnd), $vSeparatorChar)
Local $aCheckedItems = __GUICtrlListView_GetCheckedIndices($hWnd)
Local $sItemText, $iFocused = -1
For $i = 0 To $iItemCount - 1
If $iFocused = -1 Then
If _GUICtrlListView_GetItemFocused($hWnd, $i) Then $iFocused = $i
EndIf
_GUICtrlListView_SetItemSelected($hWnd, $i, False)
_GUICtrlListView_SetItemChecked($hWnd, $i, False)
For $j = 0 To $iColumnCount - 1
$sItemText = StringStripWS(_GUICtrlListView_GetItemText($hWnd, $i, $j), $STR_STRIPTRAILING)
If (StringIsFloat($sItemText) Or StringIsInt($sItemText)) Then
$aListViewItems[$i][$j] = Number($sItemText)
Else
$aListViewItems[$i][$j] = $sItemText
EndIf
Next
$aListViewItems[$i][$iIndexValue] = $i
$aListViewItems[$i][$iItemParam] = _GUICtrlListView_GetItemParam($hWnd, $i)
Next
_ArraySort($aListViewItems, $iDescending, 0, 0, $iCol)
For $i = 0 To $iItemCount - 1
For $j = 0 To $iColumnCount - 1
_GUICtrlListView_SetItemText($hWnd, $i, $aListViewItems[$i][$j], $j)
Next
_GUICtrlListView_SetItemParam($hWnd, $i, $aListViewItems[$i][$iItemParam])
For $j = 1 To $aSelectedItems[0]
If $aListViewItems[$i][$iIndexValue] = $aSelectedItems[$j] Then
If $aListViewItems[$i][$iIndexValue] = $iFocused Then
_GUICtrlListView_SetItemSelected($hWnd, $i, True, True)
Else
_GUICtrlListView_SetItemSelected($hWnd, $i, True)
EndIf
ExitLoop
EndIf
Next
For $j = 1 To $aCheckedItems[0]
If $aListViewItems[$i][$iIndexValue] = $aCheckedItems[$j] Then
_GUICtrlListView_SetItemChecked($hWnd, $i, True)
ExitLoop
EndIf
Next
Next
If $bToggleSense Then
If UBound($vSortSense) Then
$vSortSense[$iCol] = Not $iDescending
Else
$vSortSense = Not $iDescending
EndIf
EndIf
EndIf
EndFunc
#Au3Stripper_Ignore_Funcs=__GUICtrlListView_Sort
Func __GUICtrlListView_Sort($nItem1, $nItem2, $hWnd)
Local $iIndex, $sVal1, $sVal2, $nResult
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
$iIndex = $x
ExitLoop
EndIf
Next
If $__g_aListViewSortInfo[$iIndex][3] = $__g_aListViewSortInfo[$iIndex][4] Then
If Not $__g_aListViewSortInfo[$iIndex][7] Then
$__g_aListViewSortInfo[$iIndex][5] *= -1
$__g_aListViewSortInfo[$iIndex][7] = 1
EndIf
Else
$__g_aListViewSortInfo[$iIndex][7] = 1
EndIf
$__g_aListViewSortInfo[$iIndex][6] = $__g_aListViewSortInfo[$iIndex][3]
$sVal1 = _GUICtrlListView_GetItemText($hWnd, $nItem1, $__g_aListViewSortInfo[$iIndex][3])
$sVal2 = _GUICtrlListView_GetItemText($hWnd, $nItem2, $__g_aListViewSortInfo[$iIndex][3])
If $__g_aListViewSortInfo[$iIndex][8] = 1 Then
If (StringIsFloat($sVal1) Or StringIsInt($sVal1)) Then $sVal1 = Number($sVal1)
If (StringIsFloat($sVal2) Or StringIsInt($sVal2)) Then $sVal2 = Number($sVal2)
EndIf
If $__g_aListViewSortInfo[$iIndex][8] < 2 Then
$nResult = 0
If $sVal1 < $sVal2 Then
$nResult = -1
ElseIf $sVal1 > $sVal2 Then
$nResult = 1
EndIf
Else
$nResult = DllCall('shlwapi.dll', 'int', 'StrCmpLogicalW', 'wstr', $sVal1, 'wstr', $sVal2)[0]
EndIf
$nResult = $nResult * $__g_aListViewSortInfo[$iIndex][5]
Return $nResult
EndFunc
Func _GUICtrlListView_SortItems($hWnd, $iCol)
Local $iRet, $iIndex, $pFunction, $hHeader, $iFormat
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
$iIndex = $x
ExitLoop
EndIf
Next
$pFunction = DllCallbackGetPtr($__g_aListViewSortInfo[$iIndex][2])
$__g_aListViewSortInfo[$iIndex][3] = $iCol
$__g_aListViewSortInfo[$iIndex][7] = 0
$__g_aListViewSortInfo[$iIndex][4] = $__g_aListViewSortInfo[$iIndex][6]
$iRet = _SendMessage($hWnd, $LVM_SORTITEMSEX, $hWnd, $pFunction, 0, "hwnd", "ptr")
If $iRet <> 0 Then
If $__g_aListViewSortInfo[$iIndex][9] Then
$hHeader = $__g_aListViewSortInfo[$iIndex][10]
For $x = 0 To _GUICtrlHeader_GetItemCount($hHeader) - 1
$iFormat = _GUICtrlHeader_GetItemFormat($hHeader, $x)
If BitAND($iFormat, $HDF_SORTDOWN) Then
_GUICtrlHeader_SetItemFormat($hHeader, $x, BitXOR($iFormat, $HDF_SORTDOWN))
ElseIf BitAND($iFormat, $HDF_SORTUP) Then
_GUICtrlHeader_SetItemFormat($hHeader, $x, BitXOR($iFormat, $HDF_SORTUP))
EndIf
Next
$iFormat = _GUICtrlHeader_GetItemFormat($hHeader, $iCol)
If $__g_aListViewSortInfo[$iIndex][5] = 1 Then
_GUICtrlHeader_SetItemFormat($hHeader, $iCol, BitOR($iFormat, $HDF_SORTUP))
Else
_GUICtrlHeader_SetItemFormat($hHeader, $iCol, BitOR($iFormat, $HDF_SORTDOWN))
EndIf
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func __GUICtrlListView_StateImageMaskToIndex($iMask)
Return BitShift(BitAND($iMask, $LVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlListView_SubItemHitTest($hWnd, $iX = -1, $iY = -1)
Local $iTest, $tTest, $pMemory, $tMemMap, $iFlags, $aTest[11]
If $iX = -1 Then $iX = _WinAPI_GetMousePosX(True, $hWnd)
If $iY = -1 Then $iY = _WinAPI_GetMousePosY(True, $hWnd)
$tTest = DllStructCreate($tagLVHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_SUBITEMHITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
$iTest = DllStructGetSize($tTest)
$pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest)
_SendMessage($hWnd, $LVM_SUBITEMHITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_SUBITEMHITTEST, 0, DllStructGetPtr($tTest))
EndIf
$iFlags = DllStructGetData($tTest, "Flags")
$aTest[0] = DllStructGetData($tTest, "Item")
$aTest[1] = DllStructGetData($tTest, "SubItem")
$aTest[2] = BitAND($iFlags, $LVHT_NOWHERE) <> 0
$aTest[3] = BitAND($iFlags, $LVHT_ONITEMICON) <> 0
$aTest[4] = BitAND($iFlags, $LVHT_ONITEMLABEL) <> 0
$aTest[5] = BitAND($iFlags, $LVHT_ONITEMSTATEICON) <> 0
$aTest[6] = BitAND($iFlags, $LVHT_ONITEM) <> 0
$aTest[7] = BitAND($iFlags, $LVHT_ABOVE) <> 0
$aTest[8] = BitAND($iFlags, $LVHT_BELOW) <> 0
$aTest[9] = BitAND($iFlags, $LVHT_TOLEFT) <> 0
$aTest[10] = BitAND($iFlags, $LVHT_TORIGHT) <> 0
Return $aTest
EndFunc
Func _GUICtrlListView_UnRegisterSortCallBack($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
DllCallbackFree($__g_aListViewSortInfo[$x][2])
__GUICtrlListView_ArrayDelete($__g_aListViewSortInfo, $x)
$__g_aListViewSortInfo[0][0] -= 1
ExitLoop
EndIf
Next
EndFunc
Global Const $SBARS_SIZEGRIP = 0x100
Global Const $SBT_TOOLTIPS = 0x800
Global Const $SBARS_TOOLTIPS = 0x800
Global Const $SBT_SUNKEN = 0x0
Global Const $SBT_NOBORDERS = 0x100
Global Const $SBT_POPOUT = 0x200
Global Const $SBT_RTLREADING = 0x400
Global Const $SBT_NOTABPARSING = 0x800
Global Const $SBT_OWNERDRAW = 0x1000
Global Const $__STATUSBARCONSTANT_WM_USER = 0X400
Global Const $SB_GETBORDERS = ($__STATUSBARCONSTANT_WM_USER + 7)
Global Const $SB_GETICON = ($__STATUSBARCONSTANT_WM_USER + 20)
Global Const $SB_GETPARTS = ($__STATUSBARCONSTANT_WM_USER + 6)
Global Const $SB_GETRECT = ($__STATUSBARCONSTANT_WM_USER + 10)
Global Const $SB_GETTEXTA = ($__STATUSBARCONSTANT_WM_USER + 2)
Global Const $SB_GETTEXTW = ($__STATUSBARCONSTANT_WM_USER + 13)
Global Const $SB_GETTEXT = $SB_GETTEXTA
Global Const $SB_GETTEXTLENGTHA = ($__STATUSBARCONSTANT_WM_USER + 3)
Global Const $SB_GETTEXTLENGTHW = ($__STATUSBARCONSTANT_WM_USER + 12)
Global Const $SB_GETTEXTLENGTH = $SB_GETTEXTLENGTHA
Global Const $SB_GETTIPTEXTA = ($__STATUSBARCONSTANT_WM_USER + 18)
Global Const $SB_GETTIPTEXTW = ($__STATUSBARCONSTANT_WM_USER + 19)
Global Const $SB_GETUNICODEFORMAT = 0x2000 + 6
Global Const $SB_ISSIMPLE = ($__STATUSBARCONSTANT_WM_USER + 14)
Global Const $SB_SETBKCOLOR = 0x2000 + 1
Global Const $SB_SETICON = ($__STATUSBARCONSTANT_WM_USER + 15)
Global Const $SB_SETMINHEIGHT = ($__STATUSBARCONSTANT_WM_USER + 8)
Global Const $SB_SETPARTS = ($__STATUSBARCONSTANT_WM_USER + 4)
Global Const $SB_SETTEXTA = ($__STATUSBARCONSTANT_WM_USER + 1)
Global Const $SB_SETTEXTW = ($__STATUSBARCONSTANT_WM_USER + 11)
Global Const $SB_SETTEXT = $SB_SETTEXTA
Global Const $SB_SETTIPTEXTA = ($__STATUSBARCONSTANT_WM_USER + 16)
Global Const $SB_SETTIPTEXTW = ($__STATUSBARCONSTANT_WM_USER + 17)
Global Const $SB_SETUNICODEFORMAT = 0x2000 + 5
Global Const $SB_SIMPLE = ($__STATUSBARCONSTANT_WM_USER + 9)
Global Const $SB_SIMPLEID = 0xff
Global Const $SBN_FIRST = -880
Global Const $SBN_SIMPLEMODECHANGE = $SBN_FIRST - 0
Global $__g_hSBLastWnd
Global Const $__STATUSBARCONSTANT_ClassName = "msctls_statusbar32"
Global Const $__STATUSBARCONSTANT_WM_SIZE = 0x05
Global Const $__STATUSBARCONSTANT_CLR_DEFAULT = 0xFF000000
Global Const $tagBORDERS = "int BX;int BY;int RX"
Func _GUICtrlStatusBar_Create($hWnd, $vPartEdge = -1, $vPartText = "", $iStyles = -1, $iExStyles = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If $iStyles = -1 Then $iStyles = 0x00000000
If $iExStyles = -1 Then $iExStyles = 0x00000000
Local $aPartWidth[1], $aPartText[1]
If @NumParams > 1 Then
If IsArray($vPartEdge) Then
$aPartWidth = $vPartEdge
Else
$aPartWidth[0] = $vPartEdge
EndIf
If @NumParams = 2 Then
ReDim $aPartText[UBound($aPartWidth)]
Else
If IsArray($vPartText) Then
$aPartText = $vPartText
Else
$aPartText[0] = $vPartText
EndIf
If UBound($aPartWidth) <> UBound($aPartText) Then
Local $iLast
If UBound($aPartWidth) > UBound($aPartText) Then
$iLast = UBound($aPartText)
ReDim $aPartText[UBound($aPartWidth)]
Else
$iLast = UBound($aPartWidth)
ReDim $aPartWidth[UBound($aPartText)]
For $x = $iLast To UBound($aPartWidth) - 1
$aPartWidth[$x] = $aPartWidth[$x - 1] + 75
Next
$aPartWidth[UBound($aPartText) - 1] = -1
EndIf
EndIf
EndIf
If Not IsHWnd($hWnd) Then $hWnd = HWnd($hWnd)
If @NumParams > 3 Then $iStyle = BitOR($iStyle, $iStyles)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hWndSBar = _WinAPI_CreateWindowEx($iExStyles, $__STATUSBARCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
If @error Then Return SetError(@error, @extended, 0)
If @NumParams > 1 Then
_GUICtrlStatusBar_SetParts($hWndSBar, UBound($aPartWidth), $aPartWidth)
For $x = 0 To UBound($aPartText) - 1
_GUICtrlStatusBar_SetText($hWndSBar, $aPartText[$x], $x)
Next
EndIf
Return $hWndSBar
EndFunc
Func _GUICtrlStatusBar_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__STATUSBARCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlStatusBar_EmbedControl($hWnd, $iPart, $hControl, $iFit = 4)
Local $aRect = _GUICtrlStatusBar_GetRect($hWnd, $iPart)
Local $iBarX = $aRect[0]
Local $iBarY = $aRect[1]
Local $iBarW = $aRect[2] - $iBarX
Local $iBarH = $aRect[3] - $iBarY
Local $iConX = $iBarX
Local $iConY = $iBarY
Local $iConW = _WinAPI_GetWindowWidth($hControl)
Local $iConH = _WinAPI_GetWindowHeight($hControl)
If $iConW > $iBarW Then $iConW = $iBarW
If $iConH > $iBarH Then $iConH = $iBarH
Local $iPadX = ($iBarW - $iConW) / 2
Local $iPadY = ($iBarH - $iConH) / 2
If $iPadX < 0 Then $iPadX = 0
If $iPadY < 0 Then $iPadY = 0
If BitAND($iFit, 1) = 1 Then $iConX = $iBarX + $iPadX
If BitAND($iFit, 2) = 2 Then $iConY = $iBarY + $iPadY
If BitAND($iFit, 4) = 4 Then
$iPadX = _GUICtrlStatusBar_GetBordersRect($hWnd)
$iPadY = _GUICtrlStatusBar_GetBordersVert($hWnd)
$iConX = $iBarX
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iConX += $iPadX
$iConY = $iBarY + $iPadY
$iConW = $iBarW - ($iPadX * 2)
$iConH = $iBarH - ($iPadY * 2)
EndIf
_WinAPI_SetParent($hControl, $hWnd)
_WinAPI_MoveWindow($hControl, $iConX, $iConY, $iConW, $iConH)
EndFunc
Func _GUICtrlStatusBar_GetBorders($hWnd)
Local $tBorders = DllStructCreate($tagBORDERS)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_GETBORDERS, 0, $tBorders, 0, "wparam", "struct*")
Else
Local $iSize = DllStructGetSize($tBorders)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
$iRet = _SendMessage($hWnd, $SB_GETBORDERS, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBorders, $iSize)
_MemFree($tMemMap)
EndIf
Local $aBorders[3]
If $iRet = 0 Then Return SetError(-1, -1, $aBorders)
$aBorders[0] = DllStructGetData($tBorders, "BX")
$aBorders[1] = DllStructGetData($tBorders, "BY")
$aBorders[2] = DllStructGetData($tBorders, "RX")
Return $aBorders
EndFunc
Func _GUICtrlStatusBar_GetBordersHorz($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[0])
EndFunc
Func _GUICtrlStatusBar_GetBordersRect($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[2])
EndFunc
Func _GUICtrlStatusBar_GetBordersVert($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[1])
EndFunc
Func _GUICtrlStatusBar_GetCount($hWnd)
Return _SendMessage($hWnd, $SB_GETPARTS)
EndFunc
Func _GUICtrlStatusBar_GetHeight($hWnd)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top") - (_GUICtrlStatusBar_GetBordersVert($hWnd) * 2)
EndFunc
Func _GUICtrlStatusBar_GetIcon($hWnd, $iIndex = 0)
Return _SendMessage($hWnd, $SB_GETICON, $iIndex, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlStatusBar_GetParts($hWnd)
Local $iCount = _GUICtrlStatusBar_GetCount($hWnd)
Local $tParts = DllStructCreate("int[" & $iCount & "]")
Local $aParts[$iCount + 1]
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$aParts[0] = _SendMessage($hWnd, $SB_GETPARTS, $iCount, $tParts, 0, "wparam", "struct*")
Else
Local $iParts = DllStructGetSize($tParts)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iParts, $tMemMap)
$aParts[0] = _SendMessage($hWnd, $SB_GETPARTS, $iCount, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tParts, $iParts)
_MemFree($tMemMap)
EndIf
For $iI = 1 To $iCount
$aParts[$iI] = DllStructGetData($tParts, 1, $iI)
Next
Return $aParts
EndFunc
Func _GUICtrlStatusBar_GetRect($hWnd, $iPart)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
If @error Then Return SetError(@error, 0, 0)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
Local $tRECT = DllStructCreate($tagRECT)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_GETRECT, $iPart, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
$iRet = _SendMessage($hWnd, $SB_GETRECT, $iPart, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Return SetError($iRet = 0, 0, $tRECT)
EndFunc
Func _GUICtrlStatusBar_GetText($hWnd, $iPart)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = _GUICtrlStatusBar_GetTextLength($hWnd, $iPart) + 1
If $iBuffer = 1 Then Return SetError(1, 0, "")
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_GETTEXTW, $iPart, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
If $bUnicode Then
_SendMessage($hWnd, $SB_GETTEXTW, $iPart, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $SB_GETTEXT, $iPart, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlStatusBar_GetTextFlags($hWnd, $iPart)
If _GUICtrlStatusBar_GetUnicodeFormat($hWnd) Then
Return _SendMessage($hWnd, $SB_GETTEXTLENGTHW, $iPart)
Else
Return _SendMessage($hWnd, $SB_GETTEXTLENGTH, $iPart)
EndIf
EndFunc
Func _GUICtrlStatusBar_GetTextLength($hWnd, $iPart)
Return _WinAPI_LoWord(_GUICtrlStatusBar_GetTextFlags($hWnd, $iPart))
EndFunc
Func _GUICtrlStatusBar_GetTextLengthEx($hWnd, $iPart)
Return _WinAPI_HiWord(_GUICtrlStatusBar_GetTextFlags($hWnd, $iPart))
EndFunc
Func _GUICtrlStatusBar_GetTipText($hWnd, $iPart)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_GETTIPTEXTW, _WinAPI_MakeLong($iPart, 4096), $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, 4096, $tMemMap)
If $bUnicode Then
_SendMessage($hWnd, $SB_GETTIPTEXTW, _WinAPI_MakeLong($iPart, 4096), $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $SB_GETTIPTEXTA, _WinAPI_MakeLong($iPart, 4096), $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, 4096)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $SB_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlStatusBar_GetWidth($hWnd, $iPart)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left") - (_GUICtrlStatusBar_GetBordersHorz($hWnd) * 2)
EndFunc
Func _GUICtrlStatusBar_IsSimple($hWnd)
Return _SendMessage($hWnd, $SB_ISSIMPLE) <> 0
EndFunc
Func _GUICtrlStatusBar_Resize($hWnd)
_SendMessage($hWnd, $__STATUSBARCONSTANT_WM_SIZE)
EndFunc
Func _GUICtrlStatusBar_SetBkColor($hWnd, $iColor)
$iColor = _SendMessage($hWnd, $SB_SETBKCOLOR, 0, $iColor)
EndFunc
Func _GUICtrlStatusBar_SetIcon($hWnd, $iPart, $hIcon = -1, $sIconFile = "")
If $hIcon = -1 Then Return _SendMessage($hWnd, $SB_SETICON, $iPart, $hIcon, 0, "wparam", "handle") <> 0
If StringLen($sIconFile) <= 0 Then Return _SendMessage($hWnd, $SB_SETICON, $iPart, $hIcon) <> 0
Local $tIcon = DllStructCreate("handle")
Local $vResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sIconFile, "int", $hIcon, "ptr", 0, "struct*", $tIcon, "uint", 1)
If @error Then Return SetError(@error, @extended, False)
$vResult = $vResult[0]
If $vResult > 0 Then $vResult = _SendMessage($hWnd, $SB_SETICON, $iPart, DllStructGetData($tIcon, 1), 0, "wparam", "handle")
DllCall("user32.dll", "bool", "DestroyIcon", "handle", DllStructGetData($tIcon, 1))
Return $vResult
EndFunc
Func _GUICtrlStatusBar_SetMinHeight($hWnd, $iMinHeight)
_SendMessage($hWnd, $SB_SETMINHEIGHT, $iMinHeight)
_GUICtrlStatusBar_Resize($hWnd)
EndFunc
Func _GUICtrlStatusBar_SetParts($hWnd, $vPartEdge = -1, $vPartWidth = 25)
If IsArray($vPartEdge) And IsArray($vPartWidth) Then Return False
Local $tParts, $iParts
If IsArray($vPartEdge) Then
$vPartEdge[UBound($vPartEdge) - 1] = -1
$iParts = UBound($vPartEdge)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $vPartEdge[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
Else
If $vPartEdge < -1 Then Return False
If IsArray($vPartWidth) Then
$iParts = UBound($vPartWidth)
$tParts = DllStructCreate("int[" & $iParts & "]")
Local $iPartRightEdge = 0
For $x = 0 To $iParts - 2
$iPartRightEdge += $vPartWidth[$x]
If $vPartWidth[$x] <= 0 Then Return False
DllStructSetData($tParts, 1, $iPartRightEdge, $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf $vPartEdge > 1 Then
$iParts = $vPartEdge
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 1 To $iParts - 1
DllStructSetData($tParts, 1, $vPartWidth * $x, $x)
Next
DllStructSetData($tParts, 1, -1, $iParts)
Else
$iParts = 1
$tParts = DllStructCreate("int")
DllStructSetData($tParts, 1, -1)
EndIf
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $tParts, 0, "wparam", "struct*")
Else
Local $iSize = DllStructGetSize($tParts)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tParts)
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
_GUICtrlStatusBar_Resize($hWnd)
Return True
EndFunc
Func _GUICtrlStatusBar_SetSimple($hWnd, $bSimple = True)
_SendMessage($hWnd, $SB_SIMPLE, $bSimple)
EndFunc
Func _GUICtrlStatusBar_SetText($hWnd, $sText = "", $iPart = 0, $iUFlag = 0)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tText
If $bUnicode Then
$tText = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tText = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tText, "Text", $sText)
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iPart = $SB_SIMPLEID
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $tText, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tText)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $SB_SETTEXT, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlStatusBar_SetTipText($hWnd, $iPart, $sText)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tText
If $bUnicode Then
$tText = DllStructCreate("wchar TipText[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tText = DllStructCreate("char TipText[" & $iBuffer & "]")
EndIf
DllStructSetData($tText, "TipText", $sText)
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_SETTIPTEXTW, $iPart, $tText, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tText, $pMemory, $iBuffer)
If $bUnicode Then
_SendMessage($hWnd, $SB_SETTIPTEXTW, $iPart, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $SB_SETTIPTEXTA, $iPart, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUICtrlStatusBar_SetUnicodeFormat($hWnd, $bUnicode = True)
Return _SendMessage($hWnd, $SB_SETUNICODEFORMAT, $bUnicode)
EndFunc
Func _GUICtrlStatusBar_ShowHide($hWnd, $iState)
If $iState <> @SW_HIDE And $iState <> @SW_SHOW Then Return SetError(1, 1, False)
Return _WinAPI_ShowWindow($hWnd, $iState)
EndFunc
Global Const $TTF_IDISHWND = 0x00000001
Global Const $TTF_CENTERTIP = 0x00000002
Global Const $TTF_RTLREADING = 0x00000004
Global Const $TTF_SUBCLASS = 0x00000010
Global Const $TTF_TRACK = 0x00000020
Global Const $TTF_ABSOLUTE = 0x00000080
Global Const $TTF_TRANSPARENT = 0x00000100
Global Const $TTF_PARSELINKS = 0x00001000
Global Const $TTF_DI_SETITEM = 0x00008000
Global Const $__TOOLTIPCONSTANTS_WM_USER = 0X400
Global Const $TTM_ACTIVATE = $__TOOLTIPCONSTANTS_WM_USER + 1
Global Const $TTM_SETDELAYTIME = $__TOOLTIPCONSTANTS_WM_USER + 3
Global Const $TTM_ADDTOOL = $__TOOLTIPCONSTANTS_WM_USER + 4
Global Const $TTM_DELTOOL = $__TOOLTIPCONSTANTS_WM_USER + 5
Global Const $TTM_NEWTOOLRECT = $__TOOLTIPCONSTANTS_WM_USER + 6
Global Const $TTM_GETTOOLINFO = $__TOOLTIPCONSTANTS_WM_USER + 8
Global Const $TTM_SETTOOLINFO = $__TOOLTIPCONSTANTS_WM_USER + 9
Global Const $TTM_HITTEST = $__TOOLTIPCONSTANTS_WM_USER + 10
Global Const $TTM_GETTEXT = $__TOOLTIPCONSTANTS_WM_USER + 11
Global Const $TTM_UPDATETIPTEXT = $__TOOLTIPCONSTANTS_WM_USER + 12
Global Const $TTM_GETTOOLCOUNT = $__TOOLTIPCONSTANTS_WM_USER + 13
Global Const $TTM_ENUMTOOLS = $__TOOLTIPCONSTANTS_WM_USER + 14
Global Const $TTM_GETCURRENTTOOL = $__TOOLTIPCONSTANTS_WM_USER + 15
Global Const $TTM_WINDOWFROMPOINT = $__TOOLTIPCONSTANTS_WM_USER + 16
Global Const $TTM_TRACKACTIVATE = $__TOOLTIPCONSTANTS_WM_USER + 17
Global Const $TTM_TRACKPOSITION = $__TOOLTIPCONSTANTS_WM_USER + 18
Global Const $TTM_SETTIPBKCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 19
Global Const $TTM_SETTIPTEXTCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 20
Global Const $TTM_GETDELAYTIME = $__TOOLTIPCONSTANTS_WM_USER + 21
Global Const $TTM_GETTIPBKCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 22
Global Const $TTM_GETTIPTEXTCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 23
Global Const $TTM_SETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 24
Global Const $TTM_GETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 25
Global Const $TTM_SETMARGIN = $__TOOLTIPCONSTANTS_WM_USER + 26
Global Const $TTM_GETMARGIN = $__TOOLTIPCONSTANTS_WM_USER + 27
Global Const $TTM_POP = $__TOOLTIPCONSTANTS_WM_USER + 28
Global Const $TTM_UPDATE = $__TOOLTIPCONSTANTS_WM_USER + 29
Global Const $TTM_GETBUBBLESIZE = $__TOOLTIPCONSTANTS_WM_USER + 30
Global Const $TTM_ADJUSTRECT = $__TOOLTIPCONSTANTS_WM_USER + 31
Global Const $TTM_SETTITLE = $__TOOLTIPCONSTANTS_WM_USER + 32
Global Const $TTM_SETTITLEW = $__TOOLTIPCONSTANTS_WM_USER + 33
Global Const $TTM_POPUP = $__TOOLTIPCONSTANTS_WM_USER + 34
Global Const $TTM_GETTITLE = $__TOOLTIPCONSTANTS_WM_USER + 35
Global Const $TTM_ADDTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 50
Global Const $TTM_DELTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 51
Global Const $TTM_NEWTOOLRECTW = $__TOOLTIPCONSTANTS_WM_USER + 52
Global Const $TTM_GETTOOLINFOW = $__TOOLTIPCONSTANTS_WM_USER + 53
Global Const $TTM_SETTOOLINFOW = $__TOOLTIPCONSTANTS_WM_USER + 54
Global Const $TTM_HITTESTW = $__TOOLTIPCONSTANTS_WM_USER + 55
Global Const $TTM_GETTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 56
Global Const $TTM_UPDATETIPTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 57
Global Const $TTM_ENUMTOOLSW = $__TOOLTIPCONSTANTS_WM_USER + 58
Global Const $TTM_GETCURRENTTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 59
Global Const $TTM_SETWINDOWTHEME = 0x2000 + 11
Global Const $TTN_FIRST = -520
Global Const $TTN_GETDISPINFO = $TTN_FIRST - 0
Global Const $TTN_SHOW = $TTN_FIRST - 1
Global Const $TTN_POP = $TTN_FIRST - 2
Global Const $TTN_LINKCLICK = $TTN_FIRST - 3
Global Const $TTN_GETDISPINFOW = $TTN_FIRST - 10
Global Const $TTS_ALWAYSTIP = 0x00000001
Global Const $TTS_NOPREFIX = 0x00000002
Global Const $TTS_NOANIMATE = 0x00000010
Global Const $TTS_NOFADE = 0x00000020
Global Const $TTS_BALLOON = 0x00000040
Global Const $TTS_CLOSE = 0x00000080
Global Const $TTS_USEVISUALSTYLE = 0x00000100
Global Const $TTDT_AUTOMATIC = 0
Global Const $TTDT_RESHOW = 1
Global Const $TTDT_AUTOPOP = 2
Global Const $TTDT_INITIAL = 3
Global Enum $TTI_NONE, $TTI_INFO, $TTI_WARNING, $TTI_ERROR, $TTI_INFO_LARGE, $TTI_WARNING_LARGE, $TTI_ERROR_LARGE
Global $__g_hEditLastWnd
Global Const $__EDITCONSTANT_ClassName = "Edit"
Global Const $__EDITCONSTANT_GUI_CHECKED = 1
Global Const $__EDITCONSTANT_GUI_HIDE = 32
Global Const $__EDITCONSTANT_GUI_EVENT_CLOSE = -3
Global Const $__EDITCONSTANT_GUI_ENABLE = 64
Global Const $__EDITCONSTANT_GUI_DISABLE = 128
Global Const $__EDITCONSTANT_SS_CENTER = 1
Global Const $__EDITCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__EDITCONSTANT_WS_CAPTION = 0x00C00000
Global Const $__EDITCONSTANT_WS_POPUP = 0x80000000
Global Const $__EDITCONSTANT_WS_SYSMENU = 0x00080000
Global Const $__EDITCONSTANT_WS_MINIMIZEBOX = 0x00020000
Global Const $__EDITCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__EDITCONSTANT_WM_SETFONT = 0x0030
Global Const $__EDITCONSTANT_WM_GETTEXTLENGTH = 0x000E
Global Const $__EDITCONSTANT_WM_GETTEXT = 0x000D
Global Const $__EDITCONSTANT_WM_SETTEXT = 0x000C
Global Const $__EDITCONSTANT_SB_LINEUP = 0
Global Const $__EDITCONSTANT_SB_LINEDOWN = 1
Global Const $__EDITCONSTANT_SB_PAGEDOWN = 3
Global Const $__EDITCONSTANT_SB_PAGEUP = 2
Global Const $__EDITCONSTANT_SB_SCROLLCARET = 4
Global Const $__tagEDITBALLOONTIP = "dword Size;ptr Title;ptr Text;int Icon"
Func _GUICtrlEdit_AppendText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLength = _GUICtrlEdit_GetTextLen($hWnd)
_GUICtrlEdit_SetSel($hWnd, $iLength, $iLength)
_SendMessage($hWnd, $EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlEdit_CanUndo($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_CANUNDO) <> 0
EndFunc
Func _GUICtrlEdit_CharFromPos($hWnd, $iX, $iY)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aReturn[2]
Local $iRet = _SendMessage($hWnd, $EM_CHARFROMPOS, 0, _WinAPI_MakeLong($iX, $iY))
$aReturn[0] = _WinAPI_LoWord($iRet)
$aReturn[1] = _WinAPI_HiWord($iRet)
Return $aReturn
EndFunc
Func _GUICtrlEdit_Create($hWnd, $sText, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x003010C4, $iExStyle = 0x00000200)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = 0x003010C4
If $iExStyle = -1 Then $iExStyle = 0x00000200
If BitAND($iStyle, $ES_READONLY) = $ES_READONLY Then
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $iStyle)
Else
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_TABSTOP, $iStyle)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hEdit = _WinAPI_CreateWindowEx($iExStyle, $__EDITCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hEdit, $__EDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__EDITCONSTANT_DEFAULT_GUI_FONT), True)
_GUICtrlEdit_SetText($hEdit, $sText)
_GUICtrlEdit_SetLimitText($hEdit, 0)
Return $hEdit
EndFunc
Func _GUICtrlEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__EDITCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hEditLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlEdit_EmptyUndoBuffer($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_EMPTYUNDOBUFFER)
EndFunc
Func _GUICtrlEdit_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlEdit_FmtLines($hWnd, $bSoftBreak = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_FMTLINES, $bSoftBreak)
EndFunc
Func _GUICtrlEdit_Find($hWnd, $bReplace = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iPos = 0, $iCase, $iOccurance = 0, $iReplacements = 0
Local $aPartsRightEdge[3] = [125, 225, -1]
Local $iOldMode = Opt("GUIOnEventMode", 0)
Local $aSel = _GUICtrlEdit_GetSel($hWnd)
Local $sText = _GUICtrlEdit_GetText($hWnd)
Local $hGuiSearch = GUICreate("Find", 349, 177, -1, -1, BitOR($__UDFGUICONSTANT_WS_CHILD, $__EDITCONSTANT_WS_MINIMIZEBOX, $__EDITCONSTANT_WS_CAPTION, $__EDITCONSTANT_WS_POPUP, $__EDITCONSTANT_WS_SYSMENU))
Local $idStatusBar1 = _GUICtrlStatusBar_Create($hGuiSearch, $aPartsRightEdge)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: ")
GUISetIcon(@SystemDir & "\shell32.dll", 22, $hGuiSearch)
GUICtrlCreateLabel("Find what:", 9, 10, 53, 16, $__EDITCONSTANT_SS_CENTER)
Local $idInputSearch = GUICtrlCreateInput("", 80, 8, 257, 21)
Local $idLblReplace = GUICtrlCreateLabel("Replace with:", 9, 42, 69, 17, $__EDITCONSTANT_SS_CENTER)
Local $idInputReplace = GUICtrlCreateInput("", 80, 40, 257, 21)
Local $idChkWholeOnly = GUICtrlCreateCheckbox("Match whole word only", 9, 72, 145, 17)
Local $idChkMatchCase = GUICtrlCreateCheckbox("Match case", 9, 96, 145, 17)
Local $idBtnFindNext = GUICtrlCreateButton("Find Next", 168, 72, 161, 21, 0)
Local $idBtnReplace = GUICtrlCreateButton("Replace", 168, 96, 161, 21, 0)
Local $idBtnClose = GUICtrlCreateButton("Close", 104, 130, 161, 21, 0)
If (IsArray($aSel) And $aSel <> $EC_ERR) Then
GUICtrlSetData($idInputSearch, StringMid($sText, $aSel[0] + 1, $aSel[1] - $aSel[0]))
If $aSel[0] <> $aSel[1] Then
$iPos = $aSel[0]
If BitAND(GUICtrlRead($idChkMatchCase), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iCase = 1
$iOccurance = 1
Local $iTPose
While 1
$iTPose = StringInStr($sText, GUICtrlRead($idInputSearch), $iCase, $iOccurance)
If Not $iTPose Then
$iOccurance = 0
ExitLoop
ElseIf $iTPose = $iPos + 1 Then
ExitLoop
EndIf
$iOccurance += 1
WEnd
EndIf
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
EndIf
If $bReplace = False Then
GUICtrlSetState($idLblReplace, $__EDITCONSTANT_GUI_HIDE)
GUICtrlSetState($idInputReplace, $__EDITCONSTANT_GUI_HIDE)
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_HIDE)
Else
_GUICtrlStatusBar_SetText($idStatusBar1, "Replacements: " & $iReplacements, 1)
_GUICtrlStatusBar_SetText($idStatusBar1, "With: ", 2)
EndIf
GUISetState(@SW_SHOW)
Local $iMsgFind
While 1
$iMsgFind = GUIGetMsg()
Select
Case $iMsgFind = $__EDITCONSTANT_GUI_EVENT_CLOSE Or $iMsgFind = $idBtnClose
ExitLoop
Case $iMsgFind = $idBtnFindNext
GUICtrlSetState($idBtnFindNext, $__EDITCONSTANT_GUI_DISABLE)
GUICtrlSetCursor($idBtnFindNext, 15)
Sleep(100)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
If $bReplace = True Then
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
_GUICtrlStatusBar_SetText($idStatusBar1, "With: " & GUICtrlRead($idInputReplace), 2)
EndIf
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Sleep(100)
GUICtrlSetState($idBtnFindNext, $__EDITCONSTANT_GUI_ENABLE)
GUICtrlSetCursor($idBtnFindNext, 2)
Case $iMsgFind = $idBtnReplace
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_DISABLE)
GUICtrlSetCursor($idBtnReplace, 15)
Sleep(100)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
_GUICtrlStatusBar_SetText($idStatusBar1, "With: " & GUICtrlRead($idInputReplace), 2)
If $iPos Then
_GUICtrlEdit_ReplaceSel($hWnd, GUICtrlRead($idInputReplace))
$iReplacements += 1
$iOccurance -= 1
_GUICtrlStatusBar_SetText($idStatusBar1, "Replacements: " & $iReplacements, 1)
EndIf
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Sleep(100)
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_ENABLE)
GUICtrlSetCursor($idBtnReplace, 2)
EndSelect
WEnd
GUIDelete($hGuiSearch)
Opt("GUIOnEventMode", $iOldMode)
EndFunc
Func _GUICtrlEdit_GetCueBanner($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = DllStructCreate("wchar[4096]")
If _SendMessage($hWnd, $EM_GETCUEBANNER, $tText, 4096, 0, "struct*") <> 1 Then Return SetError(-1, 0, "")
Return _WinAPI_WideCharToMultiByte($tText)
EndFunc
Func __GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, ByRef $iPos, ByRef $iOccurance, ByRef $iReplacements)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iCase = 0, $iWhole = 0
Local $bExact = False
Local $sFind = GUICtrlRead($idInputSearch)
Local $sText = _GUICtrlEdit_GetText($hWnd)
If BitAND(GUICtrlRead($idChkMatchCase), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iCase = 1
If BitAND(GUICtrlRead($idChkWholeOnly), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iWhole = 1
If $sFind <> "" Then
$iOccurance += 1
$iPos = StringInStr($sText, $sFind, $iCase, $iOccurance)
If $iWhole And $iPos Then
Local $s_Compare2 = StringMid($sText, $iPos + StringLen($sFind), 1)
If $iPos = 1 Then
If ($iPos + StringLen($sFind)) - 1 = StringLen($sText) Or  ($s_Compare2 = " " Or $s_Compare2 = @LF Or $s_Compare2 = @CR Or  $s_Compare2 = @CRLF Or $s_Compare2 = @TAB) Then $bExact = True
Else
Local $s_Compare1 = StringMid($sText, $iPos - 1, 1)
If ($iPos + StringLen($sFind)) - 1 = StringLen($sText) Then
If ($s_Compare1 = " " Or $s_Compare1 = @LF Or $s_Compare1 = @CR Or  $s_Compare1 = @CRLF Or $s_Compare1 = @TAB) Then $bExact = True
Else
If ($s_Compare1 = " " Or $s_Compare1 = @LF Or $s_Compare1 = @CR Or  $s_Compare1 = @CRLF Or $s_Compare1 = @TAB) And  ($s_Compare2 = " " Or $s_Compare2 = @LF Or $s_Compare2 = @CR Or  $s_Compare2 = @CRLF Or $s_Compare2 = @TAB) Then $bExact = True
EndIf
EndIf
If $bExact = False Then
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
ElseIf $iWhole And Not $iPos Then
$iOccurance = 0
MsgBox($MB_SYSTEMMODAL, "Find", "Reached End of document, Can not find the string '" & $sFind & "'")
ElseIf Not $iWhole Then
If Not $iPos Then
$iOccurance = 1
_GUICtrlEdit_SetSel($hWnd, -1, 0)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
$iPos = StringInStr($sText, $sFind, $iCase, $iOccurance)
If Not $iPos Then
$iOccurance = 0
MsgBox($MB_SYSTEMMODAL, "Find", "Reached End of document, Can not find the string  '" & $sFind & "'")
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
EndIf
EndIf
EndFunc
Func _GUICtrlEdit_GetFirstVisibleLine($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETFIRSTVISIBLELINE)
EndFunc
Func _GUICtrlEdit_GetHandle($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return Ptr(_SendMessage($hWnd, $EM_GETHANDLE))
EndFunc
Func _GUICtrlEdit_GetIMEStatus($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETIMESTATUS, $EMSIS_COMPOSITIONSTRING)
EndFunc
Func _GUICtrlEdit_GetLimitText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETLIMITTEXT)
EndFunc
Func _GUICtrlEdit_GetLine($hWnd, $iLine)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLength = _GUICtrlEdit_LineLength($hWnd, $iLine)
If $iLength = 0 Then Return ""
Local $tBuffer = DllStructCreate("short Len;wchar Text[" & $iLength & "]")
DllStructSetData($tBuffer, "Len", $iLength + 1)
Local $iRet = _SendMessage($hWnd, $EM_GETLINE, $iLine, $tBuffer, 0, "wparam", "struct*")
If $iRet = 0 Then Return SetError($EC_ERR, $EC_ERR, "")
Local $tText = DllStructCreate("wchar Text[" & $iLength & "]", DllStructGetPtr($tBuffer))
Return DllStructGetData($tText, "Text")
EndFunc
Func _GUICtrlEdit_GetLineCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETLINECOUNT)
EndFunc
Func _GUICtrlEdit_GetMargins($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aMargins[2]
Local $iMargins = _SendMessage($hWnd, $EM_GETMARGINS)
$aMargins[0] = _WinAPI_LoWord($iMargins)
$aMargins[1] = _WinAPI_HiWord($iMargins)
Return $aMargins
EndFunc
Func _GUICtrlEdit_GetModify($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETMODIFY) <> 0
EndFunc
Func _GUICtrlEdit_GetPasswordChar($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETPASSWORDCHAR)
EndFunc
Func _GUICtrlEdit_GetRECT($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlEdit_GetRECTEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlEdit_GetRECTEx($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $EM_GETRECT, 0, $tRECT, 0, "wparam", "struct*")
Return $tRECT
EndFunc
Func _GUICtrlEdit_GetSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aSel[2]
Local $tStart = DllStructCreate("uint Start")
Local $tEnd = DllStructCreate("uint End")
_SendMessage($hWnd, $EM_GETSEL, $tStart, $tEnd, 0, "struct*", "struct*")
$aSel[0] = DllStructGetData($tStart, "Start")
$aSel[1] = DllStructGetData($tEnd, "End")
Return $aSel
EndFunc
Func _GUICtrlEdit_GetText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iTextLen = _GUICtrlEdit_GetTextLen($hWnd) + 1
Local $tText = DllStructCreate("wchar Text[" & $iTextLen & "]")
_SendMessage($hWnd, $__EDITCONSTANT_WM_GETTEXT, $iTextLen, $tText, 0, "wparam", "struct*")
Return DllStructGetData($tText, "Text")
EndFunc
Func _GUICtrlEdit_GetTextLen($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_GETTEXTLENGTH)
EndFunc
Func _GUICtrlEdit_GetThumb($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETTHUMB)
EndFunc
Func _GUICtrlEdit_GetWordBreakProc($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETWORDBREAKPROC)
EndFunc
Func _GUICtrlEdit_HideBalloonTip($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_HIDEBALLOONTIP) <> 0
EndFunc
Func _GUICtrlEdit_InsertText($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $iIndex = -1 Then
_GUICtrlEdit_AppendText($hWnd, $sText)
Else
_GUICtrlEdit_SetSel($hWnd, $iIndex, $iIndex)
_SendMessage($hWnd, $EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndIf
EndFunc
Func _GUICtrlEdit_LineFromChar($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINEFROMCHAR, $iIndex)
EndFunc
Func _GUICtrlEdit_LineIndex($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINEINDEX, $iIndex)
EndFunc
Func _GUICtrlEdit_LineLength($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iCharIndex = _GUICtrlEdit_LineIndex($hWnd, $iIndex)
Return _SendMessage($hWnd, $EM_LINELENGTH, $iCharIndex)
EndFunc
Func _GUICtrlEdit_LineScroll($hWnd, $iHoriz, $iVert)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINESCROLL, $iHoriz, $iVert) <> 0
EndFunc
Func _GUICtrlEdit_PosFromChar($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aCoord[2]
Local $iRet = _SendMessage($hWnd, $EM_POSFROMCHAR, $iIndex)
$aCoord[0] = _WinAPI_LoWord($iRet)
$aCoord[1] = _WinAPI_HiWord($iRet)
Return $aCoord
EndFunc
Func _GUICtrlEdit_ReplaceSel($hWnd, $sText, $bUndo = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_REPLACESEL, $bUndo, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_Scroll($hWnd, $iDirection)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If BitAND($iDirection, $__EDITCONSTANT_SB_LINEDOWN) <> $__EDITCONSTANT_SB_LINEDOWN And  BitAND($iDirection, $__EDITCONSTANT_SB_LINEUP) <> $__EDITCONSTANT_SB_LINEUP And  BitAND($iDirection, $__EDITCONSTANT_SB_PAGEDOWN) <> $__EDITCONSTANT_SB_PAGEDOWN And  BitAND($iDirection, $__EDITCONSTANT_SB_PAGEUP) <> $__EDITCONSTANT_SB_PAGEUP And  BitAND($iDirection, $__EDITCONSTANT_SB_SCROLLCARET) <> $__EDITCONSTANT_SB_SCROLLCARET Then Return 0
If $iDirection == $__EDITCONSTANT_SB_SCROLLCARET Then
Return _SendMessage($hWnd, $EM_SCROLLCARET)
Else
Return _SendMessage($hWnd, $EM_SCROLL, $iDirection)
EndIf
EndFunc
Func _GUICtrlEdit_SetCueBanner($hWnd, $sText, $bOnFocus = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = _WinAPI_MultiByteToWideChar($sText)
Return _SendMessage($hWnd, $EM_SETCUEBANNER, $bOnFocus, $tText, 0, "wparam", "struct*") = 1
EndFunc
Func _GUICtrlEdit_SetHandle($hWnd, $hMemory)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETHANDLE, $hMemory, 0, 0, "handle")
EndFunc
Func _GUICtrlEdit_SetIMEStatus($hWnd, $iComposition)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETIMESTATUS, $EMSIS_COMPOSITIONSTRING, $iComposition)
EndFunc
Func _GUICtrlEdit_SetLimitText($hWnd, $iLimit)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETLIMITTEXT, $iLimit)
EndFunc
Func _GUICtrlEdit_SetMargins($hWnd, $iMargin = 0x1, $iLeft = 0xFFFF, $iRight = 0xFFFF)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETMARGINS, $iMargin, _WinAPI_MakeLong($iLeft, $iRight))
EndFunc
Func _GUICtrlEdit_SetModify($hWnd, $bModified)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETMODIFY, $bModified)
EndFunc
Func _GUICtrlEdit_SetPasswordChar($hWnd, $sDisplayChar = "0")
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
$sDisplayChar = StringLeft($sDisplayChar, 1)
If Asc($sDisplayChar) = 48 Then
_SendMessage($hWnd, $EM_SETPASSWORDCHAR)
Else
_SendMessage($hWnd, $EM_SETPASSWORDCHAR, Asc($sDisplayChar))
EndIf
EndFunc
Func _GUICtrlEdit_SetReadOnly($hWnd, $bReadOnly)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETREADONLY, $bReadOnly) <> 0
EndFunc
Func _GUICtrlEdit_SetRECT($hWnd, $aRect)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $aRect[0])
DllStructSetData($tRECT, "Top", $aRect[1])
DllStructSetData($tRECT, "Right", $aRect[2])
DllStructSetData($tRECT, "Bottom", $aRect[3])
_GUICtrlEdit_SetRECTEx($hWnd, $tRECT)
EndFunc
Func _GUICtrlEdit_SetRECTEx($hWnd, $tRECT)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETRECT, 0, $tRECT, 0, "wparam", "struct*")
EndFunc
Func _GUICtrlEdit_SetRECTNP($hWnd, $aRect)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $aRect[0])
DllStructSetData($tRECT, "Top", $aRect[1])
DllStructSetData($tRECT, "Right", $aRect[2])
DllStructSetData($tRECT, "Bottom", $aRect[3])
_GUICtrlEdit_SetRectNPEx($hWnd, $tRECT)
EndFunc
Func _GUICtrlEdit_SetRectNPEx($hWnd, $tRECT)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETRECTNP, 0, $tRECT, 0, "wparam", "struct*")
EndFunc
Func _GUICtrlEdit_SetSel($hWnd, $iStart, $iEnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETSEL, $iStart, $iEnd)
EndFunc
Func _GUICtrlEdit_SetTabStops($hWnd, $aTabStops)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If Not IsArray($aTabStops) Then Return SetError(-1, -1, False)
Local $sTabStops = ""
Local $iNumTabStops = UBound($aTabStops)
For $x = 0 To $iNumTabStops - 1
$sTabStops &= "int;"
Next
$sTabStops = StringTrimRight($sTabStops, 1)
Local $tTabStops = DllStructCreate($sTabStops)
For $x = 0 To $iNumTabStops - 1
DllStructSetData($tTabStops, $x + 1, $aTabStops[$x])
Next
Local $iRet = _SendMessage($hWnd, $EM_SETTABSTOPS, $iNumTabStops, $tTabStops, 0, "wparam", "struct*") <> 0
_WinAPI_InvalidateRect($hWnd)
Return $iRet
EndFunc
Func _GUICtrlEdit_SetText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $__EDITCONSTANT_WM_SETTEXT, 0, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_SetWordBreakProc($hWnd, $iAddressFunc)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETWORDBREAKPROC, 0, $iAddressFunc)
EndFunc
Func _GUICtrlEdit_ShowBalloonTip($hWnd, $sTitle, $sText, $iIcon)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tTitle = _WinAPI_MultiByteToWideChar($sTitle)
Local $tText = _WinAPI_MultiByteToWideChar($sText)
Local $tTT = DllStructCreate($__tagEDITBALLOONTIP)
DllStructSetData($tTT, "Size", DllStructGetSize($tTT))
DllStructSetData($tTT, "Title", DllStructGetPtr($tTitle))
DllStructSetData($tTT, "Text", DllStructGetPtr($tText))
DllStructSetData($tTT, "Icon", $iIcon)
Return _SendMessage($hWnd, $EM_SHOWBALLOONTIP, 0, $tTT, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlEdit_Undo($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_UNDO) <> 0
EndFunc
Global $__g_hTabLastWnd
Global Const $__TABCONSTANT_ClassName = "SysTabControl32"
Global Const $__TABCONSTANT_WS_CLIPSIBLINGS = 0x04000000
Global Const $__TABCONSTANT_WM_NOTIFY = 0x004E
Global Const $__TABCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $tagTCITEM = "uint Mask;dword State;dword StateMask;ptr Text;int TextMax;int Image;lparam Param"
Global Const $tagTCHITTESTINFO = $tagPOINT & ";uint Flags"
Func __GUICtrlTab_AdjustRect($hWnd, ByRef $tRECT, $bLarger = False)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_ADJUSTRECT, $bLarger, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT)
_SendMessage($hWnd, $TCM_ADJUSTRECT, $bLarger, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_ActivateTab($hWnd, $iIndex)
Local $nIndX
If $hWnd = -1 Then $hWnd = GUICtrlGetHandle(-1)
If IsHWnd($hWnd) Then
$nIndX = _WinAPI_GetDlgCtrlID($hWnd)
Else
$nIndX = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hParent = _WinAPI_GetParent($hWnd)
If @error Then Return SetError(1, 0, -1)
Local $tNmhdr = DllStructCreate($tagNMHDR)
DllStructSetData($tNmhdr, 1, $hWnd)
DllStructSetData($tNmhdr, 2, $nIndX)
DllStructSetData($tNmhdr, 3, $TCN_SELCHANGING)
_SendMessage($hParent, $__TABCONSTANT_WM_NOTIFY, $nIndX, $tNmhdr, 0, "wparam", "struct*")
Local $iRet = _GUICtrlTab_SetCurSel($hWnd, $iIndex)
DllStructSetData($tNmhdr, 3, $TCN_SELCHANGE)
_SendMessage($hParent, $__TABCONSTANT_WM_NOTIFY, $nIndX, $tNmhdr, 0, "wparam", "struct*")
Return $iRet
EndFunc
Func _GUICtrlTab_ClickTab($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iX, $iY
If Not $bMove Then
Local $hWinParent = _WinAPI_GetParent($hWnd)
Local $avTabPos = _GUICtrlTab_GetItemRect($hWnd, $iIndex)
$iX = $avTabPos[0] + (($avTabPos[2] - $avTabPos[0]) / 2)
$iY = $avTabPos[1] + (($avTabPos[3] - $avTabPos[1]) / 2)
ControlClick($hWinParent, "", $hWnd, $sButton, $iClicks, $iX, $iY)
Else
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
Opt("MouseCoordMode", $iMode)
EndIf
EndFunc
Func _GUICtrlTab_Create($hWnd, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x00000040, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then
Return SetError(1, 0, 0)
EndIf
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = $TCS_HOTTRACK
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__TABCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hTab = _WinAPI_CreateWindowEx($iExStyle, $__TABCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hTab, _WinAPI_GetStockObject($__TABCONSTANT_DEFAULT_GUI_FONT))
Return $hTab
EndFunc
Func _GUICtrlTab_DeleteAllItems($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_DELETEALLITEMS) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_DELETEALLITEMS, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_DeleteItem($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_DELETEITEM, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_DELETEITEM, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_DeselectAll($hWnd, $bExclude = True)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_DESELECTALL, $bExclude)
Else
GUICtrlSendMsg($hWnd, $TCM_DESELECTALL, $bExclude, 0)
EndIf
EndFunc
Func _GUICtrlTab_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__TABCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlTab_FindTab($hWnd, $sText, $bInStr = False, $iStart = 0)
Local $sTab
For $iI = $iStart To _GUICtrlTab_GetItemCount($hWnd)
$sTab = _GUICtrlTab_GetItemText($hWnd, $iI)
Switch $bInStr
Case False
If $sTab = $sText Then Return $iI
Case True
If StringInStr($sTab, $sText) Then Return $iI
EndSwitch
Next
Return -1
EndFunc
Func _GUICtrlTab_GetCurFocus($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETCURFOCUS)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETCURFOCUS, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetCurSel($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETCURSEL)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETCURSEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetDisplayRect($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetDisplayRectEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetDisplayRectEx($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
Return __GUICtrlTab_AdjustRect($hWnd, $tRECT)
EndFunc
Func _GUICtrlTab_GetExtendedStyle($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETEXTENDEDSTYLE)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETEXTENDEDSTYLE, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetImageList($hWnd)
If IsHWnd($hWnd) Then
Return Ptr(_SendMessage($hWnd, $TCM_GETIMAGELIST))
Else
Return Ptr(GUICtrlSendMsg($hWnd, $TCM_GETIMAGELIST, 0, 0))
EndIf
EndFunc
Func _GUICtrlTab_GetItem($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
Local $iBuffer = 4096
Local $tagTCITEMEx = $tagTCITEM & ";ptr Filler"
Local $tItem = DllStructCreate($tagTCITEMEx)
DllStructSetData($tItem, "Mask", $TCIF_ALLDATA)
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "StateMask", BitOR($TCIS_HIGHLIGHTED, $TCIS_BUTTONPRESSED))
Local $iItem = DllStructGetSize($tItem)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
Local $iRet
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_GETITEMW, $iIndex, $pMemory)
Else
$iRet = _SendMessage($hWnd, $TCM_GETITEMA, $iIndex, $pMemory)
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
Local $aItem[4]
$aItem[0] = DllStructGetData($tItem, "State")
$aItem[1] = DllStructGetData($tBuffer, "Text")
$aItem[2] = DllStructGetData($tItem, "Image")
$aItem[3] = DllStructGetData($tItem, "Param")
Return SetError($iRet = 0, 0, $aItem)
EndFunc
Func _GUICtrlTab_GetItemCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETITEMCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETITEMCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetItemImage($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[2]
EndFunc
Func _GUICtrlTab_GetItemParam($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[3]
EndFunc
Func _GUICtrlTab_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $TCM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_GetItemState($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[0]
EndFunc
Func _GUICtrlTab_GetItemText($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[1]
EndFunc
Func _GUICtrlTab_GetRowCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETROWCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETROWCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetToolTips($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $TCM_GETTOOLTIPS))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $TCM_GETTOOLTIPS, 0, 0))
EndIf
EndFunc
Func _GUICtrlTab_GetUnicodeFormat($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_HighlightItem($hWnd, $iIndex, $bHighlight = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_HIGHLIGHTITEM, $iIndex, $bHighlight) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_HIGHLIGHTITEM, $iIndex, $bHighlight) <> 0
EndIf
EndFunc
Func _GUICtrlTab_HitTest($hWnd, $iX, $iY)
Local $aHit[2] = [-1, 1]
Local $tHit = DllStructCreate($tagTCHITTESTINFO)
DllStructSetData($tHit, "X", $iX)
DllStructSetData($tHit, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
$aHit[0] = _SendMessage($hWnd, $TCM_HITTEST, 0, $tHit, 0, "wparam", "struct*")
Else
Local $iHit = DllStructGetSize($tHit)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iHit, $tMemMap)
_MemWrite($tMemMap, $tHit)
$aHit[0] = _SendMessage($hWnd, $TCM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tHit, $iHit)
_MemFree($tMemMap)
EndIf
Else
$aHit[0] = GUICtrlSendMsg($hWnd, $TCM_HITTEST, 0, DllStructGetPtr($tHit))
EndIf
$aHit[1] = DllStructGetData($tHit, "Flags")
Return $aHit
EndFunc
Func _GUICtrlTab_InsertItem($hWnd, $iIndex, $sText, $iImage = -1, $iParam = 0)
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagTCITEM)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", BitOR($TCIF_TEXT, $TCIF_IMAGE, $TCIF_PARAM))
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $TCM_INSERTITEMW, $iIndex, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $TCM_INSERTITEMA, $iIndex, $pItem)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlTab_RemoveImage($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_REMOVEIMAGE, $iIndex)
_WinAPI_InvalidateRect($hWnd)
Else
GUICtrlSendMsg($hWnd, $TCM_REMOVEIMAGE, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetCurFocus($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETCURFOCUS, $iIndex)
Else
GUICtrlSendMsg($hWnd, $TCM_SETCURFOCUS, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetCurSel($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETCURSEL, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETCURSEL, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetExtendedStyle($hWnd, $iStyle)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETEXTENDEDSTYLE, 0, $iStyle)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETEXTENDEDSTYLE, 0, $iStyle)
EndIf
EndFunc
Func _GUICtrlTab_SetImageList($hWnd, $hImage)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETIMAGELIST, 0, $hImage, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $TCM_SETIMAGELIST, 0, $hImage))
EndIf
EndFunc
Func _GUICtrlTab_SetItem($hWnd, $iIndex, $sText = -1, $iState = -1, $iImage = -1, $iParam = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tItem = DllStructCreate($tagTCITEM)
Local $iBuffer, $tBuffer, $iMask = 0, $iRet
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
If IsString($sText) Then
$iBuffer = StringLen($sText) + 1
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
$iMask = $TCIF_TEXT
EndIf
If $iState <> -1 Then
DllStructSetData($tItem, "State", $iState)
DllStructSetData($tItem, "StateMask", $iState)
$iMask = BitOR($iMask, $TCIF_STATE)
EndIf
If $iImage <> -1 Then
DllStructSetData($tItem, "Image", $iImage)
$iMask = BitOR($iMask, $TCIF_IMAGE)
EndIf
If $iParam <> -1 Then
DllStructSetData($tItem, "Param", $iParam)
$iMask = BitOR($iMask, $TCIF_PARAM)
EndIf
DllStructSetData($tItem, "Mask", $iMask)
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + 8192, $tMemMap)
Local $pText = $pMemory + 4096
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If IsString($sText) Then _MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_SETITEMW, $iIndex, $pMemory) <> 0
Else
$iRet = _SendMessage($hWnd, $TCM_SETITEMA, $iIndex, $pMemory) <> 0
EndIf
_MemFree($tMemMap)
Return $iRet
EndFunc
Func _GUICtrlTab_SetItemImage($hWnd, $iIndex, $iImage)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, -1, $iImage)
EndFunc
Func _GUICtrlTab_SetItemParam($hWnd, $iIndex, $iParam)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, -1, -1, $iParam)
EndFunc
Func _GUICtrlTab_SetItemSize($hWnd, $iWidth, $iHeight)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETITEMSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight))
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETITEMSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight))
EndIf
EndFunc
Func _GUICtrlTab_SetItemState($hWnd, $iIndex, $iState)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, $iState)
EndFunc
Func _GUICtrlTab_SetItemText($hWnd, $iIndex, $sText)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, $sText)
EndFunc
Func _GUICtrlTab_SetMinTabWidth($hWnd, $iMinWidth)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETMINTABWIDTH, 0, $iMinWidth)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETMINTABWIDTH, 0, $iMinWidth)
EndIf
EndFunc
Func _GUICtrlTab_SetPadding($hWnd, $iHorz, $iVert)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETPADDING, 0, _WinAPI_MakeLong($iHorz, $iVert))
Else
GUICtrlSendMsg($hWnd, $TCM_SETPADDING, 0, _WinAPI_MakeLong($iHorz, $iVert))
EndIf
EndFunc
Func _GUICtrlTab_SetToolTips($hWnd, $hToolTip)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETTOOLTIPS, $hToolTip, 0, 0, "hwnd")
Else
GUICtrlSendMsg($hWnd, $TCM_SETTOOLTIPS, $hToolTip, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetUnicodeFormat($hWnd, $bUnicode)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETUNICODEFORMAT, $bUnicode) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETUNICODEFORMAT, $bUnicode, 0) <> 0
EndIf
EndFunc
Global Const $CF_TEXT = 1
Global Const $CF_BITMAP = 2
Global Const $CF_METAFILEPICT = 3
Global Const $CF_SYLK = 4
Global Const $CF_DIF = 5
Global Const $CF_TIFF = 6
Global Const $CF_OEMTEXT = 7
Global Const $CF_DIB = 8
Global Const $CF_PALETTE = 9
Global Const $CF_PENDATA = 10
Global Const $CF_RIFF = 11
Global Const $CF_WAVE = 12
Global Const $CF_UNICODETEXT = 13
Global Const $CF_ENHMETAFILE = 14
Global Const $CF_HDROP = 15
Global Const $CF_LOCALE = 16
Global Const $CF_DIBV5 = 17
Global Const $CF_OWNERDISPLAY = 0x0080
Global Const $CF_DSPTEXT = 0x0081
Global Const $CF_DSPBITMAP = 0x0082
Global Const $CF_DSPMETAFILEPICT = 0x0083
Global Const $CF_DSPENHMETAFILE = 0x008E
Global Const $CF_PRIVATEFIRST = 0x0200
Global Const $CF_PRIVATELAST = 0x02FF
Global Const $CF_GDIOBJFIRST = 0x0300
Global Const $CF_GDIOBJLAST = 0x03FF
Func _ClipBoard_ChangeChain($hRemove, $hNewNext)
DllCall("user32.dll", "bool", "ChangeClipboardChain", "hwnd", $hRemove, "hwnd", $hNewNext)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _ClipBoard_Close()
Local $aResult = DllCall("user32.dll", "bool", "CloseClipboard")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _ClipBoard_CountFormats()
Local $aResult = DllCall("user32.dll", "int", "CountClipboardFormats")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_Empty()
Local $aResult = DllCall("user32.dll", "bool", "EmptyClipboard")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _ClipBoard_EnumFormats($iFormat)
Local $aResult = DllCall("user32.dll", "uint", "EnumClipboardFormats", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_FormatStr($iFormat)
Local $aFormat[18] = [17, "Text", "Bitmap", "Metafile Picture", "SYLK", "DIF", "TIFF", "OEM Text", "DIB", "Palette",  "Pen Data", "RIFF", "WAVE", "Unicode Text", "Enhanced Metafile", "HDROP", "Locale", "DIB V5"]
If $iFormat >= 1 And $iFormat <= 17 Then Return $aFormat[$iFormat]
Switch $iFormat
Case $CF_OWNERDISPLAY
Return "Owner Display"
Case $CF_DSPTEXT
Return "Private Text"
Case $CF_DSPBITMAP
Return "Private Bitmap"
Case $CF_DSPMETAFILEPICT
Return "Private Metafile Picture"
Case $CF_DSPENHMETAFILE
Return "Private Enhanced Metafile"
Case Else
Return _ClipBoard_GetFormatName($iFormat)
EndSwitch
EndFunc
Func _ClipBoard_GetData($iFormat = 1)
If Not _ClipBoard_IsFormatAvailable($iFormat) Then Return SetError(-1, 0, 0)
If Not _ClipBoard_Open(0) Then Return SetError(-2, 0, 0)
Local $hMemory = _ClipBoard_GetDataEx($iFormat)
If $hMemory = 0 Then
_ClipBoard_Close()
Return SetError(-3, 0, 0)
EndIf
Local $pMemoryBlock = _MemGlobalLock($hMemory)
If $pMemoryBlock = 0 Then
_ClipBoard_Close()
Return SetError(-4, 0, 0)
EndIf
Local $iDataSize = _MemGlobalSize($hMemory)
If $iDataSize = 0 Then
_MemGlobalUnlock($hMemory)
_ClipBoard_Close()
Return SetError(-5, 0, "")
EndIf
Local $tData
Switch $iFormat
Case $CF_TEXT, $CF_OEMTEXT
$tData = DllStructCreate("char[" & $iDataSize & "]", $pMemoryBlock)
Case $CF_UNICODETEXT
$iDataSize = Round($iDataSize / 2)
$tData = DllStructCreate("wchar[" & $iDataSize & "]", $pMemoryBlock)
Case Else
$tData = DllStructCreate("byte[" & $iDataSize & "]", $pMemoryBlock)
EndSwitch
Local $vReturn = DllStructGetData($tData, 1)
_MemGlobalUnlock($hMemory)
_ClipBoard_Close()
Return SetExtended($iDataSize, $vReturn)
EndFunc
Func _ClipBoard_GetDataEx($iFormat = 1)
Local $aResult = DllCall("user32.dll", "handle", "GetClipboardData", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetFormatName($iFormat)
Local $aResult = DllCall("user32.dll", "int", "GetClipboardFormatNameW", "uint", $iFormat, "wstr", "", "int", 4096)
If @error Then Return SetError(@error, @extended, "")
Return $aResult[2]
EndFunc
Func _ClipBoard_GetOpenWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetOpenClipboardWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetOwner()
Local $aResult = DllCall("user32.dll", "hwnd", "GetClipboardOwner")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetPriorityFormat($aFormats)
If Not IsArray($aFormats) Then Return SetError(-1, 0, 0)
If $aFormats[0] <= 0 Then Return SetError(-2, 0, 0)
Local $tData = DllStructCreate("uint[" & $aFormats[0] & "]")
For $iI = 1 To $aFormats[0]
DllStructSetData($tData, 1, $aFormats[$iI], $iI)
Next
Local $aResult = DllCall("user32.dll", "int", "GetPriorityClipboardFormat", "struct*", $tData, "int", $aFormats[0])
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetSequenceNumber()
Local $aResult = DllCall("user32.dll", "dword", "GetClipboardSequenceNumber")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetViewer()
Local $aResult = DllCall("user32.dll", "hwnd", "GetClipboardViewer")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_IsFormatAvailable($iFormat)
Local $aResult = DllCall("user32.dll", "bool", "IsClipboardFormatAvailable", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _ClipBoard_Open($hOwner)
Local $aResult = DllCall("user32.dll", "bool", "OpenClipboard", "hwnd", $hOwner)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _ClipBoard_RegisterFormat($sFormat)
Local $aResult = DllCall("user32.dll", "uint", "RegisterClipboardFormatW", "wstr", $sFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_SetData($vData, $iFormat = 1)
Local $tData, $hLock, $hMemory, $iSize
If IsNumber($vData) And $vData = 0 Then
$hMemory = $vData
Else
If IsBinary($vData) Then
$iSize = BinaryLen($vData)
ElseIf IsString($vData) Then
$iSize = StringLen($vData)
Else
Return SetError(2, 0, 0)
EndIf
$iSize += 1
If $iFormat = $CF_UNICODETEXT Then
$hMemory = _MemGlobalAlloc($iSize * 2, $GHND)
Else
$hMemory = _MemGlobalAlloc($iSize, $GHND)
EndIf
If $hMemory = 0 Then Return SetError(-1, 0, 0)
$hLock = _MemGlobalLock($hMemory)
If $hLock = 0 Then Return SetError(-2, 0, 0)
Switch $iFormat
Case $CF_TEXT, $CF_OEMTEXT
$tData = DllStructCreate("char[" & $iSize & "]", $hLock)
Case $CF_UNICODETEXT
$tData = DllStructCreate("wchar[" & $iSize & "]", $hLock)
Case Else
$tData = DllStructCreate("byte[" & $iSize & "]", $hLock)
EndSwitch
DllStructSetData($tData, 1, $vData)
_MemGlobalUnlock($hMemory)
EndIf
If Not _ClipBoard_Open(0) Then Return SetError(-5, 0, 0)
If Not _ClipBoard_Empty() Then
_ClipBoard_Close()
Return SetError(-6, 0, 0)
EndIf
If Not _ClipBoard_SetDataEx($hMemory, $iFormat) Then
_ClipBoard_Close()
Return SetError(-7, 0, 0)
EndIf
_ClipBoard_Close()
Return $hMemory
EndFunc
Func _ClipBoard_SetDataEx(ByRef $hMemory, $iFormat = 1)
Local $aResult = DllCall("user32.dll", "handle", "SetClipboardData", "uint", $iFormat, "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_SetViewer($hViewer)
Local $aResult = DllCall("user32.dll", "hwnd", "SetClipboardViewer", "hwnd", $hViewer)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Global $__g_sRTFClassName, $__g_sRTFVersion, $__g_iRTFTwipsPeSpaceUnit = 1440
Global $__g_sGRE_CF_RTF, $__g_sGRE_CF_RETEXTOBJ
Global $__g_pGRC_StreamFromFileCallback = DllCallbackRegister("__GCR_StreamFromFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamFromVarCallback = DllCallbackRegister("__GCR_StreamFromVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToFileCallback = DllCallbackRegister("__GCR_StreamToFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToVarCallback = DllCallbackRegister("__GCR_StreamToVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_sStreamVar
Global $__g_hRELastWnd
Global $__g_tObj_RichComObject = DllStructCreate("ptr pIntf; dword  Refcount")
Global $__g_tCall_RichCom, $__g_pObj_RichCom
Global $__g_hLib_RichCom_OLE32 = DllOpen("OLE32.DLL")
Global $__g_pRichCom_Object_QueryInterface = DllCallbackRegister("__RichCom_Object_QueryInterface", "long", "ptr;dword;dword")
Global $__g_pRichCom_Object_AddRef = DllCallbackRegister("__RichCom_Object_AddRef", "long", "ptr")
Global $__g_pRichCom_Object_Release = DllCallbackRegister("__RichCom_Object_Release", "long", "ptr")
Global $__g_pRichCom_Object_GetNewStorage = DllCallbackRegister("__RichCom_Object_GetNewStorage", "long", "ptr;ptr")
Global $__g_pRichCom_Object_GetInPlaceContext = DllCallbackRegister("__RichCom_Object_GetInPlaceContext", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_ShowContainerUI = DllCallbackRegister("__RichCom_Object_ShowContainerUI", "long", "ptr;long")
Global $__g_pRichCom_Object_QueryInsertObject = DllCallbackRegister("__RichCom_Object_QueryInsertObject", "long", "ptr;dword;ptr;long")
Global $__g_pRichCom_Object_DeleteObject = DllCallbackRegister("__RichCom_Object_DeleteObject", "long", "ptr;ptr")
Global $__g_pRichCom_Object_QueryAcceptData = DllCallbackRegister("__RichCom_Object_QueryAcceptData", "long", "ptr;ptr;dword;dword;dword;ptr")
Global $__g_pRichCom_Object_ContextSensitiveHelp = DllCallbackRegister("__RichCom_Object_ContextSensitiveHelp", "long", "ptr;long")
Global $__g_pRichCom_Object_GetClipboardData = DllCallbackRegister("__RichCom_Object_GetClipboardData", "long", "ptr;ptr;dword;ptr")
Global $__g_pRichCom_Object_GetDragDropEffect = DllCallbackRegister("__RichCom_Object_GetDragDropEffect", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_GetContextMenu = DllCallbackRegister("__RichCom_Object_GetContextMenu", "long", "ptr;short;ptr;ptr;ptr")
Global Const $__RICHEDITCONSTANT_SB_LINEDOWN = 1
Global Const $__RICHEDITCONSTANT_SB_LINEUP = 0
Global Const $__RICHEDITCONSTANT_SB_PAGEDOWN = 3
Global Const $__RICHEDITCONSTANT_SB_PAGEUP = 2
Global Const $__RICHEDITCONSTANT_WM_COPY = 0x00000301
Global Const $__RICHEDITCONSTANT_WM_SETFONT = 0x0030
Global Const $__RICHEDITCONSTANT_WM_CUT = 0x00000300
Global Const $__RICHEDITCONSTANT_WM_PASTE = 0x00000302
Global Const $__RICHEDITCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__RICHEDITCONSTANT_COLOR_WINDOWTEXT = 8
Global Const $_GCR_S_OK = 0
Global Const $_GCR_E_NOTIMPL = 0x80004001
Global Const $_GCR_E_INVALIDARG = 0x80070057
Global Const $tagEDITSTREAM = "align 4;dword_ptr dwCookie;dword dwError;ptr pfnCallback"
Global Const $tagBIDIOPTIONS = "uint cbSize;word wMask;word wEffects"
Global Const $tagCHARFORMAT = "struct;uint cbSize;dword dwMask;dword dwEffects;long yHeight;long yOffset;INT crCharColor;" &  "byte bCharSet;byte bPitchAndFamily;wchar szFaceName[32];endstruct"
Global Const $tagCHARFORMAT2 = $tagCHARFORMAT & ";word wWeight;short sSpacing;INT crBackColor;dword lcid;dword dwReserved;" &  "short sStyle;word wKerning;byte bUnderlineType;byte bAnimation;byte bRevAuthor;byte bReserved1"
Global Const $tagCHARRANGE = "struct;long cpMin;long cpMax;endstruct"
Global Const $tagFINDTEXT = $tagCHARRANGE & ";ptr lpstrText"
Global Const $tagFINDTEXTEX = $tagCHARRANGE & ";ptr lpstrText;long cpMinRang;long cpMaxRange"
Global Const $tagGETTEXTEX = "align 4;dword cb;dword flags;uint codepage;ptr lpDefaultChar;ptr lpbUsedDefChar"
Global Const $tagGETTEXTLENGTHEX = "dword flags;uint codepage"
Global Const $tagPARAFORMAT = "uint cbSize;dword dwMask;word wNumbering;word wEffects;long dxStartIndent;"  & "long dxRightIndent;long dxOffset;word wAlignment;short cTabCount;long rgxTabs[32]"
Global Const $tagPARAFORMAT2 = $tagPARAFORMAT  & ";long dySpaceBefore;long dySpaceAfter;long dyLineSpacing;short sStyle;byte bLineSpacingRule;"  & "byte bOutlineLevel;word wShadingWeight;word wShadingStyle;word wNumberingStart;word wNumberingStyle;"  & "word wNumberingTab;word wBorderSpace;word wBorderWidth;word wBorders"
Global Const $tagSETTEXTEX = "dword flags;uint codepage"
Global Const $tagTEXTRANGE = $tagCHARRANGE & ";ptr lpstrText"
Global Const $tagMSGFILTER = "align 4;" & $tagNMHDR & ";uint msg;wparam wParam;lparam lParam"
Global Const $tagENLINK = "align 4;" & $tagNMHDR & ";uint msg;wparam wParam;lparam lParam;" & $tagCHARRANGE
Func _GUICtrlRichEdit_AppendText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iLength = _GUICtrlRichEdit_GetTextLength($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iLength, $iLength)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_AutoDetectURL($hWnd, $bState)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
If _SendMessage($hWnd, $EM_AUTOURLDETECT, $bState) Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_CanPaste($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_CANPASTE, 0, 0)
Return $iRet <> 0
EndFunc
Func _GUICtrlRichEdit_CanPasteSpecial($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANPASTE, $__g_sGRE_CF_RTF, 0) <> 0  And _SendMessage($hWnd, $EM_CANPASTE, $__g_sGRE_CF_RETEXTOBJ, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_CanRedo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANREDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_CanUndo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANUNDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_ChangeFontSize($hWnd, $iIncrement)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iIncrement) Then SetError(102, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, False)
Return _SendMessage($hWnd, $EM_SETFONTSIZE, $iIncrement, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_Copy($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_COPY, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Create($hWnd, $sText, $iLeft, $iTop, $iWidth = 150, $iHeight = 150, $iStyle = -1, $iExStyle = -1)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If Not __GCR_IsNumeric($iWidth, ">0,-1") Then Return SetError(105, 0, 0)
If Not __GCR_IsNumeric($iHeight, ">0,-1") Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iStyle, ">=0,-1") Then Return SetError(107, 0, 0)
If Not __GCR_IsNumeric($iExStyle, ">=0,-1") Then Return SetError(108, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = BitOR($ES_WANTRETURN, $ES_MULTILINE)
If BitAND($iStyle, $ES_MULTILINE) <> 0 Then $iStyle = BitOR($iStyle, $ES_WANTRETURN)
If $iExStyle = -1 Then $iExStyle = 0x200
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If BitAND($iStyle, $ES_READONLY) = 0 Then $iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_TABSTOP)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
__GCR_Init()
Local $hRichEdit = _WinAPI_CreateWindowEx($iExStyle, $__g_sRTFClassName, "", $iStyle, $iLeft, $iTop, $iWidth,  $iHeight, $hWnd, $nCtrlID)
If $hRichEdit = 0 Then Return SetError(700, 0, False)
__GCR_SetOLECallback($hRichEdit)
_SendMessage($hRichEdit, $__RICHEDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($DEFAULT_GUI_FONT), True)
_GUICtrlRichEdit_AppendText($hRichEdit, $sText)
Return $hRichEdit
EndFunc
Func _GUICtrlRichEdit_Cut($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_CUT, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Deselect($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_SETSEL, -1, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hRELastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlRichEdit_EmptyUndoBuffer($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_EMPTYUNDOBUFFER, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_FindText($hWnd, $sText, $bForward = True, $bMatchCase = False, $bWholeWord = False, $iBehavior = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, -1)
If $sText = "" Then Return SetError(102, 0, -1)
If Not IsBool($bForward) Then Return SetError(103, 0, -1)
If Not IsBool($bMatchCase) Then Return SetError(104, 0, -1)
If Not IsBool($bWholeWord) Then Return SetError(105, 0, -1)
If Not __GCR_IsNumeric($iBehavior) Then Return SetError(1061, 0, -1)
If BitAND($iBehavior, BitNOT(BitOR($FR_MATCHALEFHAMZA, $FR_MATCHDIAC, $FR_MATCHKASHIDA))) <> 0 Then Return SetError(1062, 0, -1)
Local $iLen = StringLen($sText) + 3
Local $tText = DllStructCreate("wchar[" & $iLen & "]")
DllStructSetData($tText, 1, $sText)
Local $tFindtext = DllStructCreate($tagFINDTEXT)
Local $aiAnchorActive
Local $bSel = _GUICtrlRichEdit_IsTextSelected($hWnd)
If $bSel Then
$aiAnchorActive = _GUICtrlRichEdit_GetSelAA($hWnd)
Else
$aiAnchorActive = _GUICtrlRichEdit_GetSel($hWnd)
EndIf
DllStructSetData($tFindtext, 1, $aiAnchorActive[0])
DllStructSetData($tFindtext, 2, ($bForward ? -1 : 0))
DllStructSetData($tFindtext, 3, DllStructGetPtr($tText))
Local Const $FR_DOWN = 0x00000001
Local Const $FR_WHOLEWORD = 0x00000002
Local Const $FR_MATCHCASE = 0x00000004
Local $wParam = 0
If $bForward Then $wParam = $FR_DOWN
If $bWholeWord Then $wParam = BitOR($wParam, $FR_WHOLEWORD)
If $bMatchCase Then $wParam = BitOR($wParam, $FR_MATCHCASE)
$wParam = BitOR($wParam, $iBehavior)
Return _SendMessage($hWnd, $EM_FINDTEXTW, $wParam, $tFindtext, "wparam", "ptr", "struct*")
EndFunc
Func _GUICtrlRichEdit_FindTextInRange($hWnd, $sText, $iStart = 0, $iEnd = -1, $bMatchCase = False, $bWholeWord = False, $iBehavior = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If $sText = "" Then Return SetError(102, 0, 0)
If Not __GCR_IsNumeric($iStart, ">=0,-1") Then Return SetError(103, 0, 0)
If Not __GCR_IsNumeric($iEnd, ">=0,-1") Then Return SetError(104, 0, 0)
If Not IsBool($bMatchCase) Then Return SetError(105, 0, 0)
If Not IsBool($bWholeWord) Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iBehavior) Then Return SetError(1071, 0, 0)
If BitAND($iBehavior, BitNOT(BitOR($FR_MATCHALEFHAMZA, $FR_MATCHDIAC, $FR_MATCHKASHIDA))) <> 0 Then Return SetError(1072, 0, 0)
Local $iLen = StringLen($sText) + 3
Local $tText = DllStructCreate("wchar Text[" & $iLen & "]")
DllStructSetData($tText, "Text", $sText)
Local $tFindtext = DllStructCreate($tagFINDTEXTEX)
DllStructSetData($tFindtext, "cpMin", $iStart)
DllStructSetData($tFindtext, "cpMax", $iEnd)
DllStructSetData($tFindtext, "lpstrText", DllStructGetPtr($tText))
Local Const $FR_DOWN = 0x00000001
Local Const $FR_WHOLEWORD = 0x00000002
Local Const $FR_MATCHCASE = 0x00000004
Local $wParam = 0
If $iEnd >= $iStart Or $iEnd = -1 Then
$wParam = $FR_DOWN
EndIf
If $bWholeWord Then $wParam = BitOR($wParam, $FR_WHOLEWORD)
If $bMatchCase Then $wParam = BitOR($wParam, $FR_MATCHCASE)
$wParam = BitOR($wParam, $iBehavior)
_SendMessage($hWnd, $EM_FINDTEXTEXW, $wParam, $tFindtext, "iWparam", "ptr", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tFindtext, "cpMinRang")
$aRet[1] = DllStructGetData($tFindtext, "cpMaxRange")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetCharAttributes($hWnd)
Local Const $aV[17][3] = [  ["bo", $CFM_BOLD, $CFE_BOLD], ["di", $CFM_DISABLED, $CFE_DISABLED],  ["em", $CFM_EMBOSS, $CFE_EMBOSS], ["hi", $CFM_HIDDEN, $CFE_HIDDEN],  ["im", $CFM_IMPRINT, $CFE_IMPRINT], ["it", $CFM_ITALIC, $CFE_ITALIC],  ["li", $CFM_LINK, $CFE_LINK], ["ou", $CFM_OUTLINE, $CFE_OUTLINE],  ["pr", $CFM_PROTECTED, $CFE_PROTECTED], ["re", $CFM_REVISED, $CFE_REVISED],  ["sh", $CFM_SHADOW, $CFE_SHADOW], ["sm", $CFM_SMALLCAPS, $CFE_SMALLCAPS],  ["st", $CFM_STRIKEOUT, $CFE_STRIKEOUT], ["sb", $CFM_SUBSCRIPT, $CFE_SUBSCRIPT],  ["sp", $CFM_SUPERSCRIPT, $CFE_SUPERSCRIPT], ["un", $CFM_UNDERLINE, $CFE_UNDERLINE],  ["al", $CFM_ALLCAPS, $CFE_ALLCAPS]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $bSel = _GUICtrlRichEdit_IsTextSelected($hWnd)
If Not $bSel Then Return SetError(-1, 0, "")
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
Local $iMask = _SendMessage($hWnd, $EM_GETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $sStatesAndAtts = "", $sState, $bM, $bE
For $i = 0 To UBound($aV, $UBOUND_ROWS) - 1
$bM = BitAND($iMask, $aV[$i][1]) = $aV[$i][1]
$bE = BitAND($iEffects, $aV[$i][2]) = $aV[$i][2]
If $bSel Then
If $bM Then
If $bE Then
$sState = "+"
Else
$sState = "-"
EndIf
Else
$sState = "~"
EndIf
Else
If $bM Then
$sState = "+"
Else
$sState = "-"
EndIf
EndIf
If $sState <> "-" Then $sStatesAndAtts &= $aV[$i][0] & $sState
Next
Return $sStatesAndAtts
EndFunc
Func _GUICtrlRichEdit_GetCharBkColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $iBkColor
If BitAND($iEffects, $CFE_AUTOBACKCOLOR) = $CFE_AUTOBACKCOLOR Then
$iBkColor = _WinAPI_GetSysColor($__RICHEDITCONSTANT_COLOR_WINDOWTEXT)
Else
$iBkColor = DllStructGetData($tCharFormat, 12)
EndIf
Return SetExtended(BitAND($iEffects, $CFM_BACKCOLOR) <> 0, $iBkColor)
EndFunc
Func _GUICtrlRichEdit_GetCharColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $iColor
If BitAND($iEffects, $CFE_AUTOCOLOR) = $CFE_AUTOCOLOR Then
$iColor = _WinAPI_GetSysColor($__RICHEDITCONSTANT_COLOR_WINDOWTEXT)
Else
$iColor = DllStructGetData($tCharFormat, 6)
EndIf
Return SetExtended(BitAND($iEffects, $CFM_COLOR) <> 0, $iColor)
EndFunc
Func _GUICtrlRichEdit_GetCharPosFromXY($hWnd, $iX, $iY)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iX) Then Return SetError(102, 0, 0)
If Not __GCR_IsNumeric($iY) Then Return SetError(103, 0, 0)
Local $aiRect = _GUICtrlRichEdit_GetRECT($hWnd)
If $iX < $aiRect[0] Or $iX > $aiRect[2] Or $iY < $aiRect[1] Or $iY > $aiRect[3] Then Return -1
Local $tPointL = DllStructCreate("LONG x; LONG y;")
DllStructSetData($tPointL, 1, $iX)
DllStructSetData($tPointL, 2, $iY)
Local $iRet = _SendMessage($hWnd, $EM_CHARFROMPOS, 0, $tPointL, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(-1, 0, 0)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetCharPosOfNextWord($hWnd, $iCpStart)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCpStart) Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_MOVEWORDRIGHT, $iCpStart)
EndFunc
Func _GUICtrlRichEdit_GetCharPosOfPreviousWord($hWnd, $iCpStart)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCpStart) Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_MOVEWORDLEFT, $iCpStart)
EndFunc
Func _GUICtrlRichEdit_GetCharWordBreakInfo($hWnd, $iCp)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not __GCR_IsNumeric($iCp) Then Return SetError(102, 0, "")
Local $iRet = _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_CLASSIFY, $iCp)
Local $iClass = BitAND($iRet, 0xF0)
Local $sRet = ""
If BitAND($iClass, $WBF_BREAKAFTER) Then $sRet &= "c"
If BitAND($iClass, $WBF_BREAKLINE) Then $sRet &= "d"
If BitAND($iClass, $WBF_ISWHITE) Then $sRet &= "w"
$sRet &= ";" & BitAND($iRet, 0xF)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetBkColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $iBkColor = _SendMessage($hWnd, $EM_SETBKGNDCOLOR, False, 0)
_SendMessage($hWnd, $EM_SETBKGNDCOLOR, False, $iBkColor)
Return $iBkColor
EndFunc
Func _GUICtrlRichEdit_GetText($hWnd, $bCrToCrLf = False, $iCodePage = 0, $sReplChar = "")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bCrToCrLf) Then Return SetError(102, 0, "")
If Not __GCR_IsNumeric($iCodePage) Then Return SetError(103, 0, "")
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd, False, True) + 1
Local $sUni = ''
If $iCodePage = $CP_UNICODE Or Not $iCodePage Then $sUni = "w"
Local $tText = DllStructCreate($sUni & "char[" & $iLen & "]")
Local $tGetTextEx = DllStructCreate($tagGETTEXTEX)
DllStructSetData($tGetTextEx, "cb", DllStructGetSize($tText))
Local $iFlags = 0
If $bCrToCrLf Then $iFlags = $GT_USECRLF
DllStructSetData($tGetTextEx, "flags", $iFlags)
If $iCodePage = 0 Then $iCodePage = $CP_UNICODE
DllStructSetData($tGetTextEx, "codepage", $iCodePage)
Local $pUsedDefChar = 0, $pDefaultChar = 0
If $sReplChar <> "" Then
Local $tDefaultChar = DllStructCreate("char")
$pDefaultChar = DllStructGetPtr($tDefaultChar, 1)
DllStructSetData($tDefaultChar, 1, $sReplChar)
Local $tUsedDefChar = DllStructCreate("bool")
$pUsedDefChar = DllStructGetPtr($tUsedDefChar, 1)
EndIf
DllStructSetData($tGetTextEx, "lpDefaultChar", $pDefaultChar)
DllStructSetData($tGetTextEx, "lpbUsedDefChar", $pUsedDefChar)
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTEX, $tGetTextEx, $tText, 0, "struct*", "struct*")
If $iRet = 0 Then Return SetError(700, 0, "")
If $sReplChar <> "" Then SetExtended(DllStructGetData($tUsedDefChar, 1) <> 0)
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetTextLength($hWnd, $bExact = True, $bChars = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not IsBool($bExact) Then Return SetError(102, 0, 0)
If Not IsBool($bChars) Then Return SetError(103, 0, 0)
Local $tGetTextLen = DllStructCreate($tagGETTEXTLENGTHEX)
Local $iFlags = BitOR($GTL_USECRLF, ($bExact ? $GTL_PRECISE : $GTL_CLOSE))
$iFlags = BitOR($iFlags, ($bChars ? $GTL_DEFAULT : $GTL_NUMBYTES))
DllStructSetData($tGetTextLen, 1, $iFlags)
DllStructSetData($tGetTextLen, 2, ($bChars ? $CP_ACP : $CP_UNICODE))
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTLENGTHEX, $tGetTextLen, 0, 0, "struct*")
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetZoom($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $wParam = 0, $lParam = 0
Local $aI = _SendMessage($hWnd, $EM_GETZOOM, $wParam, $lParam, -1, "int*", "int*")
If Not $aI[0] Then Return SetError(700, 0, 0)
Local $iRet
If $aI[3] = 0 And $aI[4] = 0 Then
$iRet = 100
Else
$iRet = $aI[3] / $aI[4] * 100
EndIf
Return StringFormat("%.2f", $iRet)
EndFunc
Func _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd, $iLine = -1)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(1021, 0, 0)
If $iLine <> -1 Then $iLine -= 1
Local $iRet = _SendMessage($hWnd, $EM_LINEINDEX, $iLine)
If $iRet = -1 Then Return SetError(1022, 0, 0)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetFont($hWnd)
Local $aRet[3] = [0, "", 0]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, "cbSize", DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_FACE) = $CFM_FACE Then  $aRet[1] = DllStructGetData($tCharFormat, "szFaceName")
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_SIZE) = $CFM_SIZE Then  $aRet[0] = DllStructGetData($tCharFormat, "yHeight") / 20
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_CHARSET) = $CFM_CHARSET Then  $aRet[2] = DllStructGetData($tCharFormat, "bCharSet")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetRECT($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $EM_GETRECT, 0, $tRECT, 0, "wparam", "struct*")
Local $aiRect[4]
$aiRect[0] = DllStructGetData($tRECT, "Left")
$aiRect[1] = DllStructGetData($tRECT, "Top")
$aiRect[2] = DllStructGetData($tRECT, "Right")
$aiRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aiRect
EndFunc
Func _GUICtrlRichEdit_GetLineCount($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Return _SendMessage($hWnd, $EM_GETLINECOUNT)
EndFunc
Func _GUICtrlRichEdit_GetLineLength($hWnd, $iLine)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(102, 0, 0)
Local $iCharPos = _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd, $iLine)
Local $iRet = _SendMessage($hWnd, $EM_LINELENGTH, $iCharPos)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetLineNumberFromCharPos($hWnd, $iCharPos)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCharPos, ">=0") Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_EXLINEFROMCHAR, 0, $iCharPos) + 1
EndFunc
Func _GUICtrlRichEdit_GetNextRedo($hWnd, $bName = True)
Local Const $aS[6] = ["Unknown", "Typing", "Delete", "Drag and drop", "Cut", "Paste"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bName) Then Return SetError(102, 0, "")
Local $iUid = _SendMessage($hWnd, $EM_GETREDONAME, 0, 0)
If $bName Then
Return $aS[$iUid]
Else
Return $iUid
EndIf
EndFunc
Func _GUICtrlRichEdit_GetNextUndo($hWnd, $bName = True)
Local Const $aS[6] = ["Unknown", "Typing", "Delete", "Drag and drop", "Cut", "Paste"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bName) Then Return SetError(102, 0, "")
Local $iUid = _SendMessage($hWnd, $EM_GETUNDONAME, 0, 0)
If $bName Then
Return $aS[$iUid]
Else
Return $iUid
EndIf
EndFunc
Func _GUICtrlRichEdit_GetNumberOfFirstVisibleLine($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Return _SendMessage($hWnd, $EM_GETFIRSTVISIBLELINE) + 1
EndFunc
Func _GUICtrlRichEdit_GetParaAlignment($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, 2)
Local $iAlignment = DllStructGetData($tParaFormat, 8)
Local $sRet = ""
Switch ($iAlignment)
Case $PFA_LEFT
$sRet = "l"
Case $PFA_CENTER
$sRet = "c"
Case $PFA_RIGHT
$sRet = "r"
Case $PFA_JUSTIFY
$sRet = "j"
Case $PFA_FULL_INTERWORD
$sRet = "w"
EndSwitch
$sRet &= ";" & __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_ALIGNMENT)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaAttributes($hWnd)
Local Enum $eAbbrev = 0, $eEffect, $eInverted
Local Const $aV[9][3] = [  ["fpg", $PFE_PAGEBREAKBEFORE, False],  ["hyp", $PFE_DONOTHYPHEN, True],  ["kpt", $PFE_KEEP, False],  ["kpn", $PFE_KEEPNEXT, False],  ["pwo", $PFE_NOWIDOWCONTROL, False],  ["r2l", $PFE_RTLPARA, False],  ["row", $PFE_TABLE, False],  ["sbs", $PFE_SIDEBYSIDE, False],  ["sln", $PFE_NOLINENUMBER, False]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iEffects = DllStructGetData($tParaFormat, "wEffects")
Local $sStatesAndAtts = "", $sState
For $i = 0 To UBound($aV, $UBOUND_ROWS) - 1
$sStatesAndAtts &= $aV[$i][$eAbbrev]
If BitAND($iEffects, $aV[$i][$eEffect]) = $aV[$i][$eEffect] Then
$sState = ($aV[$i][$eInverted] ? "-" : "+")
Else
$sState = ($aV[$i][$eInverted] ? "+" : "-")
EndIf
$sStatesAndAtts &= $sState & ";"
Next
$sStatesAndAtts &= (_GUICtrlRichEdit_IsTextSelected($hWnd) ? "f" : "c")
Return $sStatesAndAtts
EndFunc
Func _GUICtrlRichEdit_GetParaBorder($hWnd)
Local Const $avLocs[6][2] = [["l", 1], ["r", 2], ["t", 4], ["b", 8], ["i", 16], ["o", 32]]
Local Const $avLS[12] = ["none", .75, 1.5, 2.25, 3, 4.5, 6, ".75d", "1.5d", "2.25d", ".75g", ".75gd"]
Local Const $sClrs = "blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, 2)
Local $iSpace = DllStructGetData($tParaFormat, 22)
Local $iBorders = DllStructGetData($tParaFormat, 24)
Local $sRet = ""
For $i = 0 To UBound($avLocs, $UBOUND_ROWS) - 1
If BitAND($iBorders, $avLocs[$i][1]) Then $sRet &= $avLocs[$i][0]
Next
$sRet &= ";"
$sRet &= $avLS[BitShift(BitAND($iBorders, 0xF00), 8)]
$sRet &= ";"
If BitAND($iBorders, 64) Then
$sRet &= "aut"
Else
$sRet &= StringMid($sClrs, BitShift(BitAND($iBorders, 0xF000), 12) * 4 + 1, 3)
EndIf
$sRet &= ";"
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iSpace) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_BORDER)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaIndents($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "dwMask", BitOR($PFM_STARTINDENT, $PFM_OFFSET))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iIdxSI = DllStructGetData($tParaFormat, "dxStartIndent")
Local $iIdxOfs = DllStructGetData($tParaFormat, "dxOffset")
Local $iDxRI = DllStructGetData($tParaFormat, "dxRightIndent")
Local $iLeft = __GCR_ConvertTwipsToSpaceUnit($iIdxSI + $iIdxOfs)
Local $iFirstLine = __GCR_ConvertTwipsToSpaceUnit(-$iIdxOfs)
Local $iRight = __GCR_ConvertTwipsToSpaceUnit($iDxRI)
Local $iRet = $iLeft & ";" & $iRight & ";" & $iFirstLine & ";" & __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_STARTINDENT)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetParaNumbering($hWnd)
Local Const $avRoman[7][2] = [[1000, "m"], [500, "d"], [100, "c"], [50, "l"], [10, "x"], [5, "v"], [1, "i"]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, BitOR($PFM_NUMBERING, $PFM_NUMBERINGSTART, $PFM_NUMBERINGSTYLE))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iChar = DllStructGetData($tParaFormat, "wNumbering")
Local $iStart = DllStructGetData($tParaFormat, "wNumberingStart")
Local $iStyle = DllStructGetData($tParaFormat, "wNumberingStyle")
Local $iTab = DllStructGetData($tParaFormat, "wNumberingTab")
Local $sRet = ""
Switch $iChar
Case 0
$sRet = ""
Case 1
$sRet = "."
Case 2
$sRet = $iStart
Case 3
$sRet = Chr(Asc("a") + $iStart - 1)
Case 4
$sRet = Chr(Asc("a") + $iStart - 1)
Case 5, 6
For $i = 0 To UBound($avRoman, $UBOUND_ROWS) - 2 Step 2
For $j = $i To $i + 1
While $iStart >= $avRoman[$j][0]
$sRet &= $avRoman[$j][1]
$iStart -= $avRoman[$j][0]
WEnd
If $iStart = $avRoman[$j][0] - 1 Then
$sRet &= $avRoman[$i + 2][1] & $avRoman[$j][1]
$iStart -= $avRoman[$j][0] - $avRoman[$i + 2][0]
EndIf
Next
Next
While $iStart > 0
$sRet &= "i"
$iStart -= 1
WEnd
If $iChar = 6 Then $sRet = StringUpper($sRet)
EndSwitch
If $iChar > 1 Then
Switch $iStyle
Case 0
$sRet &= ")"
Case 0x100
$sRet = "(" & $sRet & ")"
Case 0x200
$sRet &= "."
Case 0x300
EndSwitch
EndIf
Local $aV = _GUICtrlRichEdit_GetFont($hWnd)
Local $iPoints = $aV[0]
Local $iQspaces = Round($iTab / ($iPoints * 20), 0)
For $i = 1 To $iQspaces
$sRet &= " "
Next
$sRet &= ";"
$sRet &= (($iChar = 5 Or $iChar = 6) ? "Roman;" : ";")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iTab) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, BitOR($PFM_NUMBERING, $PFM_NUMBERINGSTART, $PFM_NUMBERINGSTYLE))
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaShading($hWnd)
Local Const $asStyles[13] = ["non", "dhz", "dvt", "ddd", "dud", "dgr", "dtr", "lhz", "lrt", "ldd", "lud",  "lgr", "ltr"]
Local Const $asClrs[16] = ["blk", "blu", "cyn", "grn", "mag", "red", "yel", "whi", "dbl", "dgn", "dmg",  "drd", "dyl", "dgy", "lgy"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iWeight = DllStructGetData($tParaFormat, "wShadingWeight")
Local $iS = DllStructGetData($tParaFormat, "wShadingStyle")
Local $sRet = $iWeight & ";"
Local $iN = BitAND($iS, 0xF)
$sRet &= $asStyles[$iN] & ";"
$iN = BitShift(BitAND($iS, 0xF0), 4)
$sRet &= $asClrs[$iN] & ";"
$iN = BitShift(BitAND($iS, 0xF00), 8)
$sRet &= $asClrs[$iN] & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SHADING)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaSpacing($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iInter = DllStructGetData($tParaFormat, "dyLineSpacing")
Local $iRule = DllStructGetData($tParaFormat, "bLineSpacingRule")
Local $sRet = ""
Switch $iRule
Case 0
$sRet = "1 line;"
Case 1
$sRet = "1.5 lines;"
Case 2
$sRet = "2 lines;"
Case 3, 4
$sRet = __GCR_ConvertTwipsToSpaceUnit($iInter) & ";"
Case 5
$sRet = StringFormat("%.2f", $iInter / 20) & " lines;"
EndSwitch
Local $iMask = 0
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_LINESPACING) & ";"
Local $iBefore = DllStructGetData($tParaFormat, "dySpaceBefore")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iBefore) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SPACEBEFORE) & ";"
Local $iAfter = DllStructGetData($tParaFormat, "dySPaceAfter")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iAfter) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SPACEAFTER)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaTabStops($hWnd)
Local Const $asKind[5] = ["l", "c", "r", "d", "b"], $asLeader[6] = [" ", ".", "-", "_", "t", "="]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iQtabs = DllStructGetData($tParaFormat, "cTabCount")
Local $sRet = $iQtabs & ";"
Local $iN, $iM
For $i = 1 To $iQtabs
$iN = DllStructGetData($tParaFormat, "rgxTabs", $i)
$sRet &= __GCR_ConvertTwipsToSpaceUnit(BitAND($iN, 0xFFFFF))
$iM = BitAND(BitShift($iN, 24), 0xF)
$sRet &= $asKind[$iM]
$iM = BitAND(BitShift($iN, 28), 0xF)
$sRet &= $asLeader[$iM] & ";"
Next
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_TABSTOPS)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetPasswordChar($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $n = _SendMessage($hWnd, $EM_GETPASSWORDCHAR)
Return ($n = 0) ? "" : Chr($n)
EndFunc
Func _GUICtrlRichEdit_GetScrollPos($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tPoint = DllStructCreate($tagPOINT)
_SendMessage($hWnd, $EM_GETSCROLLPOS, 0, $tPoint, 0, "wparam", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tPoint, "x")
$aRet[1] = DllStructGetData($tPoint, "y")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSel($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharRange = DllStructCreate($tagCHARRANGE)
_SendMessage($hWnd, $EM_EXGETSEL, 0, $tCharRange, 0, "wparam", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tCharRange, 1)
$aRet[1] = DllStructGetData($tCharRange, 2)
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSelAA($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $aiLowHigh = _GUICtrlRichEdit_GetSel($hWnd)
If $aiLowHigh[0] = $aiLowHigh[1] Then Return SetError(-1, 0, 0)
_SendMessage($hWnd, $EM_SETSEL, -1, 0)
Local $aiNoSel = _GUICtrlRichEdit_GetSel($hWnd)
Local $aRet[2]
If $aiLowHigh[0] = $aiNoSel[0] Then
$aRet[0] = $aiLowHigh[1]
$aRet[1] = $aiLowHigh[0]
Else
$aRet = $aiLowHigh
EndIf
_SendMessage($hWnd, $EM_SETSEL, $aiLowHigh[0], $aiLowHigh[1])
_WinAPI_SetFocus($hWnd)
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSelText($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, -1)
Local $aiLowHigh = _GUICtrlRichEdit_GetSel($hWnd)
Local $tText = DllStructCreate("wchar[" & $aiLowHigh[1] - $aiLowHigh[0] + 1 & "]")
_SendMessage($hWnd, $EM_GETSELTEXT, 0, $tText, 0, "wparam", "struct*")
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetSpaceUnit()
Switch $__g_iRTFTwipsPeSpaceUnit
Case 1440
Return "in"
Case 567
Return "cm"
Case 56.7
Return "mm"
Case 20
Return "pt"
Case 1
Return "tw"
EndSwitch
EndFunc
Func _GUICtrlRichEdit_GetTextInLine($hWnd, $iLine)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(1021, 0, False)
If $iLine > _GUICtrlRichEdit_GetLineCount($hWnd) Then Return SetError(1022, 0, False)
Local $iLen = _GUICtrlRichEdit_GetLineLength($hWnd, $iLine)
If $iLen = 0 Then Return ""
Local $tBuffer = DllStructCreate("short Len;wchar Text[" & $iLen + 2 & "]")
DllStructSetData($tBuffer, "Len", $iLen + 2)
If $iLine <> -1 Then $iLine -= 1
Local $iRet = _SendMessage($hWnd, $EM_GETLINE, $iLine, $tBuffer, 10, "wparam", "struct*")
If $iRet = 0 Then Return SetError(700, 0, False)
Local $tString = DllStructCreate("wchar Text[" & $iLen + 1 & "]", DllStructGetPtr($tBuffer))
Return StringLeft(DllStructGetData($tString, "Text"), $iLen)
EndFunc
Func _GUICtrlRichEdit_GetTextInRange($hWnd, $iStart, $iEnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iStart, ">=0") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iEnd, ">=0,-1") Then Return SetError(1031, 0, False)
If Not ($iEnd > $iStart Or $iEnd = -1) Then Return SetError(1032, 0, False)
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd)
Local $tText = DllStructCreate("wchar[" & ($iLen + 4) & "]")
Local $tTextRange = DllStructCreate($tagTEXTRANGE)
DllStructSetData($tTextRange, 1, $iStart)
DllStructSetData($tTextRange, 2, $iEnd)
DllStructSetData($tTextRange, 3, DllStructGetPtr($tText))
_SendMessage($hWnd, $EM_GETTEXTRANGE, 0, $tTextRange, 0, "wparam", "struct*")
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetVersion()
Return $__g_sRTFVersion
EndFunc
Func _GUICtrlRichEdit_GetXYFromCharPos($hWnd, $iCharPos)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCharPos, ">=0") Then Return SetError(1021, 0, 0)
If $iCharPos > _GUICtrlRichEdit_GetTextLength($hWnd) Then Return SetError(1022, 0, 0)
Local $tPoint = DllStructCreate($tagPOINT)
_SendMessage($hWnd, $EM_POSFROMCHAR, $tPoint, $iCharPos, 0, "struct*", "lparam")
Local $aRet[2]
$aRet[0] = DllStructGetData($tPoint, "X")
$aRet[1] = DllStructGetData($tPoint, "Y")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GotoCharPos($hWnd, $iCharPos)
_GUICtrlRichEdit_SetSel($hWnd, $iCharPos, $iCharPos)
If @error Then Return SetError(@error, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_HideSelection($hWnd, $bHide = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bHide) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_HIDESELECTION, $bHide, 0)
_WinAPI_SetFocus($hWnd)
EndFunc
Func _GUICtrlRichEdit_InsertText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If $sText = "" Then Return SetError(102, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
_GUICtrlRichEdit_Deselect($hWnd)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(103, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_IsModified($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_GETMODIFY) <> 0
EndFunc
Func _GUICtrlRichEdit_IsTextSelected($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharRange = DllStructCreate($tagCHARRANGE)
_SendMessage($hWnd, $EM_EXGETSEL, 0, $tCharRange, 0, "wparam", "struct*")
Return DllStructGetData($tCharRange, 2) <> DllStructGetData($tCharRange, 1)
EndFunc
Func _GUICtrlRichEdit_Paste($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_PASTE, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_PasteSpecial($hWnd, $bAndObjects = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iN = ($bAndObjects ? $__g_sGRE_CF_RETEXTOBJ : $__g_sGRE_CF_RTF)
_SendMessage($hWnd, $EM_PASTESPECIAL, $iN, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_PauseRedraw($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_SETREDRAW, False)
EndFunc
Func _GUICtrlRichEdit_Redo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_REDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_ReplaceText($hWnd, $sText, $bCanUndo = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bCanUndo) Then Return SetError(103, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, False)
Local $tText = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tText, "Text", $sText)
If _WinAPI_InProcess($hWnd, $__g_hRELastWnd) Then
_SendMessage($hWnd, $EM_REPLACESEL, $bCanUndo, $tText, 0, "wparam", "struct*")
Else
Local $iText = DllStructGetSize($tText)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iText, $tMemMap)
_MemWrite($tMemMap, $tText)
_SendMessage($hWnd, $EM_REPLACESEL, $bCanUndo, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_ResumeRedraw($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_SETREDRAW, True)
Return _WinAPI_InvalidateRect($hWnd)
EndFunc
Func _GUICtrlRichEdit_ScrollLineOrPage($hWnd, $sAction)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If StringLen($sAction) <> 2 Then Return SetError(1021, 0, 0)
Local $sCh = StringLeft($sAction, 1)
If Not ($sCh = "l" Or $sCh = "p") Then Return SetError(1022, 0, 0)
$sCh = StringRight($sAction, 1)
If Not ($sCh = "d" Or $sCh = "u") Then Return SetError(1023, 0, 0)
Local $wParam = 0
Switch $sAction
Case "ld"
$wParam = $__RICHEDITCONSTANT_SB_LINEDOWN
Case "lu"
$wParam = $__RICHEDITCONSTANT_SB_LINEUP
Case "pd"
$wParam = $__RICHEDITCONSTANT_SB_PAGEDOWN
Case "pu"
$wParam = $__RICHEDITCONSTANT_SB_PAGEUP
EndSwitch
Local $iRet = _SendMessage($hWnd, $EM_SCROLL, $wParam, 0)
$iRet = BitAND($iRet, 0xFFFF)
If BitAND($iRet, 0x8000) <> 0 Then $iRet = BitOR($iRet, 0xFFFF0000)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_ScrollLines($hWnd, $iQlines)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iQlines) Then SetError(102, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_LINESCROLL, 0, $iQlines)
If $iRet = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_ScrollToCaret($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_SCROLLCARET, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_SetCharAttributes($hWnd, $sStatesAndEffects, $bWord = False)
Local Const $aV[17][3] = [  ["bo", $CFM_BOLD, $CFE_BOLD], ["di", $CFM_DISABLED, $CFE_DISABLED],  ["em", $CFM_EMBOSS, $CFE_EMBOSS], ["hi", $CFM_HIDDEN, $CFE_HIDDEN],  ["im", $CFM_IMPRINT, $CFE_IMPRINT], ["it", $CFM_ITALIC, $CFE_ITALIC],  ["li", $CFM_LINK, $CFE_LINK], ["ou", $CFM_OUTLINE, $CFE_OUTLINE],  ["pr", $CFM_PROTECTED, $CFE_PROTECTED], ["re", $CFM_REVISED, $CFE_REVISED],  ["sh", $CFM_SHADOW, $CFE_SHADOW], ["sm", $CFM_SMALLCAPS, $CFE_SMALLCAPS],  ["st", $CFM_STRIKEOUT, $CFE_STRIKEOUT], ["sb", $CFM_SUBSCRIPT, $CFE_SUBSCRIPT],  ["sp", $CFM_SUPERSCRIPT, $CFE_SUPERSCRIPT], ["un", $CFM_UNDERLINE, $CFE_UNDERLINE],  ["al", $CFM_ALLCAPS, $CFE_ALLCAPS]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bWord) Then Return SetError(103, 0, False)
Local $iMask = 0, $iEffects = 0, $n, $s
For $i = 1 To StringLen($sStatesAndEffects) Step 3
$s = StringMid($sStatesAndEffects, $i + 1, 2)
$n = -1
For $j = 0 To UBound($aV) - 1
If $aV[$j][0] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(1023, $s, False)
$iMask = BitOR($iMask, $aV[$n][1])
$s = StringMid($sStatesAndEffects, $i, 1)
Switch $s
Case "+"
$iEffects = BitOR($iEffects, $aV[$n][2])
Case "-"
Case Else
Return SetError(1022, $s, False)
EndSwitch
Next
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
DllStructSetData($tCharFormat, 2, $iMask)
DllStructSetData($tCharFormat, 3, $iEffects)
Local $wParam = ($bWord ? BitOR($SCF_WORD, $SCF_SELECTION) : $SCF_SELECTION)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $wParam, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetCharBkColor($hWnd, $iBkColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iBkColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOBACKCOLOR)
$iBkColor = 0
Else
If BitAND($iBkColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_BACKCOLOR)
DllStructSetData($tCharFormat, 12, $iBkColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetCharColor($hWnd, $iColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOCOLOR)
$iColor = 0
Else
If BitAND($iColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_COLOR)
DllStructSetData($tCharFormat, 6, $iColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetBkColor($hWnd, $iBngColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $bSysColor = False
If $iBngColor = Default Then
$bSysColor = True
$iBngColor = 0
Else
If BitAND($iBngColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
_SendMessage($hWnd, $EM_SETBKGNDCOLOR, $bSysColor, $iBngColor)
Return True
EndFunc
Func _GUICtrlRichEdit_SetLimitOnText($hWnd, $iNewLimit)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iNewLimit, ">=0") Then Return SetError(102, 0, False)
If $iNewLimit < 65535 Then $iNewLimit = 0
_SendMessage($hWnd, $EM_EXLIMITTEXT, 0, $iNewLimit)
Return True
EndFunc
Func _GUICtrlRichEdit_SetTabStops($hWnd, $vTabStops, $bRedraw = True)
Local Const $iTwipsPerDU = 18.75
Local $tTabStops, $tagTabStops = "", $wParam
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bRedraw) Then Return SetError(103, 0, False)
If IsString($vTabStops) Then
If $vTabStops = "" Then Return SetError(1023, 0, False)
Local $aS = StringSplit($vTabStops, ";")
Local $iNumTabStops = $aS[0]
For $i = 1 To $iNumTabStops
If Not __GCR_IsNumeric($aS[$i], ">0") Then Return SetError(1022, 0, False)
$tagTabStops &= "int;"
Next
$tagTabStops = StringTrimRight($tagTabStops, 1)
$tTabStops = DllStructCreate($tagTabStops)
For $i = 1 To $iNumTabStops
DllStructSetData($tTabStops, $i, $aS[$i] * $__g_iRTFTwipsPeSpaceUnit / $iTwipsPerDU)
Next
$wParam = $iNumTabStops
ElseIf IsNumber($vTabStops) Then
If __GCR_IsNumeric($vTabStops, ">0") Then
$tTabStops = DllStructCreate("int")
DllStructSetData($tTabStops, 1, $vTabStops * $__g_iRTFTwipsPeSpaceUnit / $iTwipsPerDU)
$wParam = 1
Else
Return SetError(1024, 9, False)
EndIf
Else
Return SetError(1021, 0, False)
EndIf
Local $bResult = _SendMessage($hWnd, $EM_SETTABSTOPS, $wParam, $tTabStops, 0, "wparam", "struct*") <> 0
If $bRedraw Then _WinAPI_InvalidateRect($hWnd)
Return $bResult
EndFunc
Func _GUICtrlRichEdit_SetZoom($hWnd, $iPercent)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iPercent, ">0") Then Return SetError(1021, 0, False)
Local $iNumerator, $iDenominator
Select
Case Not ($iPercent = 100 Or ($iPercent >= 200 And $iPercent < 6400))
Return SetError(1022, 0, False)
Case $iPercent >= 100
$iNumerator = 10000
$iDenominator = 10000 / ($iPercent / 100)
Case Else
$iNumerator = 10000 * ($iPercent / 100)
$iDenominator = 10000
EndSelect
Return _SendMessage($hWnd, $EM_SETZOOM, $iNumerator, $iDenominator) <> 0
EndFunc
Func _GUICtrlRichEdit_SetEventMask($hWnd, $iEventMask)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iEventMask) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_SETEVENTMASK, 0, $iEventMask)
Return True
EndFunc
Func _GUICtrlRichEdit_SetFont($hWnd, $iPoints = Default, $sName = Default, $iCharset = Default, $iLcid = Default)
Local $iDwMask = 0
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iPoints = Default Or __GCR_IsNumeric($iPoints, ">0")) Then Return SetError(102, 0, False)
If $sName <> Default Then
Local $aS = StringSplit($sName, " ")
For $i = 1 To UBound($aS) - 1
If Not StringIsAlpha($aS[$i]) Then Return SetError(103, 0, False)
Next
EndIf
If Not ($iCharset = Default Or __GCR_IsNumeric($iCharset)) Then Return SetError(104, 0, False)
If Not ($iLcid = Default Or __GCR_IsNumeric($iLcid)) Then Return SetError(105, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iPoints <> Default Then
$iDwMask = $CFM_SIZE
DllStructSetData($tCharFormat, 4, Int($iPoints * 20))
EndIf
If $sName <> Default Then
If StringLen($sName) > $LF_FACESIZE - 1 Then SetError(-1, 0, False)
$iDwMask = BitOR($iDwMask, $CFM_FACE)
DllStructSetData($tCharFormat, 9, $sName)
EndIf
If $iCharset <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_CHARSET)
DllStructSetData($tCharFormat, 7, $iCharset)
EndIf
If $iLcid <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_LCID)
DllStructSetData($tCharFormat, 13, $iLcid)
EndIf
DllStructSetData($tCharFormat, 2, $iDwMask)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(@error + 200, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetRECT($hWnd, $iLeft = Default, $iTop = Default, $iRight = Default, $iBottom = Default, $bRedraw = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iLeft = Default Or __GCR_IsNumeric($iLeft, ">0")) Then Return SetError(1021, 0, False)
If Not ($iTop = Default Or __GCR_IsNumeric($iTop, ">0")) Then Return SetError(1022, 0, False)
If Not ($iRight = Default Or __GCR_IsNumeric($iRight, ">0")) Then Return SetError(1023, 0, False)
If Not ($iBottom = Default Or __GCR_IsNumeric($iBottom, ">0")) Then Return SetError(1024, 0, False)
If @NumParams = 1 Then
Local $aPos = ControlGetPos($hWnd, "", "")
$iLeft = 2
$iTop = 2
$iRight = $aPos[2]
$iBottom = $aPos[3]
_GUICtrlRichEdit_SetRECT($hWnd, $iLeft, $iTop, $iRight, $iBottom)
Return True
Else
Local $aS = _GUICtrlRichEdit_GetRECT($hWnd)
If $iLeft = Default Then
$iLeft = $aS[0]
EndIf
If $iTop = Default Then
$iTop = $aS[1]
EndIf
If $iRight = Default Then
$iRight = $aS[2]
EndIf
If $iBottom = Default Then
$iBottom = $aS[3]
EndIf
If $iLeft >= $iRight Then Return SetError(1025, 0, False)
If $iTop >= $iBottom Then Return SetError(1026, 0, False)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", Number($iLeft))
DllStructSetData($tRECT, "Top", Number($iTop))
DllStructSetData($tRECT, "Right", Number($iRight))
DllStructSetData($tRECT, "Bottom", Number($iBottom))
Local $iMsg = ($bRedraw ? $EM_SETRECT : $EM_SETRECTNP)
_SendMessage($hWnd, $iMsg, 0, $tRECT, 0, "wparam", "struct*")
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_SetModified($hWnd, $bState = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_SETMODIFY, $bState)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaAlignment($hWnd, $sAlignment)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iAlignment
Switch $sAlignment
Case "l"
$iAlignment = $PFA_LEFT
Case "c"
$iAlignment = $PFA_CENTER
Case "r"
$iAlignment = $PFA_RIGHT
Case "j"
$iAlignment = $PFA_JUSTIFY
Case "w"
$iAlignment = $PFA_FULL_INTERWORD
Case Else
Return SetError(102, 0, False)
EndSwitch
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, $PFM_ALIGNMENT)
DllStructSetData($tParaFormat, 8, $iAlignment)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaAttributes($hWnd, $sStatesAndAtts)
Local Enum $eAbbrev = 0, $eMask, $eEffect, $eInverted
Local Const $aV[9][4] = [  ["fpg", $PFM_PAGEBREAKBEFORE, $PFE_PAGEBREAKBEFORE, False],  ["hyp", $PFM_DONOTHYPHEN, $PFE_DONOTHYPHEN, True],  ["kpt", $PFM_KEEP, $PFE_KEEP, False],  ["kpn", $PFM_KEEPNEXT, $PFE_KEEPNEXT, False],  ["pwo", $PFM_NOWIDOWCONTROL, $PFE_NOWIDOWCONTROL, False],  ["r2l", $PFM_RTLPARA, $PFE_RTLPARA, False],  ["row", $PFM_TABLE, $PFE_TABLE, False],  ["sbs", $PFM_SIDEBYSIDE, $PFE_SIDEBYSIDE, False],  ["sln", $PFM_NOLINENUMBER, $PFE_NOLINENUMBER, False]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Mod(StringLen($sStatesAndAtts) + 1, 5) <> 0 Then Return SetError(1023, 0, False)
Local $aS = StringSplit($sStatesAndAtts, ";")
Local $iMask = 0, $iEffects = 0, $s, $n
For $i = 1 To UBound($aS, $UBOUND_ROWS) - 1
$s = StringMid($aS[$i], 2)
$n = -1
For $j = 0 To UBound($aV, $UBOUND_ROWS) - 1
If $aV[$j][$eAbbrev] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(1022, $s, False)
$iMask = BitOR($iMask, $aV[$n][$eMask])
$s = StringLeft($aS[$i], 1)
Switch $s
Case "+"
If Not $aV[$n][$eInverted] Then
$iEffects = BitOR($iEffects, $aV[$n][$eEffect])
EndIf
Case "-"
If $aV[$n][$eInverted] Then
$iEffects = BitOR($iEffects, $aV[$n][$eEffect])
EndIf
Case Else
Return SetError(1021, $s, False)
EndSwitch
Next
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, $iMask)
DllStructSetData($tParaFormat, 4, $iEffects)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaBorder($hWnd, $sLocation = Default, $vLineStyle = Default, $sColor = Default, $iSpace = Default)
Local $iBorders
Local Const $avLocs[6][2] = [["l", 1], ["r", 2], ["t", 4], ["b", 8], ["i", 16], ["o", 32]]
Local Const $avLS[12] = ["none", .75, 1.5, 2.25, 3, 4.5, 6, ".75d", "1.5d", "2.25d", ".75g", ".75gd"]
Local Const $sClrs = ";blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;aut;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iSpace = Default Or __GCR_IsNumeric($iSpace, ">=0")) Then Return SetError(105, 0, False)
If $sLocation = "" Then
$iBorders = 0
$iSpace = 0
Else
If $sLocation = Default Or $vLineStyle = Default Or $sColor = Default Or $iSpace = Default Then
Local $aS = StringSplit(_GUICtrlRichEdit_GetParaBorder($hWnd), ";")
If $sLocation = Default Then $sLocation = $aS[1]
If $vLineStyle = Default Then $vLineStyle = $aS[2]
If $sColor = Default Then $sColor = $aS[3]
If $iSpace = Default Then $iSpace = $aS[4]
EndIf
Local $iLoc = 0, $n, $s
For $i = 1 To StringLen($sLocation)
$s = StringMid($sLocation, $i, 1)
$n = -1
For $j = 0 To UBound($avLocs, $UBOUND_ROWS) - 1
If $avLocs[$j][0] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(102, $s, False)
$iLoc = BitOR($iLoc, $avLocs[$n][1])
Next
$n = -1
For $i = 0 To UBound($avLS, $UBOUND_ROWS) - 1
If $vLineStyle = $avLS[$i] Then
$n = $i
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(103, 0, False)
Local $iLineStyle = $n
$n = StringInStr($sClrs, ";" & $sColor & ";")
If $n = 0 Then Return SetError(104, 0, False)
Local $iColor = Int($n / 4)
If $iColor = 16 Then
$iLoc = BitOR($iLoc, 64)
$iColor = 0
EndIf
$iBorders = $iLoc + BitShift($iLineStyle, -8) + BitShift($iColor, -12)
EndIf
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "wBorderSpace", $iSpace * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "wBorders", $iBorders)
DllStructSetData($tParaFormat, "dwMask", $PFM_BORDER)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaIndents($hWnd, $vLeft = Default, $iRight = Default, $iFirstLine = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($vLeft = Default Or __GCR_IsNumeric($vLeft)) Then Return SetError(1021, 0, False)
If Not ($iRight = Default Or __GCR_IsNumeric($iRight, ">=0")) Then Return SetError(103, 0, False)
If Not ($iFirstLine = Default Or __GCR_IsNumeric($iFirstLine)) Then Return SetError(104, 0, False)
Local $s = _GUICtrlRichEdit_GetParaIndents($hWnd)
Local $aS = StringSplit($s, ";")
If $vLeft = Default Then $vLeft = $aS[1]
If $iRight = Default Then $iRight = $aS[2]
If $iFirstLine = Default Then $iFirstLine = $aS[3]
If $vLeft < 0 Then Return SetError(1022, 0, False)
If $vLeft + $iFirstLine < 0 Then Return SetError(200, 0, False)
If StringInStr("+-", StringLeft($vLeft, 1)) <> 0 Then $vLeft = $aS[1] + $vLeft
Local $iIdxSI = $vLeft + $iFirstLine
Local $iIdxOfs = -$iFirstLine
Local $tParaFormat = DllStructCreate($tagPARAFORMAT)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "dxStartIndent", $iIdxSI * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "dxOffset", $iIdxOfs * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "dxRightIndent", $iRight * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, 2, BitOR($PFM_STARTINDENT, $PFM_OFFSET, $PFM_RIGHTINDENT))
Local $iRet = _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaNumbering($hWnd, $sStyle, $iTextToNbrSpace = Default, $bForceRoman = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iTextToNbrSpace = Default Or __GCR_IsNumeric($iTextToNbrSpace, ">0")) Then Return SetError(103, 0, False)
If Not IsBool($bForceRoman) Then Return SetError(104, 0, False)
Local $iPFM, $iWNumbering, $iWnumStart, $iWnumStyle, $iQspaces
__GCR_ParseParaNumberingStyle($sStyle, $bForceRoman, $iPFM, $iWNumbering, $iWnumStart, $iWnumStyle, $iQspaces)
If @error Then Return SetError(@error, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
If BitAND($iPFM, $PFM_NUMBERING) Then DllStructSetData($tParaFormat, 3, $iWNumbering)
If BitAND($iPFM, $PFM_NUMBERINGSTART) Then DllStructSetData($tParaFormat, 19, $iWnumStart)
If BitAND($iPFM, $PFM_NUMBERINGSTYLE) Then DllStructSetData($tParaFormat, 20, $iWnumStyle)
If BitAND($iPFM, $PFM_NUMBERINGTAB) Then
Local $iTwips
If $iTextToNbrSpace = Default Then
Local $aV = _GUICtrlRichEdit_GetFont($hWnd)
Local $iPoints = $aV[0]
$iTwips = $iQspaces * $iPoints * 20
Else
$iTwips = $iTextToNbrSpace * $__g_iRTFTwipsPeSpaceUnit
EndIf
DllStructSetData($tParaFormat, 21, $iTwips)
EndIf
DllStructSetData($tParaFormat, 2, $iPFM)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaShading($hWnd, $iWeight = Default, $sStyle = Default, $sForeColor = Default, $sBackColor = Default)
Local $iS = 0
Local Const $sStyles = ";non;dhz;dvt;ddd;dud;dgr;dtr;lhz;lrt;ldd;lud;lgr;ltr;"
Local Const $sClrs = ";blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iWeight = Default Or __GCR_IsNumeric($iWeight, ">=0")) Then Return SetError(1021, 0, False)
If $iWeight <> Default Or $sStyle <> Default Or $sForeColor <> Default Or $sBackColor <> Default Then
Local $aS = StringSplit(_GUICtrlRichEdit_GetParaShading($hWnd), ";")
If $iWeight = Default Then $iWeight = $aS[1]
If $sStyle = Default Then $sStyle = $aS[2]
If $sForeColor = Default Then $sForeColor = $aS[3]
If $sBackColor = Default Then $sBackColor = $aS[4]
EndIf
If $iWeight < 0 Or $iWeight > 100 Then Return SetError(1022, 0, False)
Local $iN = StringInStr($sStyles, ";" & $sStyle & ";")
If $iN = 0 Then Return SetError(103, 0, False)
Local $iStyle = Int($iN / 4)
Local $iFore = BitShift(BitAND($iS, 0xF0), 4)
$iN = StringInStr($sClrs, ";" & $sForeColor & ";")
If $iN = 0 Then Return SetError(104, 0, False)
$iFore = Int($iN / 4)
$iN = StringInStr($sClrs, ";" & $sBackColor & ";")
If $iN = 0 Then Return SetError(105, 0, False)
Local $iBack = Int($iN / 4)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "wShadingWeight", $iWeight)
$iN = $iStyle + BitShift($iFore, -4) + BitShift($iBack, -8)
DllStructSetData($tParaFormat, "wShadingStyle", $iN)
DllStructSetData($tParaFormat, "dwMask", $PFM_SHADING)
Local $iRet = _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaSpacing($hWnd, $vInter = Default, $iBefore = Default, $iAfter = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iBefore = Default Or __GCR_IsNumeric($iBefore, ">=0")) Then Return SetError(103, 0, False)
If Not ($iAfter = Default Or __GCR_IsNumeric($iAfter, ">=0")) Then Return SetError(104, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
Local $iMask = 0
If $vInter <> Default Then
$vInter = StringStripWS($vInter, $STR_STRIPALL)
Local $iP = StringInStr($vInter, "line", $STR_NOCASESENSEBASIC)
If $iP <> 0 Then
$vInter = StringLeft($vInter, $iP - 1)
EndIf
If Not __GCR_IsNumeric($vInter, ">=0") Then Return SetError(1021, 0, False)
Local $iRule, $iLnSp = 0
If $iP <> 0 Then
Switch $vInter
Case 1
$iRule = 0
Case 1.5
$iRule = 1
Case 2
$iRule = 2
Case Else
If $vInter < 1 Then Return SetError(1022, 0, False)
$iRule = 5
$iLnSp = $vInter * 20
EndSwitch
Else
$iRule = 4
$iLnSp = $vInter * $__g_iRTFTwipsPeSpaceUnit
EndIf
$iMask = $PFM_LINESPACING
DllStructSetData($tParaFormat, "bLineSpacingRule", $iRule)
If $iLnSp <> 0 Then DllStructSetData($tParaFormat, 13, $iLnSp)
EndIf
If $iBefore <> Default Then
$iMask = BitOR($iMask, $PFM_SPACEBEFORE)
DllStructSetData($tParaFormat, "dySpaceBefore", $iBefore * $__g_iRTFTwipsPeSpaceUnit)
EndIf
If $iAfter <> Default Then
$iMask = BitOR($iMask, $PFM_SPACEAFTER)
DllStructSetData($tParaFormat, "dySpaceAfter", $iAfter * $__g_iRTFTwipsPeSpaceUnit)
EndIf
If $iMask <> 0 Then
DllStructSetData($tParaFormat, "dwMask", $iMask)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
Else
Return True
EndIf
EndFunc
Func _GUICtrlRichEdit_SetParaTabStops($hWnd, $sTabStops)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
If $sTabStops = "" Then
DllStructSetData($tParaFormat, "cTabCount", 0)
Else
Local $asTabs = StringSplit($sTabStops, ";")
If $asTabs[0] > $MAX_TAB_STOPS Then Return SetError(1021, 0, False)
Local $asAtab, $i, $s, $iN, $iP
For $iTab = 1 To $asTabs[0]
$asAtab = StringSplit($asTabs[$iTab], "")
$i = 1
While $i <= $asAtab[0] And StringInStr("01234567890.", $asAtab[$i]) <> 0
$i += 1
WEnd
If $i = 1 Then Return SetError(1021, $iTab, False)
$s = StringLeft($asTabs[$iTab], $i - 1)
If Not __GCR_IsNumeric($s, ">=0") Then Return SetError(1021, $iTab, False)
$iN = $s * $__g_iRTFTwipsPeSpaceUnit
If $i <= $asAtab[0] Then
$iP = StringInStr("lcrdb", $asAtab[$i])
If $iP = 0 Then Return SetError(1022, $iTab, False)
$iN = BitOR($iN, BitShift($iP - 1, -24))
EndIf
$i += 1
If $i <= $asAtab[0] Then
$iP = StringInStr(" .-_t=", $asAtab[$i])
If $iP = 0 Then Return SetError(1023, $iTab, False)
$iN = BitOR($iN, BitShift($iP - 1, -28))
EndIf
DllStructSetData($tParaFormat, "rgxTabs", $iN, $iTab)
Next
DllStructSetData($tParaFormat, "cTabCount", $asTabs[0])
EndIf
DllStructSetData($tParaFormat, "dwMask", $PFM_TABSTOPS)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetPasswordChar($hWnd, $sDisplayChar = "*")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsString($sDisplayChar) Then SetError(102, 0, False)
If $sDisplayChar = "" Then
_SendMessage($hWnd, $EM_SETPASSWORDCHAR)
Else
_SendMessage($hWnd, $EM_SETPASSWORDCHAR, Asc($sDisplayChar))
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_SetReadOnly($hWnd, $bState = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_SETREADONLY, $bState)
If $iRet = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetScrollPos($hWnd, $iX, $iY)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iX, ">=0") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iY, ">=0") Then Return SetError(103, 0, False)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, 1, $iX)
DllStructSetData($tPoint, 2, $iY)
Return _SendMessage($hWnd, $EM_SETSCROLLPOS, 0, $tPoint, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetSel($hWnd, $iAnchor, $iActive, $bHideSel = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iAnchor, ">=0,-1") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iActive, ">=0,-1") Then Return SetError(103, 0, False)
If Not IsBool($bHideSel) Then Return SetError(104, 0, False)
_SendMessage($hWnd, $EM_SETSEL, $iAnchor, $iActive)
If $bHideSel Then _SendMessage($hWnd, $EM_HIDESELECTION, $bHideSel)
_WinAPI_SetFocus($hWnd)
Return True
EndFunc
Func _GUICtrlRichEdit_SetSpaceUnit($sUnit)
Switch StringLower($sUnit)
Case "in"
$__g_iRTFTwipsPeSpaceUnit = 1440
Case "cm"
$__g_iRTFTwipsPeSpaceUnit = 567
Case "mm"
$__g_iRTFTwipsPeSpaceUnit = 56.7
Case "pt"
$__g_iRTFTwipsPeSpaceUnit = 20
Case "tw"
$__g_iRTFTwipsPeSpaceUnit = 1
Case Else
Return SetError(1, 0, False)
EndSwitch
Return True
EndFunc
Func _GUICtrlRichEdit_SetText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_DEFAULT)
DllStructSetData($tSetText, 2, $CP_ACP)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetUndoLimit($hWnd, $iLimit)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iLimit, ">=0") Then Return SetError(102, 0, False)
Return _SendMessage($hWnd, $EM_SETUNDOLIMIT, $iLimit) <> 0 Or $iLimit = 0
EndFunc
Func _GUICtrlRichEdit_StreamFromFile($hWnd, $sFileSpec, $iFileEncoding = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamFromFileCallback))
If $iFileEncoding = Default Then $iFileEncoding = 0
Local $hFile = FileOpen($sFileSpec, $FO_READ + $iFileEncoding)
If $hFile = -1 Then Return SetError(1021, 0, False)
Local $sBuf = FileRead($hFile, 5)
FileClose($hFile)
$hFile = FileOpen($sFileSpec, $FO_READ + $iFileEncoding)
DllStructSetData($tEditStream, "dwCookie", $hFile)
Local $wParam = ($sBuf == "{\rtf" Or $sBuf == "{urtf") ? $SF_RTF : $SF_TEXT
$wParam = BitOR($wParam, $SFF_SELECTION)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
_GUICtrlRichEdit_SetText($hWnd, "")
EndIf
Local $iQchs = _SendMessage($hWnd, $EM_STREAMIN, $wParam, $tEditStream, 0, "wparam", "struct*")
FileClose($hFile)
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then Return SetError(700, $iError, False)
If $iQchs = 0 Then
If FileGetSize($sFileSpec) = 0 Then Return SetError(1022, 0, False)
Return SetError(700, $iError, False)
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_StreamFromVar($hWnd, $sVar)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamFromVarCallback))
$__g_pGRC_sStreamVar = $sVar
Local $s = StringLeft($sVar, 5)
Local $wParam = ($s == "{\rtf" Or $s == "{urtf") ? $SF_RTF : $SF_TEXT
$wParam = BitOR($wParam, $SFF_SELECTION)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
_GUICtrlRichEdit_SetText($hWnd, "")
EndIf
_SendMessage($hWnd, $EM_STREAMIN, $wParam, $tEditStream, 0, "wparam", "struct*")
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then Return SetError(700, $iError, False)
Return True
EndFunc
Func _GUICtrlRichEdit_StreamToFile($hWnd, $sFileSpec, $bIncludeCOM = True, $iOpts = 0, $iCodePage = 0, $iFileEncoding = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $wParam
If StringRight($sFileSpec, 4) = ".rtf" Then
$wParam = ($bIncludeCOM ? $SF_RTF : $SF_RTFNOOBJS)
Else
$wParam = ($bIncludeCOM ? $SF_TEXTIZED : $SF_TEXT)
If BitAND($iOpts, $SFF_PLAINRTF) Then Return SetError(1041, 0, False)
EndIf
If BitAND($iOpts, BitNOT(BitOR($SFF_PLAINRTF, $SF_UNICODE))) Then Return SetError(1042, 0, False)
If BitAND($iOpts, $SF_UNICODE) Then
If Not BitAND($wParam, $SF_TEXT) Then Return SetError(1043, 0, False)
EndIf
If _GUICtrlRichEdit_IsTextSelected($hWnd) Then $wParam = BitOR($wParam, $SFF_SELECTION)
$wParam = BitOR($wParam, $iOpts)
If $iCodePage <> 0 Then
$wParam = BitOR($wParam, $SF_USECODEPAGE, BitShift($iCodePage, -16))
EndIf
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamToFileCallback))
If $iFileEncoding = Default Then $iFileEncoding = 0
Local $hFile = FileOpen($sFileSpec, $FO_OVERWRITE + $iFileEncoding)
If $hFile = -1 Then Return SetError(102, 0, False)
DllStructSetData($tEditStream, "dwCookie", $hFile)
_SendMessage($hWnd, $EM_STREAMOUT, $wParam, $tEditStream, 0, "wparam", "struct*")
FileClose($hFile)
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then Return SetError(700, $iError, False)
Return True
EndFunc
Func _GUICtrlRichEdit_StreamToVar($hWnd, $bRtf = True, $bIncludeCOM = True, $iOpts = 0, $iCodePage = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $wParam
If $bRtf Then
$wParam = ($bIncludeCOM ? $SF_RTF : $SF_RTFNOOBJS)
Else
$wParam = ($bIncludeCOM ? $SF_TEXTIZED : $SF_TEXT)
If BitAND($iOpts, $SFF_PLAINRTF) Then Return SetError(1041, 0, "")
EndIf
If BitAND($iOpts, BitNOT(BitOR($SFF_PLAINRTF, $SF_UNICODE))) Then Return SetError(1042, 0, "")
If BitAND($iOpts, $SF_UNICODE) Then
If Not BitAND($wParam, $SF_TEXT) Then Return SetError(1043, 0, "")
EndIf
If _GUICtrlRichEdit_IsTextSelected($hWnd) Then $wParam = BitOR($wParam, $SFF_SELECTION)
$wParam = BitOR($wParam, $iOpts)
If $iCodePage <> 0 Then
$wParam = BitOR($wParam, $SF_USECODEPAGE, BitShift($iCodePage, -16))
EndIf
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamToVarCallback))
$__g_pGRC_sStreamVar = ""
_SendMessage($hWnd, $EM_STREAMOUT, $wParam, $tEditStream, 0, "wparam", "struct*")
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then Return SetError(700, $iError, "")
Return $__g_pGRC_sStreamVar
EndFunc
Func _GUICtrlRichEdit_Undo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_UNDO, 0, 0) <> 0
EndFunc
Func __GCR_Init()
Local $ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "MSFTEDIT.DLL")
If $ah_GUICtrlRTF_lib[0] <> 0 Then
$__g_sRTFClassName = "RichEdit50W"
$__g_sRTFVersion = 4.1
Else
$ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "RICHED20.DLL")
$__g_sRTFVersion = FileGetVersion(@SystemDir & "\riched20.dll", "ProductVersion")
Switch $__g_sRTFVersion
Case 3.0
$__g_sRTFClassName = "RichEdit20W"
Case 5.0
$__g_sRTFClassName = "RichEdit50W"
Case 6.0
$__g_sRTFClassName = "RichEdit60W"
EndSwitch
EndIf
$__g_sGRE_CF_RTF = _ClipBoard_RegisterFormat("Rich Text Format")
$__g_sGRE_CF_RETEXTOBJ = _ClipBoard_RegisterFormat("Rich Text Format with Objects")
EndFunc
Func __GCR_StreamFromFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sBuf = FileRead($hFile, $iBuflen - 1)
If @error Then Return 1
DllStructSetData($tBuf, 1, $sBuf)
DllStructSetData($tQbytes, 1, StringLen($sBuf))
Return 0
EndFunc
Func __GCR_StreamFromVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tCtl = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sCtl = StringLeft($__g_pGRC_sStreamVar, $iBuflen - 1)
If $sCtl = "" Then Return 1
DllStructSetData($tCtl, 1, $sCtl)
Local $iLen = StringLen($sCtl)
DllStructSetData($tQbytes, 1, $iLen)
$__g_pGRC_sStreamVar = StringMid($__g_pGRC_sStreamVar, $iLen + 1)
Return 0
EndFunc
Func __GCR_StreamToFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
FileWrite($hFile, $s)
DllStructSetData($tQbytes, 1, StringLen($s))
Return 0
EndFunc
Func __GCR_StreamToVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
$__g_pGRC_sStreamVar &= $s
Return 0
EndFunc
Func __GCR_ConvertTwipsToSpaceUnit($nIn)
Local $sRet
Switch $__g_iRTFTwipsPeSpaceUnit
Case 1440, 567
$sRet = StringFormat("%.2f", $nIn / $__g_iRTFTwipsPeSpaceUnit)
If $sRet = "-0.00" Then $sRet = "0.00"
Case 56.7, 72
$sRet = StringFormat("%.1f", $nIn / $__g_iRTFTwipsPeSpaceUnit)
If $sRet = "-0.0" Then $sRet = "0.0"
Case Else
$sRet = $nIn
EndSwitch
Return $sRet
EndFunc
Func __GCR_IsNumeric($vN, $sRange = "")
If Not (IsNumber($vN) Or StringIsInt($vN) Or StringIsFloat($vN)) Then Return False
Switch $sRange
Case ">0"
If $vN <= 0 Then Return False
Case ">=0"
If $vN < 0 Then Return False
Case ">0,-1"
If Not ($vN > 0 Or $vN = -1) Then Return False
Case ">=0,-1"
If Not ($vN >= 0 Or $vN = -1) Then Return False
EndSwitch
Return True
EndFunc
Func __GCR_GetParaScopeChar($hWnd, $iMask, $iPFM)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
Return "c"
ElseIf BitAND($iMask, $iPFM) = $iPFM Then
Return "a"
Else
Return "f"
EndIf
EndFunc
Func __GCR_ParseParaNumberingStyle($sIn, $bForceRoman, ByRef $iPFM, ByRef $iWNumbering, ByRef $iWnumStart, ByRef $iWnumStyle, ByRef $iQspaces)
Local Const $sRoman = "mdclxviMDCLXVI", $iRpar = 0, $i2par = 0x100, $iPeriod = 0x200, $iNbrOnly = 0x300
If $sIn = "" Then
$iWNumbering = 0
$iPFM = $PFM_NUMBERING
Else
Local $s = StringStripWS($sIn, $STR_STRIPTRAILING)
$iQspaces = StringLen($sIn) - StringLen($s)
$sIn = $s
$iPFM = $PFM_NUMBERINGTAB
If $sIn = "." Then
$iWNumbering = $PFN_BULLET
$iPFM = BitOR($iPFM, $PFM_NUMBERING)
ElseIf $sIn = "=" Then
$iWnumStyle = 0x400
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTYLE)
Else
Switch StringRight($sIn, 1)
Case ")"
If StringLeft($sIn, 1) = "(" Then
$iWnumStyle = $i2par
$sIn = StringTrimLeft($sIn, 1)
Else
$iWnumStyle = $iRpar
EndIf
Case "."
$iWnumStyle = $iPeriod
Case Else
$iWnumStyle = $iNbrOnly
EndSwitch
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTYLE)
If $iWnumStyle <> 0x300 Then $sIn = StringTrimRight($sIn, 1)
If StringIsDigit($sIn) Then
$iWnumStart = Number($sIn)
$iWNumbering = 2
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Else
Local $bMayBeRoman = True
For $i = 1 To StringLen($sIn)
If Not StringInStr($sRoman, StringMid($sIn, $i, 1)) Then
$bMayBeRoman = False
ExitLoop
EndIf
Next
Local $bIsRoman
If $bMayBeRoman Then
$bIsRoman = $bForceRoman
Else
$bIsRoman = False
EndIf
Switch True
Case $bIsRoman
$iWnumStart = __GCR_ConvertRomanToNumber($sIn)
If $iWnumStart = -1 Then Return SetError(102, 0, False)
$iWNumbering = (StringIsLower($sIn) ? 5 : 6)
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Case StringIsAlpha($sIn)
If StringIsLower($sIn) Then
$iWNumbering = 3
Else
$iWNumbering = 4
$sIn = StringLower($sIn)
EndIf
$iWnumStart = 0
Local $iN
For $iP = 1 To StringLen($sIn)
$iN = Asc(StringMid($sIn, $i))
If $iN >= Asc("a") And $iN <= Asc("z") Then
$iWnumStart = $iWnumStart * 26 + ($iN - Asc("a") + 1)
EndIf
Next
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Case Else
Return SetError(102, 0, False)
EndSwitch
EndIf
EndIf
EndIf
Return True
EndFunc
Func __GCR_ConvertRomanToNumber($sRnum)
Local Enum $e9, $e5, $e4, $e1, $eMult, $eHigher
Local Const $aV[3][6] = [["cm", "d", "cd", "c", 100, "m"], ["xc", "l", "xl", "x", 10, "mdc"], ["ix", "v", "iv", "i", 1, "mdclx"]]
$sRnum = StringLower($sRnum)
Local $i = 1
While StringMid($sRnum, $i, 1) = "m"
$i += 1
WEnd
Local $iDigit, $iQ1s, $iRet = ($i - 1) * 1000
For $j = 0 To 2
$iDigit = 0
If StringMid($sRnum, $i, 2) = $aV[$j][$e9] Then
$iDigit = 9
$i += 2
ElseIf StringMid($sRnum, $i, 1) = $aV[$j][$e5] Then
$iDigit = 5
$i += 1
ElseIf StringMid($sRnum, $i, 2) = $aV[$j][$e4] Then
$iDigit = 4
$i += 2
ElseIf StringInStr($aV[$j][$eHigher], StringMid($sRnum, $i, 1)) Then
Return -1
EndIf
If $iDigit = 0 Or $iDigit = 5 Then
$iQ1s = 0
While StringMid($sRnum, $i, 1) = $aV[$j][$e1]
$iQ1s += 1
If $iQ1s > 3 Then Return 0
$i += 1
WEnd
$iDigit += $iQ1s
EndIf
$iRet += $iDigit * $aV[$j][$eMult]
Next
If $i <= StringLen($sRnum) Then Return -1
Return $iRet
EndFunc
Func __GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Return _SendMessage($hWnd, $EM_GETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
EndFunc
Func __GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
Local $bIsSel = _GUICtrlRichEdit_IsTextSelected($hWnd)
Local $iInsPt = 0
If Not $bIsSel Then
Local $aS = _GUICtrlRichEdit_GetSel($hWnd)
$iInsPt = $aS[0]
Local $iN = _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iN, $iN + 1, True)
EndIf
_SendMessage($hWnd, $EM_GETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If @error Then Return SetError(@error, @extended, False)
If Not $bIsSel Then _GUICtrlRichEdit_SetSel($hWnd, $iInsPt, $iInsPt)
Return True
EndFunc
Func __GCR_SetOLECallback($hWnd)
If Not IsHWnd($hWnd) Then Return SetError(101, 0, False)
If Not $__g_pObj_RichCom Then
$__g_tCall_RichCom = DllStructCreate("ptr[20]")
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInterface), 1)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_AddRef), 2)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_Release), 3)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetNewStorage), 4)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetInPlaceContext), 5)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ShowContainerUI), 6)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInsertObject), 7)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_DeleteObject), 8)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryAcceptData), 9)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ContextSensitiveHelp), 10)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetClipboardData), 11)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetDragDropEffect), 12)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetContextMenu), 13)
DllStructSetData($__g_tObj_RichComObject, 1, DllStructGetPtr($__g_tCall_RichCom))
DllStructSetData($__g_tObj_RichComObject, 2, 1)
$__g_pObj_RichCom = DllStructGetPtr($__g_tObj_RichComObject)
EndIf
Local Const $EM_SETOLECALLBACK = 0x400 + 70
If _SendMessage($hWnd, $EM_SETOLECALLBACK, 0, $__g_pObj_RichCom) = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func __RichCom_Object_QueryInterface($pObject, $iREFIID, $pPvObj)
#forceref $pObject, $iREFIID, $pPvObj
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_AddRef($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
DllStructSetData($tData, 2, DllStructGetData($tData, 2) + 1)
Return DllStructGetData($tData, 2)
EndFunc
Func __RichCom_Object_Release($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
If DllStructGetData($tData, 2) > 0 Then
DllStructSetData($tData, 2, DllStructGetData($tData, 2) - 1)
Return DllStructGetData($tData, 2)
EndIf
EndFunc
Func __RichCom_Object_GetInPlaceContext($pObject, $pPFrame, $pPDoc, $pFrameInfo)
#forceref $pObject, $pPFrame, $pPDoc, $pFrameInfo
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_ShowContainerUI($pObject, $bShow)
#forceref $pObject, $bShow
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryInsertObject($pObject, $pClsid, $tStg, $vCp)
#forceref $pObject, $pClsid, $tStg, $vCp
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_DeleteObject($pObject, $pOleobj)
#forceref $pObject, $pOleobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryAcceptData($pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict)
#forceref $pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_ContextSensitiveHelp($pObject, $bEnterMode)
#forceref $pObject, $bEnterMode
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetClipboardData($pObject, $pChrg, $vReco, $pPdataobj)
#forceref $pObject, $pChrg, $vReco, $pPdataobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetDragDropEffect($pObject, $bDrag, $iGrfKeyState, $piEffect)
#forceref $pObject, $bDrag, $iGrfKeyState, $piEffect
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetContextMenu($pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu)
#forceref $pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetNewStorage($pObject, $pPstg)
#forceref $pObject
Local $aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "CreateILockBytesOnHGlobal", "hwnd", 0, "int", 1, "ptr*", 0)
Local $pLockBytes = $aSc[3]
$aSc = $aSc[0]
If $aSc Then Return $aSc
$aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "StgCreateDocfileOnILockBytes", "ptr", $pLockBytes, "dword", BitOR(0x10, 2, 0x1000), "dword", 0, "ptr*", 0)
Local $tStg = DllStructCreate("ptr", $pPstg)
DllStructSetData($tStg, 1, $aSc[4])
$aSc = $aSc[0]
If $aSc Then
Local $tObj = DllStructCreate("ptr", $pLockBytes)
Local $tUnknownFuncTable = DllStructCreate("ptr[3]", DllStructGetData($tObj, 1))
Local $pReleaseFunc = DllStructGetData($tUnknownFuncTable, 3)
DllCallAddress("long", $pReleaseFunc, "ptr", $pLockBytes)
EndIf
Return $aSc
EndFunc
Global Const $SIF_POS = 0x04
Global Const $SIF_PAGE = 0x02
Global Const $SIF_RANGE = 0x01
Global Const $SIF_TRACKPOS = 0x10
Global Const $SIF_ALL = BitOR($SIF_RANGE, $SIF_PAGE, $SIF_POS, $SIF_TRACKPOS)
Global Const $SB_HORZ = 0
Global Const $SB_VERT = 1
Global Const $SB_CTL = 2
Global Const $SB_BOTH = 3
Global Const $SB_LINELEFT = 0
Global Const $SB_LINERIGHT = 1
Global Const $SB_PAGELEFT = 2
Global Const $SB_PAGERIGHT = 3
Global Const $SB_THUMBPOSITION = 0x4
Global Const $SB_THUMBTRACK = 0x5
Global Const $SB_LINEDOWN = 1
Global Const $SB_LINEUP = 0
Global Const $SB_PAGEDOWN = 3
Global Const $SB_PAGEUP = 2
Global Const $SB_SCROLLCARET = 4
Global Const $SB_TOP = 6
Global Const $SB_BOTTOM = 7
Global Const $ESB_DISABLE_BOTH = 0x3
Global Const $ESB_DISABLE_DOWN = 0x2
Global Const $ESB_DISABLE_LEFT = 0x1
Global Const $ESB_DISABLE_LTUP = $ESB_DISABLE_LEFT
Global Const $ESB_DISABLE_RIGHT = 0x2
Global Const $ESB_DISABLE_RTDN = $ESB_DISABLE_RIGHT
Global Const $ESB_DISABLE_UP = 0x1
Global Const $ESB_ENABLE_BOTH = 0x0
Global Const $OBJID_HSCROLL = 0xFFFFFFFA
Global Const $OBJID_VSCROLL = 0xFFFFFFFB
Global Const $OBJID_CLIENT = 0xFFFFFFFC
Global $__g_aSB_WindowInfo[1][8]
Func _GUIScrollBars_EnableScrollBar($hWnd, $iSBflags = $SB_BOTH, $iArrows = $ESB_ENABLE_BOTH)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aResult = DllCall("user32.dll", "bool", "EnableScrollBar", "hwnd", $hWnd, "uint", $iSBflags, "uint", $iArrows)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
Local $tSCROLLBARINFO = DllStructCreate($tagSCROLLBARINFO)
DllStructSetData($tSCROLLBARINFO, "cbSize", DllStructGetSize($tSCROLLBARINFO))
Local $aResult = DllCall("user32.dll", "bool", "GetScrollBarInfo", "hwnd", $hWnd, "long", $iObject, "struct*", $tSCROLLBARINFO)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tSCROLLBARINFO)
EndFunc
Func _GUIScrollBars_GetScrollBarRect($hWnd, $iObject)
Local $aRect[4]
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(@error, @extended, 0)
$aRect[0] = DllStructGetData($tSCROLLBARINFO, "Left")
$aRect[1] = DllStructGetData($tSCROLLBARINFO, "Top")
$aRect[2] = DllStructGetData($tSCROLLBARINFO, "Right")
$aRect[3] = DllStructGetData($tSCROLLBARINFO, "Bottom")
Return $aRect
EndFunc
Func _GUIScrollBars_GetScrollBarRGState($hWnd, $iObject)
Local $aRGState[6]
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(@error, @extended, 0)
For $x = 0 To 5
$aRGState[$x] = DllStructGetData($tSCROLLBARINFO, "rgstate", $x + 1)
Next
Return $aRGState
EndFunc
Func _GUIScrollBars_GetScrollBarXYLineButton($hWnd, $iObject)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLBARINFO, "dxyLineButton")
EndFunc
Func _GUIScrollBars_GetScrollBarXYThumbTop($hWnd, $iObject)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLBARINFO, "xyThumbTop")
EndFunc
Func _GUIScrollBars_GetScrollBarXYThumbBottom($hWnd, $iObject)
If Not IsHWnd($hWnd) Then Return SetError(-1, -1, -1)
Local $tSCROLLBARINFO = _GUIScrollBars_GetScrollBarInfoEx($hWnd, $iObject)
If @error Then Return SetError(-1, -1, -1)
Return DllStructGetData($tSCROLLBARINFO, "xyThumbBottom")
EndFunc
Func _GUIScrollBars_GetScrollInfo($hWnd, $iBar, ByRef $tSCROLLINFO)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aResult = DllCall("user32.dll", "bool", "GetScrollInfo", "hwnd", $hWnd, "int", $iBar, "struct*", $tSCROLLINFO)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
Local $tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
DllStructSetData($tSCROLLINFO, "cbSize", DllStructGetSize($tSCROLLINFO))
DllStructSetData($tSCROLLINFO, "fMask", $SIF_ALL)
If Not _GUIScrollBars_GetScrollInfo($hWnd, $iBar, $tSCROLLINFO) Then Return SetError(@error, @extended, 0)
Return $tSCROLLINFO
EndFunc
Func _GUIScrollBars_GetScrollInfoPage($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nPage")
EndFunc
Func _GUIScrollBars_GetScrollInfoPos($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nPos")
EndFunc
Func _GUIScrollBars_GetScrollInfoMin($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nMin")
EndFunc
Func _GUIScrollBars_GetScrollInfoMax($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nMax")
EndFunc
Func _GUIScrollBars_GetScrollInfoTrackPos($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSCROLLINFO, "nTrackPos")
EndFunc
Func _GUIScrollBars_GetScrollPos($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $aResult = DllCall("user32.dll", "int", "GetScrollPos", "hwnd", $hWnd, "int", $iBar)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIScrollBars_GetScrollRange($hWnd, $iBar)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $aResult = DllCall("user32.dll", "bool", "GetScrollRange", "hwnd", $hWnd, "int", $iBar, "int*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
Local $aMin_Max[2]
$aMin_Max[0] = $aResult[3]
$aMin_Max[1] = $aResult[4]
Return SetExtended($aResult[0], $aMin_Max)
EndFunc
Func _GUIScrollBars_Init($hWnd, $iMaxH = -1, $iMaxV = -1)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, 0)
If $__g_aSB_WindowInfo[0][0] <> 0 Then ReDim $__g_aSB_WindowInfo[UBound($__g_aSB_WindowInfo) + 1][8]
Local $tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
Local $tRECT = DllStructCreate($tagRECT)
Local $iIndex = UBound($__g_aSB_WindowInfo) - 1
Local $iError, $iExtended
$__g_aSB_WindowInfo[$iIndex][0] = $hWnd
$__g_aSB_WindowInfo[$iIndex][1] = $iMaxH
$__g_aSB_WindowInfo[$iIndex][6] = $iMaxH
$__g_aSB_WindowInfo[$iIndex][7] = $iMaxV
If $iMaxV = -1 Then $__g_aSB_WindowInfo[$iIndex][7] = 27
Local $hDC = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended)
$hDC = $hDC[0]
Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
DllStructSetData($tSCROLLINFO, "cbSize", DllStructGetSize($tSCROLLINFO))
DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hDC, "struct*", $tTEXTMETRIC)
If @error Then
$iError = @error
$iExtended = @extended
EndIf
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If $iError Then Return SetError($iError, $iExtended)
Local $iUpperX, $iXAmount = DllStructGetData($tTEXTMETRIC, "tmAveCharWidth")
If BitAND(DllStructGetData($tTEXTMETRIC, "tmPitchAndFamily"), 1) Then
$iUpperX = 3 * $iXAmount / 2
Else
$iUpperX = 2 * $iXAmount / 2
EndIf
Local $iYAmount = DllStructGetData($tTEXTMETRIC, "tmHeight") + DllStructGetData($tTEXTMETRIC, "tmExternalLeading")
If $iMaxH = -1 Then $__g_aSB_WindowInfo[$iIndex][1] = 48 * $iXAmount + 12 * $iUpperX
$__g_aSB_WindowInfo[$iIndex][2] = $iXAmount
$__g_aSB_WindowInfo[$iIndex][3] = $iYAmount
_GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ, False)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT, False)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT)
DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Then Return SetError(@error, @extended)
Local $iClientX = DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
Local $iClientY = DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
$__g_aSB_WindowInfo[$iIndex][4] = $iClientX
$__g_aSB_WindowInfo[$iIndex][5] = $iClientY
$tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
DllStructSetData($tSCROLLINFO, "fMask", BitOR($SIF_RANGE, $SIF_PAGE))
DllStructSetData($tSCROLLINFO, "nMin", 0)
DllStructSetData($tSCROLLINFO, "nMax", $__g_aSB_WindowInfo[$iIndex][7])
DllStructSetData($tSCROLLINFO, "nPage", $iClientY / $iYAmount)
_GUIScrollBars_SetScrollInfo($hWnd, $SB_VERT, $tSCROLLINFO)
DllStructSetData($tSCROLLINFO, "fMask", BitOR($SIF_RANGE, $SIF_PAGE))
DllStructSetData($tSCROLLINFO, "nMin", 0)
DllStructSetData($tSCROLLINFO, "nMax", 2 + $__g_aSB_WindowInfo[$iIndex][1] / $iXAmount)
DllStructSetData($tSCROLLINFO, "nPage", $iClientX / $iXAmount)
_GUIScrollBars_SetScrollInfo($hWnd, $SB_HORZ, $tSCROLLINFO)
EndFunc
Func _GUIScrollBars_ScrollWindow($hWnd, $iXAmount, $iYAmount)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aResult = DllCall("user32.dll", "bool", "ScrollWindow", "hwnd", $hWnd, "int", $iXAmount, "int", $iYAmount, "ptr", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUIScrollBars_SetScrollInfo($hWnd, $iBar, $tSCROLLINFO, $bRedraw = True)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
DllStructSetData($tSCROLLINFO, "cbSize", DllStructGetSize($tSCROLLINFO))
Local $aResult = DllCall("user32.dll", "int", "SetScrollInfo", "hwnd", $hWnd, "int", $iBar, "struct*", $tSCROLLINFO, "bool", $bRedraw)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIScrollBars_SetScrollInfoMin($hWnd, $iBar, $iMin)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aRange = _GUIScrollBars_GetScrollRange($hWnd, $iBar)
_GUIScrollBars_SetScrollRange($hWnd, $iBar, $iMin, $aRange[1])
Local $aRange_check = _GUIScrollBars_GetScrollRange($hWnd, $iBar)
If $aRange[1] <> $aRange_check[1] Or $iMin <> $aRange_check[0] Then
_GUIScrollBars_SetScrollRange($hWnd, $iBar, $aRange[0], $aRange[1])
Return False
EndIf
Return True
EndFunc
Func _GUIScrollBars_SetScrollInfoMax($hWnd, $iBar, $iMax)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, False)
Local $aRange = _GUIScrollBars_GetScrollRange($hWnd, $iBar)
_GUIScrollBars_SetScrollRange($hWnd, $iBar, $aRange[0], $iMax)
Local $aRange_check = _GUIScrollBars_GetScrollRange($hWnd, $iBar)
If $aRange[0] <> $aRange_check[0] Or $iMax <> $aRange_check[1] Then
_GUIScrollBars_SetScrollRange($hWnd, $iBar, $aRange[0], $aRange[1])
Return False
EndIf
Return True
EndFunc
Func _GUIScrollBars_SetScrollInfoPage($hWnd, $iBar, $iPage)
If Not IsHWnd($hWnd) Then Return SetError(-2, -1, -1)
Local $tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
DllStructSetData($tSCROLLINFO, "fMask", $SIF_PAGE)
DllStructSetData($tSCROLLINFO, "nPage", $iPage)
Return _GUIScrollBars_SetScrollInfo($hWnd, $iBar, $tSCROLLINFO)
EndFunc
Func _GUIScrollBars_SetScrollInfoPos($hWnd, $iBar, $iPos)
Local $iIndex = -1, $iYAmount, $iXAmount
For $x = 0 To UBound($__g_aSB_WindowInfo) - 1
If $__g_aSB_WindowInfo[$x][0] = $hWnd Then
$iIndex = $x
$iXAmount = $__g_aSB_WindowInfo[$iIndex][2]
$iYAmount = $__g_aSB_WindowInfo[$iIndex][3]
ExitLoop
EndIf
Next
If $iIndex = -1 Then Return 0
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $iBar)
Local $iPosXY = DllStructGetData($tSCROLLINFO, "nPos")
DllStructSetData($tSCROLLINFO, "fMask", $SIF_POS)
DllStructSetData($tSCROLLINFO, "nPos", $iPos)
_GUIScrollBars_SetScrollInfo($hWnd, $iBar, $tSCROLLINFO)
_GUIScrollBars_GetScrollInfo($hWnd, $iBar, $tSCROLLINFO)
$iPos = DllStructGetData($tSCROLLINFO, "nPos")
If $iBar = $SB_HORZ Then
If ($iPos <> $iPosXY) Then _GUIScrollBars_ScrollWindow($hWnd, $iXAmount * ($iPosXY - $iPos), 0)
Else
If ($iPos <> $iPosXY) Then _GUIScrollBars_ScrollWindow($hWnd, 0, $iYAmount * ($iPosXY - $iPos))
EndIf
EndFunc
Func _GUIScrollBars_SetScrollRange($hWnd, $iBar, $iMinPos, $iMaxPos)
Local $aResult = DllCall("user32.dll", "bool", "SetScrollRange", "hwnd", $hWnd, "int", $iBar, "int", $iMinPos, "int", $iMaxPos, "bool", True)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUIScrollBars_ShowScrollBar($hWnd, $iBar, $bShow = True)
Local $aResult = DllCall("user32.dll", "bool", "ShowScrollBar", "hwnd", $hWnd, "int", $iBar, "bool", $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
_GUIScrollBars_Globals()
_GUIListViewEx_Globals()
#Region Header
#EndRegion Header
#Region Global Variables
Global $__g_iIELoadWaitTimeout = 300000
Global $__g_bIEAU3Debug = False
Global $__g_bIEErrorNotify = True
Global $__g_oIEErrorHandler, $__g_sIEUserErrorHandler
#EndRegion Global Variables
#Region Global Constants
Global Const $__gaIEAU3VersionInfo[6] = ["T", 3, 0, 2, "20140819", "T3.0-2"]
Global Const $LSFW_LOCK = 1, $LSFW_UNLOCK = 2
Global Enum  $_IESTATUS_Success = 0,  $_IESTATUS_GeneralError,  $_IESTATUS_ComError,  $_IESTATUS_InvalidDataType,  $_IESTATUS_InvalidObjectType,  $_IESTATUS_InvalidValue,  $_IESTATUS_LoadWaitTimeout,  $_IESTATUS_NoMatch,  $_IESTATUS_AccessIsDenied,  $_IESTATUS_ClientDisconnected
#EndRegion Global Constants
#Region Core functions
Func _IECreate($sUrl = "about:blank", $iTryAttach = 0, $iVisible = 1, $iWait = 1, $iTakeFocus = 1)
If Not $iVisible Then $iTakeFocus = 0
If $iTryAttach Then
Local $oResult = _IEAttach($sUrl, "url")
If IsObj($oResult) Then
If $iTakeFocus Then WinActivate(HWnd($oResult.hWnd))
Return SetError($_IESTATUS_Success, 1, $oResult)
EndIf
EndIf
Local $iMustUnlock = 0
If Not $iVisible And __IELockSetForegroundWindow($LSFW_LOCK) Then $iMustUnlock = 1
Local $oObject = ObjCreate("InternetExplorer.Application")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IECreate", "", "Browser Object Creation Failed")
If $iMustUnlock Then __IELockSetForegroundWindow($LSFW_UNLOCK)
Return SetError($_IESTATUS_GeneralError, 0, 0)
EndIf
$oObject.visible = $iVisible
If $iMustUnlock And Not __IELockSetForegroundWindow($LSFW_UNLOCK) Then __IEConsoleWriteError("Warning", "_IECreate", "", "Foreground Window Unlock Failed!")
_IENavigate($oObject, $sUrl, $iWait)
Local $iError = @error
If Not $iError And StringLeft($sUrl, 6) = "about:" Then
Local $oDocument = $oObject.document
_IEAction($oDocument, "focus")
EndIf
Return SetError($iError, 0, $oObject)
EndFunc
Func _IECreateEmbedded()
Local $oObject = ObjCreate("Shell.Explorer.2")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IECreateEmbedded", "", "WebBrowser Object Creation Failed")
Return SetError($_IESTATUS_GeneralError, 0, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject)
EndFunc
Func _IENavigate(ByRef $oObject, $sUrl, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.navigate($sUrl)
If @error Then
__IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndFunc
Func _IEAttach($sString, $sMode = "title", $iInstance = 1)
$sMode = StringLower($sMode)
$iInstance = Int($iInstance)
If $iInstance < 1 Then
__IEConsoleWriteError("Error", "_IEAttach", "$_IESTATUS_InvalidValue", "$iInstance < 1")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndIf
If $sMode = "embedded" Or $sMode = "dialogbox" Then
Local $iWinTitleMatchMode = Opt("WinTitleMatchMode", $OPT_MATCHANY)
If $sMode = "dialogbox" And $iInstance > 1 Then
If IsHWnd($sString) Then
$iInstance = 1
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_GeneralError", "$iInstance > 1 invalid with HWnd and DialogBox.  Setting to 1.")
Else
Local $aWinlist = WinList($sString, "")
If $iInstance <= $aWinlist[0][0] Then
$sString = $aWinlist[$iInstance][1]
$iInstance = 1
Else
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
Opt("WinTitleMatchMode", $iWinTitleMatchMode)
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndIf
EndIf
EndIf
Local $hControl = ControlGetHandle($sString, "", "[CLASS:Internet Explorer_Server; INSTANCE:" & $iInstance & "]")
Local $oResult = __IEControlGetObjFromHWND($hControl)
Opt("WinTitleMatchMode", $iWinTitleMatchMode)
If IsObj($oResult) Then
Return SetError($_IESTATUS_Success, 0, $oResult)
Else
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndIf
EndIf
Local $oShell = ObjCreate("Shell.Application")
Local $oShellWindows = $oShell.Windows()
Local $iTmp = 1
Local $iNotifyStatus, $bIsBrowser, $sTmp
Local $bStatus
For $oWindow In $oShellWindows
$bIsBrowser = True
$bStatus = __IEInternalErrorHandlerRegister()
If Not $bStatus Then __IEConsoleWriteError("Warning", "_IEAttach",  "Cannot register internal error handler, cannot trap COM errors",  "Use _IEErrorHandlerRegister() to register a user error handler")
$iNotifyStatus = _IEErrorNotify()
_IEErrorNotify(False)
If $bIsBrowser Then
$sTmp = $oWindow.type
If @error Then $bIsBrowser = False
EndIf
If $bIsBrowser Then
$sTmp = $oWindow.document.title
If @error Then $bIsBrowser = False
EndIf
_IEErrorNotify($iNotifyStatus)
__IEInternalErrorHandlerDeRegister()
If $bIsBrowser Then
Switch $sMode
Case "title"
If StringInStr($oWindow.document.title, $sString) > 0 Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "instance"
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
Case "windowtitle"
Local $bFound = False
$sTmp = RegRead("HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main\", "Window Title")
If Not @error Then
If StringInStr($oWindow.document.title & " - " & $sTmp, $sString) Then $bFound = True
Else
If StringInStr($oWindow.document.title & " - Microsoft Internet Explorer", $sString) Then $bFound = True
If StringInStr($oWindow.document.title & " - Windows Internet Explorer", $sString) Then $bFound = True
EndIf
If $bFound Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "url"
If StringInStr($oWindow.LocationURL, $sString) > 0 Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "text"
If StringInStr($oWindow.document.body.innerText, $sString) > 0 Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "html"
If StringInStr($oWindow.document.body.innerHTML, $sString) > 0 Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "hwnd"
If $iInstance > 1 Then
$iInstance = 1
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_GeneralError", "$iInstance > 1 invalid with HWnd.  Setting to 1.")
EndIf
If _IEPropertyGet($oWindow, "hwnd") = $sString Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEAttach", "$_IESTATUS_InvalidValue", "Invalid Mode Specified")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndSwitch
EndIf
Next
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndFunc
Func _IELoadWait(ByRef $oObject, $iDelay = 0, $iTimeout = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_InvalidObjectType", ObjName($oObject))
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oTemp, $bAbort = False, $iErrorStatusCode = $_IESTATUS_Success
Local $bStatus = __IEInternalErrorHandlerRegister()
If Not $bStatus Then __IEConsoleWriteError("Warning", "_IELoadWait",  "Cannot register internal error handler, cannot trap COM errors",  "Use _IEErrorHandlerRegister() to register a user error handler")
Local $iNotifyStatus = _IEErrorNotify()
_IEErrorNotify(False)
Sleep($iDelay)
Local $iError
Local $hIELoadWaitTimer = TimerInit()
If $iTimeout = -1 Then $iTimeout = $__g_iIELoadWaitTimeout
Select
Case __IEIsObjType($oObject, "browser", False)
While Not (String($oObject.readyState) = "complete" Or $oObject.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
While Not (String($oObject.document.readyState) = "complete" Or $oObject.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
Case __IEIsObjType($oObject, "window", False)
While Not (String($oObject.document.readyState) = "complete" Or $oObject.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
While Not (String($oObject.top.document.readyState) = "complete" Or $oObject.top.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
Case __IEIsObjType($oObject, "document", False)
$oTemp = $oObject.parentWindow
While Not (String($oTemp.document.readyState) = "complete" Or $oTemp.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
While Not (String($oTemp.top.document.readyState) = "complete" Or $oTemp.top.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
Case Else
$oTemp = $oObject.document.parentWindow
While Not (String($oTemp.document.readyState) = "complete" Or $oTemp.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
While Not (String($oTemp.top.document.readyState) = "complete" Or $oObject.top.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
EndSelect
_IEErrorNotify($iNotifyStatus)
__IEInternalErrorHandlerDeRegister()
Switch $iErrorStatusCode
Case $_IESTATUS_Success
Return SetError($_IESTATUS_Success, 0, 1)
Case $_IESTATUS_LoadWaitTimeout
__IEConsoleWriteError("Warning", "_IELoadWait", "$_IESTATUS_LoadWaitTimeout")
Return SetError($_IESTATUS_LoadWaitTimeout, 3, 0)
Case $_IESTATUS_AccessIsDenied
__IEConsoleWriteError("Warning", "_IELoadWait", "$_IESTATUS_AccessIsDenied",  "Cannot verify readyState.  Likely casue: cross-domain scripting security restriction. (" & $iError & ")")
Return SetError($_IESTATUS_AccessIsDenied, 0, 0)
Case $_IESTATUS_ClientDisconnected
__IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_ClientDisconnected",  $iError & ", Browser has been deleted prior to operation.")
Return SetError($_IESTATUS_ClientDisconnected, 0, 0)
Case Else
__IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_GeneralError", "Invalid Error Status - Notify IE.au3 developer")
Return SetError($_IESTATUS_GeneralError, 0, 0)
EndSwitch
EndFunc
Func _IELoadWaitTimeout($iTimeout = -1)
If $iTimeout = -1 Then
Return SetError($_IESTATUS_Success, 0, $__g_iIELoadWaitTimeout)
Else
$__g_iIELoadWaitTimeout = $iTimeout
Return SetError($_IESTATUS_Success, 0, 1)
EndIf
EndFunc
#EndRegion Core functions
#Region Frame Functions
Func _IEIsFrameSet(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEIsFrameSet", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If String($oObject.document.body.tagName) = "frameset" Then
Return SetError($_IESTATUS_Success, 0, 1)
Else
If @error Then
__IEConsoleWriteError("Error", "_IEIsFrameSet", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 0)
EndIf
EndFunc
Func _IEFrameGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFrameGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oObject.document.parentwindow.frames.length,  $oObject.document.parentwindow.frames)
Case $iIndex > -1 And $iIndex < $oObject.document.parentwindow.frames.length
Return SetError($_IESTATUS_Success, $oObject.document.parentwindow.frames.length,  $oObject.document.parentwindow.frames.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IEFrameGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IEFrameGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndSelect
EndFunc
Func _IEFrameGetObjByName(ByRef $oObject, $sName)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFrameGetObjByName", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oTemp, $oFrames
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEFrameGetObjByName", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.parentWindow
Else
$oTemp = $oObject.document.parentWindow
EndIf
If _IEIsFrameSet($oTemp) Then
$oFrames = _IETagNameGetCollection($oTemp, "frame")
Else
$oFrames = _IETagNameGetCollection($oTemp, "iframe")
EndIf
If $oFrames.length Then
For $oFrame In $oFrames
If String($oFrame.name) = $sName Then Return SetError($_IESTATUS_Success, 0, $oTemp.frames($sName))
Next
__IEConsoleWriteError("Warning", "_IEFrameGetObjByName", "$_IESTATUS_NoMatch", "No frames matching name")
Return SetError($_IESTATUS_NoMatch, 2, 0)
Else
__IEConsoleWriteError("Warning", "_IEFrameGetObjByName", "$_IESTATUS_NoMatch", "No Frames found")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
EndFunc
#EndRegion Frame Functions
#Region Link functions
Func _IELinkClickByText(ByRef $oObject, $sLinkText, $iIndex = 0, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IELinkClickByText", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $iFound = 0, $sModeLinktext, $oLinks = $oObject.document.links
$iIndex = Number($iIndex)
For $oLink In $oLinks
$sModeLinktext = String($oLink.outerText)
If $sModeLinktext = $sLinkText Then
If ($iFound = $iIndex) Then
$oLink.click()
If @error Then
__IEConsoleWriteError("Error", "_IELinkClickByText", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndIf
$iFound = $iFound + 1
EndIf
Next
__IEConsoleWriteError("Warning", "_IELinkClickByText", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndFunc
Func _IELinkClickByIndex(ByRef $oObject, $iIndex, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IELinkClickByIndex", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oLinks = $oObject.document.links, $oLink
$iIndex = Number($iIndex)
If ($iIndex >= 0) And ($iIndex <= $oLinks.length - 1) Then
$oLink = $oLinks($iIndex)
$oLink.click()
If @error Then
__IEConsoleWriteError("Error", "_IELinkClickByIndex", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
Else
__IEConsoleWriteError("Warning", "_IELinkClickByIndex", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
EndFunc
Func _IELinkGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IELinkGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oObject.document.links.length,  $oObject.document.links)
Case $iIndex > -1 And $iIndex < $oObject.document.links.length
Return SetError($_IESTATUS_Success, $oObject.document.links.length,  $oObject.document.links.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IELinkGetCollection", "$_IESTATUS_InvalidValue")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IELinkGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndSelect
EndFunc
#EndRegion Link functions
#Region Image functions
Func _IEImgClick(ByRef $oObject, $sLinkText, $sMode = "src", $iIndex = 0, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $sModeLinktext, $iFound = 0, $oImgs = $oObject.document.images
$sMode = StringLower($sMode)
$iIndex = Number($iIndex)
For $oImg In $oImgs
Select
Case $sMode = "alt"
$sModeLinktext = $oImg.alt
Case $sMode = "name"
$sModeLinktext = $oImg.name
If Not IsString($sModeLinktext) Then $sModeLinktext = $oImg.id
Case $sMode = "id"
$sModeLinktext = $oImg.id
Case $sMode = "src"
$sModeLinktext = $oImg.src
Case Else
__IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_InvalidValue", "Invalid mode: " & $sMode)
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSelect
If StringInStr($sModeLinktext, $sLinkText) Then
If ($iFound = $iIndex) Then
$oImg.click()
If @error Then
__IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndIf
$iFound = $iFound + 1
EndIf
Next
__IEConsoleWriteError("Warning", "_IEImgClick", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndFunc
Func _IEImgGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEImgGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oTemp = _IEDocGetObj($oObject)
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oTemp.images.length, $oTemp.images)
Case $iIndex > -1 And $iIndex < $oTemp.images.length
Return SetError($_IESTATUS_Success, $oTemp.images.length, $oTemp.images.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IEImgGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IEImgGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
#EndRegion Image functions
#Region Form functions
Func _IEFormGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oTemp = _IEDocGetObj($oObject)
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oTemp.forms.length, $oTemp.forms)
Case $iIndex > -1 And $iIndex < $oTemp.forms.length
Return SetError($_IESTATUS_Success, $oTemp.forms.length, $oTemp.forms.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IEFormGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IEFormGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
Func _IEFormGetObjByName(ByRef $oObject, $sName, $iIndex = 0)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormGetObjByName", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $iLength = 0
Local $oCol = $oObject.document.forms.item($sName)
If IsObj($oCol) Then
If __IEIsObjType($oCol, "elementcollection") Then
$iLength = $oCol.length
Else
$iLength = 1
EndIf
EndIf
$iIndex = Number($iIndex)
If $iIndex = -1 Then
Return SetError($_IESTATUS_Success, $iLength, $oObject.document.forms.item($sName))
Else
If IsObj($oObject.document.forms.item($sName, $iIndex)) Then
Return SetError($_IESTATUS_Success, $iLength, $oObject.document.forms.item($sName, $iIndex))
Else
__IEConsoleWriteError("Warning", "_IEFormGetObjByName", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndIf
EndIf
EndFunc
Func _IEFormElementGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oObject.elements.length, $oObject.elements)
Case $iIndex > -1 And $iIndex < $oObject.elements.length
Return SetError($_IESTATUS_Success, $oObject.elements.length, $oObject.elements.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
Func _IEFormElementGetObjByName(ByRef $oObject, $sName, $iIndex = 0)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementGetObjByName", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormElementGetObjByName", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $iLength = 0
Local $oCol = $oObject.elements.item($sName)
If IsObj($oCol) Then
If __IEIsObjType($oCol, "elementcollection") Then
$iLength = $oCol.length
Else
$iLength = 1
EndIf
EndIf
$iIndex = Number($iIndex)
If $iIndex = -1 Then
Return SetError($_IESTATUS_Success, $iLength, $oObject.elements.item($sName))
Else
If IsObj($oObject.elements.item($sName, $iIndex)) Then
Return SetError($_IESTATUS_Success, $iLength, $oObject.elements.item($sName, $iIndex))
Else
__IEConsoleWriteError("Warning", "_IEFormElementGetObjByName", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndIf
EndIf
EndFunc
Func _IEFormElementGetValue(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "forminputelement") Then
__IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $sReturn = String($oObject.value)
If @error Then
__IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
SetError($_IESTATUS_Success)
Return $sReturn
EndFunc
Func _IEFormElementSetValue(ByRef $oObject, $sNewValue, $iFireEvent = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "forminputelement") Then
__IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If String($oObject.type) = "file" Then
__IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidObjectType", "Browser security prevents SetValue of TYPE=FILE")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.value = $sNewValue
If @error Then
__IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iFireEvent Then
$oObject.fireEvent("OnChange")
$oObject.fireEvent("OnClick")
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEFormElementOptionSelect(ByRef $oObject, $sString, $iSelect = 1, $sMode = "byValue", $iFireEvent = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "formselectelement") Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oItem, $oItems = $oObject.options, $iNumItems = $oObject.options.length, $bIsMultiple = $oObject.multiple
Switch $sMode
Case "byValue"
For $oItem In $oItems
If $oItem.value = $sString Then
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItem.selected)
Case 0
If Not $bIsMultiple Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue",  "$iSelect=0 only valid for type=select multiple")
Return SetError($_IESTATUS_InvalidValue, 3)
EndIf
If $oItem.selected Then
$oItem.selected = False
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.selected Then
$oItem.selected = True
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSwitch
EndIf
Next
__IEConsoleWriteError("Warning", "_IEFormElementOptionSelect", "$_IESTATUS_NoMatch", "Value not matched")
Return SetError($_IESTATUS_NoMatch, 2, 0)
Case "byText"
For $oItem In $oItems
If String($oItem.text) = $sString Then
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItem.selected)
Case 0
If Not $bIsMultiple Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue",  "$iSelect=0 only valid for type=select multiple")
Return SetError($_IESTATUS_InvalidValue, 3)
EndIf
If $oItem.selected Then
$oItem.selected = False
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.selected Then
$oItem.selected = True
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSwitch
EndIf
Next
__IEConsoleWriteError("Warning", "_IEFormElementOptionSelect", "$_IESTATUS_NoMatch", "Text not matched")
Return SetError($_IESTATUS_NoMatch, 2, 0)
Case "byIndex"
Local $iIndex = Number($sString)
If $iIndex < 0 Or $iIndex >= $iNumItems Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid index value, " & $iIndex)
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndIf
$oItem = $oItems.item($iIndex)
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItems.item($iIndex).selected)
Case 0
If Not $bIsMultiple Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue",  "$iSelect=0 only valid for type=select multiple")
Return SetError($_IESTATUS_InvalidValue, 3)
EndIf
If $oItem.selected Then
$oItems.item($iIndex).selected = False
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.selected Then
$oItems.item($iIndex).selected = True
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSwitch
Case Else
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
Return SetError($_IESTATUS_InvalidValue, 4, 0)
EndSwitch
EndFunc
Func _IEFormElementCheckBoxSelect(ByRef $oObject, $sString, $sName = "", $iSelect = 1, $sMode = "byValue", $iFireEvent = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$sString = String($sString)
$sName = String($sName)
Local $oItems
If $sName = "" Then
$oItems = _IETagNameGetCollection($oObject, "input")
Else
$oItems = Execute("$oObject.elements('" & $sName & "')")
EndIf
If Not IsObj($oItems) Then
__IEConsoleWriteError("Warning", "_IEFormElementCheckBoxSelect", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 3, 0)
EndIf
Local $oItem, $bFound = False
Switch $sMode
Case "byValue"
If __IEIsObjType($oItems, "forminputelement") Then
$oItem = $oItems
If String($oItem.type) = "checkbox" And String($oItem.value) = $sString Then $bFound = True
Else
For $oItem In $oItems
If String($oItem.type) = "checkbox" And String($oItem.value) = $sString Then
$bFound = True
ExitLoop
EndIf
Next
EndIf
Case "byIndex"
If __IEIsObjType($oItems, "forminputelement") Then
$oItem = $oItems
If String($oItem.type) = "checkbox" And Number($sString) = 0 Then $bFound = True
Else
Local $iCount = 0
For $oItem In $oItems
If String($oItem.type) = "checkbox" And Number($sString) = $iCount Then
$bFound = True
ExitLoop
Else
If String($oItem.type) = "checkbox" Then $iCount += 1
EndIf
Next
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
Return SetError($_IESTATUS_InvalidValue, 5, 0)
EndSwitch
If Not $bFound Then
__IEConsoleWriteError("Warning", "_IEFormElementCheckBoxSelect", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItem.checked)
Case 0
If $oItem.checked Then
$oItem.checked = False
If $iFireEvent Then
$oItem.fireEvent("onChange")
$oItem.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.checked Then
$oItem.checked = True
If $iFireEvent Then
$oItem.fireEvent("onChange")
$oItem.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSwitch
EndFunc
Func _IEFormElementRadioSelect(ByRef $oObject, $sString, $sName, $iSelect = 1, $sMode = "byValue", $iFireEvent = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$sString = String($sString)
$sName = String($sName)
Local $oItems = Execute("$oObject.elements('" & $sName & "')")
If Not IsObj($oItems) Then
__IEConsoleWriteError("Warning", "_IEFormElementRadioSelect", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 3, 0)
EndIf
Local $oItem, $bFound = False
Switch $sMode
Case "byValue"
If __IEIsObjType($oItems, "forminputelement") Then
$oItem = $oItems
If String($oItem.type) = "radio" And String($oItem.value) = $sString Then $bFound = True
Else
For $oItem In $oItems
If String($oItem.type) = "radio" And String($oItem.value) = $sString Then
$bFound = True
ExitLoop
EndIf
Next
EndIf
Case "byIndex"
If __IEIsObjType($oItems, "forminputelement") Then
$oItem = $oItems
If String($oItem.type) = "radio" And Number($sString) = 0 Then $bFound = True
Else
Local $iCount = 0
For $oItem In $oItems
If String($oItem.type) = "radio" And Number($sString) = $iCount Then
$bFound = True
ExitLoop
Else
$iCount += 1
EndIf
Next
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
Return SetError($_IESTATUS_InvalidValue, 5, 0)
EndSwitch
If Not $bFound Then
__IEConsoleWriteError("Warning", "_IEFormElementRadioSelect", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItem.checked)
Case 0
If $oItem.checked Then
$oItem.checked = False
If $iFireEvent Then
$oItem.fireEvent("onChange")
$oItem.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.checked Then
$oItem.checked = True
If $iFireEvent Then
$oItem.fireEvent("onChange")
$oItem.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidValue", "$iSelect value invalid")
Return SetError($_IESTATUS_InvalidValue, 4, 0)
EndSwitch
EndFunc
Func _IEFormImageClick(ByRef $oObject, $sLinkText, $sMode = "src", $iIndex = 0, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $sModeLinktext, $iFound = 0
Local $oTemp = _IEDocGetObj($oObject)
Local $oImgs = _IETagNameGetCollection($oTemp, "input")
$sMode = StringLower($sMode)
$iIndex = Number($iIndex)
For $oImg In $oImgs
If String($oImg.type) = "image" Then
Select
Case $sMode = "alt"
$sModeLinktext = $oImg.alt
Case $sMode = "name"
$sModeLinktext = $oImg.name
If Not IsString($sModeLinktext) Then $sModeLinktext = $oImg.id
Case $sMode = "id"
$sModeLinktext = $oImg.id
Case $sMode = "src"
$sModeLinktext = $oImg.src
Case Else
__IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_InvalidValue", "Invalid mode: " & $sMode)
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSelect
If StringInStr($sModeLinktext, $sLinkText) Then
If ($iFound = $iIndex) Then
$oImg.click()
If @error Then
__IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndIf
$iFound = $iFound + 1
EndIf
EndIf
Next
__IEConsoleWriteError("Warning", "_IEFormImageClick", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndFunc
Func _IEFormSubmit(ByRef $oObject, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oWindow = $oObject.document.parentWindow
$oObject.submit()
If @error Then
__IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oWindow)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndFunc
Func _IEFormReset(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.reset()
If @error Then
__IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
#EndRegion Form functions
#Region Table functions
Func _IETableGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IETableGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oObject.document.GetElementsByTagName("table").length,  $oObject.document.GetElementsByTagName("table"))
Case $iIndex > -1 And $iIndex < $oObject.document.GetElementsByTagName("table").length
Return SetError($_IESTATUS_Success, $oObject.document.GetElementsByTagName("table").length,  $oObject.document.GetElementsByTagName("table").item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IETableGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IETableGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
Func _IETableWriteToArray(ByRef $oObject, $bTranspose = False)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "table") Then
__IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $iCols = 0, $oTds, $iCol
Local $oTrs = $oObject.rows
For $oTr In $oTrs
$oTds = $oTr.cells
$iCol = 0
For $oTd In $oTds
$iCol = $iCol + $oTd.colSpan
Next
If $iCol > $iCols Then $iCols = $iCol
Next
Local $iRows = $oTrs.length
Local $aTableCells[$iCols][$iRows]
Local $iRow = 0
For $oTr In $oTrs
$oTds = $oTr.cells
$iCol = 0
For $oTd In $oTds
$aTableCells[$iCol][$iRow] = String($oTd.innerText)
If @error Then
__IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
$iCol = $iCol + $oTd.colSpan
Next
$iRow = $iRow + 1
Next
If $bTranspose Then
Local $iD1 = UBound($aTableCells, $UBOUND_ROWS), $iD2 = UBound($aTableCells, $UBOUND_COLUMNS), $aTmp[$iD2][$iD1]
For $i = 0 To $iD2 - 1
For $j = 0 To $iD1 - 1
$aTmp[$i][$j] = $aTableCells[$j][$i]
Next
Next
$aTableCells = $aTmp
EndIf
Return SetError($_IESTATUS_Success, 0, $aTableCells)
EndFunc
#EndRegion Table functions
#Region Read/Write functions
Func _IEBodyReadHTML(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEBodyReadHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document.body.innerHTML)
EndFunc
Func _IEBodyReadText(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEBodyReadText", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEBodyReadText", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document.body.innerText)
EndFunc
Func _IEBodyWriteHTML(ByRef $oObject, $sHTML)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.document.body.innerHTML = $sHTML
If @error Then
__IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Local $oTemp = $oObject.document
_IELoadWait($oTemp)
Return SetError(@error, 0, -1)
EndFunc
Func _IEDocReadHTML(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocReadHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEDocReadHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document.documentElement.outerHTML)
EndFunc
Func _IEDocWriteHTML(ByRef $oObject, $sHTML)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.document.Write($sHTML)
$oObject.document.close()
Local $oTemp = $oObject.document
If @error Then
__IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
_IELoadWait($oTemp)
Return SetError(@error, 0, -1)
EndFunc
Func _IEDocInsertText(ByRef $oObject, $sString, $sWhere = "beforeend")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Or __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$sWhere = StringLower($sWhere)
Select
Case $sWhere = "beforebegin"
$oObject.insertAdjacentText($sWhere, $sString)
Case $sWhere = "afterbegin"
$oObject.insertAdjacentText($sWhere, $sString)
Case $sWhere = "beforeend"
$oObject.insertAdjacentText($sWhere, $sString)
Case $sWhere = "afterend"
$oObject.insertAdjacentText($sWhere, $sString)
Case Else
__IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidValue", "Invalid where value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSelect
If @error Then
__IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEDocInsertHTML(ByRef $oObject, $sString, $sWhere = "beforeend")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Or __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$sWhere = StringLower($sWhere)
Select
Case $sWhere = "beforebegin"
$oObject.insertAdjacentHTML($sWhere, $sString)
Case $sWhere = "afterbegin"
$oObject.insertAdjacentHTML($sWhere, $sString)
Case $sWhere = "beforeend"
$oObject.insertAdjacentHTML($sWhere, $sString)
Case $sWhere = "afterend"
$oObject.insertAdjacentHTML($sWhere, $sString)
Case Else
__IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidValue", "Invalid where value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSelect
If @error Then
__IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEHeadInsertEventScript(ByRef $oObject, $sHTMLFor, $sEvent, $sScript)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEHeadInsertEventScript", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oHead = $oObject.document.all.tags("HEAD").Item(0)
Local $oScript = $oObject.document.createElement("script")
If @error Then
__IEConsoleWriteError("Error", "_IEHeadInsertEventScript(script)", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
With $oScript
.defer = True
.language = "jscript"
.type = "text/javascript"
.htmlFor = $sHTMLFor
.event = $sEvent
.text = $sScript
EndWith
$oHead.appendChild($oScript)
If @error Then
__IEConsoleWriteError("Error", "_IEHeadInsertEventScript", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
#EndRegion Read/Write functions
#Region Utility functions
Func _IEDocGetObj(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocGetObj", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If __IEIsObjType($oObject, "document") Then
Return SetError($_IESTATUS_Success, 0, $oObject)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document)
EndFunc
Func _IETagNameGetCollection(ByRef $oObject, $sTagName, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oTemp
If __IEIsObjType($oObject, "documentcontainer") Then
$oTemp = _IEDocGetObj($oObject)
Else
$oTemp = $oObject
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oTemp.GetElementsByTagName($sTagName).length,  $oTemp.GetElementsByTagName($sTagName))
Case $iIndex > -1 And $iIndex < $oTemp.GetElementsByTagName($sTagName).length
Return SetError($_IESTATUS_Success, $oTemp.GetElementsByTagName($sTagName).length,  $oTemp.GetElementsByTagName($sTagName).item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
Case Else
__IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndSelect
EndFunc
Func _IETagNameAllGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oTemp
If __IEIsObjType($oObject, "documentcontainer") Then
$oTemp = _IEDocGetObj($oObject)
Else
$oTemp = $oObject
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oTemp.all.length, $oTemp.all)
Case $iIndex > -1 And $iIndex < $oTemp.all.length
Return SetError($_IESTATUS_Success, $oTemp.all.length, $oTemp.all.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
Func _IEGetObjByName(ByRef $oObject, $sName, $iIndex = 0)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEGetObjByName", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$iIndex = Number($iIndex)
If $iIndex = -1 Then
Return SetError($_IESTATUS_Success, $oObject.document.GetElementsByName($sName).length,  $oObject.document.GetElementsByName($sName))
Else
If IsObj($oObject.document.GetElementsByName($sName).item($iIndex)) Then
Return SetError($_IESTATUS_Success, $oObject.document.GetElementsByName($sName).length,  $oObject.document.GetElementsByName($sName).item($iIndex))
Else
__IEConsoleWriteError("Warning", "_IEGetObjByName", "$_IESTATUS_NoMatch", "Name: " & $sName & ", Index: " & $iIndex)
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndIf
EndIf
EndFunc
Func _IEGetObjById(ByRef $oObject, $sID)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEGetObjById", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEGetObById", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If IsObj($oObject.document.getElementById($sID)) Then
Return SetError($_IESTATUS_Success, 0, $oObject.document.getElementById($sID))
Else
__IEConsoleWriteError("Warning", "_IEGetObjById", "$_IESTATUS_NoMatch", $sID)
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
EndFunc
Func _IEAction(ByRef $oObject, $sAction)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEAction(" & $sAction & ")", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$sAction = StringLower($sAction)
Select
Case $sAction = "click"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(click)", " $_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Click()
Case $sAction = "disable"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(disable)", " $_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.disabled = True
Case $sAction = "enable"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(enable)", " $_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.disabled = False
Case $sAction = "focus"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(focus)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Focus()
Case $sAction = "scrollintoview"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(scrollintoview)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.scrollIntoView()
Case $sAction = "copy"
$oObject.document.execCommand("Copy")
Case $sAction = "cut"
$oObject.document.execCommand("Cut")
Case $sAction = "paste"
$oObject.document.execCommand("Paste")
Case $sAction = "delete"
$oObject.document.execCommand("Delete")
Case $sAction = "saveas"
$oObject.document.execCommand("SaveAs")
Case $sAction = "refresh"
$oObject.document.execCommand("Refresh")
If @error Then
__IEConsoleWriteError("Error", "_IEAction(refresh)", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
_IELoadWait($oObject)
Case $sAction = "selectall"
$oObject.document.execCommand("SelectAll")
Case $sAction = "unselect"
$oObject.document.execCommand("Unselect")
Case $sAction = "print"
$oObject.document.parentwindow.Print()
Case $sAction = "printdefault"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(printdefault)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.execWB(6, 2)
Case $sAction = "back"
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(back)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.GoBack()
Case $sAction = "blur"
$oObject.Blur()
Case $sAction = "forward"
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(forward)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.GoForward()
Case $sAction = "home"
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(home)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.GoHome()
Case $sAction = "invisible"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(invisible)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.visible = 0
Case $sAction = "visible"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(visible)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.visible = 1
Case $sAction = "search"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(search)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.GoSearch()
Case $sAction = "stop"
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(stop)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Stop()
Case $sAction = "quit"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(quit)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Quit()
If @error Then
__IEConsoleWriteError("Error", "_IEAction(" & $sAction & ")", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
$oObject = 0
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEAction(" & $sAction & ")", "$_IESTATUS_InvalidValue", "Invalid Action")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndSelect
If @error Then
__IEConsoleWriteError("Error", "_IEAction(" & $sAction & ")", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEPropertyGet(ByRef $oObject, $sProperty)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oTemp, $iTemp
$sProperty = StringLower($sProperty)
Select
Case $sProperty = "browserx"
If __IEIsObjType($oObject, "browsercontainer") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oTemp = $oObject
$iTemp = 0
While IsObj($oTemp)
$iTemp += $oTemp.offsetLeft
$oTemp = $oTemp.offsetParent
WEnd
Return SetError($_IESTATUS_Success, 0, $iTemp)
Case $sProperty = "browsery"
If __IEIsObjType($oObject, "browsercontainer") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oTemp = $oObject
$iTemp = 0
While IsObj($oTemp)
$iTemp += $oTemp.offsetTop
$oTemp = $oTemp.offsetParent
WEnd
Return SetError($_IESTATUS_Success, 0, $iTemp)
Case $sProperty = "screenx"
If __IEIsObjType($oObject, "window") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.left())
Else
$oTemp = $oObject
$iTemp = 0
While IsObj($oTemp)
$iTemp += $oTemp.offsetLeft
$oTemp = $oTemp.offsetParent
WEnd
EndIf
Return SetError($_IESTATUS_Success, 0,  $iTemp + $oObject.document.parentWindow.screenLeft)
Case $sProperty = "screeny"
If __IEIsObjType($oObject, "window") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.top())
Else
$oTemp = $oObject
$iTemp = 0
While IsObj($oTemp)
$iTemp += $oTemp.offsetTop
$oTemp = $oTemp.offsetParent
WEnd
EndIf
Return SetError($_IESTATUS_Success, 0,  $iTemp + $oObject.document.parentWindow.screenTop)
Case $sProperty = "height"
If __IEIsObjType($oObject, "window") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.Height())
Else
Return SetError($_IESTATUS_Success, 0, $oObject.offsetHeight)
EndIf
Case $sProperty = "width"
If __IEIsObjType($oObject, "window") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.Width())
Else
Return SetError($_IESTATUS_Success, 0, $oObject.offsetWidth)
EndIf
Case $sProperty = "isdisabled"
Return SetError($_IESTATUS_Success, 0, $oObject.isDisabled())
Case $sProperty = "addressbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.AddressBar())
Case $sProperty = "busy"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Busy())
Case $sProperty = "fullscreen"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.fullScreen())
Case $sProperty = "hwnd"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, HWnd($oObject.HWnd()))
Case $sProperty = "left"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Left())
Case $sProperty = "locationname"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.LocationName())
Case $sProperty = "locationurl"
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.locationURL())
EndIf
If __IEIsObjType($oObject, "window") Then
Return SetError($_IESTATUS_Success, 0, $oObject.location.href())
EndIf
If __IEIsObjType($oObject, "document") Then
Return SetError($_IESTATUS_Success, 0, $oObject.parentwindow.location.href())
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentwindow.location.href())
Case $sProperty = "menubar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.MenuBar())
Case $sProperty = "offline"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.OffLine())
Case $sProperty = "readystate"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.ReadyState())
Case $sProperty = "resizable"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Resizable())
Case $sProperty = "silent"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Silent())
Case $sProperty = "statusbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.StatusBar())
Case $sProperty = "statustext"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.StatusText())
Case $sProperty = "top"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Top())
Case $sProperty = "visible"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Visible())
Case $sProperty = "appcodename"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.appCodeName())
Case $sProperty = "appminorversion"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.appMinorVersion())
Case $sProperty = "appname"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.appName())
Case $sProperty = "appversion"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.appVersion())
Case $sProperty = "browserlanguage"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.browserLanguage())
Case $sProperty = "cookieenabled"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.cookieEnabled())
Case $sProperty = "cpuclass"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.cpuClass())
Case $sProperty = "javaenabled"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.javaEnabled())
Case $sProperty = "online"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.onLine())
Case $sProperty = "platform"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.platform())
Case $sProperty = "systemlanguage"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.systemLanguage())
Case $sProperty = "useragent"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.userAgent())
Case $sProperty = "userlanguage"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.userLanguage())
Case $sProperty = "referrer"
Return SetError($_IESTATUS_Success, 0, $oObject.document.referrer)
Case $sProperty = "theatermode"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.TheaterMode)
Case $sProperty = "toolbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.ToolBar)
Case $sProperty = "contenteditable"
If __IEIsObjType($oObject, "browser") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.isContentEditable)
Case $sProperty = "innertext"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.innerText)
Case $sProperty = "outertext"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.outerText)
Case $sProperty = "innerhtml"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.innerHTML)
Case $sProperty = "outerhtml"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.outerHTML)
Case $sProperty = "title"
Return SetError($_IESTATUS_Success, 0, $oObject.document.title)
Case $sProperty = "uniqueid"
If __IEIsObjType($oObject, "window") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
Else
Return SetError($_IESTATUS_Success, 0, $oObject.uniqueID)
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidValue", "Invalid Property")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndSelect
EndFunc
Func _IEPropertySet(ByRef $oObject, $sProperty, $vValue)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oTemp
#forceref $oTemp
$sProperty = StringLower($sProperty)
Select
Case $sProperty = "addressbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.AddressBar = $vValue
Case $sProperty = "height"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Height = $vValue
Case $sProperty = "left"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Left = $vValue
Case $sProperty = "menubar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.MenuBar = $vValue
Case $sProperty = "offline"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.OffLine = $vValue
Case $sProperty = "resizable"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Resizable = $vValue
Case $sProperty = "statusbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.StatusBar = $vValue
Case $sProperty = "statustext"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.StatusText = $vValue
Case $sProperty = "top"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Top = $vValue
Case $sProperty = "width"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Width = $vValue
Case $sProperty = "theatermode"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If $vValue Then
$oObject.TheaterMode = True
Else
$oObject.TheaterMode = False
EndIf
Case $sProperty = "toolbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If $vValue Then
$oObject.ToolBar = True
Else
$oObject.ToolBar = False
EndIf
Case $sProperty = "contenteditable"
If __IEIsObjType($oObject, "browser") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
If $vValue Then
$oTemp.contentEditable = "true"
Else
$oTemp.contentEditable = "false"
EndIf
Case $sProperty = "innertext"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
$oTemp.innerText = $vValue
Case $sProperty = "outertext"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
$oTemp.outerText = $vValue
Case $sProperty = "innerhtml"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
$oTemp.innerHTML = $vValue
Case $sProperty = "outerhtml"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
$oTemp.outerHTML = $vValue
Case $sProperty = "title"
$oObject.document.title = $vValue
Case $sProperty = "silent"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If $vValue Then
$oObject.silent = True
Else
$oObject.silent = False
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidValue", "Invalid Property")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndSelect
If @error Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEErrorNotify($vNotify = Default)
If $vNotify = Default Then Return $__g_bIEErrorNotify
If $vNotify Then
$__g_bIEErrorNotify = True
Else
$__g_bIEErrorNotify = False
EndIf
Return 1
EndFunc
Func _IEErrorHandlerRegister($sFunctionName = "__IEInternalErrorHandler")
$__g_oIEErrorHandler = ObjEvent("AutoIt.Error", $sFunctionName)
If IsObj($__g_oIEErrorHandler) Then
$__g_sIEUserErrorHandler = $sFunctionName
Return SetError($_IESTATUS_Success, 0, 1)
Else
$__g_oIEErrorHandler = ""
__IEConsoleWriteError("Error", "_IEErrorHandlerRegister", "$_IEStatus_GeneralError",  "Error Handler Not Registered - Check existance of error function")
Return SetError($_IEStatus_GeneralError, 1, 0)
EndIf
EndFunc
Func _IEErrorHandlerDeRegister()
$__g_sIEUserErrorHandler = ""
$__g_oIEErrorHandler = ""
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func __IEInternalErrorHandlerRegister()
Local $sCurrentErrorHandler = ObjEvent("AutoIt.Error")
If $sCurrentErrorHandler <> "" And Not IsObj($__g_oIEErrorHandler) Then
Return SetError($_IEStatus_GeneralError, 0, False)
EndIf
$__g_oIEErrorHandler = ObjEvent("AutoIt.Error", "__IEInternalErrorHandler")
If IsObj($__g_oIEErrorHandler) Then
Return SetError($_IESTATUS_Success, 0, True)
Else
$__g_oIEErrorHandler = ""
Return SetError($_IEStatus_GeneralError, 0, False)
EndIf
EndFunc
Func __IEInternalErrorHandlerDeRegister()
$__g_oIEErrorHandler = ""
If $__g_sIEUserErrorHandler <> "" Then
$__g_oIEErrorHandler = ObjEvent("AutoIt.Error", $__g_sIEUserErrorHandler)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func __IEInternalErrorHandler($oCOMError)
If $__g_bIEErrorNotify Or $__g_bIEAU3Debug Then ConsoleWrite("--> " & __COMErrorFormating($oCOMError, "----> $IEComError") & @CRLF)
SetError($_IEStatus_ComError)
Return
EndFunc
Func _IEQuit(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.quit()
If @error Then
__IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
$oObject = 0
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
#EndRegion Utility functions
#Region General
Func _IE_Introduction($sModule = "basic")
Local $sHTML = ""
Switch $sModule
Case "basic"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Introduction ("basic")</title>' & @CR
$sHTML &= '<style>body {font-family: Arial}' & @CR
$sHTML &= 'td {padding:6px}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '<table border=1 id="table1" style="width:600px;border-spacing:6px;">' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<h1>Welcome to IE.au3</h1>' & @CR
$sHTML &= 'IE.au3 is a UDF (User Defined Function) library for the ' & @CR
$sHTML &= '<a href="http://www.autoitscript.com">AutoIt</a> scripting language.' & @CR
$sHTML &= '<br>  ' & @CR
$sHTML &= 'IE.au3 allows you to either create or attach to an Internet Explorer browser and do ' & @CR
$sHTML &= 'just about anything you could do with it interactively with the mouse and ' & @CR
$sHTML &= 'keyboard, but do it through script.' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= 'You can navigate to pages, click links, fill and submit forms etc. You can ' & @CR
$sHTML &= 'also do things you cannot do interactively like change or rewrite page ' & @CR
$sHTML &= 'content and JavaScripts, read, parse and save page content and monitor and act ' & @CR
$sHTML &= 'upon browser "events".<br>' & @CR
$sHTML &= 'IE.au3 uses the COM interface in AutoIt to interact with the Internet Explorer ' & @CR
$sHTML &= 'object model and the DOM (Document Object Model) supported by the browser.' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= 'Here are some links for more information and helpful tools:<br>' & @CR
$sHTML &= 'Reference Material: ' & @CR
$sHTML &= '<ul>' & @CR
$sHTML &= '<li><a href="http://msdn1.microsoft.com/">MSDN (Microsoft Developer Network)</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/library/aa752084.aspx" target="_blank">InternetExplorer Object</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/library/ms531073.aspx" target="_blank">Document Object</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/ie/aa740473.aspx" target="_blank">Overviews and Tutorials</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/library/ms533029.aspx" target="_blank">DHTML Objects</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/library/ms533051.aspx" target="_blank">DHTML Events</a></li>' & @CR
$sHTML &= '</ul><br>' & @CR
$sHTML &= 'Helpful Tools: ' & @CR
$sHTML &= '<ul>' & @CR
$sHTML &= '<li><a href="http://www.autoitscript.com/forum/index.php?showtopic=19368" target="_blank">AutoIt IE Builder</a> (build IE scripts interactively)</li>' & @CR
$sHTML &= '<li><a href="http://www.debugbar.com/" target="_blank">DebugBar</a> (DOM inspector, HTTP inspector, HTML validator and more - free for personal use) Recommended</li>' & @CR
$sHTML &= '<li><a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=e59c3964-672d-4511-bb3e-2d5e1db91038&amp;displaylang=en" target="_blank">IE Developer Toolbar</a> (comprehensive DOM analysis tool)</li>' & @CR
$sHTML &= '<li><a href="http://slayeroffice.com/tools/modi/v2.0/modi_help.html" target="_blank">MODIV2</a> (view the DOM of a web page by mousing around)</li>' & @CR
$sHTML &= '<li><a href="http://validator.w3.org/" target="_blank">HTML Validator</a> (verify HTML follows format rules)</li>' & @CR
$sHTML &= '<li><a href="http://www.fiddlertool.com/fiddler/" target="_blank">Fiddler</a> (examine HTTP traffic)</li>' & @CR
$sHTML &= '</ul>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
Case Else
__IEConsoleWriteError("Error", "_IE_Introduction", "$_IESTATUS_InvalidValue")
Return SetError($_IESTATUS_InvalidValue, 1, 0)
EndSwitch
Local $oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
Return SetError($_IESTATUS_Success, 0, $oObject)
EndFunc
Func _IE_Example($sModule = "basic")
Local $sHTML = "", $oObject
Switch $sModule
Case "basic"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("basic")</title>' & @CR
$sHTML &= '<style>body {font-family: Arial}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '<a href="http://www.autoitscript.com"><img src="http://www.autoitscript.com/images/logo_autoit_210x72.png" id="AutoItImage" alt="AutoIt Homepage Image" style="background: #204080;"></a>' & @CR
$sHTML &= '<p></p>' & @CR
$sHTML &= '<div id="line1">This is a simple HTML page with text, links and images.</div>' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= '<div id="line2"><a href="http://www.autoitscript.com">AutoIt</a> is a wonderful automation scripting language.</div>' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= '<div id="line3">It is supported by a very active and supporting <a href="http://www.autoitscript.com/forum/">user forum</a>.</div>' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= '<div id="IEAu3Data"></div>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
Case "table"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=utf-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("table")</title>' & @CR
$sHTML &= '<style>body {font-family: Arial}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '$oTableOne = _IETableGetObjByName($oIE, "tableOne")<br>' & @CR
$sHTML &= '&lt;table border=1 id="tableOne"&gt;<br>' & @CR
$sHTML &= '<table border=1 id="tableOne">' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>AutoIt</td>' & @CR
$sHTML &= '		<td>is</td>' & @CR
$sHTML &= '		<td>really</td>' & @CR
$sHTML &= '		<td>great</td>' & @CR
$sHTML &= '		<td>with</td>' & @CR
$sHTML &= '		<td>IE.au3</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>1</td>' & @CR
$sHTML &= '		<td>2</td>' & @CR
$sHTML &= '		<td>3</td>' & @CR
$sHTML &= '		<td>4</td>' & @CR
$sHTML &= '		<td>5</td>' & @CR
$sHTML &= '		<td>6</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>the</td>' & @CR
$sHTML &= '		<td>quick</td>' & @CR
$sHTML &= '		<td>red</td>' & @CR
$sHTML &= '		<td>fox</td>' & @CR
$sHTML &= '		<td>jumped</td>' & @CR
$sHTML &= '		<td>over</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>the</td>' & @CR
$sHTML &= '		<td>lazy</td>' & @CR
$sHTML &= '		<td>brown</td>' & @CR
$sHTML &= '		<td>dog</td>' & @CR
$sHTML &= '		<td>the</td>' & @CR
$sHTML &= '		<td>time</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>has</td>' & @CR
$sHTML &= '		<td>come</td>' & @CR
$sHTML &= '		<td>for</td>' & @CR
$sHTML &= '		<td>all</td>' & @CR
$sHTML &= '		<td>good</td>' & @CR
$sHTML &= '		<td>men</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>to</td>' & @CR
$sHTML &= '		<td>come</td>' & @CR
$sHTML &= '		<td>to</td>' & @CR
$sHTML &= '		<td>the</td>' & @CR
$sHTML &= '		<td>aid</td>' & @CR
$sHTML &= '		<td>of</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= '$oTableTwo = _IETableGetObjByName($oIE, "tableTwo")<br>' & @CR
$sHTML &= '&lt;table border="1" id="tableTwo"&gt;<br>' & @CR
$sHTML &= '<table border=1 id="tableTwo">' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td colspan="4">Table Top</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>One</td>' & @CR
$sHTML &= '		<td colspan="3">Two</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>Three</td>' & @CR
$sHTML &= '		<td>Four</td>' & @CR
$sHTML &= '		<td colspan="2">Five</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>Six</td>' & @CR
$sHTML &= '		<td colspan="3">Seven</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>Eight</td>' & @CR
$sHTML &= '		<td>Nine</td>' & @CR
$sHTML &= '		<td>Ten</td>' & @CR
$sHTML &= '		<td>Eleven</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
Case "form"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("form")</title>' & @CR
$sHTML &= '<style>body {font-family: Arial}' & @CR
$sHTML &= 'td {padding:6px}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '<form name="ExampleForm" onSubmit="javascript:alert(''ExampleFormSubmitted'');" method="post">' & @CR
$sHTML &= '<table style="border-spacing:6px 6px;" border=1>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>ExampleForm</td>' & @CR
$sHTML &= '<td>&lt;form name="ExampleForm" onSubmit="javascript:alert(''ExampleFormSubmitted'');" method="post"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>Hidden Input Element<input type="hidden" name="hiddenExample" value="secret value"></td>' & @CR
$sHTML &= '<td>&lt;input type="hidden" name="hiddenExample" value="secret value"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="text" name="textExample" value="http://" size="20" maxlength="30">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="text" name="textExample" value="http://" size="20" maxlength="30"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="password" name="passwordExample" size="10">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="password" name="passwordExample" size="10"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="file" name="fileExample">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="file" name="fileExample"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="image" name="imageExample" alt="AutoIt Homepage" src="http://www.autoitscript.com/images/logo_autoit_210x72.png" style="background: #204080;>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="image" name="imageExample" alt="AutoIt Homepage" src="http://www.autoitscript.com/images/logo_autoit_210x72.png"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<textarea name="textareaExample" rows="5" cols="15">Hello!</textarea>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;textarea name="textareaExample" rows="5" cols="15"&gt;Hello!&lt;/textarea&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="checkbox" name="checkboxG1Example" value="gameBasketball">Basketball<br>' & @CR
$sHTML &= '<input type="checkbox" name="checkboxG1Example" value="gameFootball">Football<br>' & @CR
$sHTML &= '<input type="checkbox" name="checkboxG2Example" value="gameTennis" checked>Tennis<br>' & @CR
$sHTML &= '<input type="checkbox" name="checkboxG2Example" value="gameBaseball">Baseball' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="checkbox" name="checkboxG1Example" value="gameBasketball"&gt;Basketball&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="checkbox" name="checkboxG1Example" value="gameFootball"&gt;Football&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="checkbox" name="checkboxG2Example" value="gameTennis" checked&gt;Tennis&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="checkbox" name="checkboxG2Example" value="gameBaseball"&gt;Baseball</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="radio" name="radioExample" value="vehicleAirplane">Airplane<br>' & @CR
$sHTML &= '<input type="radio" name="radioExample" value="vehicleTrain" checked>Train<br>' & @CR
$sHTML &= '<input type="radio" name="radioExample" value="vehicleBoat">Boat<br>' & @CR
$sHTML &= '<input type="radio" name="radioExample" value="vehicleCar">Car</td>' & @CR
$sHTML &= '<td>&lt;input type="radio" name="radioExample" value="vehicleAirplane"&gt;Airplane&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="radio" name="radioExample" value="vehicleTrain" checked&gt;Train&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="radio" name="radioExample" value="vehicleBoat"&gt;Boat&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="radio" name="radioExample" value="vehicleCar"&gt;Car&lt;br&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<select name="selectExample">' & @CR
$sHTML &= '<option value="homepage.html">Homepage' & @CR
$sHTML &= '<option value="midipage.html">Midipage' & @CR
$sHTML &= '<option value="freepage.html">Freepage' & @CR
$sHTML &= '</select>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;select name="selectExample"&gt;<br>' & @CR
$sHTML &= '&lt;option value="homepage.html"&gt;Homepage<br>' & @CR
$sHTML &= '&lt;option value="midipage.html"&gt;Midipage<br>' & @CR
$sHTML &= '&lt;option value="freepage.html"&gt;Freepage<br>' & @CR
$sHTML &= '&lt;/select&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<select name="multipleSelectExample" size="6" multiple>' & @CR
$sHTML &= '<option value="Name1">Aaron' & @CR
$sHTML &= '<option value="Name2">Bruce' & @CR
$sHTML &= '<option value="Name3">Carlos' & @CR
$sHTML &= '<option value="Name4">Denis' & @CR
$sHTML &= '<option value="Name5">Ed' & @CR
$sHTML &= '<option value="Name6">Freddy' & @CR
$sHTML &= '</select>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;select name="multipleSelectExample" size="6" multiple&gt;<br>' & @CR
$sHTML &= '&lt;option value="Name1"&gt;Aaron<br>' & @CR
$sHTML &= '&lt;option value="Name2"&gt;Bruce<br>' & @CR
$sHTML &= '&lt;option value="Name3"&gt;Carlos<br>' & @CR
$sHTML &= '&lt;option value="Name4"&gt;Denis<br>' & @CR
$sHTML &= '&lt;option value="Name5"&gt;Ed<br>' & @CR
$sHTML &= '&lt;option value="Name6"&gt;Freddy<br>' & @CR
$sHTML &= '&lt;/select&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input name="submitExample" type="submit" value="Submit">' & @CR
$sHTML &= '<input name="resetExample" type="reset" value="Reset">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input name="submitExample" type="submit" value="Submit"&gt;<br>' & @CR
$sHTML &= '&lt;input name="resetExample" type="reset" value="Reset"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '<input type="hidden" name="hiddenExample" value="secret value">' & @CR
$sHTML &= '</form>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
Case "frameset"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("frameset")</title>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<frameset rows="25,200">' & @CR
$sHTML &= '	<frame name=Top SRC=about:blank>' & @CR
$sHTML &= '	<frameset cols="100,500">' & @CR
$sHTML &= '		<frame name=Menu SRC=about:blank>' & @CR
$sHTML &= '		<frame name=Main SRC=about:blank>' & @CR
$sHTML &= '	</frameset>' & @CR
$sHTML &= '</frameset>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
_IEAction($oObject, "refresh")
Local $oFrameTop = _IEFrameGetObjByName($oObject, "Top")
Local $oFrameMenu = _IEFrameGetObjByName($oObject, "Menu")
Local $oFrameMain = _IEFrameGetObjByName($oObject, "Main")
_IEBodyWriteHTML($oFrameTop, '$oFrameTop = _IEFrameGetObjByName($oIE, "Top")')
_IEBodyWriteHTML($oFrameMenu, '$oFrameMenu = _IEFrameGetObjByName($oIE, "Menu")')
_IEBodyWriteHTML($oFrameMain, '$oFrameMain = _IEFrameGetObjByName($oIE, "Main")')
Case "iframe"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("iframe")</title>' & @CR
$sHTML &= '<style>td {padding:6px}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '<table style="border-spacing:6px" border=1>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td><iframe name="iFrameOne" src="about:blank" title="iFrameOne"></iframe></td>' & @CR
$sHTML &= '<td>&lt;iframe name="iFrameOne" src="about:blank" title="iFrameOne"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td><iframe name="iFrameTwo" src="about:blank" title="iFrameTwo"></iframe></td>' & @CR
$sHTML &= '<td>&lt;iframe name="iFrameTwo" src="about:blank" title="iFrameTwo"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
_IEAction($oObject, "refresh")
Local $oIFrameOne = _IEFrameGetObjByName($oObject, "iFrameOne")
Local $oIFrameTwo = _IEFrameGetObjByName($oObject, "iFrameTwo")
_IEBodyWriteHTML($oIFrameOne, '$oIFrameOne = _IEFrameGetObjByName($oIE, "iFrameOne")')
_IEBodyWriteHTML($oIFrameTwo, '$oIFrameTwo = _IEFrameGetObjByName($oIE, "iFrameTwo")')
Case Else
__IEConsoleWriteError("Error", "_IE_Example", "$_IESTATUS_InvalidValue")
Return SetError($_IESTATUS_InvalidValue, 1, 0)
EndSwitch
Sleep(500)
Return SetError($_IESTATUS_Success, 0, $oObject)
EndFunc
Func _IE_VersionInfo()
__IEConsoleWriteError("Information", "_IE_VersionInfo", "version " &  $__gaIEAU3VersionInfo[0] &  $__gaIEAU3VersionInfo[1] & "." &  $__gaIEAU3VersionInfo[2] & "-" &  $__gaIEAU3VersionInfo[3], "Release date: " & $__gaIEAU3VersionInfo[4])
Return SetError($_IESTATUS_Success, 0, $__gaIEAU3VersionInfo)
EndFunc
#EndRegion General
#Region Internal functions
Func __IELockSetForegroundWindow($iLockCode)
Local $aRet = DllCall("user32.dll", "bool", "LockSetForegroundWindow", "uint", $iLockCode)
If @error Or Not $aRet[0] Then Return SetError(1, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func __IEControlGetObjFromHWND(ByRef $hWin)
DllCall("ole32.dll", "long", "CoInitialize", "ptr", 0)
If @error Then Return SetError(2, @error, 0)
Local Const $WM_HTML_GETOBJECT = __IERegisterWindowMessage("WM_HTML_GETOBJECT")
Local Const $SMTO_ABORTIFHUNG = 0x0002
Local $iResult
__IESendMessageTimeout($hWin, $WM_HTML_GETOBJECT, 0, 0, $SMTO_ABORTIFHUNG, 1000, $iResult)
Local $tUUID = DllStructCreate("int;short;short;byte[8]")
DllStructSetData($tUUID, 1, 0x626FC520)
DllStructSetData($tUUID, 2, 0xA41E)
DllStructSetData($tUUID, 3, 0x11CF)
DllStructSetData($tUUID, 4, 0xA7, 1)
DllStructSetData($tUUID, 4, 0x31, 2)
DllStructSetData($tUUID, 4, 0x0, 3)
DllStructSetData($tUUID, 4, 0xA0, 4)
DllStructSetData($tUUID, 4, 0xC9, 5)
DllStructSetData($tUUID, 4, 0x8, 6)
DllStructSetData($tUUID, 4, 0x26, 7)
DllStructSetData($tUUID, 4, 0x37, 8)
Local $aRet = DllCall("oleacc.dll", "long", "ObjectFromLresult", "lresult", $iResult, "struct*", $tUUID,  "wparam", 0, "idispatch*", 0)
If @error Then Return SetError(3, @error, 0)
If IsObj($aRet[4]) Then
Local $oIE = $aRet[4].Script()
Return $oIE.Document.parentwindow
Else
Return SetError(1, $aRet[0], 0)
EndIf
EndFunc
Func __IERegisterWindowMessage($sMsg)
Local $aRet = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMsg)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 0 Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func __IESendMessageTimeout($hWnd, $iMsg, $wParam, $lParam, $iFlags, $iTimeout, ByRef $vOut, $r = 0, $sT1 = "int", $sT2 = "int")
Local $aRet = DllCall("user32.dll", "lresult", "SendMessageTimeout", "hwnd", $hWnd, "uint", $iMsg, $sT1, $wParam,  $sT2, $lParam, "uint", $iFlags, "uint", $iTimeout, "dword_ptr*", "")
If @error Or $aRet[0] = 0 Then
$vOut = 0
Return SetError(1, _WinAPI_GetLastError(), 0)
EndIf
$vOut = $aRet[7]
If $r >= 0 And $r <= 4 Then Return $aRet[$r]
Return $aRet
EndFunc
Func __IEIsObjType(ByRef $oObject, $sType, $bRegister = True)
If Not IsObj($oObject) Then
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $bStatus = $bRegister
If $bRegister Then
$bStatus = __IEInternalErrorHandlerRegister()
If Not $bStatus Then __IEConsoleWriteError("Warning", "internal function __IEIsObjType",  "Cannot register internal error handler, cannot trap COM errors",  "Use _IEErrorHandlerRegister() to register a user error handler")
EndIf
Local $iNotifyStatus = _IEErrorNotify()
_IEErrorNotify(False)
Local $sName = String(ObjName($oObject)), $iErrorStatus = $_IESTATUS_InvalidObjectType
Switch $sType
Case "browserdom"
If __IEIsObjType($oObject, "documentcontainer", False) Then
$iErrorStatus = $_IESTATUS_Success
ElseIf __IEIsObjType($oObject, "document", False) Then
$iErrorStatus = $_IESTATUS_Success
Else
Local $oTemp = $oObject.document
If __IEIsObjType($oTemp, "document", False) Then
$iErrorStatus = $_IESTATUS_Success
EndIf
EndIf
Case "browser"
If ($sName = "IWebBrowser2") Or ($sName = "IWebBrowser") Or ($sName = "WebBrowser") Then $iErrorStatus = $_IESTATUS_Success
Case "window"
If $sName = "HTMLWindow2" Then $iErrorStatus = $_IESTATUS_Success
Case "documentContainer"
If __IEIsObjType($oObject, "window", False) Or __IEIsObjType($oObject, "browser", False) Then $iErrorStatus = $_IESTATUS_Success
Case "document"
If $sName = "HTMLDocument" Then $iErrorStatus = $_IESTATUS_Success
Case "table"
If $sName = "HTMLTable" Then $iErrorStatus = $_IESTATUS_Success
Case "form"
If $sName = "HTMLFormElement" Then $iErrorStatus = $_IESTATUS_Success
Case "forminputelement"
If ($sName = "HTMLInputElement") Or ($sName = "HTMLSelectElement") Or ($sName = "HTMLTextAreaElement") Then $iErrorStatus = $_IESTATUS_Success
Case "elementcollection"
If ($sName = "HTMLElementCollection") Then $iErrorStatus = $_IESTATUS_Success
Case "formselectelement"
If $sName = "HTMLSelectElement" Then $iErrorStatus = $_IESTATUS_Success
Case Else
$iErrorStatus = $_IESTATUS_InvalidValue
EndSwitch
_IEErrorNotify($iNotifyStatus)
If $bRegister Then
__IEInternalErrorHandlerDeRegister()
EndIf
If $iErrorStatus = $_IESTATUS_Success Then
Return SetError($_IESTATUS_Success, 0, 1)
Else
Return SetError($iErrorStatus, 1, 0)
EndIf
EndFunc
Func __IEConsoleWriteError($sSeverity, $sFunc, $sMessage = Default, $sStatus = Default)
If $__g_bIEErrorNotify Or $__g_bIEAU3Debug Then
Local $sStr = "--> IE.au3 " & $__gaIEAU3VersionInfo[5] & " " & $sSeverity & " from function " & $sFunc
If Not ($sMessage = Default) Then $sStr &= ", " & $sMessage
If Not ($sStatus = Default) Then $sStr &= " (" & $sStatus & ")"
ConsoleWrite($sStr & @CRLF)
EndIf
Return SetError($sStatus, 0, 1)
EndFunc
Func __IEComErrorUnrecoverable($iError)
Switch $iError
Case -2147352567
Return $_IESTATUS_AccessIsDenied
Case -2147024891
Return $_IESTATUS_AccessIsDenied
Case -2147417848
Return $_IESTATUS_ClientDisconnected
Case -2147023174
Return $_IESTATUS_ClientDisconnected
Case -2147023179
Return $_IESTATUS_ClientDisconnected
Case Else
Return $_IESTATUS_Success
EndSwitch
EndFunc
#EndRegion Internal functions
#Region ProtoType Functions
Func __IENavigate(ByRef $oObject, $sUrl, $iWait = 1, $iFags = 0, $sTarget = "", $sPostdata = "", $sHeaders = "")
__IEConsoleWriteError("Warning", "__IENavigate", "Unsupported function called. Not fully tested.")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "__IENavigate", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "__IENavigate", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.navigate($sUrl, $iFags, $sTarget, $sPostdata, $sHeaders)
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, $oObject)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject)
EndFunc
Func __IEStringToBstr($sString, $sCharSet = "us-ascii")
Local Const $iTypeBinary = 1, $iTypeText = 2
Local $oStream = ObjCreate("ADODB.Stream")
$oStream.type = $iTypeText
$oStream.CharSet = $sCharSet
$oStream.Open
$oStream.WriteText($sString)
$oStream.Position = 0
$oStream.type = $iTypeBinary
$oStream.Position = 0
Return $oStream.Read()
EndFunc
Func __IEBstrToString($oBstr, $sCharSet = "us-ascii")
Local Const $iTypeBinary = 1, $iTypeText = 2
Local $oStream = ObjCreate("ADODB.Stream")
$oStream.type = $iTypeBinary
$oStream.Open
$oStream.Write($oBstr)
$oStream.Position = 0
$oStream.type = $iTypeText
$oStream.CharSet = $sCharSet
$oStream.Position = 0
Return $oStream.ReadText()
EndFunc
Func __IECreateNewIE($sTitle, $sHead = "", $sBody = "")
Local $sTemp = __IETempFile("", "~IE~", ".htm")
If @error Then
__IEConsoleWriteError("Error", "_IECreateHTA", "", "Error creating temporary file in @TempDir or @ScriptDir")
Return SetError($_IESTATUS_GeneralError, 1, 0)
EndIf
Local $sHTML = ''
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>' & $sTemp & '</title>' & @CR & $sHead & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR & $sBody & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
Local $hFile = FileOpen($sTemp, $FO_OVERWRITE)
FileWrite($hFile, $sHTML)
FileClose($hFile)
If @error Then
__IEConsoleWriteError("Error", "_IECreateNewIE", "", "Error creating temporary file in @TempDir or @ScriptDir")
Return SetError($_IESTATUS_GeneralError, 2, 0)
EndIf
Run(@ProgramFilesDir & "\Internet Explorer\iexplore.exe " & $sTemp)
Local $iPID
If WinWait($sTemp, "", 60) Then
$iPID = WinGetProcess($sTemp)
Else
__IEConsoleWriteError("Error", "_IECreateNewIE", "", "Timeout waiting for new IE window creation")
Return SetError($_IESTATUS_GeneralError, 3, 0)
EndIf
If Not FileDelete($sTemp) Then
__IEConsoleWriteError("Warning", "_IECreateNewIE", "", "Could not delete temporary file " & FileGetLongName($sTemp))
EndIf
Local $oObject = _IEAttach($sTemp)
_IELoadWait($oObject)
_IEPropertySet($oObject, "title", $sTitle)
Return SetError($_IESTATUS_Success, $iPID, $oObject)
EndFunc
Func __IETempFile($sDirectoryName = @TempDir, $sFilePrefix = "~", $sFileExtension = ".tmp", $iRandomLength = 7)
Local $sTempName, $iTmp = 0
If Not FileExists($sDirectoryName) Then $sDirectoryName = @TempDir
If Not FileExists($sDirectoryName) Then $sDirectoryName = @ScriptDir
If StringRight($sDirectoryName, 1) <> "\" Then $sDirectoryName = $sDirectoryName & "\"
Do
$sTempName = ""
While StringLen($sTempName) < $iRandomLength
$sTempName = $sTempName & Chr(Random(97, 122, 1))
WEnd
$sTempName = $sDirectoryName & $sFilePrefix & $sTempName & $sFileExtension
$iTmp += 1
If $iTmp > 200 Then
Return SetError($_IESTATUS_GeneralError, 1, 0)
EndIf
Until Not FileExists($sTempName)
Return $sTempName
EndFunc
#EndRegion ProtoType Functions
Global Const $INET_LOCALCACHE = 0
Global Const $INET_FORCERELOAD = 1
Global Const $INET_IGNORESSL = 2
Global Const $INET_ASCIITRANSFER = 4
Global Const $INET_BINARYTRANSFER = 8
Global Const $INET_FORCEBYPASS = 16
Global Const $INET_DOWNLOADWAIT = 0
Global Const $INET_DOWNLOADBACKGROUND = 1
Global Const $INET_DOWNLOADREAD = 0
Global Const $INET_DOWNLOADSIZE = 1
Global Const $INET_DOWNLOADCOMPLETE = 2
Global Const $INET_DOWNLOADSUCCESS = 3
Global Const $INET_DOWNLOADERROR = 4
Global Const $INET_DOWNLOADEXTENDED = 5
Func _GetIP()
Local Const $GETIP_TIMER = 300000
Local Static $hTimer = 0
Local Static $sLastIP = 0
If TimerDiff($hTimer) < $GETIP_TIMER And Not $sLastIP Then
Return SetExtended(1, $sLastIP)
EndIf
Local $aGetIPURL = ["https://api.ipify.org", "http://checkip.dyndns.org", "http://www.myexternalip.com/raw", "http://bot.whatismyipaddress.com"],  $aReturn = 0,  $sReturn = ""
For $i = 0 To UBound($aGetIPURL) - 1
$sReturn = InetRead($aGetIPURL[$i])
If @error Or $sReturn == "" Then ContinueLoop
$aReturn = StringRegExp(BinaryToString($sReturn), "((?:\d{1,3}\.){3}\d{1,3})", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$sReturn = $aReturn[0]
ExitLoop
EndIf
$sReturn = ""
Next
$hTimer = TimerInit()
$sLastIP = $sReturn
If $sReturn == "" Then Return SetError(1, 0, -1)
Return $sReturn
EndFunc
Func _INetExplorerCapable($sIEString)
If StringLen($sIEString) <= 0 Then Return SetError(1, 0, '')
Local $s_IEReturn
Local $n_IEChar
For $i_IECount = 1 To StringLen($sIEString)
$n_IEChar = '0x' & Hex(Asc(StringMid($sIEString, $i_IECount, 1)), 2)
If $n_IEChar < 0x21 Or $n_IEChar = 0x25 Or $n_IEChar = 0x2f Or $n_IEChar > 0x7f Then
$s_IEReturn = $s_IEReturn & '%' & StringRight($n_IEChar, 2)
Else
$s_IEReturn = $s_IEReturn & Chr($n_IEChar)
EndIf
Next
Return $s_IEReturn
EndFunc
Func _INetGetSource($sURL, $bString = True)
Local $sString = InetRead($sURL, $INET_FORCERELOAD)
Local $iError = @error, $iExtended = @extended
If $bString = Default Or $bString Then $sString = BinaryToString($sString)
Return SetError($iError, $iExtended, $sString)
EndFunc
Func _INetMail($sMailTo, $sMailSubject, $sMailBody)
Local $iPrev = Opt("ExpandEnvStrings", 1)
Local $sVar, $sDflt = RegRead('HKCU\Software\Clients\Mail', "")
If $sDflt = "Windows Live Mail" Then
$sVar = RegRead('HKCR\WLMail.Url.Mailto\Shell\open\command', "")
Else
$sVar = RegRead('HKCR\mailto\shell\open\command', "")
EndIf
Local $iRet = Run(StringReplace($sVar, '%1', _INetExplorerCapable('mailto:' & $sMailTo & '?subject=' & $sMailSubject & '&body=' & $sMailBody)))
Local $iError = @error, $iExtended = @extended
Opt("ExpandEnvStrings", $iPrev)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func _INetSmtpMail($sSMTPServer, $sFromName, $sFromAddress, $sToAddress, $sSubject = "", $aBody = "", $sEHLO = "", $sFirst = "", $bTrace = 0)
If $sSMTPServer = "" Or $sFromAddress = "" Or $sToAddress = "" Or $sFromName = "" Or StringLen($sFromName) > 256 Then Return SetError(1, 0, 0)
If $sEHLO = "" Then $sEHLO = @ComputerName
If TCPStartup() = 0 Then Return SetError(2, 0, 0)
Local $s_IPAddress, $i_Count
If StringRegExp($sSMTPServer, "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$") Then
$s_IPAddress = $sSMTPServer
Else
$s_IPAddress = TCPNameToIP($sSMTPServer)
EndIf
If $s_IPAddress = "" Then
TCPShutdown()
Return SetError(3, 0, 0)
EndIf
Local $vSocket = TCPConnect($s_IPAddress, 25)
If $vSocket = -1 Then
TCPShutdown()
Return SetError(4, 0, 0)
EndIf
Local $aSend[6], $aReplyCode[6]
$aSend[0] = "HELO " & $sEHLO & @CRLF
If StringLeft($sEHLO, 5) = "EHLO " Then $aSend[0] = $sEHLO & @CRLF
$aReplyCode[0] = "250"
$aSend[1] = "MAIL FROM: <" & $sFromAddress & ">" & @CRLF
$aReplyCode[1] = "250"
$aSend[2] = "RCPT TO: <" & $sToAddress & ">" & @CRLF
$aReplyCode[2] = "250"
$aSend[3] = "DATA" & @CRLF
$aReplyCode[3] = "354"
Local $aResult = _Date_Time_GetTimeZoneInformation()
Local $iBias = -$aResult[1] / 60
Local $iBiasH = Int($iBias)
Local $iBiasM = 0
If $iBiasH <> $iBias Then $iBiasM = Abs($iBias - $iBiasH) * 60
$iBias = StringFormat(" (%+.2d%.2d)", $iBiasH, $iBiasM)
$aSend[4] = "From:" & $sFromName & "<" & $sFromAddress & ">" & @CRLF &  "To:" & "<" & $sToAddress & ">" & @CRLF &  "Subject:" & $sSubject & @CRLF &  "Mime-Version: 1.0" & @CRLF &  "Date: " & _DateDayOfWeek(@WDAY, 1) & ", " & @MDAY & " " & _DateToMonth(@MON, 1) & " " & @YEAR & " " & @HOUR & ":" & @MIN & ":" & @SEC & $iBias & @CRLF &  "Content-Type: text/plain; charset=US-ASCII" & @CRLF &  @CRLF
$aReplyCode[4] = ""
$aSend[5] = @CRLF & "." & @CRLF
$aReplyCode[5] = "250"
If __SmtpSend($vSocket, $aSend[0], $aReplyCode[0], $bTrace, "220", $sFirst) Then Return SetError(50, 0, 0)
For $i_Count = 1 To UBound($aSend) - 2
If __SmtpSend($vSocket, $aSend[$i_Count], $aReplyCode[$i_Count], $bTrace) Then Return SetError(50 + $i_Count, 0, 0)
Next
For $i_Count = 0 To UBound($aBody) - 1
If StringLeft($aBody[$i_Count], 1) = "." Then $aBody[$i_Count] = "." & $aBody[$i_Count]
If __SmtpSend($vSocket, $aBody[$i_Count] & @CRLF, "", $bTrace) Then Return SetError(500 + $i_Count, 0, 0)
Next
$i_Count = UBound($aSend) - 1
If __SmtpSend($vSocket, $aSend[$i_Count], $aReplyCode[$i_Count], $bTrace) Then Return SetError(5000, 0, 0)
TCPCloseSocket($vSocket)
TCPShutdown()
Return 1
EndFunc
Func __SmtpTrace($sStr, $iTimeout = 0)
Local $sW_TITLE = "SMTP trace"
Local $sSmtpTrace = ControlGetText($sW_TITLE, "", "Static1")
$sStr = StringLeft(StringReplace($sStr, @CRLF, ""), 70)
$sSmtpTrace &= @HOUR & ":" & @MIN & ":" & @SEC & " " & $sStr & @LF
If WinExists($sW_TITLE) Then
ControlSetText($sW_TITLE, "", "Static1", $sSmtpTrace)
Else
SplashTextOn($sW_TITLE, $sSmtpTrace, 400, 500, 500, 100, 4 + 16, "", 8)
EndIf
If $iTimeout Then Sleep($iTimeout * 1000)
EndFunc
Func __SmtpSend($vSocket, $sSend, $sReplyCode, $bTrace, $sIntReply = "", $sFirst = "")
Local $sReceive, $i, $hTimer
If $bTrace Then __SmtpTrace($sSend)
If $sIntReply <> "" Then
If $sFirst <> -1 Then
If TCPSend($vSocket, $sFirst) = 0 Then
TCPCloseSocket($vSocket)
TCPShutdown()
Return 1
EndIf
EndIf
$sReceive = ""
$hTimer = TimerInit()
While StringLeft($sReceive, StringLen($sIntReply)) <> $sIntReply And TimerDiff($hTimer) < 45000
$sReceive = TCPRecv($vSocket, 1000)
If $bTrace And $sReceive <> "" Then __SmtpTrace("intermediate->" & $sReceive)
WEnd
EndIf
If TCPSend($vSocket, $sSend) = 0 Then
TCPCloseSocket($vSocket)
TCPShutdown()
Return 1
EndIf
$hTimer = TimerInit()
$sReceive = ""
While $sReceive = "" And TimerDiff($hTimer) < 45000
$i += 1
$sReceive = TCPRecv($vSocket, 1000)
If $sReplyCode = "" Then ExitLoop
WEnd
If $sReplyCode <> "" Then
If $bTrace Then __SmtpTrace($i & " <- " & $sReceive)
If StringLeft($sReceive, StringLen($sReplyCode)) <> $sReplyCode Then
TCPCloseSocket($vSocket)
TCPShutdown()
If $bTrace Then __SmtpTrace("<-> " & $sReplyCode, 5)
Return 2
EndIf
EndIf
Return 0
EndFunc
Func _TCPIpToName($sIp, $iOption = Default, $hDll = Default)
Local $iINADDR_NONE = 0xffffffff, $iAF_INET = 2, $sSeparator = @CR
If $iOption = Default Then $iOption = 0
If $hDll = Default Then $hDll = "ws2_32.dll"
Local $avDllCall = DllCall($hDll, "ulong", "inet_addr", "STR", $sIp)
If @error Then Return SetError(1, 0, "")
Local $vBinIP = $avDllCall[0]
If $vBinIP = $iINADDR_NONE Then Return SetError(2, 0, "")
$avDllCall = DllCall($hDll, "ptr", "gethostbyaddr", "ptr*", $vBinIP, "int", 4, "int", $iAF_INET)
If @error Then Return SetError(3, 0, "")
Local $pvHostent = $avDllCall[0]
If $pvHostent = 0 Then
$avDllCall = DllCall($hDll, "int", "WSAGetLastError")
If @error Then Return SetError(5, 0, "")
Return SetError(4, $avDllCall[0], "")
EndIf
Local $tHostent = DllStructCreate("ptr;ptr;short;short;ptr", $pvHostent)
Local $sHostnames = __TCPIpToName_szStringRead(DllStructGetData($tHostent, 1))
If @error Then Return SetError(6, 0, $sHostnames)
If $iOption = 1 Then
Local $tAliases
$sHostnames &= $sSeparator
For $i = 0 To 63
$tAliases = DllStructCreate("ptr", DllStructGetData($tHostent, 2) + ($i * 4))
If DllStructGetData($tAliases, 1) = 0 Then ExitLoop
$sHostnames &= __TCPIpToName_szStringRead(DllStructGetData($tAliases, 1))
If @error Then
SetError(7)
ExitLoop
EndIf
Next
Return StringSplit(StringStripWS($sHostnames, $STR_STRIPTRAILING), @CR)
Else
Return $sHostnames
EndIf
EndFunc
Func __TCPIpToName_szStringRead($pStr, $iLen = -1)
Local $tString
If $pStr < 1 Then Return ""
If $iLen < 0 Then $iLen = _WinAPI_StrLen($pStr, False)
$tString = DllStructCreate("char[" & $iLen & "]", $pStr)
If @error Then Return SetError(2, 0, "")
Return SetExtended($iLen, DllStructGetData($tString, 1))
EndFunc
Global Const $FW_DONTCARE = 0
Global Const $FW_THIN = 100
Global Const $FW_EXTRALIGHT = 200
Global Const $FW_ULTRALIGHT = 200
Global Const $FW_LIGHT = 300
Global Const $FW_NORMAL = 400
Global Const $FW_REGULAR = 400
Global Const $FW_MEDIUM = 500
Global Const $FW_SEMIBOLD = 600
Global Const $FW_DEMIBOLD = 600
Global Const $FW_BOLD = 700
Global Const $FW_EXTRABOLD = 800
Global Const $FW_ULTRABOLD = 800
Global Const $FW_HEAVY = 900
Global Const $FW_BLACK = 900
Global Const $CF_EFFECTS = 0x100
Global Const $CF_PRINTERFONTS = 0x2
Global Const $CF_SCREENFONTS = 0x1
Global Const $CF_NOSCRIPTSEL = 0x800000
Global Const $CF_INITTOLOGFONTSTRUCT = 0x40
Global Const $LOGPIXELSX = 88
Global Const $LOGPIXELSY = 90
Global Const $ANSI_CHARSET = 0
Global Const $ARABIC_CHARSET = 178
Global Const $BALTIC_CHARSET = 186
Global Const $CHINESEBIG5_CHARSET = 136
Global Const $DEFAULT_CHARSET = 1
Global Const $EASTEUROPE_CHARSET = 238
Global Const $GB2312_CHARSET = 134
Global Const $GREEK_CHARSET = 161
Global Const $HANGEUL_CHARSET = 129
Global Const $HEBREW_CHARSET = 177
Global Const $JOHAB_CHARSET = 130
Global Const $MAC_CHARSET = 77
Global Const $OEM_CHARSET = 255
Global Const $RUSSIAN_CHARSET = 204
Global Const $SHIFTJIS_CHARSET = 128
Global Const $SYMBOL_CHARSET = 2
Global Const $THAI_CHARSET = 222
Global Const $TURKISH_CHARSET = 162
Global Const $VIETNAMESE_CHARSET = 163
Global Const $OUT_CHARACTER_PRECIS = 2
Global Const $OUT_DEFAULT_PRECIS = 0
Global Const $OUT_DEVICE_PRECIS = 5
Global Const $OUT_OUTLINE_PRECIS = 8
Global Const $OUT_PS_ONLY_PRECIS = 10
Global Const $OUT_RASTER_PRECIS = 6
Global Const $OUT_STRING_PRECIS = 1
Global Const $OUT_STROKE_PRECIS = 3
Global Const $OUT_TT_ONLY_PRECIS = 7
Global Const $OUT_TT_PRECIS = 4
Global Const $CLIP_CHARACTER_PRECIS = 1
Global Const $CLIP_DEFAULT_PRECIS = 0
Global Const $CLIP_DFA_DISABLE = 0x0030
Global Const $CLIP_EMBEDDED = 128
Global Const $CLIP_LH_ANGLES = 16
Global Const $CLIP_MASK = 0xF
Global Const $CLIP_DFA_OVERRIDE = 0x0040
Global Const $CLIP_STROKE_PRECIS = 2
Global Const $CLIP_TT_ALWAYS = 32
Global Const $ANTIALIASED_QUALITY = 4
Global Const $DEFAULT_QUALITY = 0
Global Const $DRAFT_QUALITY = 1
Global Const $NONANTIALIASED_QUALITY = 3
Global Const $PROOF_QUALITY = 2
Global Const $CLEARTYPE_QUALITY = 5
Global Const $DEFAULT_PITCH = 0
Global Const $FIXED_PITCH = 1
Global Const $VARIABLE_PITCH = 2
Global Const $FF_DECORATIVE = 80
Global Const $FF_DONTCARE = 0
Global Const $FF_MODERN = 48
Global Const $FF_ROMAN = 16
Global Const $FF_SCRIPT = 64
Global Const $FF_SWISS = 32
Global Const $FS_REGULAR = 0x00
Global Const $FS_BOLD = 0x01
Global Const $FS_ITALIC = 0x02
Global Const $__MISCCONSTANT_CC_ANYCOLOR = 0x0100
Global Const $__MISCCONSTANT_CC_FULLOPEN = 0x0002
Global Const $__MISCCONSTANT_CC_RGBINIT = 0x0001
Global Const $tagCHOOSECOLOR = "dword Size;hwnd hWndOwnder;handle hInstance;dword rgbResult;ptr CustColors;dword Flags;lparam lCustData;" &  "ptr lpfnHook;ptr lpTemplateName"
Global Const $tagCHOOSEFONT = "dword Size;hwnd hWndOwner;handle hDC;ptr LogFont;int PointSize;dword Flags;dword rgbColors;lparam CustData;" &  "ptr fnHook;ptr TemplateName;handle hInstance;ptr szStyle;word FontType;int SizeMin;int SizeMax"
Func _ChooseColor($iReturnType = 0, $iColorRef = 0, $iRefType = 0, $hWndOwnder = 0)
Local $tagCustcolors = "dword[16]"
Local $tChoose = DllStructCreate($tagCHOOSECOLOR)
Local $tCc = DllStructCreate($tagCustcolors)
If $iRefType = 1 Then
$iColorRef = Int($iColorRef)
ElseIf $iRefType = 2 Then
$iColorRef = Hex(String($iColorRef), 6)
$iColorRef = '0x' & StringMid($iColorRef, 5, 2) & StringMid($iColorRef, 3, 2) & StringMid($iColorRef, 1, 2)
EndIf
DllStructSetData($tChoose, "Size", DllStructGetSize($tChoose))
DllStructSetData($tChoose, "hWndOwnder", $hWndOwnder)
DllStructSetData($tChoose, "rgbResult", $iColorRef)
DllStructSetData($tChoose, "CustColors", DllStructGetPtr($tCc))
DllStructSetData($tChoose, "Flags", BitOR($__MISCCONSTANT_CC_ANYCOLOR, $__MISCCONSTANT_CC_FULLOPEN, $__MISCCONSTANT_CC_RGBINIT))
Local $aResult = DllCall("comdlg32.dll", "bool", "ChooseColor", "struct*", $tChoose)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] = 0 Then Return SetError(-3, -3, -1)
Local $sColor_picked = DllStructGetData($tChoose, "rgbResult")
If $iReturnType = 1 Then
Return '0x' & Hex(String($sColor_picked), 6)
ElseIf $iReturnType = 2 Then
$sColor_picked = Hex(String($sColor_picked), 6)
Return '0x' & StringMid($sColor_picked, 5, 2) & StringMid($sColor_picked, 3, 2) & StringMid($sColor_picked, 1, 2)
ElseIf $iReturnType = 0 Then
Return $sColor_picked
Else
Return SetError(-4, -4, -1)
EndIf
EndFunc
Func _ChooseFont($sFontName = "Courier New", $iPointSize = 10, $iFontColorRef = 0, $iFontWeight = 0, $bItalic = False, $bUnderline = False, $bStrikethru = False, $hWndOwner = 0)
Local $iItalic = 0, $iUnderline = 0, $iStrikeout = 0
$iFontColorRef = BitOR(BitShift(BitAND($iFontColorRef, 0x000000FF), -16), BitAND($iFontColorRef, 0x0000FF00), BitShift(BitAND($iFontColorRef, 0x00FF0000), 16))
Local $hDC = __MISC_GetDC(0)
Local $iHeight = Round(($iPointSize * __MISC_GetDeviceCaps($hDC, $LOGPIXELSX)) / 72, 0)
__MISC_ReleaseDC(0, $hDC)
Local $tChooseFont = DllStructCreate($tagCHOOSEFONT)
Local $tLogFont = DllStructCreate($tagLOGFONT)
DllStructSetData($tChooseFont, "Size", DllStructGetSize($tChooseFont))
DllStructSetData($tChooseFont, "hWndOwner", $hWndOwner)
DllStructSetData($tChooseFont, "LogFont", DllStructGetPtr($tLogFont))
DllStructSetData($tChooseFont, "PointSize", $iPointSize)
DllStructSetData($tChooseFont, "Flags", BitOR($CF_SCREENFONTS, $CF_PRINTERFONTS, $CF_EFFECTS, $CF_INITTOLOGFONTSTRUCT, $CF_NOSCRIPTSEL))
DllStructSetData($tChooseFont, "rgbColors", $iFontColorRef)
DllStructSetData($tChooseFont, "FontType", 0)
DllStructSetData($tLogFont, "Height", $iHeight)
DllStructSetData($tLogFont, "Weight", $iFontWeight)
DllStructSetData($tLogFont, "Italic", $bItalic)
DllStructSetData($tLogFont, "Underline", $bUnderline)
DllStructSetData($tLogFont, "Strikeout", $bStrikethru)
DllStructSetData($tLogFont, "FaceName", $sFontName)
Local $aResult = DllCall("comdlg32.dll", "bool", "ChooseFontW", "struct*", $tChooseFont)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] = 0 Then Return SetError(-3, -3, -1)
Local $sFaceName = DllStructGetData($tLogFont, "FaceName")
If StringLen($sFaceName) = 0 And StringLen($sFontName) > 0 Then $sFaceName = $sFontName
If DllStructGetData($tLogFont, "Italic") Then $iItalic = 2
If DllStructGetData($tLogFont, "Underline") Then $iUnderline = 4
If DllStructGetData($tLogFont, "Strikeout") Then $iStrikeout = 8
Local $iAttributes = BitOR($iItalic, $iUnderline, $iStrikeout)
Local $iSize = DllStructGetData($tChooseFont, "PointSize") / 10
Local $iColorRef = DllStructGetData($tChooseFont, "rgbColors")
Local $iWeight = DllStructGetData($tLogFont, "Weight")
Local $sColor_picked = Hex(String($iColorRef), 6)
Return StringSplit($iAttributes & "," & $sFaceName & "," & $iSize & "," & $iWeight & "," & $iColorRef & "," & '0x' & $sColor_picked & "," & '0x' & StringMid($sColor_picked, 5, 2) & StringMid($sColor_picked, 3, 2) & StringMid($sColor_picked, 1, 2), ",")
EndFunc
Func _ClipPutFile($sFilePath, $sDelimiter = "|")
Local Const $GMEM_MOVEABLE = 0x0002, $CF_HDROP = 15
$sFilePath &= $sDelimiter & $sDelimiter
Local $nGlobMemSize = 2 * (StringLen($sFilePath) + 20)
Local $aResult = DllCall("user32.dll", "bool", "OpenClipboard", "hwnd", 0)
If @error Or $aResult[0] = 0 Then Return SetError(1, _WinAPI_GetLastError(), False)
Local $iError = 0, $iLastError = 0
$aResult = DllCall("user32.dll", "bool", "EmptyClipboard")
If @error Or Not $aResult[0] Then
$iError = 2
$iLastError = _WinAPI_GetLastError()
Else
$aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $nGlobMemSize)
If @error Or Not $aResult[0] Then
$iError = 3
$iLastError = _WinAPI_GetLastError()
Else
Local $hGlobal = $aResult[0]
$aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hGlobal)
If @error Or Not $aResult[0] Then
$iError = 4
$iLastError = _WinAPI_GetLastError()
Else
Local $hLock = $aResult[0]
Local $tDROPFILES = DllStructCreate("dword pFiles;" & $tagPOINT & ";bool fNC;bool fWide;wchar[" & StringLen($sFilePath) + 1 & "]", $hLock)
If @error Then Return SetError(5, 6, False)
Local $tStruct = DllStructCreate("dword;long;long;bool;bool")
DllStructSetData($tDROPFILES, "pFiles", DllStructGetSize($tStruct))
DllStructSetData($tDROPFILES, "X", 0)
DllStructSetData($tDROPFILES, "Y", 0)
DllStructSetData($tDROPFILES, "fNC", 0)
DllStructSetData($tDROPFILES, "fWide", 1)
DllStructSetData($tDROPFILES, 6, $sFilePath)
For $i = 1 To StringLen($sFilePath)
If DllStructGetData($tDROPFILES, 6, $i) = $sDelimiter Then DllStructSetData($tDROPFILES, 6, Chr(0), $i)
Next
$aResult = DllCall("user32.dll", "handle", "SetClipboardData", "uint", $CF_HDROP, "handle", $hGlobal)
If @error Or Not $aResult[0] Then
$iError = 6
$iLastError = _WinAPI_GetLastError()
EndIf
$aResult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hGlobal)
If (@error Or Not $aResult[0]) And Not $iError And _WinAPI_GetLastError() Then
$iError = 8
$iLastError = _WinAPI_GetLastError()
EndIf
EndIf
$aResult = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hGlobal)
If (@error Or $aResult[0]) And Not $iError Then
$iError = 9
$iLastError = _WinAPI_GetLastError()
EndIf
EndIf
EndIf
$aResult = DllCall("user32.dll", "bool", "CloseClipboard")
If (@error Or Not $aResult[0]) And Not $iError Then Return SetError(7, _WinAPI_GetLastError(), False)
If $iError Then Return SetError($iError, $iLastError, False)
Return True
EndFunc
Func _MouseTrap($iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0)
Local $aReturn = 0
If $iLeft = Default Then $iLeft = 0
If $iTop = Default Then $iTop = 0
If $iRight = Default Then $iRight = 0
If $iBottom = Default Then $iBottom = 0
If @NumParams = 0 Then
$aReturn = DllCall("user32.dll", "bool", "ClipCursor", "ptr", 0)
If @error Or Not $aReturn[0] Then Return SetError(1, _WinAPI_GetLastError(), False)
Else
If @NumParams = 2 Then
$iRight = $iLeft + 1
$iBottom = $iTop + 1
EndIf
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
$aReturn = DllCall("user32.dll", "bool", "ClipCursor", "struct*", $tRECT)
If @error Or Not $aReturn[0] Then Return SetError(2, _WinAPI_GetLastError(), False)
EndIf
Return True
EndFunc
Func _Singleton($sOccurrenceName, $iFlag = 0)
Local Const $ERROR_ALREADY_EXISTS = 183
Local Const $SECURITY_DESCRIPTOR_REVISION = 1
Local $tSecurityAttributes = 0
If BitAND($iFlag, 2) Then
Local $tSecurityDescriptor = DllStructCreate("byte;byte;word;ptr[4]")
Local $aRet = DllCall("advapi32.dll", "bool", "InitializeSecurityDescriptor",  "struct*", $tSecurityDescriptor, "dword", $SECURITY_DESCRIPTOR_REVISION)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then
$aRet = DllCall("advapi32.dll", "bool", "SetSecurityDescriptorDacl",  "struct*", $tSecurityDescriptor, "bool", 1, "ptr", 0, "bool", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then
$tSecurityAttributes = DllStructCreate($tagSECURITY_ATTRIBUTES)
DllStructSetData($tSecurityAttributes, 1, DllStructGetSize($tSecurityAttributes))
DllStructSetData($tSecurityAttributes, 2, DllStructGetPtr($tSecurityDescriptor))
DllStructSetData($tSecurityAttributes, 3, 0)
EndIf
EndIf
EndIf
Local $aHandle = DllCall("kernel32.dll", "handle", "CreateMutexW", "struct*", $tSecurityAttributes, "bool", 1, "wstr", $sOccurrenceName)
If @error Then Return SetError(@error, @extended, 0)
Local $aLastError = DllCall("kernel32.dll", "dword", "GetLastError")
If @error Then Return SetError(@error, @extended, 0)
If $aLastError[0] = $ERROR_ALREADY_EXISTS Then
If BitAND($iFlag, 1) Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $aHandle[0])
If @error Then Return SetError(@error, @extended, 0)
Return SetError($aLastError[0], $aLastError[0], 0)
Else
Exit -1
EndIf
EndIf
Return $aHandle[0]
EndFunc
Func _IsPressed($sHexKey, $vDLL = "user32.dll")
Local $aReturn = DllCall($vDLL, "short", "GetAsyncKeyState", "int", "0x" & $sHexKey)
If @error Then Return SetError(@error, @extended, False)
Return BitAND($aReturn[0], 0x8000) <> 0
EndFunc
Func _VersionCompare($sVersion1, $sVersion2)
If $sVersion1 = $sVersion2 Then Return 0
Local $sSubVersion1 = "", $sSubVersion2 = ""
If StringIsAlpha(StringRight($sVersion1, 1)) Then
$sSubVersion1 = StringRight($sVersion1, 1)
$sVersion1 = StringTrimRight($sVersion1, 1)
EndIf
If StringIsAlpha(StringRight($sVersion2, 1)) Then
$sSubVersion2 = StringRight($sVersion2, 1)
$sVersion2 = StringTrimRight($sVersion2, 1)
EndIf
Local $aVersion1 = StringSplit($sVersion1, ".,"),  $aVersion2 = StringSplit($sVersion2, ".,")
Local $iPartDifference = ($aVersion1[0] - $aVersion2[0])
If $iPartDifference < 0 Then
ReDim $aVersion1[UBound($aVersion2)]
$aVersion1[0] = UBound($aVersion1) - 1
For $i = (UBound($aVersion1) - Abs($iPartDifference)) To $aVersion1[0]
$aVersion1[$i] = "0"
Next
ElseIf $iPartDifference > 0 Then
ReDim $aVersion2[UBound($aVersion1)]
$aVersion2[0] = UBound($aVersion2) - 1
For $i = (UBound($aVersion2) - Abs($iPartDifference)) To $aVersion2[0]
$aVersion2[$i] = "0"
Next
EndIf
For $i = 1 To $aVersion1[0]
If StringIsDigit($aVersion1[$i]) And StringIsDigit($aVersion2[$i]) Then
If Number($aVersion1[$i]) > Number($aVersion2[$i]) Then
Return SetExtended(2, 1)
ElseIf Number($aVersion1[$i]) < Number($aVersion2[$i]) Then
Return SetExtended(2, -1)
ElseIf $i = $aVersion1[0] Then
If $sSubVersion1 > $sSubVersion2 Then
Return SetExtended(3, 1)
ElseIf $sSubVersion1 < $sSubVersion2 Then
Return SetExtended(3, -1)
EndIf
EndIf
Else
If $aVersion1[$i] > $aVersion2[$i] Then
Return SetExtended(1, 1)
ElseIf $aVersion1[$i] < $aVersion2[$i] Then
Return SetExtended(1, -1)
EndIf
EndIf
Next
Return SetExtended(Abs($iPartDifference), 0)
EndFunc
Func __MISC_GetDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Or Not $aResult[0] Then Return SetError(1, _WinAPI_GetLastError(), 0)
Return $aResult[0]
EndFunc
Func __MISC_GetDeviceCaps($hDC, $iIndex)
Local $aResult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func __MISC_ReleaseDC($hWnd, $hDC)
Local $aResult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _ProcessGetName($iPID)
Local $aProcessList = ProcessList()
For $i = 1 To UBound($aProcessList) - 1
If $aProcessList[$i][1] = $iPID Then
Return $aProcessList[$i][0]
EndIf
Next
Return SetError(1, 0, "")
EndFunc
Func _ProcessGetPriority($vProcess)
Local $iError = 0, $iExtended = 0, $iReturn = -1
Local $iPID = ProcessExists($vProcess)
If Not $iPID Then Return SetError(1, 0, -1)
Local $hDLL = DllOpen('kernel32.dll')
Do
Local $aProcessHandle = DllCall($hDLL, 'handle', 'OpenProcess', 'dword', $PROCESS_QUERY_INFORMATION, 'bool', False, 'dword', $iPID)
If @error Then
$iError = @error + 10
$iExtended = @extended
ExitLoop
EndIf
If Not $aProcessHandle[0] Then ExitLoop
Local $aPriority = DllCall($hDLL, 'dword', 'GetPriorityClass', 'handle', $aProcessHandle[0])
If @error Then
$iError = @error
$iExtended = @extended
EndIf
DllCall($hDLL, 'bool', 'CloseHandle', 'handle', $aProcessHandle[0])
If $iError Then ExitLoop
Switch $aPriority[0]
Case 0x00000040
$iReturn = 0
Case 0x00004000
$iReturn = 1
Case 0x00000020
$iReturn = 2
Case 0x00008000
$iReturn = 3
Case 0x00000080
$iReturn = 4
Case 0x00000100
$iReturn = 5
Case Else
$iError = 1
$iExtended = $aPriority[0]
$iReturn = -1
EndSwitch
Until True
DllClose($hDLL)
Return SetError($iError, $iExtended, $iReturn)
EndFunc
Func _RunDos($sCommand)
Local $iResult = RunWait(@ComSpec & " /C " & $sCommand, "", @SW_HIDE)
Return SetError(@error, @extended, $iResult)
EndFunc
Func _HexToString($sHex)
If Not (StringLeft($sHex, 2) == "0x") Then $sHex = "0x" & $sHex
Return BinaryToString($sHex, $SB_UTF8)
EndFunc
Func _StringBetween($sString, $sStart, $sEnd, $iMode = $STR_ENDISSTART, $bCase = False)
$sStart = $sStart ? "\Q" & $sStart & "\E" : "\A"
If $iMode <> $STR_ENDNOTSTART Then $iMode = $STR_ENDISSTART
If $iMode = $STR_ENDISSTART Then
$sEnd = $sEnd ? "(?=\Q" & $sEnd & "\E)" : "\z"
Else
$sEnd = $sEnd ? "\Q" & $sEnd & "\E" : "\z"
EndIf
If $bCase = Default Then
$bCase = False
EndIf
Local $aReturn = StringRegExp($sString, "(?s" & (Not $bCase ? "i" : "") & ")" & $sStart & "(.*?)" & $sEnd, $STR_REGEXPARRAYGLOBALMATCH)
If @error Then Return SetError(1, 0, 0)
Return $aReturn
EndFunc
Func _StringExplode($sString, $sDelimiter, $iLimit = 0)
If $iLimit = Default Then $iLimit = 0
If $iLimit > 0 Then
Local Const $NULL = Chr(0)
$sString = StringReplace($sString, $sDelimiter, $NULL, $iLimit)
$sDelimiter = $NULL
ElseIf $iLimit < 0 Then
Local $iIndex = StringInStr($sString, $sDelimiter, $STR_NOCASESENSEBASIC, $iLimit)
If $iIndex Then
$sString = StringLeft($sString, $iIndex - 1)
EndIf
EndIf
Return StringSplit($sString, $sDelimiter, BItOR($STR_ENTIRESPLIT, $STR_NOCOUNT))
EndFunc
Func _StringInsert($sString, $sInsertion, $iPosition)
Local $iLength = StringLen($sString)
$iPosition = Int($iPosition)
If $iPosition < 0 Then $iPosition = $iLength + $iPosition
If $iLength < $iPosition Or $iPosition < 0 Then Return SetError(1, 0, $sString)
Return StringLeft($sString, $iPosition) & $sInsertion & StringRight($sString, $iLength - $iPosition)
EndFunc
Func _StringProper($sString)
Local $bCapNext = True, $sChr = "", $sReturn = ""
For $i = 1 To StringLen($sString)
$sChr = StringMid($sString, $i, 1)
Select
Case $bCapNext = True
If StringRegExp($sChr, '[a-zA-Z-]') Then
$sChr = StringUpper($sChr)
$bCapNext = False
EndIf
Case Not StringRegExp($sChr, '[a-zA-Z-]')
$bCapNext = True
Case Else
$sChr = StringLower($sChr)
EndSelect
$sReturn &= $sChr
Next
Return $sReturn
EndFunc
Func _StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If $iRepeatCount = 0 Then Return ""
If StringLen($sString) < 1 Or $iRepeatCount < 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Func _StringTitleCase($sString)
Local $bCapNext = True, $sChr = "", $sReturn = ""
For $i = 1 To StringLen($sString)
$sChr = StringMid($sString, $i, 1)
Select
Case $bCapNext = True
If StringRegExp($sChr, "[a-zA-Z\xC0-\xFF0-9]") Then
$sChr = StringUpper($sChr)
$bCapNext = False
EndIf
Case Not StringRegExp($sChr, "[a-zA-Z\xC0-\xFF'0-9]")
$bCapNext = True
Case Else
$sChr = StringLower($sChr)
EndSelect
$sReturn &= $sChr
Next
Return $sReturn
EndFunc
Func _StringToHex($sString)
Return Hex(StringToBinary($sString, $SB_UTF8))
EndFunc
Global Const $TRAY_ITEM_EXIT = 3
Global Const $TRAY_ITEM_PAUSE = 4
Global Const $TRAY_ITEM_FIRST = 7
Global Const $TRAY_CHECKED = 1
Global Const $TRAY_UNCHECKED = 4
Global Const $TRAY_ENABLE = 64
Global Const $TRAY_DISABLE = 128
Global Const $TRAY_FOCUS = 256
Global Const $TRAY_DEFAULT = 512
Global Const $TRAY_EVENT_NONE = 0
Global Const $TRAY_EVENT_SHOWICON = -3
Global Const $TRAY_EVENT_HIDEICON = -4
Global Const $TRAY_EVENT_FLASHICON = -5
Global Const $TRAY_EVENT_NOFLASHICON = -6
Global Const $TRAY_EVENT_PRIMARYDOWN = -7
Global Const $TRAY_EVENT_PRIMARYUP = -8
Global Const $TRAY_EVENT_SECONDARYDOWN = -9
Global Const $TRAY_EVENT_SECONDARYUP = -10
Global Const $TRAY_EVENT_MOUSEOVER = -11
Global Const $TRAY_EVENT_MOUSEOUT = -12
Global Const $TRAY_EVENT_PRIMARYDOUBLE = -13
Global Const $TRAY_EVENT_SECONDARYDOUBLE = -14
Global Const $TIP_ICONNONE = 0
Global Const $TIP_ICONASTERISK = 1
Global Const $TIP_ICONEXCLAMATION = 2
Global Const $TIP_ICONHAND = 3
Global Const $TIP_NOSOUND = 16
Global Const $TRAY_ITEM_NORMAL = 0
Global Const $TRAY_ITEM_RADIO = 1
Global Const $TRAY_CLICK_SHOW = 0
Global Const $TRAY_CLICK_PRIMARYDOWN = 1
Global Const $TRAY_CLICK_PRIMARYUP = 2
Global Const $TRAY_DBLCLICK_PRIMARY= 4
Global Const $TRAY_CLICK_SECONDARYDOWN = 8
Global Const $TRAY_CLICK_SECONDARYUP = 16
Global Const $TRAY_DBLCLICK_SECONDARY= 32
Global Const $TRAY_CLICK_HOVERING= 64
Global Const $TRAY_ICONSTATE_SHOW = 1
Global Const $TRAY_ICONSTATE_HIDE = 2
Global Const $TRAY_ICONSTATE_FLASH = 4
Global Const $TRAY_ICONSTATE_STOPFLASH = 8
Global Const $TRAY_ICONSTATE_RESET = 16
Global Const $__DLG_WM_USER = 0x400
Global Const $BIF_BROWSEFILEJUNCTIONS = 0x00010000
Global Const $BIF_BROWSEFORCOMPUTER = 0x00001000
Global Const $BIF_BROWSEFORPRINTER = 0x00002000
Global Const $BIF_BROWSEINCLUDEFILES = 0x00004000
Global Const $BIF_BROWSEINCLUDEURLS = 0x00000080
Global Const $BIF_DONTGOBELOWDOMAIN = 0x00000002
Global Const $BIF_EDITBOX = 0x00000010
Global Const $BIF_NEWDIALOGSTYLE = 0x00000040
Global Const $BIF_NONEWFOLDERBUTTON = 0x00000200
Global Const $BIF_NOTRANSLATETARGETS = 0x00000400
Global Const $BIF_RETURNFSANCESTORS = 0x00000008
Global Const $BIF_RETURNONLYFSDIRS = 0x00000001
Global Const $BIF_SHAREABLE = 0x00008000
Global Const $BIF_STATUSTEXT = 0x00000004
Global Const $BIF_USENEWUI = BitOR($BIF_EDITBOX, $BIF_NEWDIALOGSTYLE)
Global Const $BIF_UAHINT = 0x00000100
Global Const $BIF_VALIDATE = 0x00000020
Global Const $BFFM_INITIALIZED = 1
Global Const $BFFM_IUNKNOWN = 5
Global Const $BFFM_SELCHANGED = 2
Global Const $BFFM_VALIDATEFAILED = 4
Global Const $BFFM_SETSTATUSTEXTA = $__DLG_WM_USER + 100
Global Const $BFFM_ENABLEOK = $__DLG_WM_USER + 101
Global Const $BFFM_SETSELECTIONA = $__DLG_WM_USER + 102
Global Const $BFFM_SETSELECTIONW = $__DLG_WM_USER + 103
Global Const $BFFM_SETSTATUSTEXTW = $__DLG_WM_USER + 104
Global Const $BFFM_SETOKTEXT = $__DLG_WM_USER + 105
Global Const $BFFM_SETEXPANDED = $__DLG_WM_USER + 106
Global Const $CDERR_DIALOGFAILURE = 0xFFFF
Global Const $CDERR_FINDRESFAILURE = 0x0006
Global Const $CDERR_INITIALIZATION = 0x0002
Global Const $CDERR_LOADRESFAILURE = 0x0007
Global Const $CDERR_LOADSTRFAILURE = 0x0005
Global Const $CDERR_LOCKRESFAILURE = 0x0008
Global Const $CDERR_MEMALLOCFAILURE = 0x0009
Global Const $CDERR_MEMLOCKFAILURE = 0x000A
Global Const $CDERR_NOHINSTANCE = 0x0004
Global Const $CDERR_NOHOOK = 0x000B
Global Const $CDERR_NOTEMPLATE = 0x0003
Global Const $CDERR_REGISTERMSGFAIL = 0x000C
Global Const $CDERR_STRUCTSIZE = 0x0001
Global Const $PDERR_CREATEICFAILURE = 0x100A
Global Const $PDERR_DEFAULTDIFFERENT = 0x100C
Global Const $PDERR_DNDMMISMATCH = 0x1009
Global Const $PDERR_GETDEVMODEFAIL = 0x1005
Global Const $PDERR_INITFAILURE = 0x1006
Global Const $PDERR_LOADDRVFAILURE = 0x1004
Global Const $PDERR_NODEFAULTPRN = 0x1008
Global Const $PDERR_NODEVICES = 0x1007
Global Const $PDERR_PARSEFAILURE = 0x1002
Global Const $PDERR_PRINTERNOTFOUND = 0x100B
Global Const $PDERR_RETDEFFAILURE = 0x1003
Global Const $PDERR_SETUPFAILURE = 0x1001
Global Const $CFERR_MAXLESSTHANMIN = 0x2002
Global Const $CFERR_NOFONTS = 0x2001
Global Const $FNERR_BUFFERTOOSMALL = 0x3003
Global Const $FNERR_INVALIDFILENAME = 0x3002
Global Const $FNERR_SUBCLASSFAILURE = 0x3001
Global Const $FRERR_BUFFERLENGTHZERO = 0x4001
Global Const $FR_DIALOGTERM = 0x00000040
Global Const $FR_DOWN = 0x00000001
Global Const $FR_ENABLEHOOK = 0x00000100
Global Const $FR_ENABLETEMPLATE = 0x00000200
Global Const $FR_ENABLETEMPLATEHANDLE = 0x00002000
Global Const $FR_FINDNEXT = 0x00000008
Global Const $FR_HIDEUPDOWN = 0x00004000
Global Const $FR_HIDEMATCHCASE = 0x00008000
Global Const $FR_HIDEWHOLEWORD = 0x00010000
Global Const $FR_MATCHCASE = 0x00000004
Global Const $FR_NOMATCHCASE = 0x00000800
Global Const $FR_NOUPDOWN = 0x00000400
Global Const $FR_NOWHOLEWORD = 0x00001000
Global Const $FR_REPLACE = 0x00000010
Global Const $FR_REPLACEALL = 0x00000020
Global Const $FR_SHOWHELP = 0x00000080
Global Const $FR_WHOLEWORD = 0x00000002
Global Const $SHFMT_ID_DEFAULT = 0xFFFF
Global Const $SHFMT_OPT_FULL = 0x00
Global Const $SHFMT_OPT_QUICKFORMAT = 0x01
Global Const $SHFMT_OPT_SYSONLY = 0x02
Global Const $SHFMT_ERROR = -1
Global Const $SHFMT_CANCEL = -2
Global Const $SHFMT_NOFORMAT = -3
Global Const $CDM_FIRST = $__DLG_WM_USER + 100
Global Const $CDM_GETSPEC = $CDM_FIRST
Global Const $CDM_GETFILEPATH = $CDM_FIRST + 1
Global Const $CDM_GETFOLDERPATH = $CDM_FIRST + 2
Global Const $CDM_GETFOLDERIDLIST = $CDM_FIRST + 3
Global Const $CDM_SETCONTROLTEXT = $CDM_FIRST + 4
Global Const $CDM_HIDECONTROL = $CDM_FIRST + 5
Global Const $CDM_SETDEFEXT = $CDM_FIRST + 6
Global Const $CDM_LAST = $__DLG_WM_USER + 200
Global Const $CDN_FIRST = -601
Global Const $CDN_INITDONE = $CDN_FIRST
Global Const $CDN_SELCHANGE = $CDN_FIRST - 1
Global Const $CDN_FOLDERCHANGE = $CDN_FIRST - 2
Global Const $CDN_SHAREVIOLATION = $CDN_FIRST - 3
Global Const $CDN_HELP = $CDN_FIRST - 4
Global Const $CDN_FILEOK = $CDN_FIRST - 5
Global Const $CDN_TYPECHANGE = $CDN_FIRST - 6
Global Const $CDN_INCLUDEITEM = $CDN_FIRST - 7
Global Const $CDN_LAST = -699
Global Const $PSD_DEFAULTMINMARGINS = 0x00000000
Global Const $PSD_DISABLEMARGINS = 0x00000010
Global Const $PSD_DISABLEORIENTATION = 0x00000100
Global Const $PSD_DISABLEPAGEPAINTING = 0x00080000
Global Const $PSD_DISABLEPAPER = 0x00000200
Global Const $PSD_DISABLEPRINTER = 0x00000020
Global Const $PSD_ENABLEPAGEPAINTHOOK = 0x00040000
Global Const $PSD_ENABLEPAGESETUPHOOK = 0x00002000
Global Const $PSD_ENABLEPAGESETUPTEMPLATE = 0x00008000
Global Const $PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 0x00020000
Global Const $PSD_INHUNDREDTHSOFMILLIMETERS = 0x00000008
Global Const $PSD_INTHOUSANDTHSOFINCHES = 0x00000004
Global Const $PSD_MARGINS = 0x00000002
Global Const $PSD_MINMARGINS = 0x00000001
Global Const $PSD_NONETWORKBUTTON = 0x00200000
Global Const $PSD_NOWARNING = 0x00000080
Global Const $PSD_RETURNDEFAULT = 0x00000400
Global Const $PSD_SHOWHELP = 0x00000800
Global Const $WM_PSD_PAGESETUPDLG = $__DLG_WM_USER
Global Const $WM_PSD_FULLPAGERECT = $__DLG_WM_USER + 1
Global Const $WM_PSD_MINMARGINRECT = $__DLG_WM_USER + 2
Global Const $WM_PSD_MARGINRECT = $__DLG_WM_USER + 3
Global Const $WM_PSD_GREEKTEXTRECT = $__DLG_WM_USER + 4
Global Const $WM_PSD_ENVSTAMPRECT = $__DLG_WM_USER + 5
Global Const $WM_PSD_YAFULLPAGERECT = $__DLG_WM_USER + 6
Global Const $PD_ALLPAGES = 0x00000000
Global Const $PD_COLLATE = 0x00000010
Global Const $PD_CURRENTPAGE = 0x00400000
Global Const $PD_DISABLEPRINTTOFILE = 0x00080000
Global Const $PD_ENABLEPRINTHOOK = 0x00001000
Global Const $PD_ENABLEPRINTTEMPLATE = 0x00004000
Global Const $PD_ENABLEPRINTTEMPLATEHANDLE = 0x00010000
Global Const $PD_ENABLESETUPHOOK = 0x00002000
Global Const $PD_ENABLESETUPTEMPLATE = 0x00008000
Global Const $PD_ENABLESETUPTEMPLATEHANDLE = 0x00020000
Global Const $PD_EXCLUSIONFLAGS = 0x01000000
Global Const $PD_HIDEPRINTTOFILE = 0x00100000
Global Const $PD_NOCURRENTPAGE = 0x00800000
Global Const $PD_NONETWORKBUTTON = 0x00200000
Global Const $PD_NOPAGENUMS = 0x00000008
Global Const $PD_NOSELECTION = 0x00000004
Global Const $PD_NOWARNING = 0x00000080
Global Const $PD_PAGENUMS = 0x00000002
Global Const $PD_PRINTSETUP = 0x00000040
Global Const $PD_PRINTTOFILE = 0x00000020
Global Const $PD_RETURNDC = 0x00000100
Global Const $PD_RETURNDEFAULT = 0x00000400
Global Const $PD_RETURNIC = 0x00000200
Global Const $PD_SELECTION = 0x00000001
Global Const $PD_SHOWHELP = 0x00000800
Global Const $PD_USEDEVMODECOPIES = 0x00040000
Global Const $PD_USEDEVMODECOPIESANDCOLLATE = $PD_USEDEVMODECOPIES
Global Const $PD_USELARGETEMPLATE = 0x10000000
Global Const $PD_RESULT_APPLY = 2
Global Const $PD_RESULT_CANCEL = 0
Global Const $PD_RESULT_PRINT = 1
Global Const $EWX_LOGOFF = 0
Global Const $EWX_POWEROFF = 8
Global Const $EWX_REBOOT = 2
Global Const $EWX_SHUTDOWN = 1
Global Const $EWX_FORCE = 4
Global Const $EWX_FORCEIFHUNG = 16
Global Const $OAIF_ALLOW_REGISTRATION = 0x00000001
Global Const $OAIF_REGISTER_EXT = 0x00000002
Global Const $OAIF_EXEC = 0x00000004
Global Const $OAIF_FORCE_REGISTRATION = 0x00000008
Global Const $OAIF_HIDE_REGISTRATION = 0x00000020
Global Const $OAIF_URL_PROTOCOL = 0x00000040
Global Const $CREDUI_FLAGS_ALWAYS_SHOW_UI = 0x00000080
Global Const $CREDUI_FLAGS_COMPLETE_USERNAME = 0x00000800
Global Const $CREDUI_FLAGS_DO_NOT_PERSIST = 0x00000002
Global Const $CREDUI_FLAGS_EXCLUDE_CERTIFICATES = 0x00000008
Global Const $CREDUI_FLAGS_EXPECT_CONFIRMATION = 0x00020000
Global Const $CREDUI_FLAGS_GENERIC_CREDENTIALS = 0x00040000
Global Const $CREDUI_FLAGS_INCORRECT_PASSWORD = 0x00000001
Global Const $CREDUI_FLAGS_KEEP_USERNAME = 0x00100000
Global Const $CREDUI_FLAGS_PASSWORD_ONLY_OK = 0x00000200
Global Const $CREDUI_FLAGS_PERSIST = 0x00001000
Global Const $CREDUI_FLAGS_REQUEST_ADMINISTRATOR = 0x00000004
Global Const $CREDUI_FLAGS_REQUIRE_CERTIFICATE = 0x00000010
Global Const $CREDUI_FLAGS_REQUIRE_SMARTCARD = 0x00000100
Global Const $CREDUI_FLAGS_SERVER_CREDENTIAL = 0x00004000
Global Const $CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX = 0x00000040
Global Const $CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS = 0x00080000
Global Const $CREDUI_FLAGS_VALIDATE_USERNAME = 0x00000400
Global Const $CREDUIWIN_AUTHPACKAGE_ONLY = 0x00000010
Global Const $CREDUIWIN_CHECKBOX = 0x00000002
Global Const $CREDUIWIN_ENUMERATE_ADMINS = 0x00000100
Global Const $CREDUIWIN_ENUMERATE_CURRENT_USER = 0x00000200
Global Const $CREDUIWIN_GENERIC = 0x00000001
Global Const $CREDUIWIN_IN_CRED_ONLY = 0x00000020
Global Const $CREDUIWIN_SECURE_PROMPT = 0x00001000
Global Const $CREDUIWIN_PACK_32_WOW = 0x10000000
Global Const $CREDUIWIN_PREPROMPTING = 0x00002000
Global Const $DLLVER_PLATFORM_WINDOWS = 0x01
Global Const $DLLVER_PLATFORM_NT = 0x02
Global Const $SHCNE_ALLEVENTS = 0x7FFFFFFF
Global Const $SHCNE_ASSOCCHANGED = 0x8000000
Global Const $SHCNE_ATTRIBUTES = 0x00000800
Global Const $SHCNE_CREATE = 0x00000002
Global Const $SHCNE_DELETE = 0x00000004
Global Const $SHCNE_DRIVEADD = 0x00000100
Global Const $SHCNE_DRIVEADDGUI = 0x00010000
Global Const $SHCNE_DRIVEREMOVED = 0x00000080
Global Const $SHCNE_EXTENDED_EVENT = 0x04000000
Global Const $SHCNE_FREESPACE = 0x00040000
Global Const $SHCNE_MEDIAINSERTED = 0x00000020
Global Const $SHCNE_MEDIAREMOVED = 0x00000040
Global Const $SHCNE_MKDIR = 0x00000008
Global Const $SHCNE_NETSHARE = 0x00000200
Global Const $SHCNE_NETUNSHARE = 0x00000400
Global Const $SHCNE_RENAMEFOLDER = 0x00020000
Global Const $SHCNE_RENAMEITEM = 0x00000001
Global Const $SHCNE_RMDIR = 0x00000010
Global Const $SHCNE_SERVERDISCONNECT = 0x00004000
Global Const $SHCNE_UPDATEDIR = 0x00001000
Global Const $SHCNE_UPDATEIMAGE = 0x00008000
Global Const $SHCNE_UPDATEITEM = 0x00002000
Global Const $SHCNE_DISKEVENTS = 0x0002381F
Global Const $SHCNE_GLOBALEVENTS = 0x0C0581E0
Global Const $SHCNE_INTERRUPT = 0x80000000
Global Const $SHCNF_DWORD = 0x00000003
Global Const $SHCNF_IDLIST = 0x00000000
Global Const $SHCNF_PATH = 0x00000001
Global Const $SHCNF_PRINTER = 0x00000002
Global Const $SHCNF_FLUSH = 0x00001000
Global Const $SHCNF_FLUSHNOWAIT = 0x00002000
Global Const $SHCNF_NOTIFYRECURSIVE = 0x00010000
Global Const $SHCNRF_INTERRUPTLEVEL = 0x0001
Global Const $SHCNRF_SHELLLEVEL = 0x0002
Global Const $SHCNRF_RECURSIVEINTERRUPT = 0x1000
Global Const $SHCNRF_NEWDELIVERY = 0x8000
Global Const $SHERB_NOCONFIRMATION = 0x01
Global Const $SHERB_NOPROGRESSUI = 0x02
Global Const $SHERB_NOSOUND = 0x04
Global Const $SHERB_NO_UI = BitOR($SHERB_NOCONFIRMATION, $SHERB_NOPROGRESSUI, $SHERB_NOSOUND)
Global Const $SEE_MASK_DEFAULT = 0x00000000
Global Const $SEE_MASK_CLASSNAME = 0x00000001
Global Const $SEE_MASK_CLASSKEY = 0x00000003
Global Const $SEE_MASK_IDLIST = 0x00000004
Global Const $SEE_MASK_INVOKEIDLIST = 0x0000000C
Global Const $SEE_MASK_ICON = 0x00000010
Global Const $SEE_MASK_HOTKEY = 0x00000020
Global Const $SEE_MASK_NOCLOSEPROCESS = 0x00000040
Global Const $SEE_MASK_CONNECTNETDRV = 0x00000080
Global Const $SEE_MASK_NOASYNC = 0x00000100
Global Const $SEE_MASK_FLAG_DDEWAIT = $SEE_MASK_NOASYNC
Global Const $SEE_MASK_DOENVSUBST = 0x00000200
Global Const $SEE_MASK_FLAG_NO_UI = 0x00000400
Global Const $SEE_MASK_UNICODE = 0x00004000
Global Const $SEE_MASK_NO_CONSOLE = 0x00008000
Global Const $SEE_MASK_ASYNCOK = 0x00100000
Global Const $SEE_MASK_NOQUERYCLASSSTORE = 0x01000000
Global Const $SEE_MASK_HMONITOR = 0x00200000
Global Const $SEE_MASK_NOZONECHECKS = 0x00800000
Global Const $SEE_MASK_WAITFORINPUTIDLE = 0x02000000
Global Const $SEE_MASK_FLAG_LOG_USAGE = 0x04000000
Global Const $SE_ERR_ACCESSDENIED = 5
Global Const $SE_ERR_ASSOCINCOMPLETE = 27
Global Const $SE_ERR_DDEBUSY = 30
Global Const $SE_ERR_DDEFAIL = 29
Global Const $SE_ERR_DDETIMEOUT = 28
Global Const $SE_ERR_DLLNOTFOUND = 32
Global Const $SE_ERR_FNF = 2
Global Const $SE_ERR_NOASSOC = 31
Global Const $SE_ERR_OOM = 8
Global Const $SE_ERR_PNF = 3
Global Const $SE_ERR_SHARE = 26
Global Const $FO_COPY = 2
Global Const $FO_DELETE = 3
Global Const $FO_MOVE = 1
Global Const $FO_RENAME = 4
Global Const $FOF_ALLOWUNDO = 0x0040
Global Const $FOF_CONFIRMMOUSE = 0x0002
Global Const $FOF_FILESONLY = 0x0080
Global Const $FOF_MULTIDESTFILES = 0x0001
Global Const $FOF_NOCONFIRMATION = 0x0010
Global Const $FOF_NOCONFIRMMKDIR = 0x0200
Global Const $FOF_NO_CONNECTED_ELEMENTS = 0x2000
Global Const $FOF_NOCOPYSECURITYATTRIBS = 0x0800
Global Const $FOF_NOERRORUI = 0x0400
Global Const $FOF_NORECURSEREPARSE = 0x8000
Global Const $FOF_NORECURSION = 0x1000
Global Const $FOF_RENAMEONCOLLISION = 0x0008
Global Const $FOF_SILENT = 0x0004
Global Const $FOF_SIMPLEPROGRESS = 0x0100
Global Const $FOF_WANTMAPPINGHANDLE = 0x0020
Global Const $FOF_WANTNUKEWARNING = 0x4000
Global Const $FOF_NO_UI = BitOR($FOF_NOCONFIRMATION, $FOF_NOCONFIRMMKDIR, $FOF_NOERRORUI, $FOF_SILENT)
Global Const $SHGFI_ADDOVERLAYS = 0x00000020
Global Const $SHGFI_ATTR_SPECIFIED = 0x00020000
Global Const $SHGFI_ATTRIBUTES = 0x00000800
Global Const $SHGFI_DISPLAYNAME = 0x00000200
Global Const $SHGFI_EXETYPE = 0x00002000
Global Const $SHGFI_ICON = 0x00000100
Global Const $SHGFI_ICONLOCATION = 0x00001000
Global Const $SHGFI_LARGEICON = 0x00000000
Global Const $SHGFI_LINKOVERLAY = 0x00008000
Global Const $SHGFI_OPENICON = 0x00000002
Global Const $SHGFI_OVERLAYINDEX = 0x00000040
Global Const $SHGFI_PIDL = 0x00000008
Global Const $SHGFI_SELECTED = 0x00010000
Global Const $SHGFI_SHELLICONSIZE = 0x00000004
Global Const $SHGFI_SMALLICON = 0x00000001
Global Const $SHGFI_SYSICONINDEX = 0x00004000
Global Const $SHGFI_TYPENAME = 0x00000400
Global Const $SHGFI_USEFILEATTRIBUTES = 0x00000010
Global Const $SFGAO_CANCOPY = 0x00000001
Global Const $SFGAO_CANMOVE = 0x00000002
Global Const $SFGAO_CANLINK = 0x00000004
Global Const $SFGAO_STORAGE = 0x00000008
Global Const $SFGAO_CANRENAME = 0x00000010
Global Const $SFGAO_CANDELETE = 0x00000020
Global Const $SFGAO_HASPROPSHEET = 0x00000040
Global Const $SFGAO_DROPTARGET = 0x00000100
Global Const $SFGAO_CAPABILITYMASK = BitOR($SFGAO_CANCOPY, $SFGAO_CANMOVE, $SFGAO_CANLINK, $SFGAO_CANRENAME, $SFGAO_CANDELETE, $SFGAO_HASPROPSHEET, $SFGAO_DROPTARGET)
Global Const $SFGAO_SYSTEM = 0x00001000
Global Const $SFGAO_ENCRYPTED = 0x00002000
Global Const $SFGAO_ISSLOW = 0x00004000
Global Const $SFGAO_GHOSTED = 0x00008000
Global Const $SFGAO_LINK = 0x00010000
Global Const $SFGAO_SHARE = 0x00020000
Global Const $SFGAO_READONLY = 0x00040000
Global Const $SFGAO_HIDDEN = 0x00080000
Global Const $SFGAO_DISPLAYATTRMASK = BitOR($SFGAO_ISSLOW, $SFGAO_GHOSTED, $SFGAO_LINK, $SFGAO_SHARE, $SFGAO_READONLY, $SFGAO_HIDDEN)
Global Const $SFGAO_NONENUMERATED = 0x00100000
Global Const $SFGAO_NEWCONTENT = 0x00200000
Global Const $SFGAO_STREAM = 0x00400000
Global Const $SFGAO_STORAGEANCESTOR = 0x00800000
Global Const $SFGAO_VALIDATE = 0x01000000
Global Const $SFGAO_REMOVABLE = 0x02000000
Global Const $SFGAO_COMPRESSED = 0x04000000
Global Const $SFGAO_BROWSABLE = 0x08000000
Global Const $SFGAO_FILESYSANCESTOR = 0x10000000
Global Const $SFGAO_FOLDER = 0x20000000
Global Const $SFGAO_FILESYSTEM = 0x40000000
Global Const $SFGAO_STORAGECAPMASK = BitOR($SFGAO_STORAGE, $SFGAO_LINK, $SFGAO_READONLY, $SFGAO_STREAM, $SFGAO_STORAGEANCESTOR, $SFGAO_FILESYSANCESTOR, $SFGAO_FOLDER, $SFGAO_FILESYSTEM)
Global Const $SFGAO_HASSUBFOLDER = 0x80000000
Global Const $SFGAO_CONTENTSMASK = $SFGAO_HASSUBFOLDER
Global Const $SFGAO_PKEYSFGAOMASK = BitOR($SFGAO_ISSLOW, $SFGAO_READONLY, $SFGAO_HASSUBFOLDER, $SFGAO_VALIDATE)
Global Const $IDO_SHGIOI_DEFAULT = 0x0FFFFFFC
Global Const $IDO_SHGIOI_LINK = 0x0FFFFFFE
Global Const $IDO_SHGIOI_SHARE = 0x0FFFFFFF
Global Const $IDO_SHGIOI_SLOWFILE = 0x0FFFFFFD
Global Const $FCSM_VIEWID = 0x0001
Global Const $FCSM_WEBVIEWTEMPLATE = 0x0002
Global Const $FCSM_INFOTIP = 0x0004
Global Const $FCSM_CLSID = 0x0008
Global Const $FCSM_ICONFILE = 0x0010
Global Const $FCSM_LOGO = 0x0020
Global Const $FCSM_FLAGS = 0x0040
Global Const $FCS_READ = 0x0001
Global Const $FCS_FORCEWRITE = 0x0002
Global Const $FCS_WRITE = BitOR($FCS_READ, $FCS_FORCEWRITE)
Global Const $SSF_AUTOCHECKSELECT = 0x00800000
Global Const $SSF_DESKTOPHTML = 0x00000200
Global Const $SSF_DONTPRETTYPATH = 0x00000800
Global Const $SSF_DOUBLECLICKINWEBVIEW = 0x00000080
Global Const $SSF_HIDEICONS = 0x00004000
Global Const $SSF_ICONSONLY = 0x01000000
Global Const $SSF_MAPNETDRVBUTTON = 0x00001000
Global Const $SSF_NOCONFIRMRECYCLE = 0x00008000
Global Const $SSF_NONETCRAWLING = 0x00100000
Global Const $SSF_SEPPROCESS = 0x00080000
Global Const $SSF_SHOWALLOBJECTS = 0x00000001
Global Const $SSF_SHOWCOMPCOLOR = 0x00000008
Global Const $SSF_SHOWEXTENSIONS = 0x00000002
Global Const $SSF_SHOWINFOTIP = 0x00002000
Global Const $SSF_SHOWSUPERHIDDEN = 0x00040000
Global Const $SSF_SHOWSYSFILES = 0x00000020
Global Const $SSF_SHOWTYPEOVERLAY = 0x02000000
Global Const $SSF_STARTPANELON = 0x00200000
Global Const $SSF_WIN95CLASSIC = 0x00000400
Global Const $SSF_WEBVIEW = 0x00020000
Global Const $CSIDL_ADMINTOOLS = 0x0030
Global Const $CSIDL_ALTSTARTUP = 0x001D
Global Const $CSIDL_APPDATA = 0x001A
Global Const $CSIDL_BITBUCKET = 0x000A
Global Const $CSIDL_CDBURN_AREA = 0x003B
Global Const $CSIDL_COMMON_ADMINTOOLS = 0x002F
Global Const $CSIDL_COMMON_ALTSTARTUP = 0x001E
Global Const $CSIDL_COMMON_APPDATA = 0x0023
Global Const $CSIDL_COMMON_DESKTOPDIRECTORY = 0x0019
Global Const $CSIDL_COMMON_DOCUMENTS = 0x002E
Global Const $CSIDL_COMMON_FAVORITES = 0x001F
Global Const $CSIDL_COMMON_MUSIC = 0x0035
Global Const $CSIDL_COMMON_PICTURES = 0x0036
Global Const $CSIDL_COMMON_PROGRAMS = 0x0017
Global Const $CSIDL_COMMON_STARTMENU = 0x0016
Global Const $CSIDL_COMMON_STARTUP = 0x0018
Global Const $CSIDL_COMMON_TEMPLATES = 0x002D
Global Const $CSIDL_COMMON_VIDEO = 0x0037
Global Const $CSIDL_COMPUTERSNEARME = 0x003D
Global Const $CSIDL_CONNECTIONS = 0x0031
Global Const $CSIDL_CONTROLS = 0x0003
Global Const $CSIDL_COOKIES = 0x0021
Global Const $CSIDL_DESKTOP = 0x0000
Global Const $CSIDL_DESKTOPDIRECTORY = 0x0010
Global Const $CSIDL_DRIVES = 0x0011
Global Const $CSIDL_FAVORITES = 0x0006
Global Const $CSIDL_FONTS = 0x0014
Global Const $CSIDL_INTERNET_CACHE = 0x0020
Global Const $CSIDL_HISTORY = 0x0022
Global Const $CSIDL_LOCAL_APPDATA = 0x001C
Global Const $CSIDL_MYMUSIC = 0x000D
Global Const $CSIDL_MYPICTURES = 0x0027
Global Const $CSIDL_MYVIDEO = 0x000E
Global Const $CSIDL_NETHOOD = 0x0013
Global Const $CSIDL_PERSONAL = 0x0005
Global Const $CSIDL_PRINTERS = 0x0004
Global Const $CSIDL_PRINTHOOD = 0x001B
Global Const $CSIDL_PROFILE = 0x0028
Global Const $CSIDL_PROGRAM_FILES = 0x0026
Global Const $CSIDL_PROGRAM_FILES_COMMON = 0x002B
Global Const $CSIDL_PROGRAM_FILES_COMMONX86 = 0x002C
Global Const $CSIDL_PROGRAM_FILESX86 = 0x002A
Global Const $CSIDL_PROGRAMS = 0x0002
Global Const $CSIDL_RECENT = 0x0008
Global Const $CSIDL_SENDTO = 0x0009
Global Const $CSIDL_STARTMENU = 0x000B
Global Const $CSIDL_STARTUP = 0x0007
Global Const $CSIDL_SYSTEM = 0x0025
Global Const $CSIDL_SYSTEMX86 = 0x0029
Global Const $CSIDL_TEMPLATES = 0x0015
Global Const $CSIDL_WINDOWS = 0x0024
Global Const $SIID_DOCNOASSOC = 0
Global Const $SIID_DOCASSOC = 1
Global Const $SIID_APPLICATION = 2
Global Const $SIID_FOLDER = 3
Global Const $SIID_FOLDEROPEN = 4
Global Const $SIID_DRIVE525 = 5
Global Const $SIID_DRIVE35 = 6
Global Const $SIID_DRIVEREMOVE = 7
Global Const $SIID_DRIVEFIXED = 8
Global Const $SIID_DRIVENET = 9
Global Const $SIID_DRIVENETDISABLED = 10
Global Const $SIID_DRIVECD = 11
Global Const $SIID_DRIVERAM = 12
Global Const $SIID_WORLD = 13
Global Const $SIID_SERVER = 15
Global Const $SIID_PRINTER = 16
Global Const $SIID_MYNETWORK = 17
Global Const $SIID_FIND = 22
Global Const $SIID_HELP = 23
Global Const $SIID_SHARE = 28
Global Const $SIID_LINK = 29
Global Const $SIID_SLOWFILE = 30
Global Const $SIID_RECYCLER = 31
Global Const $SIID_RECYCLERFULL = 32
Global Const $SIID_MEDIACDAUDIO = 40
Global Const $SIID_LOCK = 47
Global Const $SIID_AUTOLIST = 49
Global Const $SIID_PRINTERNET = 50
Global Const $SIID_SERVERSHARE = 51
Global Const $SIID_PRINTERFAX = 52
Global Const $SIID_PRINTERFAXNET = 53
Global Const $SIID_PRINTERFILE = 54
Global Const $SIID_STACK = 55
Global Const $SIID_MEDIASVCD = 56
Global Const $SIID_STUFFEDFOLDER = 57
Global Const $SIID_DRIVEUNKNOWN = 58
Global Const $SIID_DRIVEDVD = 59
Global Const $SIID_MEDIADVD = 60
Global Const $SIID_MEDIADVDRAM = 61
Global Const $SIID_MEDIADVDRW = 62
Global Const $SIID_MEDIADVDR = 63
Global Const $SIID_MEDIADVDROM = 64
Global Const $SIID_MEDIACDAUDIOPLUS = 65
Global Const $SIID_MEDIACDRW = 66
Global Const $SIID_MEDIACDR = 67
Global Const $SIID_MEDIACDBURN = 68
Global Const $SIID_MEDIABLANKCD = 69
Global Const $SIID_MEDIACDROM = 70
Global Const $SIID_AUDIOFILES = 71
Global Const $SIID_IMAGEFILES = 72
Global Const $SIID_VIDEOFILES = 73
Global Const $SIID_MIXEDFILES = 74
Global Const $SIID_FOLDERBACK = 75
Global Const $SIID_FOLDERFRONT = 76
Global Const $SIID_SHIELD = 77
Global Const $SIID_WARNING = 78
Global Const $SIID_INFO = 79
Global Const $SIID_ERROR = 80
Global Const $SIID_KEY = 81
Global Const $SIID_SOFTWARE = 82
Global Const $SIID_RENAME = 83
Global Const $SIID_DELETE = 84
Global Const $SIID_MEDIAAUDIODVD = 85
Global Const $SIID_MEDIAMOVIEDVD = 86
Global Const $SIID_MEDIAENHANCEDCD = 87
Global Const $SIID_MEDIAENHANCEDDVD = 88
Global Const $SIID_MEDIAHDDVD = 89
Global Const $SIID_MEDIABLURAY = 90
Global Const $SIID_MEDIAVCD = 91
Global Const $SIID_MEDIADVDPLUSR = 92
Global Const $SIID_MEDIADVDPLUSRW = 93
Global Const $SIID_DESKTOPPC = 94
Global Const $SIID_MOBILEPC = 95
Global Const $SIID_USERS = 96
Global Const $SIID_MEDIASMARTMEDIA = 97
Global Const $SIID_MEDIACOMPACTFLASH = 98
Global Const $SIID_DEVICECELLPHONE = 99
Global Const $SIID_DEVICECAMERA = 100
Global Const $SIID_DEVICEVIDEOCAMERA = 101
Global Const $SIID_DEVICEAUDIOPLAYER = 102
Global Const $SIID_NETWORKCONNECT = 103
Global Const $SIID_INTERNET = 104
Global Const $SIID_ZIPFILE = 105
Global Const $SIID_SETTINGS = 106
Global Const $SIID_DRIVEHDDVD = 132
Global Const $SIID_DRIVEBD = 133
Global Const $SIID_MEDIAHDDVDROM = 134
Global Const $SIID_MEDIAHDDVDR = 135
Global Const $SIID_MEDIAHDDVDRAM = 136
Global Const $SIID_MEDIABDROM = 137
Global Const $SIID_MEDIABDR = 138
Global Const $SIID_MEDIABDRE = 139
Global Const $SIID_CLUSTEREDDRIVE = 140
Global Const $SIID_MAX_ICONS = 174
Global Const $SHGSI_ICONLOCATION = 0
Global Const $SHGSI_ICON = $SHGFI_ICON
Global Const $SHGSI_SYSICONINDEX = $SHGFI_SYSICONINDEX
Global Const $SHGSI_LINKOVERLAY = $SHGFI_LINKOVERLAY
Global Const $SHGSI_SELECTED = $SHGFI_SELECTED
Global Const $SHGSI_LARGEICON = $SHGFI_LARGEICON
Global Const $SHGSI_SMALLICON = $SHGFI_SMALLICON
Global Const $SHGSI_SHELLICONSIZE = $SHGFI_SHELLICONSIZE
Global Const $NIM_ADD = 0x00
Global Const $NIM_MODIFY = 0x01
Global Const $NIM_DELETE = 0x02
Global Const $NIM_SETFOCUS = 0x03
Global Const $NIM_SETVERSION = 0x04
Global Const $NIF_MESSAGE = 0x01
Global Const $NIF_ICON = 0x02
Global Const $NIF_TIP = 0x04
Global Const $NIF_STATE = 0x08
Global Const $NIF_INFO = 0x10
Global Const $NIF_GUID = 0x20
Global Const $NIF_REALTIME = 0x40
Global Const $NIF_SHOWTIP = 0x80
Global Const $NIS_HIDDEN = 0x01
Global Const $NIS_SHAREDICON = 0x02
Global Const $NIIF_NONE = 0x00
Global Const $NIIF_INFO = 0x01
Global Const $NIIF_WARNING = 0x02
Global Const $NIIF_ERROR = 0x03
Global Const $NIIF_USER = 0x04
Global Const $NIIF_NOSOUND = 0x10
Global Const $NIIF_LARGE_ICON = 0x10
Global Const $NIIF_RESPECT_QUIET_TIME = 0x80
Global Const $NIIF_ICON_MASK = 0x0F
Global Const $SHOP_PRINTERNAME = 1
Global Const $SHOP_FILEPATH = 2
Global Const $SHOP_VOLUMEGUID = 4
Global Const $OFASI_EDIT = 0x01
Global Const $OFASI_OPENDESKTOP = 0x02
Global Const $QUNS_NOT_PRESENT = 1
Global Const $QUNS_BUSY = 2
Global Const $QUNS_RUNNING_D3D_FULL_SCREEN = 3
Global Const $QUNS_PRESENTATION_MODE = 4
Global Const $QUNS_ACCEPTS_NOTIFICATIONS = 5
Global Const $QUNS_QUIET_TIME = 6
Global Const $REST_NORUN = 1
Global Const $REST_NOCLOSE = 2
Global Const $REST_NOSAVESET = 3
Global Const $REST_NOFILEMENU = 4
Global Const $REST_NOSETFOLDERS = 5
Global Const $REST_NOSETTASKBAR = 6
Global Const $REST_NODESKTOP = 7
Global Const $REST_NOFIND = 8
Global Const $REST_NODRIVES = 9
Global Const $REST_NODRIVEAUTORUN = 10
Global Const $REST_NODRIVETYPEAUTORUN = 11
Global Const $REST_NONETHOOD = 12
Global Const $REST_STARTBANNER = 13
Global Const $REST_RESTRICTRUN = 14
Global Const $REST_NOPRINTERTABS = 15
Global Const $REST_NOPRINTERDELETE = 16
Global Const $REST_NOPRINTERADD = 17
Global Const $REST_NOSTARTMENUSUBFOLDERS = 18
Global Const $REST_MYDOCSONNET = 19
Global Const $REST_NOEXITTODOS = 20
Global Const $REST_ENFORCESHELLEXTSECURITY = 21
Global Const $REST_LINKRESOLVEIGNORELINKINFO = 22
Global Const $REST_NOCOMMONGROUPS = 23
Global Const $REST_SEPARATEDESKTOPPROCESS = 24
Global Const $REST_NOWEB = 25
Global Const $REST_NOTRAYCONTEXTMENU = 26
Global Const $REST_NOVIEWCONTEXTMENU = 27
Global Const $REST_NONETCONNECTDISCONNECT = 28
Global Const $REST_STARTMENULOGOFF = 29
Global Const $REST_NOSETTINGSASSIST = 30
Global Const $REST_NOINTERNETICON = 31
Global Const $REST_NORECENTDOCSHISTORY = 32
Global Const $REST_NORECENTDOCSMENU = 33
Global Const $REST_NOACTIVEDESKTOP = 34
Global Const $REST_NOACTIVEDESKTOPCHANGES = 35
Global Const $REST_NOFAVORITESMENU = 36
Global Const $REST_CLEARRECENTDOCSONEXIT = 37
Global Const $REST_CLASSICSHELL = 38
Global Const $REST_NOCUSTOMIZEWEBVIEW = 39
Global Const $REST_NOHTMLWALLPAPER = 40
Global Const $REST_NOCHANGINGWALLPAPER = 41
Global Const $REST_NODESKCOMP = 42
Global Const $REST_NOADDDESKCOMP = 43
Global Const $REST_NODELDESKCOMP = 44
Global Const $REST_NOCLOSEDESKCOMP = 45
Global Const $REST_NOCLOSE_DRAGDROPBAND = 46
Global Const $REST_NOMOVINGBAND = 47
Global Const $REST_NOEDITDESKCOMP = 48
Global Const $REST_NORESOLVESEARCH = 49
Global Const $REST_NORESOLVETRACK = 50
Global Const $REST_FORCECOPYACLWITHFILE = 51
Global Const $REST_NOLOGO3CHANNELNOTIFY = 52
Global Const $REST_NOFORGETSOFTWAREUPDATE = 53
Global Const $REST_NOSETACTIVEDESKTOP = 54
Global Const $REST_NOUPDATEWINDOWS = 55
Global Const $REST_NOCHANGESTARMENU = 56
Global Const $REST_NOFOLDEROPTIONS = 57
Global Const $REST_HASFINDCOMPUTERS = 58
Global Const $REST_INTELLIMENUS = 59
Global Const $REST_RUNDLGMEMCHECKBOX = 60
Global Const $REST_ARP_ShowPostSetup = 61
Global Const $REST_NOCSC = 62
Global Const $REST_NOCONTROLPANEL = 63
Global Const $REST_ENUMWORKGROUP = 64
Global Const $REST_ARP_NOARP = 65
Global Const $REST_ARP_NOREMOVEPAGE = 66
Global Const $REST_ARP_NOADDPAGE = 67
Global Const $REST_ARP_NOWINSETUPPAGE = 68
Global Const $REST_GREYMSIADS = 69
Global Const $REST_NOCHANGEMAPPEDDRIVELABEL = 70
Global Const $REST_NOCHANGEMAPPEDDRIVECOMMENT = 71
Global Const $REST_MAXRECENTDOCS = 72
Global Const $REST_NONETWORKCONNECTIONS = 73
Global Const $REST_FORCESTARTMENULOGOFF = 74
Global Const $REST_NOWEBVIEW = 75
Global Const $REST_NOCUSTOMIZETHISFOLDER = 76
Global Const $REST_NOENCRYPTION = 77
Global Const $REST_DONTSHOWSUPERHIDDEN = 78
Global Const $REST_NOSHELLSEARCHBUTTON = 79
Global Const $REST_NOHARDWARETAB = 80
Global Const $REST_NORUNASINSTALLPROMPT = 81
Global Const $REST_PROMPTRUNASINSTALLNETPATH = 82
Global Const $REST_NOMANAGEMYCOMPUTERVERB = 83
Global Const $REST_NORECENTDOCSNETHOOD = 84
Global Const $REST_DISALLOWRUN = 85
Global Const $REST_NOWELCOMESCREEN = 86
Global Const $REST_RESTRICTCPL = 87
Global Const $REST_DISALLOWCPL = 88
Global Const $REST_NOSMBALLOONTIP = 89
Global Const $REST_NOSMHELP = 90
Global Const $REST_NOWINKEYS = 91
Global Const $REST_NOENCRYPTONMOVE = 92
Global Const $REST_NOLOCALMACHINERUN = 93
Global Const $REST_NOCURRENTUSERRUN = 94
Global Const $REST_NOLOCALMACHINERUNONCE = 95
Global Const $REST_NOCURRENTUSERRUNONCE = 96
Global Const $REST_FORCEACTIVEDESKTOPON = 97
Global Const $REST_NOCOMPUTERSNEARME = 98
Global Const $REST_NOVIEWONDRIVE = 99
Global Const $REST_NONETCRAWL = 100
Global Const $REST_NOSHAREDDOCUMENTS = 101
Global Const $REST_NOSMMYDOCS = 102
Global Const $REST_NOSMMYPICS = 103
Global Const $REST_ALLOWBITBUCKDRIVES = 104
Global Const $REST_NONLEGACYSHELLMODE = 105
Global Const $REST_NOCONTROLPANELBARRICADE = 106
Global Const $REST_NOSTARTPAGE = 107
Global Const $REST_NOAUTOTRAYNOTIFY = 108
Global Const $REST_NOTASKGROUPING = 109
Global Const $REST_NOCDBURNING = 110
Global Const $REST_MYCOMPNOPROP = 111
Global Const $REST_MYDOCSNOPROP = 112
Global Const $REST_NOSTARTPANEL = 113
Global Const $REST_NODISPLAYAPPEARANCEPAGE = 114
Global Const $REST_NOTHEMESTAB = 115
Global Const $REST_NOVISUALSTYLECHOICE = 116
Global Const $REST_NOSIZECHOICE = 117
Global Const $REST_NOCOLORCHOICE = 118
Global Const $REST_SETVISUALSTYLE = 119
Global Const $REST_STARTRUNNOHOMEPATH = 120
Global Const $REST_NOUSERNAMEINSTARTPANEL = 121
Global Const $REST_NOMYCOMPUTERICON = 122
Global Const $REST_NOSMNETWORKPLACES = 123
Global Const $REST_NOSMPINNEDLIST = 124
Global Const $REST_NOSMMYMUSIC = 125
Global Const $REST_NOSMEJECTPC = 126
Global Const $REST_NOSMMOREPROGRAMS = 127
Global Const $REST_NOSMMFUPROGRAMS = 128
Global Const $REST_NOTRAYITEMSDISPLAY = 129
Global Const $REST_NOTOOLBARSONTASKBAR = 130
Global Const $REST_NOSMCONFIGUREPROGRAMS = 131
Global Const $REST_HIDECLOCK = 132
Global Const $REST_NOLOWDISKSPACECHECKS = 133
Global Const $REST_NOENTIRENETWORK = 134
Global Const $REST_NODESKTOPCLEANUP = 135
Global Const $REST_BITBUCKNUKEONDELETE = 136
Global Const $REST_BITBUCKCONFIRMDELETE = 137
Global Const $REST_BITBUCKNOPROP = 138
Global Const $REST_NODISPBACKGROUND = 139
Global Const $REST_NODISPSCREENSAVEPG = 140
Global Const $REST_NODISPSETTINGSPG = 141
Global Const $REST_NODISPSCREENSAVEPREVIEW = 142
Global Const $REST_NODISPLAYCPL = 143
Global Const $REST_HIDERUNASVERB = 144
Global Const $REST_NOTHUMBNAILCACHE = 145
Global Const $REST_NOSTRCMPLOGICAL = 146
Global Const $REST_NOPUBLISHWIZARD = 147
Global Const $REST_NOONLINEPRINTSWIZARD = 148
Global Const $REST_NOWEBSERVICES = 149
Global Const $REST_ALLOWUNHASHEDWEBVIEW = 150
Global Const $REST_ALLOWLEGACYWEBVIEW = 151
Global Const $REST_REVERTWEBVIEWSECURITY = 152
Global Const $REST_INHERITCONSOLEHANDLES = 153
Global Const $REST_SORTMAXITEMCOUNT = 154
Global Const $REST_NOREMOTERECURSIVEEVENTS = 155
Global Const $REST_NOREMOTECHANGENOTIFY = 156
Global Const $REST_NOSIMPLENETIDLIST = 157
Global Const $REST_NOENUMENTIRENETWORK = 158
Global Const $REST_NODETAILSTHUMBNAILONNETWORK = 159
Global Const $REST_NOINTERNETOPENWITH = 160
Global Const $REST_ALLOWLEGACYLMZBEHAVIOR = 161
Global Const $REST_DONTRETRYBADNETNAME = 162
Global Const $REST_ALLOWFILECLSIDJUNCTIONS = 163
Global Const $REST_NOUPNPINSTALL = 164
Global Const $REST_ARP_DONTGROUPPATCHES = 165
Global Const $REST_ARP_NOCHOOSEPROGRAMSPAGE = 166
Global Const $REST_NODISCONNECT = 167
Global Const $REST_NOSECURITY = 168
Global Const $REST_NOFILEASSOCIATE = 169
Global Const $REST_ALLOWCOMMENTTOGGLE = 170
Global Const $REST_USEDESKTOPINICACHE = 171
Global Const $GIL_DONTCACHE = 0x0010
Global Const $GIL_NOTFILENAME = 0x0008
Global Const $GIL_PERCLASS = 0x0004
Global Const $GIL_PERINSTANCE = 0x0002
Global Const $GIL_SIMULATEDOC = 0x0001
Global Const $GIL_SHIELD = 0x0200
Global Const $GIL_FORCENOSHIELD = 0x0400
Global Const $FOLDERID_AddNewPrograms = '{DE61D971-5EBC-4F02-A3A9-6C82895E5C04}'
Global Const $FOLDERID_AdminTools = '{724EF170-A42D-4FEF-9F26-B60E846FBA4F}'
Global Const $FOLDERID_AppUpdates = '{A305CE99-F527-492B-8B1A-7E76FA98D6E4}'
Global Const $FOLDERID_CDBurning = '{9E52AB10-F80D-49DF-ACB8-4330F5687855}'
Global Const $FOLDERID_ChangeRemovePrograms = '{DF7266AC-9274-4867-8D55-3BD661DE872D}'
Global Const $FOLDERID_CommonAdminTools = '{D0384E7D-BAC3-4797-8F14-CBA229B392B5}'
Global Const $FOLDERID_CommonOEMLinks = '{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}'
Global Const $FOLDERID_CommonPrograms = '{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}'
Global Const $FOLDERID_CommonStartMenu = '{A4115719-D62E-491D-AA7C-E74B8BE3B067}'
Global Const $FOLDERID_CommonStartup = '{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}'
Global Const $FOLDERID_CommonTemplates = '{B94237E7-57AC-4347-9151-B08C6C32D1F7}'
Global Const $FOLDERID_ComputerFolder = '{0AC0837C-BBF8-452A-850D-79D08E667CA7}'
Global Const $FOLDERID_ConflictFolder = '{4BFEFB45-347D-4006-A5BE-AC0CB0567192}'
Global Const $FOLDERID_ConnectionsFolder = '{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}'
Global Const $FOLDERID_Contacts = '{56784854-C6CB-462B-8169-88E350ACB882}'
Global Const $FOLDERID_ControlPanelFolder = '{82A74AEB-AEB4-465C-A014-D097EE346D63}'
Global Const $FOLDERID_Cookies = '{2B0F765D-C0E9-4171-908E-08A611B84FF6}'
Global Const $FOLDERID_Desktop = '{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}'
Global Const $FOLDERID_DeviceMetadataStore = '{5CE4A5E9-E4EB-479D-B89F-130C02886155}'
Global Const $FOLDERID_DocumentsLibrary = '{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}'
Global Const $FOLDERID_Downloads = '{374DE290-123F-4565-9164-39C4925E467B}'
Global Const $FOLDERID_Favorites = '{1777F761-68AD-4D8A-87BD-30B759FA33DD}'
Global Const $FOLDERID_Fonts = '{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}'
Global Const $FOLDERID_Games = '{CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434}'
Global Const $FOLDERID_GameTasks = '{054FAE61-4DD8-4787-80B6-090220C4B700}'
Global Const $FOLDERID_History = '{D9DC8A3B-B784-432E-A781-5A1130A75963}'
Global Const $FOLDERID_HomeGroup = '{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}'
Global Const $FOLDERID_ImplicitAppShortcuts = '{BCB5256F-79F6-4CEE-B725-DC34E402FD46}'
Global Const $FOLDERID_InternetCache = '{352481E8-33BE-4251-BA85-6007CAEDCF9D}'
Global Const $FOLDERID_InternetFolder = '{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}'
Global Const $FOLDERID_Libraries = '{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}'
Global Const $FOLDERID_Links = '{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}'
Global Const $FOLDERID_LocalAppData = '{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}'
Global Const $FOLDERID_LocalAppDataLow = '{A520A1A4-1780-4FF6-BD18-167343C5AF16}'
Global Const $FOLDERID_LocalizedResourcesDir = '{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}'
Global Const $FOLDERID_Music = '{4BD8D571-6D19-48D3-BE97-422220080E43}'
Global Const $FOLDERID_MusicLibrary = '{2112AB0A-C86A-4FFE-A368-0DE96E47012E}'
Global Const $FOLDERID_NetHood = '{C5ABBF53-E17F-4121-8900-86626FC2C973}'
Global Const $FOLDERID_NetworkFolder = '{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}'
Global Const $FOLDERID_OriginalImages = '{2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39}'
Global Const $FOLDERID_PhotoAlbums = '{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}'
Global Const $FOLDERID_PicturesLibrary = '{A990AE9F-A03B-4E80-94BC-9912D7504104}'
Global Const $FOLDERID_Pictures = '{33E28130-4E1E-4676-835A-98395C3BC3BB}'
Global Const $FOLDERID_Playlists = '{DE92C1C7-837F-4F69-A3BB-86E631204A23}'
Global Const $FOLDERID_PrintersFolder = '{76FC4E2D-D6AD-4519-A663-37BD56068185}'
Global Const $FOLDERID_PrintHood = '{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}'
Global Const $FOLDERID_Profile = '{5E6C858F-0E22-4760-9AFE-EA3317B67173}'
Global Const $FOLDERID_ProgramData = '{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}'
Global Const $FOLDERID_ProgramFiles = '{905E63B6-C1BF-494E-B29C-65B732D3D21A}'
Global Const $FOLDERID_ProgramFilesX64 = '{6D809377-6AF0-444B-8957-A3773F02200E}'
Global Const $FOLDERID_ProgramFilesX86 = '{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}'
Global Const $FOLDERID_ProgramFilesCommon = '{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}'
Global Const $FOLDERID_ProgramFilesCommonX64 = '{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}'
Global Const $FOLDERID_ProgramFilesCommonX86 = '{DE974D24-D9C6-4D3E-BF91-F4455120B917}'
Global Const $FOLDERID_Programs = '{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}'
Global Const $FOLDERID_Public = '{DFDF76A2-C82A-4D63-906A-5644AC457385}'
Global Const $FOLDERID_PublicDesktop = '{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}'
Global Const $FOLDERID_PublicDocuments = '{ED4824AF-DCE4-45A8-81E2-FC7965083634}'
Global Const $FOLDERID_PublicDownloads = '{3D644C9B-1FB8-4F30-9B45-F670235F79C0}'
Global Const $FOLDERID_PublicGameTasks = '{DEBF2536-E1A8-4C59-B6A2-414586476AEA}'
Global Const $FOLDERID_PublicLibraries = '{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}'
Global Const $FOLDERID_PublicMusic = '{3214FAB5-9757-4298-BB61-92A9DEAA44FF}'
Global Const $FOLDERID_PublicPictures = '{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}'
Global Const $FOLDERID_PublicRingtones = '{E555AB60-153B-4D17-9F04-A5FE99FC15EC}'
Global Const $FOLDERID_PublicVideos = '{2400183A-6185-49FB-A2D8-4A392A602BA3}'
Global Const $FOLDERID_QuickLaunch = '{52A4F021-7B75-48A9-9F6B-4B87A210BC8F}'
Global Const $FOLDERID_Recent = '{AE50C081-EBD2-438A-8655-8A092E34987A}'
Global Const $FOLDERID_RecordedTVLibrary = '{1A6FDBA2-F42D-4358-A798-B74D745926C5}'
Global Const $FOLDERID_RecycleBinFolder = '{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}'
Global Const $FOLDERID_ResourceDir = '{8AD10C31-2ADB-4296-A8F7-E4701232C972}'
Global Const $FOLDERID_Ringtones = '{C870044B-F49E-4126-A9C3-B52A1FF411E8}'
Global Const $FOLDERID_RoamingAppData = '{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}'
Global Const $FOLDERID_SampleMusic = '{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}'
Global Const $FOLDERID_SamplePictures = '{C4900540-2379-4C75-844B-64E6FAF8716B}'
Global Const $FOLDERID_SamplePlaylists = '{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}'
Global Const $FOLDERID_SampleVideos = '{859EAD94-2E85-48AD-A71A-0969CB56A6CD}'
Global Const $FOLDERID_SavedGames = '{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}'
Global Const $FOLDERID_SavedSearches = '{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}'
Global Const $FOLDERID_SEARCH_CSC = '{EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E}'
Global Const $FOLDERID_SEARCH_MAPI = '{98EC0E18-2098-4D44-8644-66979315A281}'
Global Const $FOLDERID_SearchHome = '{190337D1-B8CA-4121-A639-6D472D16972A}'
Global Const $FOLDERID_SendTo = '{8983036C-27C0-404B-8F08-102D10DCFD74}'
Global Const $FOLDERID_SidebarDefaultParts = '{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}'
Global Const $FOLDERID_SidebarParts = '{A75D362E-50FC-4FB7-AC2C-A8BEAA314493}'
Global Const $FOLDERID_StartMenu = '{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}'
Global Const $FOLDERID_Startup = '{B97D20BB-F46A-4C97-BA10-5E3608430854}'
Global Const $FOLDERID_SyncManagerFolder = '{43668BF8-C14E-49B2-97C9-747784D784B7}'
Global Const $FOLDERID_SyncResultsFolder = '{289A9A43-BE44-4057-A41B-587A76D7E7F9}'
Global Const $FOLDERID_SyncSetupFolder = '{0F214138-B1D3-4A90-BBA9-27CBC0C5389A}'
Global Const $FOLDERID_System = '{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}'
Global Const $FOLDERID_SystemX86 = '{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}'
Global Const $FOLDERID_Templates = '{A63293E8-664E-48DB-A079-DF759E0509F7}'
Global Const $FOLDERID_UserPinned = '{9E3995AB-1F9C-4F13-B827-48B24B6C7174}'
Global Const $FOLDERID_UserProfiles = '{0762D272-C50A-4BB0-A382-697DCD729B80}'
Global Const $FOLDERID_UserProgramFiles = '{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}'
Global Const $FOLDERID_UserProgramFilesCommon = '{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}'
Global Const $FOLDERID_UsersFiles = '{F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F}'
Global Const $FOLDERID_UsersLibraries = '{A302545D-DEFF-464B-ABE8-61C8648D939B}'
Global Const $FOLDERID_Videos = '{18989B1D-99B5-455B-841C-AB7C74E4DDFC}'
Global Const $FOLDERID_VideosLibrary = '{491E922F-5643-4AF4-A7EB-4E7A138D8174}'
Global Const $FOLDERID_Windows = '{F38BF404-1D43-42F2-9305-67DE0B28FC23}'
Global Const $KF_FLAG_ALIAS_ONLY = 0x80000000
Global Const $KF_FLAG_CREATE = 0x00008000
Global Const $KF_FLAG_DONT_VERIFY = 0x00004000
Global Const $KF_FLAG_DONT_UNEXPAND = 0x00002000
Global Const $KF_FLAG_NO_ALIAS = 0x00001000
Global Const $KF_FLAG_INIT = 0x00000800
Global Const $KF_FLAG_DEFAULT_PATH = 0x00000400
Global Const $KF_FLAG_NO_APPCONTAINER_REDIRECTION = 0x00010000
Global Const $KF_FLAG_NOT_PARENT_RELATIVE = 0x00000200
Global Const $KF_FLAG_SIMPLE_IDLIST = 0x00000100
Global Const $URL_SCHEME_INVALID = -1
Global Const $URL_SCHEME_UNKNOWN = 0
Global Const $URL_SCHEME_FTP = 1
Global Const $URL_SCHEME_HTTP = 2
Global Const $URL_SCHEME_GOPHER = 3
Global Const $URL_SCHEME_MAILTO = 4
Global Const $URL_SCHEME_NEWS = 5
Global Const $URL_SCHEME_NNTP = 6
Global Const $URL_SCHEME_TELNET = 7
Global Const $URL_SCHEME_WAIS = 8
Global Const $URL_SCHEME_FILE = 9
Global Const $URL_SCHEME_MK = 10
Global Const $URL_SCHEME_HTTPS = 11
Global Const $URL_SCHEME_SHELL = 12
Global Const $URL_SCHEME_SNEWS = 13
Global Const $URL_SCHEME_LOCAL = 14
Global Const $URL_SCHEME_JAVASCRIPT = 15
Global Const $URL_SCHEME_VBSCRIPT = 16
Global Const $URL_SCHEME_ABOUT = 17
Global Const $URL_SCHEME_RES = 18
Global Const $URL_SCHEME_MSSHELLROOTED = 19
Global Const $URL_SCHEME_MSSHELLIDLIST = 20
Global Const $URL_SCHEME_MSHELP = 21
Global Const $URL_SCHEME_MSSHELLDEVICE = 22
Global Const $URL_SCHEME_WILDCARD = 23
Global Const $URL_SCHEME_SEARCH_MS = 24
Global Const $URL_SCHEME_SEARCH = 25
Global Const $URL_SCHEME_KNOWNFOLDER = 26
Global Const $GCT_INVALID = 0x00
Global Const $GCT_LFNCHAR = 0x01
Global Const $GCT_SEPARATOR = 0x08
Global Const $GCT_SHORTCHAR = 0x02
Global Const $GCT_WILD = 0x04
Global Const $URL_APPLY_DEFAULT = 0x01
Global Const $URL_APPLY_GUESSSCHEME = 0x02
Global Const $URL_APPLY_GUESSFILE = 0x04
Global Const $URL_APPLY_FORCEAPPLY = 0x08
Global Const $URL_DONT_SIMPLIFY = 0x08000000
Global Const $URL_ESCAPE_AS_UTF8 = 0x00040000
Global Const $URL_ESCAPE_PERCENT = 0x00001000
Global Const $URL_ESCAPE_SPACES_ONLY = 0x04000000
Global Const $URL_ESCAPE_UNSAFE = 0x20000000
Global Const $URL_NO_META = 0x08000000
Global Const $URL_PLUGGABLE_PROTOCOL = 0x40000000
Global Const $URL_UNESCAPE = 0x10000000
Global Const $URL_PART_HOSTNAME = 2
Global Const $URL_PART_PASSWORD = 4
Global Const $URL_PART_PORT = 5
Global Const $URL_PART_QUERY = 6
Global Const $URL_PART_SCHEME = 1
Global Const $URL_PART_USERNAME = 3
Global Const $URLIS_APPLIABLE = 4
Global Const $URLIS_DIRECTORY = 5
Global Const $URLIS_FILEURL = 3
Global Const $URLIS_HASQUERY = 6
Global Const $URLIS_NOHISTORY = 2
Global Const $URLIS_OPAQUE = 1
Global Const $URLIS_URL = 0
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CommandLineToArgv($sCmd)
Local $aResult[1] = [0]
$sCmd = StringStripWS($sCmd, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If Not $sCmd Then
Return $aResult
EndIf
Local $aRet = DllCall('shell32.dll', 'ptr', 'CommandLineToArgvW', 'wstr', $sCmd, 'int*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[2]) Then Return SetError(@error + 10, @extended, 0)
Local $tPtr = DllStructCreate('ptr[' & $aRet[2] & ']', $aRet[0])
Dim $aResult[$aRet[2] + 1] = [$aRet[2]]
For $i = 1 To $aRet[2]
$aResult[$i] = _WinAPI_GetString(DllStructGetData($tPtr, 1, $i))
Next
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $aRet[0])
Return $aResult
EndFunc
Func _WinAPI_IsNameInExpression($sString, $sPattern, $bCaseSensitive = False)
If Not $bCaseSensitive Then $sPattern = StringUpper($sPattern)
Local $tUS1 = __US($sPattern)
Local $tUS2 = __US($sString)
Local $aRet = DllCall('ntdll.dll', 'boolean', 'RtlIsNameInExpression', 'struct*', $tUS1, 'struct*', $tUS2,  'boolean', Not $bCaseSensitive, 'ptr', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ParseURL($sUrl)
Local $tagPARSEDURL = 'dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme'
Local $tPURL = DllStructCreate($tagPARSEDURL)
DllStructSetData($tPURL, 1, DllStructGetSize($tPURL))
Local $tURL = DllStructCreate('wchar[4096]')
DllStructSetData($tURL, 1, $sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'ParseURLW', 'struct*', $tURL, 'struct*', $tPURL)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $aResult[3]
$aResult[0] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 3) & ']', DllStructGetData($tPURL, 2)), 1)
$aResult[1] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 5) & ']', DllStructGetData($tPURL, 4)), 1)
$aResult[2] = DllStructGetData($tPURL, 6)
Return $aResult
EndFunc
Func _WinAPI_ParseUserName($sUser)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $aRet = DllCall('credui.dll', 'dword', 'CredUIParseUserNameW', 'wstr', $sUser, 'wstr', '', 'ulong', 4096, 'wstr', '',  'ulong', 4096)
If @error Then Return SetError(@error, @extended, 0)
Switch $aRet[0]
Case 0
Case 1315
If StringStripWS($sUser, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$aRet[2] = $sUser
$aRet[4] = ''
Else
ContinueCase
EndIf
Case Else
Return SetError(10, $aRet[0], 0)
EndSwitch
Local $aResult[2]
$aResult[0] = $aRet[4]
$aResult[1] = $aRet[2]
Return $aResult
EndFunc
Func _WinAPI_PathAddBackslash($sFilePath)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathAddBackslashW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathAddExtension($sFilePath, $sExt = '')
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $sTypeOfExt = 'wstr'
If Not StringStripWS($sExt, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfExt = 'ptr'
$sExt = 0
EndIf
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathAddExtensionW', 'struct*', $tPath, $sTypeOfExt, $sExt)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], DllStructGetData($tPath, 1))
EndFunc
Func _WinAPI_PathAppend($sFilePath, $sMore)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathAppendW', 'struct*', $tPath, 'wstr', $sMore)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathBuildRoot($iDrive)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathBuildRootW', 'wstr', '', 'int', $iDrive)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathCanonicalize($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathCanonicalizeW', 'wstr', '', 'wstr', $sFilePath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, $sFilePath)
Return $aRet[1]
EndFunc
Func _WinAPI_PathCommonPrefix($sPath1, $sPath2)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathCommonPrefixW', 'wstr', $sPath1, 'wstr', $sPath2, 'wstr', '')
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], $aRet[3])
EndFunc
Func _WinAPI_PathCompactPath($hWnd, $sFilePath, $iWidth = 0)
If $iWidth < 1 Then
Local $tRECT = DllStructCreate($tagRECT)
DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
$iWidth += DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', $hWnd)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, $sFilePath)
Local $hDC = $aRet[0]
Local Const $WM_GETFONT = 0x0031
$aRet = DllCall('user32.dll', 'ptr', 'SendMessage', 'hwnd', $hWnd, 'uint', $WM_GETFONT, 'wparam', 0, 'lparam', 0)
Local $hBack = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $aRet[0])
Local $iError = 0
$aRet = DllCall('shlwapi.dll', 'bool', 'PathCompactPathW', 'handle', $hDC, 'wstr', $sFilePath, 'int', $iWidth)
If @error Or Not $aRet[0] Then $iError = @error + 10
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hBack[0])
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If $iError Then Return SetError($iError, 0, $sFilePath)
Return $aRet[2]
EndFunc
Func _WinAPI_PathCompactPathEx($sFilePath, $iMax)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathCompactPathExW', 'wstr', '', 'wstr', $sFilePath, 'uint', $iMax + 1, 'dword', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, $sFilePath)
Return $aRet[1]
EndFunc
Func _WinAPI_PathCreateFromUrl($sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'PathCreateFromUrlW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathFindExtension($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'wstr', 'PathFindExtensionW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[0]
EndFunc
Func _WinAPI_PathFindFileName($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'wstr', 'PathFindFileNameW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, $sFilePath)
Return $aRet[0]
EndFunc
Func _WinAPI_PathFindNextComponent($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathFindNextComponentW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathFindOnPath(Const $sFilePath, $aExtraPaths = "", Const $sPathDelimiter = @LF)
Local $iExtraCount = 0
If IsString($aExtraPaths) Then
If StringLen($aExtraPaths) Then
$aExtraPaths = StringSplit($aExtraPaths, $sPathDelimiter, $STR_ENTIRESPLIT + $STR_NOCOUNT)
$iExtraCount = UBound($aExtraPaths, $UBOUND_ROWS)
EndIf
ElseIf IsArray($aExtraPaths) Then
$iExtraCount = UBound($aExtraPaths)
EndIf
Local $tPaths, $tPathPtrs
If $iExtraCount Then
Local $tagStruct = ""
For $path In $aExtraPaths
$tagStruct &= "wchar[" & StringLen($path) + 1 & "];"
Next
$tPaths = DllStructCreate($tagStruct)
$tPathPtrs = DllStructCreate("ptr[" & $iExtraCount + 1 & "]")
For $i = 1 To $iExtraCount
DllStructSetData($tPaths, $i, $aExtraPaths[$i - 1])
DllStructSetData($tPathPtrs, 1, DllStructGetPtr($tPaths, $i), $i)
Next
DllStructSetData($tPathPtrs, 1, Ptr(0), $iExtraCount + 1)
EndIf
Local $aResult = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $sFilePath, "struct*", $tPathPtrs)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, $sFilePath)
Return $aResult[1]
EndFunc
Func _WinAPI_PathGetArgs($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathGetArgsW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathGetCharType($sChar)
Local $aRet = DllCall('shlwapi.dll', 'uint', 'PathGetCharTypeW', 'word', AscW($sChar))
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_PathGetDriveNumber($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathGetDriveNumberW', 'wstr', $sFilePath)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, '')
Return Chr($aRet[0] + 65) & ':'
EndFunc
Func _WinAPI_PathIsContentType($sFilePath, $sType)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsContentTypeW', 'wstr', $sFilePath, 'wstr', $sType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsExe($sFilePath)
Local $aRet = DllCall('shell32.dll', 'bool', 'PathIsExe', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsLFNFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsLFNFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsRelative($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsRelativeW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsRoot($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsRootW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsSameRoot($sPath1, $sPath2)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsSameRootW', 'wstr', $sPath1, 'wstr', $sPath2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsSystemFolderW', 'wstr', $sFilePath, 'dword', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNC($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNCServer($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCServerW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNCServerShare($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCServerShareW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathMakeSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMakeSystemFolderW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathMatchSpec($sFilePath, $sSpec)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMatchSpecW', 'wstr', $sFilePath, 'wstr', $sSpec)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathParseIconLocation($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathParseIconLocationW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[2]
$aResult[0] = $aRet[1]
$aResult[1] = $aRet[0]
Return $aResult
EndFunc
Func _WinAPI_PathRelativePathTo($sPathFrom, $bDirFrom, $sPathTo, $bDirTo)
If $bDirFrom Then
$bDirFrom = 0x10
EndIf
If $bDirTo Then
$bDirTo = 0x10
EndIf
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRelativePathToW', 'wstr', '', 'wstr', $sPathFrom, 'dword', $bDirFrom,  'wstr', $sPathTo, 'dword', $bDirTo)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveArgs($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathRemoveArgsW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveBackslash($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathRemoveBackslashW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveExtension($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathRemoveExtensionW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRemoveFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], $aRet[1])
EndFunc
Func _WinAPI_PathRenameExtension($sFilePath, $sExt)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRenameExtensionW', 'struct*', $tPath, 'wstr', $sExt)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathSearchAndQualify($sFilePath, $bExists = False)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathSearchAndQualifyW', 'wstr', $sFilePath, 'wstr', '', 'int', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
If $bExists And Not FileExists($aRet[2]) Then Return SetError(20, 0, '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathSkipRoot($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathSkipRootW', 'struct*', $tPath)
If @error Then Return SetError(@error, @extended, '')
If Not $aRet[0] Then Return $sFilePath
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathStripPath($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathStripPathW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathStripToRoot($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathStripToRootW', 'wstr', $sFilePath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathUndecorate($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathUndecorateW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathUnExpandEnvStrings($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathUnExpandEnvStringsW', 'wstr', $sFilePath, 'wstr', '', 'uint', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathUnmakeSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathUnmakeSystemFolderW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathUnquoteSpaces($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathUnquoteSpacesW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathYetAnotherMakeUniqueName($sFilePath)
Local $aRet = DllCall('shell32.dll', 'int', 'PathYetAnotherMakeUniqueName', 'wstr', '', 'wstr', $sFilePath, 'ptr', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_ShellGetImageList($bSmall = False)
Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')
If $bSmall Then
$pLarge = 0
$pSmall = DllStructGetPtr($tPtr)
Else
$pLarge = DllStructGetPtr($tPtr)
$pSmall = 0
EndIf
Local $aRet = DllCall('shell32.dll', 'int', 'Shell_GetImageLists', 'ptr', $pLarge, 'ptr', $pSmall)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPtr, 1)
EndFunc
Func _WinAPI_UrlApplyScheme($sUrl, $iFlags = 1)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlApplySchemeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlCanonicalize($sUrl, $iFlags)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCanonicalizeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlCombine($sUrl, $sPart, $iFlags = 0)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCombineW', 'wstr', $sUrl, 'wstr', $sPart, 'wstr', '', 'dword*', 4096,  'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[3]
EndFunc
Func _WinAPI_UrlCompare($sUrl1, $sUrl2, $bIgnoreSlash = False)
Local $aRet = DllCall('shlwapi.dll', 'int', 'UrlCompareW', 'wstr', $sUrl1, 'wstr', $sUrl2, 'bool', $bIgnoreSlash)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UrlCreateFromPath($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCreateFromPathW', 'wstr', $sFilePath, 'wstr', '', 'dword*', 4096, 'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] < 0 Or $aRet[0] > 1 Then
Return SetError(10, $aRet[0], '')
EndIf
Return $aRet[2]
EndFunc
Func _WinAPI_UrlFixup($sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlFixupW', 'wstr', $sUrl, 'wstr', '', 'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlGetPart($sUrl, $iPart)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlGetPartW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iPart,  'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlHash($sUrl, $iLength = 32)
If $iLength <= 0 Or $iLength > 256 Then Return SetError(256, 0, 0)
Local $tData = DllStructCreate('byte[' & $iLength & ']')
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlHashW', 'wstr', $sUrl, 'struct*', $tData, 'dword', $iLength)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_UrlIs($sUrl, $iType = 0)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'UrlIsW', 'wstr', $sUrl, 'uint', $iType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __US($sString, $iLength = 0)
If $iLength Then
$sString = StringLeft($sString, $iLength)
Else
$iLength = StringLen($sString)
EndIf
Local $tUS = DllStructCreate('ushort;ushort;ptr;wchar[' & ($iLength + 1) & ']')
DllStructSetData($tUS, 1, 2 * StringLen($sString))
DllStructSetData($tUS, 2, 2 * $iLength)
DllStructSetData($tUS, 3, DllStructGetPtr($tUS, 4))
DllStructSetData($tUS, 4, $sString)
Return $tUS
EndFunc
#EndRegion Internal Functions
Global Const $KLF_ACTIVATE = 0x00000001
Global Const $KLF_NOTELLSHELL = 0x00000080
Global Const $KLF_REORDER = 0x00000008
Global Const $KLF_REPLACELANG = 0x00000010
Global Const $KLF_RESET = 0x40000000
Global Const $KLF_SETFORPROCESS = 0x00000100
Global Const $KLF_SHIFTLOCK = 0x00010000
Global Const $KLF_SUBSTITUTE_OK = 0x00000002
Global Const $HKL_NEXT = 1
Global Const $HKL_PREV = 0
Global Const $AW_ACTIVATE = 0x00020000
Global Const $AW_BLEND = 0x00080000
Global Const $AW_CENTER = 0x00000010
Global Const $AW_HIDE = 0x00010000
Global Const $AW_HOR_NEGATIVE = 0x00000002
Global Const $AW_HOR_POSITIVE = 0x00000001
Global Const $AW_SLIDE = 0x00040000
Global Const $AW_VER_NEGATIVE = 0x00000008
Global Const $AW_VER_POSITIVE = 0x00000004
Global Const $BSF_ALLOWSFW = 0x0080
Global Const $BSF_FLUSHDISK = 0x0004
Global Const $BSF_FORCEIFHUNG = 0x0020
Global Const $BSF_IGNORECURRENTTASK = 0x0002
Global Const $BSF_NOHANG = 0x0008
Global Const $BSF_NOTIMEOUTIFNOTHUNG = 0x0040
Global Const $BSF_POSTMESSAGE = 0x0010
Global Const $BSF_QUERY = 0x0001
Global Const $BSF_SENDNOTIFYMESSAGE = 0x0100
Global Const $BSM_ALLCOMPONENTS = 0x00
Global Const $BSM_ALLDESKTOPS = 0x08
Global Const $BSM_APPLICATIONS = 0x10
Global Const $BSM_INSTALLABLEDRIVERS = 0x04
Global Const $BSM_NETDRIVER = 0x02
Global Const $BSM_VXDS = 0x01
Global Const $MDITILE_HORIZONTAL = 0x01
Global Const $MDITILE_SKIPDISABLED = 0x02
Global Const $MDITILE_VERTICAL = 0x00
Global Const $MDITILE_ZORDER = 0x04
Global Const $MSGFLT_ALLOW = 1
Global Const $MSGFLT_DISALLOW = 2
Global Const $MSGFLT_RESET = 0
Global Const $MSGFLTINFO_ALLOWED_HIGHER = 3
Global Const $MSGFLTINFO_ALREADYALLOWED_FORWND = 1
Global Const $MSGFLTINFO_ALREADYDISALLOWED_FORWND = 2
Global Const $MSGFLTINFO_NONE = 0
Global Const $CWP_ALL = 0x00
Global Const $CWP_SKIPINVISIBLE = 0x01
Global Const $CWP_SKIPDISABLED = 0x02
Global Const $CWP_SKIPTRANSPARENT = 0x04
Global Const $COMPRESSION_FORMAT_NONE = 0x0000
Global Const $COMPRESSION_FORMAT_DEFAULT = 0x0001
Global Const $COMPRESSION_FORMAT_LZNT1 = 0x0002
Global Const $COMPRESSION_FORMAT_XPRESS = 0x0003
Global Const $COMPRESSION_FORMAT_XPRESS_HUFF = 0x0004
Global Const $COMPRESSION_ENGINE_STANDARD = 0x0000
Global Const $COMPRESSION_ENGINE_MAXIMUM = 0x0100
Global Const $COMPRESSION_ENGINE_HIBER = 0x0200
Global Const $WINSTA_ACCESSCLIPBOARD = 0x0004
Global Const $WINSTA_ACCESSGLOBALATOMS = 0x0020
Global Const $WINSTA_CREATEDESKTOP = 0x0008
Global Const $WINSTA_ENUMDESKTOPS = 0x0001
Global Const $WINSTA_ENUMERATE = 0x0100
Global Const $WINSTA_EXITWINDOWS = 0x0040
Global Const $WINSTA_READATTRIBUTES = 0x0002
Global Const $WINSTA_READSCREEN = 0x0200
Global Const $WINSTA_WRITEATTRIBUTES = 0x0010
Global Const $WINSTA_ALL_ACCESS = BitOR($WINSTA_ACCESSCLIPBOARD, $WINSTA_ACCESSGLOBALATOMS, $WINSTA_CREATEDESKTOP, $WINSTA_ENUMDESKTOPS, $WINSTA_ENUMERATE, $WINSTA_EXITWINDOWS, $WINSTA_READATTRIBUTES, $WINSTA_READSCREEN, $WINSTA_WRITEATTRIBUTES)
Global Const $CWF_CREATE_ONLY = 0x01
Global Const $GCL_CBCLSEXTRA = -20
Global Const $GCL_CBWNDEXTRA = -18
Global Const $GCL_HBRBACKGROUND = -10
Global Const $GCL_HCURSOR = -12
Global Const $GCL_HICON = -14
Global Const $GCL_HICONSM = -34
Global Const $GCL_HMODULE = -16
Global Const $GCL_MENUNAME = -8
Global Const $GCL_STYLE = -26
Global Const $GCL_WNDPROC = -24
Global Const $DOCKINFO_DOCKED = 0x02
Global Const $DOCKINFO_UNDOCKED = 0x01
Global Const $DOCKINFO_USER_SUPPLIED = 0x04
Global Const $DOCKINFO_USER_DOCKED = 0x05
Global Const $DOCKINFO_USER_UNDOCKED = 0x06
Global Const $GUI_CARETBLINKING = 0x0001
Global Const $GUI_INMENUMODE = 0x0004
Global Const $GUI_INMOVESIZE = 0x0002
Global Const $GUI_POPUPMENUMODE = 0x0010
Global Const $GUI_SYSTEMMENUMODE = 0x0008
Global Const $HANDLE_FLAG_INHERIT = 0x00000001
Global Const $HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002
Global Const $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 0x0004
Global Const $GET_MODULE_HANDLE_EX_FLAG_PIN = 0x0001
Global Const $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 0x0002
Global Const $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0x0000
Global Const $PROCESSOR_ARCHITECTURE_AMD64 = 9
Global Const $PROCESSOR_ARCHITECTURE_IA64 = 6
Global Const $PROCESSOR_ARCHITECTURE_INTEL = 0
Global Const $PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF
Global Const $PROCESSOR_INTEL_386 = 386
Global Const $PROCESSOR_INTEL_486 = 486
Global Const $PROCESSOR_INTEL_PENTIUM = 586
Global Const $PROCESSOR_INTEL_IA64 = 2200
Global Const $PROCESSOR_AMD_X8664 = 8664
Global Const $UOI_FLAGS = 1
Global Const $UOI_HEAPSIZE = 5
Global Const $UOI_IO = 6
Global Const $UOI_NAME = 2
Global Const $UOI_TYPE = 3
Global Const $UOI_USER_SID = 4
Global Const $DF_ALLOWOTHERACCOUNTHOOK = 0x01
Global Const $WSF_VISIBLE = 0x01
Global Const $VER_SUITE_BACKOFFICE = 0x00000004
Global Const $VER_SUITE_BLADE = 0x00000400
Global Const $VER_SUITE_COMPUTE_SERVER = 0x00004000
Global Const $VER_SUITE_DATACENTER = 0x00000080
Global Const $VER_SUITE_ENTERPRISE = 0x00000002
Global Const $VER_SUITE_EMBEDDEDNT = 0x00000040
Global Const $VER_SUITE_PERSONAL = 0x00000200
Global Const $VER_SUITE_SINGLEUSERTS = 0x00000100
Global Const $VER_SUITE_SMALLBUSINESS = 0x00000001
Global Const $VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020
Global Const $VER_SUITE_STORAGE_SERVER = 0x00002000
Global Const $VER_SUITE_TERMINAL = 0x00000010
Global Const $VER_SUITE_WH_SERVER = 0x00008000
Global Const $VER_NT_DOMAIN_CONTROLLER = 0x0000002
Global Const $VER_NT_SERVER = 0x0000003
Global Const $VER_NT_WORKSTATION = 0x0000001
Global Const $WDA_MONITOR = 0x01
Global Const $WDA_NONE = 0x00
Global Const $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
Global Const $PF_CHANNELS_ENABLED = 16
Global Const $PF_COMPARE_EXCHANGE_DOUBLE = 2
Global Const $PF_COMPARE_EXCHANGE128 = 14
Global Const $PF_COMPARE64_EXCHANGE128 = 15
Global Const $PF_FLOATING_POINT_EMULATED = 1
Global Const $PF_FLOATING_POINT_PRECISION_ERRATA = 0
Global Const $PF_MMX_INSTRUCTIONS_AVAILABLE = 3
Global Const $PF_NX_ENABLED = 12
Global Const $PF_PAE_ENABLED = 9
Global Const $PF_RDTSC_INSTRUCTION_AVAILABLE = 8
Global Const $PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
Global Const $PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
Global Const $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
Global Const $PF_XSAVE_ENABLED = 17
Global Const $KEYEVENTF_EXTENDEDKEY = 0x01
Global Const $KEYEVENTF_KEYUP = 0x02
Global Const $LIM_SMALL = 0
Global Const $LIM_LARGE = 1
Global Const $MAPVK_VK_TO_CHAR = 2
Global Const $MAPVK_VK_TO_VSC = 0
Global Const $MAPVK_VK_TO_VSC_EX = 4
Global Const $MAPVK_VSC_TO_VK = 1
Global Const $MAPVK_VSC_TO_VK_EX = 3
Global Const $MOD_ALT = 0x0001
Global Const $MOD_CONTROL = 0x0002
Global Const $MOD_NOREPEAT = 0x4000
Global Const $MOD_SHIFT = 0x0004
Global Const $MOD_WIN = 0x0008
Global Const $GUID_ACDC_POWER_SOURCE = '{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}'
Global Const $GUID_BATTERY_PERCENTAGE_REMAINING = '{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}'
Global Const $GUID_IDLE_BACKGROUND_TASK = '{515C31D8-F734-163D-A0FD-11A08C91E8F1}'
Global Const $GUID_MONITOR_POWER_ON = '{02731015-4510-4526-99E6-E5A17EBD1AEA}'
Global Const $GUID_POWERSCHEME_PERSONALITY = '{245D8541-3943-4422-B025-13A784F679B7}'
Global Const $GUID_SYSTEM_AWAYMODE = '{98A7F580-01F7-48AA-9C0F-44352C29E5C0}'
Global Const $GUID_MIN_POWER_SAVINGS = '{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}'
Global Const $GUID_MAX_POWER_SAVINGS = '{A1841308-3541-4FAB-BC81-F71556F20B4A}'
Global Const $GUID_TYPICAL_POWER_SAVINGS = '{381B4222-F694-41F0-9685-FF5BB260DF2E}'
Global Const $HSHELL_WINDOWCREATED = 1
Global Const $HSHELL_WINDOWDESTROYED = 2
Global Const $HSHELL_ACTIVATESHELLWINDOW = 3
Global Const $HSHELL_WINDOWACTIVATED = 4
Global Const $HSHELL_GETMINRECT = 5
Global Const $HSHELL_REDRAW = 6
Global Const $HSHELL_TASKMAN = 7
Global Const $HSHELL_LANGUAGE = 8
Global Const $HSHELL_SYSMENU = 9
Global Const $HSHELL_ENDTASK = 10
Global Const $HSHELL_ACCESSIBILITYSTATE = 11
Global Const $HSHELL_APPCOMMAND = 12
Global Const $HSHELL_WINDOWREPLACED = 13
Global Const $HSHELL_WINDOWREPLACING = 14
Global Const $HSHELL_RUDEAPPACTIVATED = 32772
Global Const $HSHELL_FLASH = 32774
Global Const $HWND_BROADCAST = 0xFFFF
Global Const $SMTO_BLOCK = 0x0001
Global Const $SMTO_NORMAL = 0x0000
Global Const $SMTO_ABORTIFHUNG = 0x0002
Global Const $SMTO_NOTIMEOUTIFNOTHUNG = 0x0008
Global Const $SMTO_ERRORONEXIT = 0x0020
Global Const $INPUTLANGCHANGE_BACKWARD = 0x0004
Global Const $INPUTLANGCHANGE_FORWARD = 0x0002
Global Const $INPUTLANGCHANGE_SYSCHARSET = 0x0001
Global Const $EVENT_MIN = 0x00000001
Global Const $EVENT_SYSTEM_SOUND = 0x00000001
Global Const $EVENT_SYSTEM_ALERT = 0x00000002
Global Const $EVENT_SYSTEM_FOREGROUND = 0x00000003
Global Const $EVENT_SYSTEM_MENUSTART = 0x00000004
Global Const $EVENT_SYSTEM_MENUEND = 0x00000005
Global Const $EVENT_SYSTEM_MENUPOPUPSTART = 0x00000006
Global Const $EVENT_SYSTEM_MENUPOPUPEND = 0x00000007
Global Const $EVENT_SYSTEM_CAPTURESTART = 0x00000008
Global Const $EVENT_SYSTEM_CAPTUREEND = 0x00000009
Global Const $EVENT_SYSTEM_MOVESIZESTART = 0x0000000A
Global Const $EVENT_SYSTEM_MOVESIZEEND = 0x0000000B
Global Const $EVENT_SYSTEM_CONTEXTHELPSTART = 0x0000000C
Global Const $EVENT_SYSTEM_CONTEXTHELPEND = 0x0000000D
Global Const $EVENT_SYSTEM_DRAGDROPSTART = 0x0000000E
Global Const $EVENT_SYSTEM_DRAGDROPEND = 0x0000000F
Global Const $EVENT_SYSTEM_DIALOGSTART = 0x00000010
Global Const $EVENT_SYSTEM_DIALOGEND = 0x00000011
Global Const $EVENT_SYSTEM_SCROLLINGSTART = 0x00000012
Global Const $EVENT_SYSTEM_SCROLLINGEND = 0x00000013
Global Const $EVENT_SYSTEM_SWITCHSTART = 0x00000014
Global Const $EVENT_SYSTEM_SWITCHEND = 0x00000015
Global Const $EVENT_SYSTEM_MINIMIZESTART = 0x00000016
Global Const $EVENT_SYSTEM_MINIMIZEEND = 0x00000017
Global Const $EVENT_SYSTEM_DESKTOPSWITCH = 0x00000020
Global Const $EVENT_OBJECT_CREATE = 0x00008000
Global Const $EVENT_OBJECT_DESTROY = 0x00008001
Global Const $EVENT_OBJECT_SHOW = 0x00008002
Global Const $EVENT_OBJECT_HIDE = 0x00008003
Global Const $EVENT_OBJECT_REORDER = 0x00008004
Global Const $EVENT_OBJECT_FOCUS = 0x00008005
Global Const $EVENT_OBJECT_SELECTION = 0x00008006
Global Const $EVENT_OBJECT_SELECTIONADD = 0x00008007
Global Const $EVENT_OBJECT_SELECTIONREMOVE = 0x00008008
Global Const $EVENT_OBJECT_SELECTIONWITHIN = 0x00008009
Global Const $EVENT_OBJECT_STATECHANGE = 0x0000800A
Global Const $EVENT_OBJECT_LOCATIONCHANGE = 0x0000800B
Global Const $EVENT_OBJECT_NAMECHANGE = 0x0000800C
Global Const $EVENT_OBJECT_DESCRIPTIONCHANGE = 0x0000800D
Global Const $EVENT_OBJECT_VALUECHANGE = 0x0000800E
Global Const $EVENT_OBJECT_PARENTCHANGE = 0x0000800F
Global Const $EVENT_OBJECT_HELPCHANGE = 0x00008010
Global Const $EVENT_OBJECT_DEFACTIONCHANGE = 0x00008011
Global Const $EVENT_OBJECT_ACCELERATORCHANGE = 0x00008012
Global Const $EVENT_OBJECT_INVOKED = 0x00008013
Global Const $EVENT_OBJECT_TEXTSELECTIONCHANGED = 0x00008014
Global Const $EVENT_OBJECT_CONTENTSCROLLED = 0x00008015
Global Const $EVENT_MAX = 0x7FFFFFFF
Global Const $WINEVENT_INCONTEXT = 0x04
Global Const $WINEVENT_OUTOFCONTEXT = 0x00
Global Const $WINEVENT_SKIPOWNPROCESS = 0x02
Global Const $WINEVENT_SKIPOWNTHREAD = 0x01
Global Const $TME_CANCEL = 0x80000000
Global Const $TME_HOVER = 0x00000001
Global Const $TME_LEAVE = 0x00000002
Global Const $TME_NONCLIENT = 0x00000010
Global Const $TME_QUERY = 0x40000000
Global Const $DESKTOP_CREATEMENU = 0x0004
Global Const $DESKTOP_CREATEWINDOW = 0x0002
Global Const $DESKTOP_ENUMERATE = 0x0040
Global Const $DESKTOP_HOOKCONTROL = 0x0008
Global Const $DESKTOP_JOURNALPLAYBACK = 0x0020
Global Const $DESKTOP_JOURNALRECORD = 0x0010
Global Const $DESKTOP_READOBJECTS = 0x0001
Global Const $DESKTOP_SWITCHDESKTOP = 0x0100
Global Const $DESKTOP_WRITEOBJECTS = 0x0080
Global Const $DESKTOP_ALL_ACCESS = BitOR($DESKTOP_CREATEMENU, $DESKTOP_CREATEWINDOW, $DESKTOP_ENUMERATE, $DESKTOP_HOOKCONTROL, $DESKTOP_JOURNALPLAYBACK, $DESKTOP_JOURNALRECORD, $DESKTOP_READOBJECTS, $DESKTOP_SWITCHDESKTOP, $DESKTOP_WRITEOBJECTS)
Global Const $RIDEV_APPKEYS = 0x00000400
Global Const $RIDEV_CAPTUREMOUSE = 0x00000200
Global Const $RIDEV_DEVNOTIFY = 0x00002000
Global Const $RIDEV_EXCLUDE = 0x00000010
Global Const $RIDEV_EXINPUTSINK = 0x00001000
Global Const $RIDEV_INPUTSINK = 0x00000100
Global Const $RIDEV_NOHOTKEYS = 0x00000200
Global Const $RIDEV_NOLEGACY = 0x00000030
Global Const $RIDEV_PAGEONLY = 0x00000020
Global Const $RIDEV_REMOVE = 0x00000001
Global Const $RID_HEADER = 0x10000005
Global Const $RID_INPUT = 0x10000003
Global Const $RIM_TYPEHID = 2
Global Const $RIM_TYPEKEYBOARD = 1
Global Const $RIM_TYPEMOUSE = 0
Global Const $RIDI_DEVICENAME = 0x20000007
Global Const $RIDI_DEVICEINFO = 0x2000000B
Global Const $RIDI_PREPARSEDDATA = 0x20000005
Global Const $MOUSE_ATTRIBUTES_CHANGED = 0x04
Global Const $MOUSE_MOVE_ABSOLUTE = 0x01
Global Const $MOUSE_MOVE_RELATIVE = 0x00
Global Const $MOUSE_VIRTUAL_DESKTOP = 0x02
Global Const $RI_MOUSE_LEFT_BUTTON_DOWN = 0x0001
Global Const $RI_MOUSE_LEFT_BUTTON_UP = 0x0002
Global Const $RI_MOUSE_MIDDLE_BUTTON_DOWN = 0x0010
Global Const $RI_MOUSE_MIDDLE_BUTTON_UP = 0x0020
Global Const $RI_MOUSE_RIGHT_BUTTON_DOWN = 0x0004
Global Const $RI_MOUSE_RIGHT_BUTTON_UP = 0x0008
Global Const $RI_MOUSE_BUTTON_1_DOWN = $RI_MOUSE_LEFT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_1_UP = $RI_MOUSE_LEFT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_2_DOWN = $RI_MOUSE_RIGHT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_2_UP = $RI_MOUSE_RIGHT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_3_DOWN = $RI_MOUSE_MIDDLE_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_3_UP = $RI_MOUSE_MIDDLE_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_4_DOWN = 0x0040
Global Const $RI_MOUSE_BUTTON_4_UP = 0x0080
Global Const $RI_MOUSE_BUTTON_5_DOWN = 0x0100
Global Const $RI_MOUSE_BUTTON_5_UP = 0x0200
Global Const $RI_MOUSE_WHEEL = 0x0400
Global Const $RI_KEY_BREAK = 1
Global Const $RI_KEY_E0 = 2
Global Const $RI_KEY_E1 = 4
Global Const $RI_KEY_MAKE = 0
Global Const $FLASHW_CAPTION = 0x00000001
Global Const $FLASHW_TRAY = 0x00000002
Global Const $FLASHW_TIMER = 0x00000004
Global Const $FLASHW_TIMERNOFG = 0x0000000C
Global Const $tagUPDATELAYEREDWINDOWINFO = 'dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom'
Global Const $tagWINDOWINFO = 'dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;word atomWindowType;word CreatorVersion'
Global Const $tagWNDCLASS = 'uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName'
Global Const $tagWNDCLASSEX = 'uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm'
Global Const $tagFLASHWINFO = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
Func _WinAPI_AdjustWindowRectEx(ByRef $tRECT, $iStyle, $iExStyle = 0, $bMenu = False)
Local $aRet = DllCall('user32.dll', 'bool', 'AdjustWindowRectEx', 'struct*', $tRECT, 'dword', $iStyle, 'bool', $bMenu,  'dword', $iExStyle)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AnimateWindow($hWnd, $iFlags, $iDuration = 1000)
Local $aRet = DllCall('user32.dll', 'bool', 'AnimateWindow', 'hwnd', $hWnd, 'dword', $iDuration, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginDeferWindowPos($iAmount = 1)
Local $aRet = DllCall('user32.dll', 'handle', 'BeginDeferWindowPos', 'int', $iAmount)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_BringWindowToTop($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'BringWindowToTop', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BroadcastSystemMessage($iMsg, $wParam = 0, $lParam = 0, $iFlags = 0, $iRecipients = 0)
Local $aRet = DllCall('user32.dll', 'long', 'BroadcastSystemMessageW', 'dword', $iFlags, 'dword*', $iRecipients,  'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, -1)
Return SetExtended($aRet[2], $aRet[0])
EndFunc
Func _WinAPI_CallWindowProc($pPrevWndFunc, $hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pPrevWndFunc, "hwnd", $hWnd, "uint", $iMsg,  "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_CallWindowProcW($pPrevWndProc, $hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('user32.dll', 'lresult', 'CallWindowProcW', 'ptr', $pPrevWndProc, 'hwnd', $hWnd, 'uint', $iMsg,  'wparam', $wParam, 'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CascadeWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aWnds, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tWnds = DllStructCreate('hwnd[' & $iCount & ']')
$iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tWnds, 1, $aWnds[$i], $iCount)
$iCount += 1
Next
Local $aRet = DllCall('user32.dll', 'word', 'CascadeWindows', 'hwnd', $hParent, 'uint', $iFlags, 'struct*', $tRECT,  'uint', $iCount - 1, 'struct*', $tWnds)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ChangeWindowMessageFilterEx($hWnd, $iMsg, $iAction)
Local $tCFS, $aRet
If $hWnd And ($__WINVER > 0x0600) Then
Local Const $tagCHANGEFILTERSTRUCT = 'dword cbSize; dword ExtStatus'
$tCFS = DllStructCreate($tagCHANGEFILTERSTRUCT)
DllStructSetData($tCFS, 1, DllStructGetSize($tCFS))
$aRet = DllCall('user32.dll', 'bool', 'ChangeWindowMessageFilterEx', 'hwnd', $hWnd, 'uint', $iMsg, 'dword', $iAction,  'struct*', $tCFS)
Else
$tCFS = 0
$aRet = DllCall('user32.dll', 'bool', 'ChangeWindowMessageFilter', 'uint', $iMsg, 'dword', $iAction)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended(DllStructGetData($tCFS, 2), 1)
EndFunc
Func _WinAPI_ChildWindowFromPointEx($hWnd, $tPOINT, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'hwnd', 'ChildWindowFromPointEx', 'hwnd', $hWnd, 'struct', $tPOINT, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DeferWindowPos($hInfo, $hWnd, $hAfter, $iX, $iY, $iWidth, $iHeight, $iFlags)
Local $aRet = DllCall('user32.dll', 'handle', 'DeferWindowPos', 'handle', $hInfo, 'hwnd', $hWnd, 'hwnd', $hAfter,  'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DefWindowProc($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "DefWindowProc", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam,  "lparam", $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DefWindowProcW($hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('user32.dll', 'lresult', 'DefWindowProcW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DeregisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'DeregisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DragAcceptFiles($hWnd, $bAccept = True)
DllCall('shell32.dll', 'none', 'DragAcceptFiles', 'hwnd', $hWnd, 'bool', $bAccept)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DragFinish($hDrop)
DllCall('shell32.dll', 'none', 'DragFinish', 'handle', $hDrop)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DragQueryFileEx($hDrop, $iFlag = 0)
Local $aRet = DllCall('shell32.dll', 'uint', 'DragQueryFileW', 'handle', $hDrop, 'uint', -1, 'ptr', 0, 'uint', 0)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
Local $iCount = $aRet[0]
Local $aResult[$iCount + 1]
For $i = 0 To $iCount - 1
$aRet = DllCall('shell32.dll', 'uint', 'DragQueryFileW', 'handle', $hDrop, 'uint', $i, 'wstr', '', 'uint', 4096)
If Not $aRet[0] Then Return SetError(11, 0, 0)
If $iFlag Then
Local $bDir = _WinAPI_PathIsDirectory($aRet[3])
If (($iFlag = 1) And $bDir) Or (($iFlag = 2) And Not $bDir) Then
ContinueLoop
EndIf
EndIf
$aResult[$i + 1] = $aRet[3]
$aResult[0] += 1
Next
If Not $aResult[0] Then Return SetError(12, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_DragQueryPoint($hDrop)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('shell32.dll', 'bool', 'DragQueryPoint', 'handle', $hDrop, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_EndDeferWindowPos($hInfo)
Local $aRet = DllCall('user32.dll', 'bool', 'EndDeferWindowPos', 'handle', $hInfo)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumChildWindows($hWnd, $bVisible = True)
If Not _WinAPI_GetWindow($hWnd, 5) Then Return SetError(2, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
DllCall('user32.dll', 'bool', 'EnumChildWindows', 'hwnd', $hWnd, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $bVisible)
If @error Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FindWindow($sClassName, $sWindowName)
Local $aResult = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sClassName, "wstr", $sWindowName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FlashWindow($hWnd, $bInvert = True)
Local $aResult = DllCall("user32.dll", "bool", "FlashWindow", "hwnd", $hWnd, "bool", $bInvert)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FlashWindowEx($hWnd, $iFlags = 3, $iCount = 3, $iTimeout = 0)
Local $tFlash = DllStructCreate($tagFLASHWINFO)
Local $iFlash = DllStructGetSize($tFlash)
Local $iMode = 0
If BitAND($iFlags, 1) <> 0 Then $iMode = BitOR($iMode, $FLASHW_CAPTION)
If BitAND($iFlags, 2) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TRAY)
If BitAND($iFlags, 4) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TIMER)
If BitAND($iFlags, 8) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TIMERNOFG)
DllStructSetData($tFlash, "Size", $iFlash)
DllStructSetData($tFlash, "hWnd", $hWnd)
DllStructSetData($tFlash, "Flags", $iMode)
DllStructSetData($tFlash, "Count", $iCount)
DllStructSetData($tFlash, "Timeout", $iTimeout)
Local $aResult = DllCall("user32.dll", "bool", "FlashWindowEx", "struct*", $tFlash)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetAncestor($hWnd, $iFlags = 1)
Local $aResult = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hWnd, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClassInfoEx($sClass, $hInstance = 0)
Local $sTypeOfClass = 'ptr'
If IsString($sClass) Then
$sTypeOfClass = 'wstr'
EndIf
Local $tWNDCLASSEX = DllStructCreate($tagWNDCLASSEX)
Local $aRet = DllCall('user32.dll', 'bool', 'GetClassInfoExW', 'handle', $hInstance, $sTypeOfClass, $sClass,  'struct*', $tWNDCLASSEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWNDCLASSEX
EndFunc
Func _WinAPI_GetClassLongEx($hWnd, $iIndex)
Local $aRet
If @AutoItX64 Then
$aRet = DllCall('user32.dll', 'ulong_ptr', 'GetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex)
Else
$aRet = DllCall('user32.dll', 'dword', 'GetClassLongW', 'hwnd', $hWnd, 'int', $iIndex)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetClientHeight($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetClientWidth($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_GetDlgItem($hWnd, $iItemID)
Local $aResult = DllCall("user32.dll", "hwnd", "GetDlgItem", "hwnd", $hWnd, "int", $iItemID)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetForegroundWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetGUIThreadInfo($iThreadId)
Local Const $tagGUITHREADINFO = 'dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;struct rcCaret;long left;long top;long right;long bottom;endstruct'
Local $tGTI = DllStructCreate($tagGUITHREADINFO)
DllStructSetData($tGTI, 1, DllStructGetSize($tGTI))
Local $aRet = DllCall('user32.dll', 'bool', 'GetGUIThreadInfo', 'dword', $iThreadId, 'struct*', $tGTI)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[11]
For $i = 0 To 10
$aResult[$i] = DllStructGetData($tGTI, $i + 2)
Next
For $i = 9 To 10
$aResult[$i] -= $aResult[$i - 2]
Next
Return $aResult
EndFunc
Func _WinAPI_GetLastActivePopup($hWnd)
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetLastActivePopup', 'hwnd', $hWnd)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] = $hWnd Then Return SetError(1, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetLayeredWindowAttributes($hWnd, ByRef $iTransColor, ByRef $iTransGUI, $bColorRef = False)
$iTransColor = -1
$iTransGUI = -1
Local $aResult = DllCall("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $hWnd, "INT*", $iTransColor,  "byte*", $iTransGUI, "dword*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
If Not $bColorRef Then
$aResult[2] = Int(BinaryMid($aResult[2], 3, 1) & BinaryMid($aResult[2], 2, 1) & BinaryMid($aResult[2], 1, 1))
EndIf
$iTransColor = $aResult[2]
$iTransGUI = $aResult[3]
Return $aResult[4]
EndFunc
Func _WinAPI_GetMessageExtraInfo()
Local $aRet = DllCall('user32.dll', 'lparam', 'GetMessageExtraInfo')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetShellWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetShellWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTopWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetTopWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWindowDisplayAffinity($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'GetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetWindowInfo($hWnd)
Local $tWINDOWINFO = DllStructCreate($tagWINDOWINFO)
DllStructSetData($tWINDOWINFO, 'Size', DllStructGetSize($tWINDOWINFO))
Local $aRet = DllCall('user32.dll', 'bool', 'GetWindowInfo', 'hwnd', $hWnd, 'struct*', $tWINDOWINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWINDOWINFO
EndFunc
Func _WinAPI_GetWindowPlacement($hWnd)
Local $tWindowPlacement = DllStructCreate($tagWINDOWPLACEMENT)
DllStructSetData($tWindowPlacement, "length", DllStructGetSize($tWindowPlacement))
Local $aRet = DllCall("user32.dll", "bool", "GetWindowPlacement", "hwnd", $hWnd, "struct*", $tWindowPlacement)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWindowPlacement
EndFunc
Func _WinAPI_IsChild($hWnd, $hWndParent)
Local $aRet = DllCall('user32.dll', 'bool', 'IsChild', 'hwnd', $hWndParent, 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsHungAppWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsHungAppWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsIconic($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsIconic', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsWindowUnicode($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsWindowUnicode', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsZoomed($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsZoomed', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_KillTimer($hWnd, $iTimerID)
Local $aRet = DllCall('user32.dll', 'bool', 'KillTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenIcon($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'OpenIcon', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PostMessage($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam,  "lparam", $lParam)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RegisterClass($tWNDCLASS)
Local $aRet = DllCall('user32.dll', 'word', 'RegisterClassW', 'struct*', $tWNDCLASS)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterClassEx($tWNDCLASSEX)
Local $aRet = DllCall('user32.dll', 'word', 'RegisterClassExW', 'struct*', $tWNDCLASSEX)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterWindowMessage($sMessage)
Local $aResult = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMessage)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SendMessageTimeout($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iTimeout = 1000, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'lresult', 'SendMessageTimeoutW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam, 'uint', $iFlags, 'uint', $iTimeout, 'dword_ptr*', 0)
If @error Then Return SetError(@error, @extended, -1)
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), -1)
Return $aRet[7]
EndFunc
Func _WinAPI_SetClassLongEx($hWnd, $iIndex, $iNewLong)
Local $aRet
If @AutoItX64 Then
$aRet = DllCall('user32.dll', 'ulong_ptr', 'SetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex, 'long_ptr', $iNewLong)
Else
$aRet = DllCall('user32.dll', 'dword', 'SetClassLongW', 'hwnd', $hWnd, 'int', $iIndex, 'long', $iNewLong)
EndIf
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetForegroundWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'SetForegroundWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetLayeredWindowAttributes($hWnd, $iTransColor, $iTransGUI = 255, $iFlags = 0x03, $bColorRef = False)
If $iFlags = Default Or $iFlags = "" Or $iFlags < 0 Then $iFlags = 0x03
If Not $bColorRef Then
$iTransColor = Int(BinaryMid($iTransColor, 3, 1) & BinaryMid($iTransColor, 2, 1) & BinaryMid($iTransColor, 1, 1))
EndIf
Local $aResult = DllCall("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $hWnd, "INT", $iTransColor,  "byte", $iTransGUI, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetMessageExtraInfo($lParam)
Local $aRet = DllCall('user32.dll', 'lparam', 'SetMessageExtraInfo', 'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetSysColors($vElements, $vColors)
Local $bIsEArray = IsArray($vElements), $bIsCArray = IsArray($vColors)
Local $iElementNum
If Not $bIsCArray And Not $bIsEArray Then
$iElementNum = 1
ElseIf $bIsCArray Or $bIsEArray Then
If Not $bIsCArray Or Not $bIsEArray Then Return SetError(-1, -1, False)
If UBound($vElements) <> UBound($vColors) Then Return SetError(-1, -1, False)
$iElementNum = UBound($vElements)
EndIf
Local $tElements = DllStructCreate("int Element[" & $iElementNum & "]")
Local $tColors = DllStructCreate("INT NewColor[" & $iElementNum & "]")
If Not $bIsEArray Then
DllStructSetData($tElements, "Element", $vElements, 1)
Else
For $x = 0 To $iElementNum - 1
DllStructSetData($tElements, "Element", $vElements[$x], $x + 1)
Next
EndIf
If Not $bIsCArray Then
DllStructSetData($tColors, "NewColor", $vColors, 1)
Else
For $x = 0 To $iElementNum - 1
DllStructSetData($tColors, "NewColor", $vColors[$x], $x + 1)
Next
EndIf
Local $aResult = DllCall("user32.dll", "bool", "SetSysColors", "int", $iElementNum, "struct*", $tElements, "struct*", $tColors)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetTimer($hWnd, $iTimerID, $iElapse, $pTimerFunc)
Local $aRet = DllCall('user32.dll', 'uint_ptr', 'SetTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID, 'uint', $iElapse,  'ptr', $pTimerFunc)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowDisplayAffinity($hWnd, $iAffinity)
Local $aRet = DllCall('user32.dll', 'bool', 'SetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword', $iAffinity)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowLong($hWnd, $iIndex, $iValue)
_WinAPI_SetLastError(0)
Local $sFuncName = "SetWindowLongW"
If @AutoItX64 Then $sFuncName = "SetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex, "long_ptr", $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPlacement($hWnd, $tWindowPlacement)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPlacement", "hwnd", $hWnd, "struct*", $tWindowPlacement)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowOwnedPopups($hWnd, $bShow)
Local $aRet = DllCall('user32.dll', 'bool', 'ShowOwnedPopups', 'hwnd', $hWnd, 'bool', $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SwitchToThisWindow($hWnd, $bAltTab = False)
DllCall('user32.dll', 'none', 'SwitchToThisWindow', 'hwnd', $hWnd, 'bool', $bAltTab)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_TileWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aWnds, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tWnds = DllStructCreate('hwnd[' & $iCount & ']')
$iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tWnds, 1, $aWnds[$i], $iCount)
$iCount += 1
Next
Local $aRet = DllCall('user32.dll', 'word', 'TileWindows', 'hwnd', $hParent, 'uint', $iFlags, 'struct*', $tRECT,  'uint', $iCount - 1, 'struct*', $tWnds)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterClass($sClass, $hInstance = 0)
Local $sTypeOfClass = 'ptr'
If IsString($sClass) Then
$sTypeOfClass = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterClassW', $sTypeOfClass, $sClass, 'handle', $hInstance)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateLayeredWindow($hWnd, $hDestDC, $tPTDest, $tSize, $hSrcDC, $tPTSrce, $iRGB, $tBlend, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hWnd, "handle", $hDestDC, "struct*", $tPTDest,  "struct*", $tSize, "handle", $hSrcDC, "struct*", $tPTSrce, "dword", $iRGB, "struct*", $tBlend, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateLayeredWindowEx($hWnd, $iX, $iY, $hBitmap, $iOpacity = 255, $bDelete = False)
Local $aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', $hWnd)
Local $hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBitmap)
Local $hDestSv = $aRet[0]
Local $tPOINT
If ($iX = -1) And ($iY = -1) Then
$tPOINT = DllStructCreate('int;int')
Else
$tPOINT = DllStructCreate('int;int;int;int')
DllStructSetData($tPOINT, 3, $iX)
DllStructSetData($tPOINT, 4, $iY)
EndIf
DllStructSetData($tPOINT, 1, 0)
DllStructSetData($tPOINT, 2, 0)
Local $tBLENDFUNCTION = DllStructCreate($tagBLENDFUNCTION)
DllStructSetData($tBLENDFUNCTION, 1, 0)
DllStructSetData($tBLENDFUNCTION, 2, 0)
DllStructSetData($tBLENDFUNCTION, 3, $iOpacity)
DllStructSetData($tBLENDFUNCTION, 4, 1)
Local Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Local $tObj = DllStructCreate($tagBITMAP)
DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
Local $tSize = DllStructCreate($tagSIZE, DllStructGetPtr($tObj, "bmWidth"))
$aRet = DllCall('user32.dll', 'bool', 'UpdateLayeredWindow', 'hwnd', $hWnd, 'handle', $hDC, 'ptr', DllStructGetPtr($tPOINT, 3),  'struct*', $tSIZE, 'handle', $hDestDC, 'struct*', $tPOINT, 'dword', 0, 'struct*', $tBLENDFUNCTION, 'dword', 0x02)
Local $iError = @error
DllCall('user32.dll', 'bool', 'ReleaseDC', 'hwnd', $hWnd, 'handle', $hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
If $iError Then Return SetError($iError, 0, False)
If $bDelete Then
DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hBitmap)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateLayeredWindowIndirect($hWnd, $tULWINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'UpdateLayeredWindowIndirect', 'hwnd', $hWnd, 'struct*', $tULWINFO)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_WindowFromPoint(ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "hwnd", "WindowFromPoint", "struct", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __EnumDefaultProc($pData, $lParam)
#forceref $lParam
Local $iLength = _WinAPI_StrLen($pData)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $pData), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = ''
EndIf
Return 1
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $tagOSVERSIONINFOEX = $tagOSVERSIONINFO & ';ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved'
Global Const $tagRAWINPUTDEVICE = 'struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct'
Global Const $tagRAWINPUTHEADER = 'struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct'
Global Const $tagRAWMOUSE = 'ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;'
Global Const $tagRAWKEYBOARD = 'ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;'
Global Const $tagRAWHID = 'dword SizeHid;dword Count;'
Global Const $tagRAWINPUTMOUSE = $tagRAWINPUTHEADER & ';' & $tagRAWMOUSE
Global Const $tagRAWINPUTKEYBOARD = $tagRAWINPUTHEADER & ';' & $tagRAWKEYBOARD
Global Const $tagRAWINPUTHID = $tagRAWINPUTHEADER & ';' & $tagRAWHID
Global Const $tagRID_DEVICE_INFO_MOUSE = 'struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc'
Global Const $tagRID_DEVICE_INFO_KEYBOARD = 'struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruc'
Global Const $tagRID_DEVICE_INFO_HID = 'struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc'
Global Const $tagRID_INFO_MOUSE = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_MOUSE & ';dword Unused[2];'
Global Const $tagRID_INFO_KEYBOARD = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_KEYBOARD
Global Const $tagRID_INFO_HID = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_HID & ';dword Unused[2]'
Global Const $tagUSEROBJECTFLAGS = 'int Inherit;int Reserved;dword Flags'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_ActivateKeyboardLayout($hLocale, $iFlag = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'ActivateKeyboardLayout', 'handle', $hLocale, 'uint', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_AddClipboardFormatListener($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'AddClipboardFormatListener', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CallNextHookEx($hHook, $iCode, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hHook, "int", $iCode, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_CloseDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseWindowStation($hStation)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseWindowStation', 'handle', $hStation)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormatAndEngine = 0x0002)
Local $aRet, $pWorkSpace = 0, $iError = 0
Do
$aRet = DllCall('ntdll.dll', 'uint', 'RtlGetCompressionWorkSpaceSize', 'ushort', $iFormatAndEngine, 'ulong*', 0, 'ulong*', 0)
If @error Or $aRet[0] Then
$iError = @error + 20
ExitLoop
EndIf
$pWorkSpace = __HeapAlloc($aRet[2])
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$aRet = DllCall('ntdll.dll', 'uint', 'RtlCompressBuffer', 'ushort', $iFormatAndEngine, 'struct*', $pUncompressedBuffer,  'ulong', $iUncompressedSize, 'struct*', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong', 4096,  'ulong*', 0, 'ptr', $pWorkSpace)
If @error Or $aRet[0] Or Not $aRet[7] Then
$iError = @error + 30
ExitLoop
EndIf
Until 1
__HeapFree($pWorkSpace)
If $iError Then
If IsArray($aRet) Then
Return SetError(10, $aRet[0], 0)
Else
Return SetError($iError, 0, 0)
EndIf
EndIf
Return $aRet[7]
EndFunc
Func _WinAPI_ComputeCrc32($pMemory, $iLength)
If _WinAPI_IsBadReadPtr($pMemory, $iLength) Then Return SetError(1, @extended, 0)
Local $aRet = DllCall('ntdll.dll', 'dword', 'RtlComputeCrc32', 'dword', 0, 'struct*', $pMemory, 'int', $iLength)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateDesktop($sName, $iAccess = 0x0002, $iFlags = 0, $iHeap = 0, $tSecurity = 0)
Local $aRet
If $iHeap Then
$aRet = DllCall('user32.dll', 'handle', 'CreateDesktopExW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags,  'dword', $iAccess, 'struct*', $tSecurity, 'ulong', $iHeap, 'ptr', 0)
Else
$aRet = DllCall('user32.dll', 'handle', 'CreateDesktopW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags,  'dword', $iAccess, 'struct*', $tSecurity)
EndIf
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateWindowStation($sName = '', $iAccess = 0, $iFlags = 0, $tSecurity = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateWindowStationW', 'wstr', $sName, 'dword', $iFlags, 'dword', $iAccess,  'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DecompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormat = 0x0002)
Local $aRet = DllCall('ntdll.dll', 'long', 'RtlDecompressBuffer', 'ushort', $iFormat, 'struct*', $pUncompressedBuffer,  'ulong', $iUncompressedSize, 'struct*', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[6]
EndFunc
Func _WinAPI_DefRawInputProc($paRawInput, $iInput)
Local $aRet = DllCall('user32.dll', 'lresult', 'DefRawInputProc', 'ptr', $paRawInput, 'int', $iInput,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_EnumDesktops($hStation)
If StringCompare(_WinAPI_GetUserObjectInformation($hStation, 3), 'WindowStation') Then Return SetError(1, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'bool', 'ptr;lparam')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDesktopsW', 'handle', $hStation, 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDesktopWindows($hDesktop, $bVisible = True)
If StringCompare(_WinAPI_GetUserObjectInformation($hDesktop, 3), 'Desktop') Then Return SetError(1, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDesktopWindows', 'handle', $hDesktop, 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', $bVisible)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumPageFiles()
Local $aInfo = _WinAPI_GetSystemInfo()
Local $hEnumProc = DllCallbackRegister('__EnumPageFilesProc', 'bool', 'lparam;ptr;ptr')
Dim $__g_vEnum[101][4] = [[0]]
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumPageFilesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $aInfo[1])
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumRawInputDevices()
Local Const $tagRAWINPUTDEVICELIST = 'struct;handle hDevice;dword Type;endstruct'
Local $tRIDL, $iLength = DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICELIST))
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceList', 'ptr', 0, 'uint*', 0, 'uint', $iLength)
If @error Then Return SetError(@error + 10, @extended, 0)
If ($aRet[0] = 4294967295) Or (Not $aRet[2]) Then Return SetError(10, -1, 0)
Local $tData = DllStructCreate('byte[' & ($aRet[2] * $iLength) & ']')
Local $pData = DllStructGetPtr($tData)
If @error Then Return SetError(@error + 20, 0, 0)
$aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceList', 'ptr', $pData, 'uint*', $aRet[2], 'uint', $iLength)
If ($aRet[0] = 4294967295) Or (Not $aRet[0]) Then Return SetError(1, -1, 0)
Local $aResult[$aRet[2] + 1][2] = [[$aRet[2]]]
For $i = 1 To $aRet[2]
$tRIDL = DllStructCreate('ptr;dword', $pData + $iLength * ($i - 1))
For $j = 0 To 1
$aResult[$i][$j] = DllStructGetData($tRIDL, $j + 1)
Next
Next
Return $aResult
EndFunc
Func _WinAPI_EnumWindowStations()
Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'bool', 'ptr;lparam')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumWindowStationsW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_ExpandEnvironmentStrings($sString)
Local $aResult = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $sString, "wstr", "", "dword", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return $aResult[2]
EndFunc
Func _WinAPI_GetActiveWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetAsyncKeyState($iKey)
Local $aResult = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", $iKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClipboardSequenceNumber()
Local $aRet = DllCall('user32.dll', 'dword', 'GetClipboardSequenceNumber')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCurrentHwProfile()
Local $tagHW_PROFILE_INFO = 'dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]'
Local $tHWPI = DllStructCreate($tagHW_PROFILE_INFO)
Local $aRet = DllCall('advapi32.dll', 'bool', 'GetCurrentHwProfileW', 'struct*', $tHWPI)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[3]
For $i = 0 To 2
$aResult[$i] = DllStructGetData($tHWPI, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetDefaultPrinter()
Local $aRet = DllCall('winspool.drv', 'bool', 'GetDefaultPrinterW', 'wstr', '', 'dword*', 2048)
If @error Then Return SetError(@error, @extended, '')
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetDllDirectory()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetDllDirectoryW', 'dword', 4096, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetEffectiveClientRect($hWnd, $aCtrl, $iStart = 0, $iEnd = -1)
If Not IsArray($aCtrl) Then
Local $iCtrl = $aCtrl
Dim $aCtrl[1] = [$iCtrl]
$iStart = 0
$iEnd = 0
EndIf
If __CheckErrorArrayBounds($aCtrl, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tCtrl = DllStructCreate('uint64[' & ($iCount + 2) & ']')
$iCount = 2
For $i = $iStart To $iEnd
If IsHWnd($aCtrl[$i]) Then
$aCtrl[$i] = _WinAPI_GetDlgCtrlID($aCtrl[$i])
EndIf
DllStructSetData($tCtrl, 1, _WinAPI_MakeQWord(1, $aCtrl[$i]), $iCount)
$iCount += 1
Next
Local $tRECT = DllStructCreate($tagRECT)
DllCall('comctl32.dll', 'none', 'GetEffectiveClientRect', 'hwnd', $hWnd, 'struct*', $tRECT, 'struct*', $tCtrl)
If @error Then Return SetError(@error, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetHandleInformation($hObject)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetHandleInformation', 'handle', $hObject, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetIdleTime()
Local $tLASTINPUTINFO = DllStructCreate('uint;dword')
DllStructSetData($tLASTINPUTINFO, 1, DllStructGetSize($tLASTINPUTINFO))
Local $aRet = DllCall('user32.dll', 'bool', 'GetLastInputInfo', 'struct*', $tLASTINPUTINFO)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return _WinAPI_GetTickCount() - DllStructGetData($tLASTINPUTINFO, 2)
EndFunc
Func _WinAPI_GetKeyboardLayout($hWnd)
Local $aRet = DllCall('user32.dll', 'dword', 'GetWindowThreadProcessId', 'hwnd', $hWnd, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'GetKeyboardLayout', 'dword', $aRet[0])
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetKeyboardLayoutList()
Local $aRet = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Local $tData = DllStructCreate('handle[' & $aRet[0] & ']')
$aRet = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', $aRet[0], 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aList[$aRet[0] + 1] = [$aRet[0]]
For $i = 1 To $aList[0]
$aList[$i] = DllStructGetData($tData, 1, $i)
Next
Return $aList
EndFunc
Func _WinAPI_GetKeyboardState()
Local $tData = DllStructCreate('byte[256]')
Local $aRet = DllCall('user32.dll', 'bool', 'GetKeyboardState', 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tData
EndFunc
Func _WinAPI_GetKeyboardType($iType)
Local $aRet = DllCall('user32.dll', 'int', 'GetKeyboardType', 'int', $iType)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetKeyNameText($lParam)
Local $aRet = DllCall('user32.dll', 'int', 'GetKeyNameTextW', 'long', $lParam, 'wstr', '', 'int', 128)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetKeyState($vKey)
Local $aRet = DllCall('user32.dll', 'short', 'GetKeyState', 'int', $vKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetModuleHandleEx($sModule, $iFlags = 0)
Local $sTypeOfModule = 'ptr'
If IsString($sModule) Then
If StringStripWS($sModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfModule = 'wstr'
Else
$sModule = 0
EndIf
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetModuleHandleExW', 'dword', $iFlags, $sTypeOfModule, $sModule, 'ptr*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_GetMUILanguage()
Local $aRet = DllCall('comctl32.dll', 'word', 'GetMUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetPerformanceInfo()
Local $tPI = DllStructCreate('dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword')
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetPerformanceInfo', 'struct*', $tPI, 'dword', DllStructGetSize($tPI))
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[13]
For $i = 0 To 12
$aResult[$i] = DllStructGetData($tPI, $i + 2)
Next
For $i = 0 To 8
$aResult[$i] *= $aResult[9]
Next
Return $aResult
EndFunc
Func _WinAPI_GetProcAddress($hModule, $vName)
Local $sType = "str"
If IsNumber($vName) Then $sType = "word"
Local $aResult = DllCall("kernel32.dll", "ptr", "GetProcAddress", "handle", $hModule, $sType, $vName)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetPhysicallyInstalledSystemMemory()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetPhysicallyInstalledSystemMemory', 'uint64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_GetProcessShutdownParameters()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessShutdownParameters', 'dword*', 0, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended(Number(Not $aRet[2]), $aRet[1])
EndFunc
Func _WinAPI_GetProcessWindowStation()
Local $aRet = DllCall('user32.dll', 'handle', 'GetProcessWindowStation')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetPwrCapabilities()
If Not __DLL('powrprof.dll') Then Return SetError(103, 0, 0)
Local $tSPC = DllStructCreate('byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]')
Local $aRet = DllCall('powrprof.dll', 'boolean', 'GetPwrCapabilities', 'struct*', $tSPC)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[25]
For $i = 0 To 17
$aResult[$i] = DllStructGetData($tSPC, 1, $i + 1)
Next
$aResult[18] = DllStructGetData($tSPC, 3)
For $i = 19 To 20
$aResult[$i] = DllStructGetData($tSPC, 5, $i - 18)
Next
For $i = 21 To 24
$aResult[$i] = DllStructGetData($tSPC, 7, $i - 20)
Next
Return $aResult
EndFunc
Func _WinAPI_GetRawInputBuffer($pBuffer, $iLength)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputBuffer', 'struct*', $pBuffer, 'uint*', $iLength,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If ($aRet[0] = 4294967295) Or (Not $aRet[1]) Then Return SetError(10, -1, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetRawInputBufferLength()
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputBuffer', 'ptr', 0, 'uint*', 0,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return $aRet[2] * 8
EndFunc
Func _WinAPI_GetRawInputData($hRawInput, $pBuffer, $iLength, $iFlag)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputData', 'handle', $hRawInput, 'uint', $iFlag, 'struct*', $pBuffer,  'uint*', $iLength, 'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return ($aRet[3] ? $aRet[0] : $aRet[4])
EndFunc
Func _WinAPI_GetRawInputDeviceInfo($hDevice, $pBuffer, $iLength, $iFlag)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceInfoW', 'handle', $hDevice, 'uint', $iFlag, 'struct*', $pBuffer,  'uint*', $iLength)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return ($aRet[3] ? $aRet[0] : $aRet[4])
EndFunc
Func _WinAPI_GetRegisteredRawInputDevices($pBuffer, $iLength)
Local $iLengthRAW = DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICE))
Local $aRet = DllCall('user32.dll', 'uint', 'GetRegisteredRawInputDevices', 'struct*', $pBuffer,  'uint*', Floor($iLength / $iLengthRAW), 'uint', $iLengthRAW)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then
Local $iLastError = _WinAPI_GetLastError()
If $iLastError = 122 Then Return SetExtended($iLastError, $aRet[2] * $iLengthRAW)
Return SetError(10, $iLastError, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetStartupInfo()
Local $tSI = DllStructCreate($tagSTARTUPINFO)
DllCall('kernel32.dll', 'none', 'GetStartupInfoW', 'struct*', $tSI)
If @error Then Return SetError(@error, @extended, 0)
Return $tSI
EndFunc
Func _WinAPI_GetSystemDEPPolicy()
Local $aRet = DllCall('kernel32.dll', 'uint', 'GetSystemDEPPolicy')
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetSystemInfo()
Local $sProc
If _WinAPI_IsWow64Process() Then
$sProc = 'GetNativeSystemInfo'
Else
$sProc = 'GetSystemInfo'
EndIf
Local Const $tagSYSTEMINFO = 'struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;' &  'ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;' &  'dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision'
Local $tSystemInfo = DllStructCreate($tagSYSTEMINFO)
DllCall('kernel32.dll', 'none', $sProc, 'struct*', $tSystemInfo)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[10]
$aResult[0] = DllStructGetData($tSystemInfo, 1)
For $i = 1 To 9
$aResult[$i] = DllStructGetData($tSystemInfo, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_GetSystemPowerStatus()
Local $tagSYSTEM_POWER_STATUS = 'byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;' &  'int BatteryLifeTime;int BatteryFullLifeTime'
Local $tSYSTEM_POWER_STATUS = DllStructCreate($tagSYSTEM_POWER_STATUS)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetSystemPowerStatus', 'struct*', $tSYSTEM_POWER_STATUS)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[5]
$aResult[0] = DllStructGetData($tSYSTEM_POWER_STATUS, 1)
$aResult[1] = DllStructGetData($tSYSTEM_POWER_STATUS, 2)
$aResult[2] = DllStructGetData($tSYSTEM_POWER_STATUS, 3)
$aResult[3] = DllStructGetData($tSYSTEM_POWER_STATUS, 5)
$aResult[4] = DllStructGetData($tSYSTEM_POWER_STATUS, 6)
Return $aResult
EndFunc
Func _WinAPI_GetSystemTimes()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetSystemTimes', 'uint64*', 0, 'uint64*', 0, 'uint64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[3]
For $i = 0 To 2
$aResult[$i] = $aRet[$i + 1]
Next
Return $aResult
EndFunc
Func _WinAPI_GetSystemWow64Directory()
Local $aRet = DllCall('kernel32.dll', 'uint', 'GetSystemWow64DirectoryW', 'wstr', '', 'uint', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, _WinAPI_GetLastError(), '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetTickCount()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetTickCount')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTickCount64()
Local $aRet = DllCall('kernel32.dll', 'uint64', 'GetTickCount64')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserObjectInformation($hObject, $iIndex)
Local $aRet = DllCall('user32.dll', 'bool', 'GetUserObjectInformationW', 'handle', $hObject, 'int', $iIndex, 'ptr', 0,  'dword', 0, 'dword*', 0)
If @error Or Not $aRet[5] Then Return SetError(@error + 10, @extended, 0)
Local $tData
Switch $iIndex
Case 1
$tData = DllStructCreate($tagUSEROBJECTFLAGS)
Case 5, 6
$tData = DllStructCreate('uint')
Case 2, 3
$tData = DllStructCreate('wchar[' & $aRet[5] & ']')
Case 4
$tData = DllStructCreate('byte[' & $aRet[5] & ']')
Case Else
Return SetError(20, 0, 0)
EndSwitch
$aRet = DllCall('user32.dll', 'bool', 'GetUserObjectInformationW', 'handle', $hObject, 'int', $iIndex, 'struct*', $tData,  'dword', DllStructGetSize($tData), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 30, @extended, 0)
Switch $iIndex
Case 1, 4
Return $tData
Case Else
Return DllStructGetData($tData, 1)
EndSwitch
EndFunc
Func _WinAPI_GetVersion()
Return Number(BitAND(BitShift($__WINVER, 8), 0xFF) & '.' & BitAND($__WINVER, 0xFF), $NUMBER_DOUBLE)
EndFunc
Func _WinAPI_GetVersionEx()
Local $tOSVERSIONINFOEX = DllStructCreate($tagOSVERSIONINFOEX)
DllStructSetData($tOSVERSIONINFOEX, 'OSVersionInfoSize', DllStructGetSize($tOSVERSIONINFOEX))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVERSIONINFOEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tOSVERSIONINFOEX
EndFunc
Func _WinAPI_GetWorkArea()
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'int', 'SystemParametersInfo', 'uint', 48, 'uint', 0, 'struct*', $tRECT, 'uint', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_InitMUILanguage($iLanguage)
DllCall('comctl32.dll', 'none', 'InitMUILanguage', 'word', $iLanguage)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_IsLoadKBLayout($iLanguage)
Local $aLayout = _WinAPI_GetKeyboardLayoutList()
If @error Then Return SetError(@error, @extended, False)
For $i = 1 To $aLayout[0]
If $aLayout[$i] = $iLanguage Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsProcessorFeaturePresent($iFeature)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsProcessorFeaturePresent', 'dword', $iFeature)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsWindowEnabled($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsWindowEnabled', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Keybd_Event($vKey, $iFlags, $iScanCode = 0, $iExtraInfo = 0)
DllCall('user32.dll', 'none', 'keybd_event', 'byte', $vKey, 'byte', $iScanCode, 'dword', $iFlags, 'ulong_ptr', $iExtraInfo)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_LoadKeyboardLayout($iLanguage, $iFlag = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'LoadKeyboardLayoutW', 'wstr', Hex($iLanguage, 8), 'uint', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LockWorkStation()
Local $aRet = DllCall('user32.dll', 'bool', 'LockWorkStation')
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MapVirtualKey($iCode, $iType, $hLocale = 0)
Local $aRet = DllCall('user32.dll', 'INT', 'MapVirtualKeyExW', 'uint', $iCode, 'uint', $iType, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_Mouse_Event($iFlags, $iX = 0, $iY = 0, $iData = 0, $iExtraInfo = 0)
DllCall("user32.dll", "none", "mouse_event", "dword", $iFlags, "dword", $iX, "dword", $iY, "dword", $iData,  "ulong_ptr", $iExtraInfo)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_OpenDesktop($sName, $iAccess = 0, $iFlags = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenDesktopW', 'wstr', $sName, 'dword', $iFlags, 'bool', $bInherit,  'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenInputDesktop($iAccess = 0, $iFlags = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenInputDesktop', 'dword', $iFlags, 'bool', $bInherit, 'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenWindowStation($sName, $iAccess = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenWindowStationW', 'wstr', $sName, 'bool', $bInherit, 'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryPerformanceCounter()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceCounter', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_QueryPerformanceFrequency()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceFrequency', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_RegisterHotKey($hWnd, $iID, $iModifiers, $vKey)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterHotKey', 'hwnd', $hWnd, 'int', $iID, 'uint', $iModifiers, 'uint', $vKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterPowerSettingNotification($hWnd, $sGUID)
Local $tGUID = DllStructCreate($tagGUID)
Local $aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aRet[0] Then Return SetError(@error + 20, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'RegisterPowerSettingNotification', 'handle', $hWnd, 'struct*', $tGUID, 'dword', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterRawInputDevices($paDevice, $iCount = 1)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterRawInputDevices', 'struct*', $paDevice, 'uint', $iCount,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICE)) * $iCount)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseCapture()
Local $aResult = DllCall("user32.dll", "bool", "ReleaseCapture")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RemoveClipboardFormatListener($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'RemoveClipboardFormatListener', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetActiveWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'int', 'SetActiveWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetCapture($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetCapture", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetDefaultPrinter($sPrinter)
Local $aResult = DllCall("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $sPrinter)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetDllDirectory($sDirPath = Default)
Local $sTypeOfPath = 'wstr'
If $sDirPath = Default Then
$sTypeOfPath = 'ptr'
$sDirPath = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetDllDirectoryW', $sTypeOfPath, $sDirPath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetKeyboardLayout($hWnd, $iLanguage, $iFlags = 0)
If Not _WinAPI_IsWindow($hWnd) Then Return SetError(@error + 10, @extended, 0)
Local $hLocale = 0
If $iLanguage Then
$hLocale = _WinAPI_LoadKeyboardLayout($iLanguage)
If Not $hLocale Then Return SetError(10, 0, 0)
EndIf
Local Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $hWnd, 'uint', $WM_INPUTLANGCHANGEREQUEST, 'uint', $iFlags, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_SetKeyboardState(ByRef $tState)
Local $aRet = DllCall('user32.dll', 'int', 'SetKeyboardState', 'struct*', $tState)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetProcessShutdownParameters($iLevel, $bDialog = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetProcessShutdownParameters', 'dword', $iLevel, 'dword', Not $bDialog)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetProcessWindowStation($hStation)
Local $aRet = DllCall('user32.dll', 'bool', 'SetProcessWindowStation', 'handle', $hStation)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetUserObjectInformation($hObject, $iIndex, ByRef $tData)
If $iIndex <> 1 Then Return SetError(10, 0, False)
Local $aRet = DllCall('user32.dll', 'bool', 'SetUserObjectInformationW', 'handle', $hObject, 'int', 1, 'struct*', $tData,  'dword', DllStructGetSize($tData))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowsHookEx($iHook, $pProc, $hDll, $iThreadId = 0)
Local $aResult = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $iHook, "ptr", $pProc, "handle", $hDll,  "dword", $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWinEventHook($iEventMin, $iEventMax, $pEventProc, $iPID = 0, $iThreadId = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'SetWinEventHook', 'uint', $iEventMin, 'uint', $iEventMax, 'ptr', 0,  'ptr', $pEventProc, 'dword', $iPID, 'dword', $iThreadId, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonCreate($hWnd, $sText)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonCreate', 'hwnd', $hWnd, 'wstr', $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonDestroy($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonDestroy', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonQuery($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonQuery', 'hwnd', $hWnd, 'wstr', '', 'dword*', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_SwitchDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'SwitchDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SystemParametersInfo($iAction, $iParam = 0, $vParam = 0, $iWinIni = 0)
Local $aResult = DllCall("user32.dll", "bool", "SystemParametersInfoW", "uint", $iAction, "uint", $iParam, "struct*", $vParam,  "uint", $iWinIni)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_TrackMouseEvent($hWnd, $iFlags, $iTime = -1)
Local $tTME = DllStructCreate('dword;dword;hwnd;dword')
DllStructSetData($tTME, 1, DllStructGetSize($tTME))
DllStructSetData($tTME, 2, $iFlags)
DllStructSetData($tTME, 3, $hWnd)
DllStructSetData($tTME, 4, $iTime)
Local $aRet = DllCall('user32.dll', 'bool', 'TrackMouseEvent', 'struct*', $tTME)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnhookWindowsHookEx($hHook)
Local $aResult = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hHook)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UnhookWinEvent($hEventHook)
Local $aRet = DllCall('user32.dll', 'bool', 'UnhookWinEvent', 'handle', $hEventHook)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UnloadKeyboardLayout($hLocale)
Local $aRet = DllCall('user32.dll', 'bool', 'UnloadKeyboardLayout', 'handle', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterHotKey($hWnd, $iID)
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterHotKey', 'hwnd', $hWnd, 'int', $iID)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterPowerSettingNotification($hNotify)
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterPowerSettingNotification', 'handle', $hNotify)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func __EnumPageFilesProc($iSize, $pInfo, $pFile)
Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
For $i = 1 To 3
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
Next
Return 1
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $tagNOTIFYICONDATA = 'struct;dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar InfoTitle[64];dword InfoFlags;endstruct'
Global Const $tagNOTIFYICONDATA_V3 = $tagNOTIFYICONDATA & ';' & $tagGUID
Global Const $tagNOTIFYICONDATA_V4 = $tagNOTIFYICONDATA_V3 & ';ptr hBalloonIcon;'
Global Const $tagSHELLEXECUTEINFO = 'dword Size;ulong Mask;hwnd hWnd;ptr Verb;ptr File;ptr Parameters;ptr Directory;int Show;ulong_ptr hInstApp;ptr IDList;ptr Class;ulong_ptr hKeyClass;dword HotKey;ptr hMonitor;ptr hProcess'
Global Const $tagSHFILEINFO = 'ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80]'
Global Const $tagSHFILEOPSTRUCT = 'hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle'
Global Const $tagSHFOLDERCUSTOMSETTINGS = 'dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword SizeIF;int IconIndex;ptr Logo;dword SizeL'
Global Const $tagSHSTOCKICONINFO = 'dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260]'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_DefSubclassProc($hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('comctl32.dll', 'lresult', 'DefSubclassProc', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DllGetVersion($sFilePath)
Local $tVersion = DllStructCreate('dword[5]')
DllStructSetData($tVersion, 1, DllStructGetSize($tVersion), 1)
Local $aRet = DllCall($sFilePath, 'uint', 'DllGetVersion', 'struct*', $tVersion)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $aResult[4]
For $i = 0 To 3
$aResult[$i] = DllStructGetData($tVersion, 1, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_FindExecutable($sFileName, $sDirectory = "")
Local $aResult = DllCall("shell32.dll", "INT", "FindExecutableW", "wstr", $sFileName, "wstr", $sDirectory, "wstr", "")
If @error Then Return SetError(@error, @extended, '')
If $aResult[0] <= 32 Then Return SetError(10, $aResult[0], '')
Return SetExtended($aResult[0], $aResult[3])
EndFunc
Func _WinAPI_GetAllUsersProfileDirectory()
Local $aRet = DllCall('userenv.dll', 'bool', 'GetAllUsersProfileDirectoryW', 'wstr', '', 'dword*', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetDefaultUserProfileDirectory()
Local $aRet = DllCall('userenv.dll', 'bool', 'GetDefaultUserProfileDirectoryW', 'wstr', '', 'dword*', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetWindowSubclass($hWnd, $pSubclassProc, $idSubClass)
Local $aRet = DllCall('comctl32.dll', 'bool', 'GetWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $idSubClass,  'dword_ptr*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[4]
EndFunc
Func _WinAPI_RemoveWindowSubclass($hWnd, $pSubclassProc, $idSubClass)
Local $aRet = DllCall('comctl32.dll', 'bool', 'RemoveWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $idSubClass)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetCurrentProcessExplicitAppUserModelID($sAppID)
Local $aRet = DllCall('shell32.dll', 'long', 'SetCurrentProcessExplicitAppUserModelID', 'wstr', $sAppID)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_SetWindowSubclass($hWnd, $pSubclassProc, $idSubClass, $pData = 0)
Local $aRet = DllCall('comctl32.dll', 'bool', 'SetWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $idSubClass,  'dword_ptr', $pData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellAddToRecentDocs($sFilePath)
Local $sTypeOfFile = 'wstr'
If StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sFilePath = _WinAPI_PathSearchAndQualify($sFilePath, 1)
If Not $sFilePath Then
Return SetError(1, 0, 0)
EndIf
Else
$sTypeOfFile = 'ptr'
$sFilePath = 0
EndIf
DllCall('shell32.dll', 'none', 'SHAddToRecentDocs', 'uint', 3, $sTypeOfFile, $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellChangeNotify($iEvent, $iFlags, $iItem1 = 0, $iItem2 = 0)
Local $sTypeOfItem1 = 'dword_ptr', $sTypeOfItem2 = 'dword_ptr'
If IsString($iItem1) Then
$sTypeOfItem1 = 'wstr'
EndIf
If IsString($iItem2) Then
$sTypeOfItem2 = 'wstr'
EndIf
DllCall('shell32.dll', 'none', 'SHChangeNotify', 'long', $iEvent, 'uint', $iFlags, $sTypeOfItem1, $iItem1, $sTypeOfItem2, $iItem2)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellChangeNotifyDeregister($iID)
Local $aRet = DllCall('shell32.dll', 'bool', 'SHChangeNotifyDeregister', 'ulong', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellChangeNotifyRegister($hWnd, $iMsg, $iEvents, $iSources, $aPaths, $bRecursive = False)
Local $iPath = $aPaths, $tagStruct = ''
If IsArray($aPaths) Then
If UBound($aPaths, $UBOUND_COLUMNS) Then Return SetError(1, 0, 0)
Else
Dim $aPaths[1] = [$iPath]
EndIf
For $i = 0 To UBound($aPaths) - 1
If Not _WinAPI_PathIsDirectory($aPaths[$i]) Then Return SetError(2, 0, 0)
Next
For $i = 0 To UBound($aPaths) - 1
$tagStruct &= 'ptr;int;'
Next
Local $tEntry = DllStructCreate($tagStruct)
For $i = 0 To UBound($aPaths) - 1
$aPaths[$i] = _WinAPI_ShellILCreateFromPath(_WinAPI_PathSearchAndQualify($aPaths[$i]))
DllStructSetData($tEntry, 2 * $i + 1, $aPaths[$i])
DllStructSetData($tEntry, 2 * $i + 2, $bRecursive)
Next
Local $iError = 0
Local $aRet = DllCall('shell32.dll', 'ulong', 'SHChangeNotifyRegister', 'hwnd', $hWnd, 'int', $iSources, 'long', $iEvents,  'uint', $iMsg, 'int', UBound($aPaths), 'struct*', $tEntry)
If @error Or Not $aRet[0] Then $iError = @error + 10
For $i = 0 To UBound($aPaths) - 1
_WinAPI_CoTaskMemFree($aPaths[$i])
Next
Return SetError($iError, 0, $aRet[0])
EndFunc
Func _WinAPI_ShellCreateDirectory($sFilePath, $hParent = 0, $tSecurity = 0)
Local $aRet = DllCall('shell32.dll', 'int', 'SHCreateDirectoryExW', 'hwnd', $hParent, 'wstr', $sFilePath, 'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellEmptyRecycleBin($sRoot = '', $iFlags = 0, $hParent = 0)
Local $aRet = DllCall('shell32.dll', 'long', 'SHEmptyRecycleBinW', 'hwnd', $hParent, 'wstr', $sRoot, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellExecute($sFilePath, $sArgs = '', $sDir = '', $sVerb = '', $iShow = 1, $hParent = 0)
Local $sTypeOfArgs = 'wstr', $sTypeOfDir = 'wstr', $sTypeOfVerb = 'wstr'
If Not StringStripWS($sArgs, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfArgs = 'ptr'
$sArgs = 0
EndIf
If Not StringStripWS($sDir, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfDir = 'ptr'
$sDir = 0
EndIf
If Not StringStripWS($sVerb, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfVerb = 'ptr'
$sVerb = 0
EndIf
Local $aRet = DllCall('shell32.dll', 'ULONG_PTR', 'ShellExecuteW', 'hwnd', $hParent, $sTypeOfVerb, $sVerb, 'wstr', $sFilePath,  $sTypeOfArgs, $sArgs, $sTypeOfDir, $sDir, 'int', $iShow)
If @error Then Return SetError(@error, @extended, False)
If $aRet[0] <= 32 Then Return SetError(10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellExecuteEx(ByRef $tSHEXINFO)
Local $aRet = DllCall('shell32.dll', 'bool', 'ShellExecuteExW', 'struct*', $tSHEXINFO)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellExtractAssociatedIcon($sFilePath, $bSmall = False)
Local $iFlags = 0x00000100
If Not _WinAPI_PathIsDirectory($sFilePath) Then
$iFlags = BitOR($iFlags, 0x00000010)
EndIf
If $bSmall Then
$iFlags = BitOR($iFlags, 0x00000001)
EndIf
Local $tSHFILEINFO = DllStructCreate($tagSHFILEINFO)
If Not _WinAPI_ShellGetFileInfo($sFilePath, $iFlags, 0, $tSHFILEINFO) Then Return SetError(@error + 10, @extended, 0)
Return DllStructGetData($tSHFILEINFO, 'hIcon')
EndFunc
Func _WinAPI_ShellExtractIcon($sIcon, $iIndex, $iWidth, $iHeight)
Local $aRet = DllCall('shell32.dll', 'int', 'SHExtractIconsW', 'wstr', $sIcon, 'int', $iIndex, 'int', $iWidth,  'int', $iHeight, 'ptr*', 0, 'ptr*', 0, 'int', 1, 'int', 0)
If @error Or Not $aRet[0] Or Not $aRet[5] Then Return SetError(@error, @extended, 0)
Return $aRet[5]
EndFunc
Func _WinAPI_ShellFileOperation($sFrom, $sTo, $iFunc, $iFlags, $sTitle = '', $hParent = 0)
Local $iData
If Not IsArray($sFrom) Then
$iData = $sFrom
Dim $sFrom[1] = [$iData]
EndIf
Local $tFrom = _WinAPI_ArrayToStruct($sFrom)
If @error Then Return SetError(@error + 20, @extended, 0)
If Not IsArray($sTo) Then
$iData = $sTo
Dim $sTo[1] = [$iData]
EndIf
Local $tTo = _WinAPI_ArrayToStruct($sTo)
If @error Then Return SetError(@error + 30, @extended, 0)
Local $tSHFILEOPSTRUCT = DllStructCreate($tagSHFILEOPSTRUCT)
DllStructSetData($tSHFILEOPSTRUCT, 'hWnd', $hParent)
DllStructSetData($tSHFILEOPSTRUCT, 'Func', $iFunc)
DllStructSetData($tSHFILEOPSTRUCT, 'From', DllStructGetPtr($tFrom))
DllStructSetData($tSHFILEOPSTRUCT, 'To', DllStructGetPtr($tTo))
DllStructSetData($tSHFILEOPSTRUCT, 'Flags', $iFlags)
DllStructSetData($tSHFILEOPSTRUCT, 'ProgressTitle', $sTitle)
Local $aRet = DllCall('shell32.dll', 'int', 'SHFileOperationW', 'struct*', $tSHFILEOPSTRUCT)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tSHFILEOPSTRUCT
EndFunc
Func _WinAPI_ShellFlushSFCache()
DllCall('shell32.dll', 'none', 'SHFlushSFCache')
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellGetFileInfo($sFilePath, $iFlags, $iAttributes, ByRef $tSHFILEINFO)
Local $aRet = DllCall('shell32.dll', 'dword_ptr', 'SHGetFileInfoW', 'wstr', $sFilePath, 'dword', $iAttributes,  'struct*', $tSHFILEINFO, 'uint', DllStructGetSize($tSHFILEINFO), 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellGetIconOverlayIndex($sIcon, $iIndex)
Local $sTypeOfIcon = 'wstr'
If Not StringStripWS($sIcon, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfIcon = 'ptr'
$sIcon = 0
EndIf
Local $aRet = DllCall('shell32.dll', 'int', 'SHGetIconOverlayIndexW', $sTypeOfIcon, $sIcon, 'int', $iIndex)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellGetKnownFolderIDList($sGUID, $iFlags = 0, $hToken = 0)
Local $tGUID = DllStructCreate($tagGUID)
Local $aRet = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aRet[0] Then Return SetError(@error + 20, @extended, 0)
$aRet = DllCall('shell32.dll', 'uint', 'SHGetKnownFolderIDList', 'struct*', $tGUID, 'dword', $iFlags, 'handle', $hToken, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[4]
EndFunc
Func _WinAPI_ShellGetKnownFolderPath($sGUID, $iFlags = 0, $hToken = 0)
Local $tGUID = DllStructCreate($tagGUID)
Local $aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aRet[0] Then Return SetError(@error + 20, @extended, '')
$aRet = DllCall('shell32.dll', 'long', 'SHGetKnownFolderPath', 'struct*', $tGUID, 'dword', $iFlags, 'handle', $hToken, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $sPath = _WinAPI_GetString($aRet[4])
_WinAPI_CoTaskMemFree($aRet[4])
Return $sPath
EndFunc
Func _WinAPI_ShellGetLocalizedName($sFilePath)
Local $aRet = DllCall('shell32.dll', 'long', 'SHGetLocalizedName', 'wstr', $sFilePath, 'wstr', '', 'uint*', 0, 'int*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $aResult[2]
Local $aRet1 = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $aRet[2], "wstr", "", "dword", 4096)
$aResult[0] = $aRet1[2]
$aResult[1] = $aRet[4]
Return $aResult
EndFunc
Func _WinAPI_ShellGetPathFromIDList($pPIDL)
Local $aRet = DllCall('shell32.dll', 'bool', 'SHGetPathFromIDListW', 'struct*', $pPIDL, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_ShellGetSetFolderCustomSettings($sFilePath, $iFlag, ByRef $tSHFCS)
Local $sProc = 'SHGetSetFolderCustomSettings'
If $__WINVER < 0x0600 Then $sProc &= 'W'
Local $aRet = DllCall('shell32.dll', 'long', $sProc, 'struct*', $tSHFCS, 'wstr', $sFilePath, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellGetSettings($iFlags)
Local $tSHELLSTATE = DllStructCreate('uint[8]')
DllCall('shell32.dll', 'none', 'SHGetSetSettings', 'struct*', $tSHELLSTATE, 'dword', $iFlags, 'bool', 0)
If @error Then Return SetError(@error, @extended, 0)
Local $iVal1 = DllStructGetData($tSHELLSTATE, 1, 1)
Local $iVal2 = DllStructGetData($tSHELLSTATE, 1, 8)
Local $iResult = 0
Local $aOpt[20][2] =  [[0x00000001, 0x00000001],  [0x00000002, 0x00000002],  [0x00000004, 0x00008000],  [0x00000008, 0x00000020],  [0x00000010, 0x00000008],  [0x00000020, 0x00000080],  [0x00000040, 0x00000200],  [0x00000080, 0x00000400],  [0x00000100, 0x00000800],  [0x00000400, 0x00001000],  [0x00000800, 0x00002000],  [0x00001000, 0x00004000],  [0x00002000, 0x00020000],  [0x00008000, 0x00040000],  [0x00010000, 0x00100000],  [0x00000001, 0x00080000],  [0x00000002, 0x00200000],  [0x00000008, 0x00800000],  [0x00000010, 0x01000000],  [0x00000020, 0x02000000]]
For $i = 0 To 14
If BitAND($iVal1, $aOpt[$i][0]) Then
$iResult += $aOpt[$i][1]
EndIf
Next
For $i = 15 To 19
If BitAND($iVal2, $aOpt[$i][0]) Then
$iResult += $aOpt[$i][1]
EndIf
Next
Return $iResult
EndFunc
Func _WinAPI_ShellGetSpecialFolderLocation($iCSIDL)
Local $aRet = DllCall('shell32.dll', 'long', 'SHGetSpecialFolderLocation', 'hwnd', 0, 'int', $iCSIDL, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[3]
EndFunc
Func _WinAPI_ShellGetSpecialFolderPath($iCSIDL, $bCreate = False)
Local $aRet = DllCall('shell32.dll', 'bool', 'SHGetSpecialFolderPathW', 'hwnd', 0, 'wstr', '', 'int', $iCSIDL, 'bool', $bCreate)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_ShellGetStockIconInfo($iSIID, $iFlags)
Local $tSHSTOCKICONINFO = DllStructCreate($tagSHSTOCKICONINFO)
DllStructSetData($tSHSTOCKICONINFO, 'Size', DllStructGetSize($tSHSTOCKICONINFO))
Local $aRet = DllCall('shell32.dll', 'long', 'SHGetStockIconInfo', 'int', $iSIID, 'uint', $iFlags, 'struct*', $tSHSTOCKICONINFO)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tSHSTOCKICONINFO
EndFunc
Func _WinAPI_ShellILCreateFromPath($sFilePath)
Local $aRet = DllCall('shell32.dll', 'long', 'SHILCreateFromPath', 'wstr', $sFilePath, 'ptr*', 0, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[2]
EndFunc
Func _WinAPI_ShellNotifyIcon($iMessage, ByRef $tNOTIFYICONDATA)
Local $aRet = DllCall('shell32.dll', 'bool', 'Shell_NotifyIconW', 'dword', $iMessage, 'struct*', $tNOTIFYICONDATA)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellNotifyIconGetRect($hWnd, $iID, $tGUID = 0)
Local $tNII = DllStructCreate('dword;hwnd;uint;' & $tagGUID)
DllStructSetData($tNII, 1, DllStructGetSize($tNII))
DllStructSetData($tNII, 2, $hWnd)
DllStructSetData($tNII, 3, $iID)
If IsDllStruct($tGUID) Then
If Not _WinAPI_MoveMemory(DllStructGetPtr($tNII, 4), $tGUID, 16) Then Return SetError(@error + 10, @extended, 0)
EndIf
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('shell32.dll', 'long', 'Shell_NotifyIconGetRect', 'struct*', $tNII, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tRECT
EndFunc
Func _WinAPI_ShellObjectProperties($sFilePath, $iType = 2, $sProperty = '', $hParent = 0)
Local $sTypeOfProperty = 'wstr'
If Not StringStripWS($sProperty, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfProperty = 'ptr'
$sProperty = 0
EndIf
Local $aRet = DllCall('shell32.dll', 'bool', 'SHObjectProperties', 'hwnd', $hParent, 'dword', $iType, 'wstr', $sFilePath,  $sTypeOfProperty, $sProperty)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellOpenFolderAndSelectItems($sFilePath, $aNames = 0, $iStart = 0, $iEnd = -1, $iFlags = 0)
Local $pPIDL, $aRet, $tPtr = 0, $iCount = 0, $iObj = 0, $iError = 0
$sFilePath = _WinAPI_PathRemoveBackslash(_WinAPI_PathSearchAndQualify($sFilePath))
If IsArray($aNames) Then
If $sFilePath And Not _WinAPI_PathIsDirectory($sFilePath) Then Return SetError(@error + 20, @extended, 0)
EndIf
$pPIDL = _WinAPI_ShellILCreateFromPath($sFilePath)
If @error Then Return SetError(@error + 30, @extended, 0)
If Not __CheckErrorArrayBounds($aNames, $iStart, $iEnd) Then
$tPtr = DllStructCreate('ptr[' & ($iEnd - $iStart + 1) & ']')
For $i = $iStart To $iEnd
$iCount += 1
If $aNames[$i] Then
DllStructSetData($tPtr, 1, _WinAPI_ShellILCreateFromPath($sFilePath & '\' & $aNames[$i]), $iCount)
Else
DllStructSetData($tPtr, 1, 0, $iCount)
EndIf
Next
EndIf
If _WinAPI_CoInitialize() Then $iObj = 1
$aRet = DllCall('shell32.dll', 'long', 'SHOpenFolderAndSelectItems', 'ptr', $pPIDL, 'uint', $iCount, 'struct*', $tPtr,  'dword', $iFlags)
If @error Then
$iError = @error + 10
Else
If $aRet[0] Then $iError = 10
EndIf
If $iObj Then _WinAPI_CoUninitialize()
_WinAPI_CoTaskMemFree($pPIDL)
For $i = 1 To $iCount
$pPIDL = DllStructGetData($tPtr, $i)
If $pPIDL Then
_WinAPI_CoTaskMemFree($pPIDL)
EndIf
Next
If $iError = 10 Then Return SetError(10, $aRet[0], 0)
If $iError Then Return SetError($iError, 0, 0)
Return 1
EndFunc
Func _WinAPI_ShellQueryRecycleBin($sRoot = '')
Local $tSHQRBI = DllStructCreate('align 4;dword_ptr;int64;int64')
DllStructSetData($tSHQRBI, 1, DllStructGetSize($tSHQRBI))
Local $aRet = DllCall('shell32.dll', 'long', 'SHQueryRecycleBinW', 'wstr', $sRoot, 'struct*', $tSHQRBI)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $aResult[2]
$aResult[0] = DllStructGetData($tSHQRBI, 2)
$aResult[1] = DllStructGetData($tSHQRBI, 3)
Return $aResult
EndFunc
Func _WinAPI_ShellQueryUserNotificationState()
Local $aRet = DllCall('shell32.dll', 'long', 'SHQueryUserNotificationState', 'uint*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[1]
EndFunc
Func _WinAPI_ShellRemoveLocalizedName($sFilePath)
Local $aRet = DllCall('shell32.dll', 'long', 'SHRemoveLocalizedName', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellRestricted($iRestriction)
Local $aRet = DllCall('shell32.dll', 'dword', 'SHRestricted', 'uint', $iRestriction)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellSetKnownFolderPath($sGUID, $sFilePath, $iFlags = 0, $hToken = 0)
Local $tGUID = DllStructCreate($tagGUID)
Local $aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aRet[0] Then Return SetError(@error + 20, @extended, 0)
$aRet = DllCall('shell32.dll', 'long', 'SHSetKnownFolderPath', 'struct*', $tGUID, 'dword', $iFlags, 'handle', $hToken, 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellSetLocalizedName($sFilePath, $sModule, $iResID)
Local $aRet = DllCall('shell32.dll', 'long', 'SHSetLocalizedName', 'wstr', $sFilePath, 'wstr', $sModule, 'int', $iResID)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellSetSettings($iFlags, $bSet)
Local $iVal1 = 0, $iVal2 = 0
Local $aOpt[20][2] =  [[0x00000001, 0x00000001],  [0x00000002, 0x00000002],  [0x00000004, 0x00008000],  [0x00000008, 0x00000020],  [0x00000010, 0x00000008],  [0x00000020, 0x00000080],  [0x00000040, 0x00000200],  [0x00000080, 0x00000400],  [0x00000100, 0x00000800],  [0x00000400, 0x00001000],  [0x00000800, 0x00002000],  [0x00001000, 0x00004000],  [0x00002000, 0x00020000],  [0x00008000, 0x00040000],  [0x00010000, 0x00100000],  [0x00000001, 0x00080000],  [0x00000002, 0x00200000],  [0x00000008, 0x00800000],  [0x00000010, 0x01000000],  [0x00000020, 0x02000000]]
If $bSet Then
For $i = 0 To 14
If BitAND($iFlags, $aOpt[$i][1]) Then
$iVal1 += $aOpt[$i][0]
EndIf
Next
For $i = 15 To 19
If BitAND($iFlags, $aOpt[$i][1]) Then
$iVal2 += $aOpt[$i][0]
EndIf
Next
EndIf
Local $tSHELLSTATE = DllStructCreate('uint[8]')
DllStructSetData($tSHELLSTATE, 1, $iVal1, 1)
DllStructSetData($tSHELLSTATE, 1, $iVal2, 8)
DllCall('shell32.dll', 'none', 'SHGetSetSettings', 'struct*', $tSHELLSTATE, 'dword', $iFlags, 'bool', 1)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellUpdateImage($sIcon, $iIndex, $iImage, $iFlags = 0)
DllCall('shell32.dll', 'none', 'SHUpdateImageW', 'wstr', $sIcon, 'int', $iIndex, 'uint', $iFlags, 'int', $iImage)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global $__g_pFRBuffer = 0, $__g_iFRBufferSize = 16385
Global Const $tagDEVNAMES = 'ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default'
Global Const $tagFINDREPLACE = 'dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName'
Global Const $tagMSGBOXPARAMS = 'uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId'
Global Const $tagPAGESETUPDLG = 'dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long MarginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemplateName;ptr hPageSetupTemplate'
Global Const $tagPRINTDLG = (@AutoItX64 ? '' : 'align 2;') & 'dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;word FromPage;word ToPage;word MinPage;word MaxPage;word Copies;handle hInstance;lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;handle hPrintTemplate;handle hSetupTemplate'
Global Const $tagPRINTDLGEX = 'dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr PageRanges;dword MinPage;dword MaxPage;dword Copies;handle hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;dword ResultAction'
Global Const $tagPRINTPAGERANGE = 'dword FromPage;dword ToPage'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_BrowseForFolderDlg($sRoot = '', $sText = '', $iFlags = 0, $pBrowseProc = 0, $lParam = 0, $hParent = 0)
Local Const $tagBROWSEINFO = 'hwnd hwndOwner;ptr pidlRoot;ptr pszDisplayName; ptr lpszTitle;uint ulFlags;ptr lpfn;lparam lParam;int iImage'
Local $tBROWSEINFO = DllStructCreate($tagBROWSEINFO & ';wchar[' & (StringLen($sText) + 1) & '];wchar[260]')
Local $pPIDL = 0, $sResult = ''
If StringStripWS($sRoot, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
Local $sPath = _WinAPI_PathSearchAndQualify($sRoot, 1)
If @error Then
$sPath = $sRoot
EndIf
$pPIDL = _WinAPI_ShellILCreateFromPath($sPath)
If @error Then
EndIf
EndIf
DllStructSetData($tBROWSEINFO, 1, $hParent)
DllStructSetData($tBROWSEINFO, 2, $pPIDL)
DllStructSetData($tBROWSEINFO, 3, DllStructGetPtr($tBROWSEINFO, 10))
DllStructSetData($tBROWSEINFO, 4, DllStructGetPtr($tBROWSEINFO, 9))
DllStructSetData($tBROWSEINFO, 5, $iFlags)
DllStructSetData($tBROWSEINFO, 6, $pBrowseProc)
DllStructSetData($tBROWSEINFO, 7, $lParam)
DllStructSetData($tBROWSEINFO, 8, 0)
DllStructSetData($tBROWSEINFO, 9, $sText)
Local $aRet = DllCall('shell32.dll', 'ptr', 'SHBrowseForFolderW', 'struct*', $tBROWSEINFO)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
$sResult = _WinAPI_ShellGetPathFromIDList($aRet[0])
_WinAPI_CoTaskMemFree($aRet[0])
If $pPIDL Then
_WinAPI_CoTaskMemFree($pPIDL)
EndIf
If Not $sResult Then Return SetError(10, 0, '')
Return $sResult
EndFunc
Func _WinAPI_CommDlgExtendedError()
Local Const $CDERR_DIALOGFAILURE = 0xFFFF
Local Const $CDERR_FINDRESFAILURE = 0x06
Local Const $CDERR_INITIALIZATION = 0x02
Local Const $CDERR_LOADRESFAILURE = 0x07
Local Const $CDERR_LOADSTRFAILURE = 0x05
Local Const $CDERR_LOCKRESFAILURE = 0x08
Local Const $CDERR_MEMALLOCFAILURE = 0x09
Local Const $CDERR_MEMLOCKFAILURE = 0x0A
Local Const $CDERR_NOHINSTANCE = 0x04
Local Const $CDERR_NOHOOK = 0x0B
Local Const $CDERR_NOTEMPLATE = 0x03
Local Const $CDERR_REGISTERMSGFAIL = 0x0C
Local Const $CDERR_STRUCTSIZE = 0x01
Local Const $FNERR_BUFFERTOOSMALL = 0x3003
Local Const $FNERR_INVALIDFILENAME = 0x3002
Local Const $FNERR_SUBCLASSFAILURE = 0x3001
Local $aResult = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
If Not @error Then
Switch $aResult[0]
Case $CDERR_DIALOGFAILURE
Return SetError($aResult[0], 0, "The dialog box could not be created." & @LF &  "The common dialog box function's call to the DialogBox function failed." & @LF &  "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
Case $CDERR_FINDRESFAILURE
Return SetError($aResult[0], 0, "The common dialog box function failed to find a specified resource.")
Case $CDERR_INITIALIZATION
Return SetError($aResult[0], 0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
Case $CDERR_LOADRESFAILURE
Return SetError($aResult[0], 0, "The common dialog box function failed to load a specified resource.")
Case $CDERR_LOADSTRFAILURE
Return SetError($aResult[0], 0, "The common dialog box function failed to load a specified string.")
Case $CDERR_LOCKRESFAILURE
Return SetError($aResult[0], 0, "The common dialog box function failed to lock a specified resource.")
Case $CDERR_MEMALLOCFAILURE
Return SetError($aResult[0], 0, "The common dialog box function was unable to allocate memory for internal structures.")
Case $CDERR_MEMLOCKFAILURE
Return SetError($aResult[0], 0, "The common dialog box function was unable to lock the memory associated with a handle.")
Case $CDERR_NOHINSTANCE
Return SetError($aResult[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a corresponding instance handle.")
Case $CDERR_NOHOOK
Return SetError($aResult[0], 0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a pointer to a corresponding hook procedure.")
Case $CDERR_NOTEMPLATE
Return SetError($aResult[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a corresponding template.")
Case $CDERR_REGISTERMSGFAIL
Return SetError($aResult[0], 0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
Case $CDERR_STRUCTSIZE
Return SetError($aResult[0], 0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
Case $FNERR_BUFFERTOOSMALL
Return SetError($aResult[0], 0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF &  "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
Case $FNERR_INVALIDFILENAME
Return SetError($aResult[0], 0, "A file name is invalid.")
Case $FNERR_SUBCLASSFAILURE
Return SetError($aResult[0], 0, "An attempt to subclass a list box failed because sufficient memory was not available.")
EndSwitch
EndIf
Return SetError(@error, @extended, '0x' & Hex($aResult[0]))
EndFunc
Func _WinAPI_CommDlgExtendedErrorEx()
Local $aRet = DllCall('comdlg32.dll', 'dword', 'CommDlgExtendedError')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ConfirmCredentials($sTarget, $bConfirm)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $aRet = DllCall('credui.dll', 'dword', 'CredUIConfirmCredentialsW', 'wstr', $sTarget, 'bool', $bConfirm)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_FindTextDlg($hOwner, $sFindWhat = '', $iFlags = 0, $pFindProc = 0, $lParam = 0)
$__g_pFRBuffer = __HeapReAlloc($__g_pFRBuffer, 2 * $__g_iFRBufferSize)
If @error Then Return SetError(@error + 20, @extended, 0)
DllStructSetData(DllStructCreate('wchar[' & $__g_iFRBufferSize & ']', $__g_pFRBuffer), 1, StringLeft($sFindWhat, $__g_iFRBufferSize - 1))
Local $tFR = DllStructCreate($tagFINDREPLACE)
DllStructSetData($tFR, 'Size', DllStructGetSize($tFR))
DllStructSetData($tFR, 'hOwner', $hOwner)
DllStructSetData($tFR, 'hInstance', 0)
DllStructSetData($tFR, 'Flags', $iFlags)
DllStructSetData($tFR, 'FindWhat', $__g_pFRBuffer)
DllStructSetData($tFR, 'ReplaceWith', 0)
DllStructSetData($tFR, 'FindWhatLen', $__g_iFRBufferSize * 2)
DllStructSetData($tFR, 'ReplaceWithLen', 0)
DllStructSetData($tFR, 'lParam', $lParam)
DllStructSetData($tFR, 'Hook', $pFindProc)
DllStructSetData($tFR, 'TemplateName', 0)
Local $aRet = DllCall('comdlg32.dll', 'hwnd', 'FindTextW', 'struct*', $tFR)
If @error Or Not $aRet[0] Then
Local $iError = @error + 30
__HeapFree($__g_pFRBuffer)
If IsArray($aRet) Then
Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), 0)
Else
Return SetError($iError, @extended, 0)
EndIf
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_FlushFRBuffer()
If Not __HeapFree($__g_pFRBuffer, 1) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_FormatDriveDlg($sDrive, $iOption = 0, $hParent = 0)
If Not IsString($sDrive) Then Return SetError(10, 0, 0)
$sDrive = StringLeft(StringUpper(StringStripWS($sDrive, $STR_STRIPLEADING)), 1)
If Not $sDrive Then Return SetError(11, 0, 0)
$sDrive = Asc($sDrive) - 65
If ($sDrive < 0) Or ($sDrive > 25) Then Return SetError(12, 0, 0)
Local $aRet = DllCall('shell32.dll', 'dword', 'SHFormatDrive', 'hwnd', $hParent, 'uint', $sDrive, 'uint', 0xFFFF,  'uint', $iOption)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] < 0 Then Return SetError($aRet[0], 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetConnectedDlg($iDlg, $iFlags = 0, $hParent = 0)
If Not __DLL('connect.dll') Then Return SetError(103, 0, 0)
Switch $iDlg
Case 0
$iDlg = 'GetNetworkConnected'
Case 1
$iDlg = 'GetInternetConnected'
Case 2
$iDlg = 'GetVPNConnected'
Case Else
Return SetError(1, 0, 0)
EndSwitch
Local $sStr = ''
If BitAND($iFlags, 1) Then
$sStr &= '-SkipInternetDetection '
EndIf
If BitAND($iFlags, 2) Then
$sStr &= '-SkipExistingConnections '
EndIf
If BitAND($iFlags, 4) Then
$sStr &= '-HideFinishPage '
EndIf
Local $aRet = DllCall('connect.dll', 'long', $iDlg, 'hwnd', $hParent, 'dword', 0, 'dword', 0, 'dword', 0, 'handle', 0,  'wstr', StringStripWS($sStr, $STR_STRIPTRAILING))
If @error Then Return SetError(@error, @extended, 0)
If Not ($aRet[0] = 0 Or $aRet[0] = 1) Then Return SetError(10, $aRet[0], 0)
Return Number(Not $aRet[0])
EndFunc
Func _WinAPI_GetFRBuffer()
Return $__g_iFRBufferSize - 1
EndFunc
Func _WinAPI_GetOpenFileName($sTitle = "", $sFilter = "All files (*.*)", $sInitalDir = ".", $sDefaultFile = "", $sDefaultExt = "", $iFilterIndex = 1, $iFlags = 0, $iFlagsEx = 0, $hWndOwner = 0)
Local $vResult = __OFNDlg(0, $sTitle, $sInitalDir, $sFilter, $iFilterIndex, $sDefaultFile, $sDefaultExt, $iFlags, $iFlagsEx, 0, 0, $hWndOwner)
If @error Then Return SetError(@error, @extended, '')
If BitAND($iFlags, $OFN_ALLOWMULTISELECT) Then
Return __WinAPI_ParseMultiSelectFileDialogPath($vResult)
Else
Return __WinAPI_ParseFileDialogPath($vResult)
EndIf
EndFunc
Func _WinAPI_GetSaveFileName($sTitle = "", $sFilter = "All files (*.*)", $sInitalDir = ".", $sDefaultFile = "", $sDefaultExt = "", $iFilterIndex = 1, $iFlags = 0, $iFlagsEx = 0, $hWndOwner = 0)
Local $sReturn = __OFNDlg(1, $sTitle, $sInitalDir, $sFilter, $iFilterIndex, $sDefaultFile, $sDefaultExt, $iFlags, $iFlagsEx, 0, 0, $hWndOwner)
If @error Then Return SetError(@error, @extended, '')
Return __WinAPI_ParseFileDialogPath($sReturn)
EndFunc
Func _WinAPI_MessageBoxCheck($iType, $sTitle, $sText, $sRegVal, $iDefault = -1, $hParent = 0)
Local $aRet = DllCall('shlwapi.dll', 'int', 'SHMessageBoxCheckW', 'hwnd', $hParent, 'wstr', $sText, 'wstr', $sTitle,  'uint', $iType, 'int', $iDefault, 'wstr', $sRegVal)
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_MessageBoxIndirect($tMSGBOXPARAMS)
Local $aRet = DllCall('user32.dll', 'int', 'MessageBoxIndirectW', 'struct*', $tMSGBOXPARAMS)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenFileDlg($sTitle = '', $sInitDir = '', $sFilters = '', $iDefaultFilter = 0, $sDefaultFilePath = '', $sDefaultExt = '', $iFlags = 0, $iFlagsEx = 0, $pOFNProc = 0, $pData = 0, $hParent = 0)
Local $sResult = __OFNDlg(0, $sTitle, $sInitDir, $sFilters, $iDefaultFilter, $sDefaultFilePath, $sDefaultExt, $iFlags, $iFlagsEx, $pOFNProc, $pData, $hParent)
If @error Then Return SetError(@error, @extended, '')
Return $sResult
EndFunc
Func _WinAPI_PageSetupDlg(ByRef $tPAGESETUPDLG)
Local $aRet = DllCall('comdlg32.dll', 'int', 'PageSetupDlgW', 'struct*', $tPAGESETUPDLG)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PickIconDlg($sIcon = '', $iIndex = 0, $hParent = 0)
Local $aRet = DllCall('shell32.dll', 'int', 'PickIconDlg', 'hwnd', $hParent, 'wstr', $sIcon, 'int', 4096, 'int*', $iIndex)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[2]
Local $aRes = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $aRet[2], "wstr", "", "dword", 4096)
$aResult[0] = $aRes[2]
$aResult[1] = $aRet[4]
Return $aResult
EndFunc
Func _WinAPI_PrintDlg(ByRef $tPRINTDLG)
Local $aRet = DllCall('comdlg32.dll', 'long', 'PrintDlgW', 'struct*', $tPRINTDLG)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PrintDlgEx(ByRef $tPRINTDLGEX)
Local $tPDEX = DllStructCreate($tagPRINTDLGEX, DllStructGetPtr($tPRINTDLGEX))
Local $aRet = DllCall('comdlg32.dll', 'long', 'PrintDlgExW', 'struct*', $tPDEX)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return SetExtended(DllStructGetData($tPDEX, 'ResultAction'), 1)
EndFunc
Func _WinAPI_ReplaceTextDlg($hOwner, $sFindWhat = '', $sReplaceWith = '', $iFlags = 0, $pReplaceProc = 0, $lParam = 0)
$__g_pFRBuffer = __HeapReAlloc($__g_pFRBuffer, 4 * $__g_iFRBufferSize)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $tBuff = DllStructCreate('wchar[' & $__g_iFRBufferSize & '];wchar[' & $__g_iFRBufferSize & ']', $__g_pFRBuffer)
DllStructSetData($tBuff, 1, StringLeft($sFindWhat, $__g_iFRBufferSize - 1))
DllStructSetData($tBuff, 2, StringLeft($sReplaceWith, $__g_iFRBufferSize - 1))
Local $tFR = DllStructCreate($tagFINDREPLACE)
DllStructSetData($tFR, 'Size', DllStructGetSize($tFR))
DllStructSetData($tFR, 'hOwner', $hOwner)
DllStructSetData($tFR, 'hInstance', 0)
DllStructSetData($tFR, 'Flags', $iFlags)
DllStructSetData($tFR, 'FindWhat', DllStructGetPtr($tBuff, 1))
DllStructSetData($tFR, 'ReplaceWith', DllStructGetPtr($tBuff, 2))
DllStructSetData($tFR, 'FindWhatLen', $__g_iFRBufferSize * 2)
DllStructSetData($tFR, 'ReplaceWithLen', $__g_iFRBufferSize * 2)
DllStructSetData($tFR, 'lParam', $lParam)
DllStructSetData($tFR, 'Hook', $pReplaceProc)
DllStructSetData($tFR, 'TemplateName', 0)
Local $aRet = DllCall('comdlg32.dll', 'hwnd', 'ReplaceTextW', 'struct*', $tFR)
If @error Or Not $aRet[0] Then
Local $iError = @error
__HeapFree($__g_pFRBuffer)
If IsArray($aRet) Then
Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), 0)
Else
Return SetError($iError, 0, 0)
EndIf
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_RestartDlg($sText = '', $iFlags = 2, $hParent = 0)
Local $aRet = DllCall('shell32.dll', 'int', 'RestartDialog', 'hwnd', $hParent, 'wstr', $sText, 'int', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SaveFileDlg($sTitle = "", $sInitDir = "", $sFilters = "", $iDefaultFilter = 0, $sDefaultFilePath = "", $sDefaultExt = "", $iFlags = 0, $iFlagsEx = 0, $pOFNProc = 0, $pData = 0, $hParent = 0)
Local $sResult = __OFNDlg(1, $sTitle, $sInitDir, $sFilters, $iDefaultFilter, $sDefaultFilePath, $sDefaultExt, $iFlags, $iFlagsEx, $pOFNProc, $pData, $hParent)
If @error Then Return SetError(@error, @extended, "")
Return $sResult
EndFunc
Func _WinAPI_SetFRBuffer($iChars)
$iChars = Number($iChars)
If $iChars < 80 Then
$iChars = 80
EndIf
$__g_iFRBufferSize = $iChars + 1
Return 1
EndFunc
Func _WinAPI_ShellAboutDlg($sTitle, $sName, $sText, $hIcon = 0, $hParent = 0)
Local $aRet = DllCall('shell32.dll', 'int', 'ShellAboutW', 'hwnd', $hParent, 'wstr', $sTitle & '#' & $sName, 'wstr', $sText,  'handle', $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShellOpenWithDlg($sFilePath, $iFlags = 0, $hParent = 0)
Local $tOPENASINFO = DllStructCreate('ptr;ptr;dword;wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tOPENASINFO, 1, DllStructGetPtr($tOPENASINFO, 4))
DllStructSetData($tOPENASINFO, 2, 0)
DllStructSetData($tOPENASINFO, 3, $iFlags)
DllStructSetData($tOPENASINFO, 4, $sFilePath)
Local $aRet = DllCall('shell32.dll', 'long', 'SHOpenWithDialog', 'hwnd', $hParent, 'struct*', $tOPENASINFO)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_ShellStartNetConnectionDlg($sRemote = '', $iFlags = 0, $hParent = 0)
Local $sTypeOfRemote = 'wstr'
If Not StringStripWS($sRemote, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfRemote = 'ptr'
$sRemote = 0
EndIf
DllCall('shell32.dll', 'long', 'SHStartNetConnectionDialogW', 'hwnd', $hParent, $sTypeOfRemote, $sRemote, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ShellUserAuthenticationDlg($sCaption, $sMessage, $sUser, $sPassword, $sTarget, $iFlags = 0, $iError = 0, $bSave = False, $hBitmap = 0, $hParent = 0)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $tInfo = DllStructCreate('dword;hwnd;ptr;ptr;ptr;wchar[' & (StringLen($sMessage) + 1) & '];wchar[' & (StringLen($sCaption) + 1) & ']')
DllStructSetData($tInfo, 1, DllStructGetPtr($tInfo, 6) - DllStructGetPtr($tInfo))
DllStructSetData($tInfo, 2, $hParent)
DllStructSetData($tInfo, 3, DllStructGetPtr($tInfo, 6))
DllStructSetData($tInfo, 4, DllStructGetPtr($tInfo, 7))
DllStructSetData($tInfo, 5, $hBitmap)
DllStructSetData($tInfo, 6, $sMessage)
DllStructSetData($tInfo, 7, $sCaption)
Local $aRet = DllCall('credui.dll', 'dword', 'CredUIPromptForCredentialsW', 'struct*', $tInfo, 'wstr', $sTarget, 'ptr', 0,  'dword', $iError, 'wstr', $sUser, 'ulong', 4096, 'wstr', $sPassword, 'ulong', 4096, 'bool*', $bSave,  'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $aResult[3]
$aResult[0] = $aRet[5]
$aResult[1] = $aRet[7]
$aResult[2] = $aRet[9]
Return $aResult
EndFunc
Func _WinAPI_ShellUserAuthenticationDlgEx($sCaption, $sMessage, $sUser, $sPassword, $iFlags = 0, $iAuthError = 0, $bSave = False, $iPackage = 0, $hParent = 0)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $tBLOB = 0, $aRet
If StringLen($sUser) Then
$aRet = DllCall('credui.dll', 'bool', 'CredPackAuthenticationBufferW', 'dword', 1, 'wstr', $sUser, 'wstr', $sPassword,  'ptr', 0, 'dword*', 0)
If @error Or Not $aRet[5] Then Return SetError(@error + 10, @extended, 0)
$tBLOB = DllStructCreate('byte[' & $aRet[5] & ']')
$aRet = DllCall('credui.dll', 'bool', 'CredPackAuthenticationBufferW', 'dword', 1, 'wstr', $sUser, 'wstr', $sPassword,  'struct*', $tBLOB, 'dword*', $aRet[5])
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
EndIf
Local $tInfo = DllStructCreate('dword;hwnd;ptr;ptr;ptr;wchar[' & (StringLen($sMessage) + 1) & '];wchar[' & (StringLen($sCaption) + 1) & ']')
DllStructSetData($tInfo, 1, DllStructGetPtr($tInfo, 6) - DllStructGetPtr($tInfo))
DllStructSetData($tInfo, 2, $hParent)
DllStructSetData($tInfo, 3, DllStructGetPtr($tInfo, 6))
DllStructSetData($tInfo, 4, DllStructGetPtr($tInfo, 7))
DllStructSetData($tInfo, 5, 0)
DllStructSetData($tInfo, 6, $sMessage)
DllStructSetData($tInfo, 7, $sCaption)
$aRet = DllCall('credui.dll', 'dword', 'CredUIPromptForWindowsCredentialsW', 'struct*', $tInfo, 'dword', $iAuthError,  'ulong*', $iPackage, 'struct*', $tBLOB, 'ulong', DllStructGetSize($tBLOB), 'ptr*', 0, 'ulong*', 0,  'bool*', $bSave, 'dword', $iFlags)
If @error Then Return SetError(@error + 30, @extended, 0)
If $aRet[0] Then Return SetError(30, $aRet[0], 0)
Local $aResult[4], $iError = 0
$aResult[2] = $aRet[8]
$aResult[3] = $aRet[3]
Local $pBLOB = $aRet[6]
Local $iSize = $aRet[7]
$aRet = DllCall('credui.dll', 'bool', 'CredUnPackAuthenticationBufferW', 'dword', 1, 'ptr', $pBLOB, 'dword', $iSize,  'wstr', '', 'dword*', 4096, 'wstr', '', 'dword*', 4096, 'wstr', '', 'dword*', 4096)
If Not @error And $aRet[0] Then
$aResult[0] = $aRet[4]
$aResult[1] = $aRet[8]
Else
$iError = @error + 40
EndIf
If Not _WinAPI_ZeroMemory($pBLOB, $iSize) Then
EndIf
_WinAPI_CoTaskMemFree($pBLOB)
If $iError Then Return SetError($iError, 0, 0)
Return $aResult
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __OFNDlg($iDlg, $sTitle, $sInitDir, $sFilters, $iDefFilter, $sDefFile, $sDefExt, $iFlags, $iFlagsEx, $pOFNProc, $pData, $hParent)
Local $tBuffer = DllStructCreate('wchar[32768]')
Local $tFilters = 0, $tDefExt = 0, $tInitDir = 0, $tTitle = 0
Local $tOFN = DllStructCreate($tagOPENFILENAME)
DllStructSetData($tOFN, "StructSize", DllStructGetSize($tOFN))
DllStructSetData($tOFN, "hwndOwner", $hParent)
DllStructSetData($tOFN, 3, 0)
Local $aData = StringSplit($sFilters, '|')
Local $aFilters[$aData[0] * 2]
Local $iCount = 0
For $i = 1 To $aData[0]
$aFilters[$iCount + 0] = StringStripWS($aData[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)
$aFilters[$iCount + 1] = StringStripWS(StringRegExpReplace($aData[$i], '.*\((.*)\)', '\1'), $STR_STRIPALL)
If $aFilters[$iCount + 1] Then
$iCount += 2
EndIf
Next
If $iCount Then
$tFilters = _WinAPI_ArrayToStruct($aFilters, 0, $iCount - 1)
If @error Then
EndIf
EndIf
DllStructSetData($tOFN, "lpstrFilter", DllStructGetPtr($tFilters))
DllStructSetData($tOFN, 5, 0)
DllStructSetData($tOFN, 6, 0)
DllStructSetData($tOFN, "nFilterIndex", $iDefFilter)
$sDefFile = StringStripWS($sDefFile, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sDefFile Then
DllStructSetData($tBuffer, 1, $sDefFile)
EndIf
DllStructSetData($tOFN, "lpstrFile", DllStructGetPtr($tBuffer))
DllStructSetData($tOFN, "nMaxFile", 32768)
DllStructSetData($tOFN, 10, 0)
DllStructSetData($tOFN, 11, 0)
$sInitDir = StringStripWS($sInitDir, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sInitDir Then
$tInitDir = DllStructCreate('wchar[' & (StringLen($sInitDir) + 1) & ']')
EndIf
DllStructSetData($tInitDir, 1, $sInitDir)
DllStructSetData($tOFN, "lpstrInitialDir", DllStructGetPtr($tInitDir))
$sTitle = StringStripWS($sTitle, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sTitle Then
$tTitle = DllStructCreate('wchar[' & (StringLen($sTitle) + 1) & ']')
EndIf
DllStructSetData($tTitle, 1, $sTitle)
DllStructSetData($tOFN, "lpstrTitle", DllStructGetPtr($tTitle))
DllStructSetData($tOFN, "Flags", $iFlags)
DllStructSetData($tOFN, 15, 0)
DllStructSetData($tOFN, 16, 0)
$sDefExt = StringStripWS($sDefExt, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If $sDefExt Then
$tDefExt = DllStructCreate('wchar[' & (StringLen($tDefExt) + 1) & ']')
EndIf
DllStructSetData($tDefExt, 1, StringReplace($sDefExt, '.', ''))
DllStructSetData($tOFN, "lpstrDefExt", DllStructGetPtr($tDefExt))
DllStructSetData($tOFN, "lCustData", $pData)
DllStructSetData($tOFN, "lpfnHook", $pOFNProc)
DllStructSetData($tOFN, 20, 0)
DllStructSetData($tOFN, 21, 0)
DllStructSetData($tOFN, 22, 0)
DllStructSetData($tOFN, "FlagsEx", $iFlagsEx)
Local $aRet
Switch $iDlg
Case 0
$aRet = DllCall('comdlg32.dll', 'bool', 'GetOpenFileNameW', 'struct*', $tOFN)
Case 1
$aRet = DllCall('comdlg32.dll', 'bool', 'GetSaveFileNameW', 'struct*', $tOFN)
Case Else
EndSwitch
If @error Then Return SetError(@error, @extended, '')
If Not $aRet[0] Then Return SetError(10, _WinAPI_CommDlgExtendedErrorEx(), '')
If BitAND($iFlags, $OFN_ALLOWMULTISELECT) Then
If BitAND($iFlags, $OFN_EXPLORER) Then
$aData = _WinAPI_StructToArray($tBuffer)
If @error Then
Return SetError(11, 0, '')
EndIf
Else
$aData = StringSplit(DllStructGetData($tBuffer, 1), ' ')
EndIf
Switch $aData[0]
Case 0
Return SetError(12, 0, '')
Case 1
Case Else
Local $sPath = $aData[1]
For $i = 2 To $aData[0]
$aData[$i - 1] = _WinAPI_PathAppend($sPath, $aData[$i])
Next
ReDim $aData[$aData[0]]
$aData[0] -= 1
EndSwitch
Else
$aData = DllStructGetData($tBuffer, 1)
EndIf
$__g_vExt = $tOFN
Return $aData
EndFunc
Func __WinAPI_ParseMultiSelectFileDialogPath($aPath)
Local $aFiles[UBound($aPath) + 1]
$aFiles[0] = UBound($aPath)
$aFiles[1] = StringMid($aPath[1], 1, StringInStr($aPath[1], "\", $STR_NOCASESENSEBASIC, -1) - 1)
For $i = 1 To UBound($aPath) - 1
$aFiles[$i + 1] = StringMid($aPath[$i], StringInStr($aPath[$i], "\", $STR_NOCASESENSEBASIC, -1) + 1)
Next
Return $aFiles
EndFunc
Func __WinAPI_ParseFileDialogPath($sPath)
Local $aFiles[3]
$aFiles[0] = 2
$aFiles[1] = StringMid($sPath, 1, StringInStr($sPath, "\", $STR_NOCASESENSEBASIC, -1) - 1)
$aFiles[2] = StringMid($sPath, StringInStr($sPath, "\", $STR_NOCASESENSEBASIC, -1) + 1)
Return $aFiles
EndFunc
#EndRegion Internal Functions
Global Const $BACKUP_ALTERNATE_DATA = 0x00000004
Global Const $BACKUP_DATA = 0x00000001
Global Const $BACKUP_EA_DATA = 0x00000002
Global Const $BACKUP_LINK = 0x00000005
Global Const $BACKUP_OBJECT_ID = 0x00000007
Global Const $BACKUP_PROPERTY_DATA = 0x00000006
Global Const $BACKUP_REPARSE_DATA = 0x00000008
Global Const $BACKUP_SECURITY_DATA = 0x00000003
Global Const $BACKUP_SPARSE_BLOCK = 0x00000009
Global Const $BACKUP_TXFS_DATA = 0x0000000A
Global Const $COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 0x0008
Global Const $COPY_FILE_COPY_SYMLINK = 0x0800
Global Const $COPY_FILE_FAIL_IF_EXISTS = 0x0001
Global Const $COPY_FILE_NO_BUFFERING = 0x1000
Global Const $COPY_FILE_OPEN_SOURCE_FOR_WRITE = 0x0004
Global Const $COPY_FILE_RESTARTABLE = 0x0002
Global Const $MOVE_FILE_COPY_ALLOWED = 0x0002
Global Const $MOVE_FILE_CREATE_HARDLINK = 0x0010
Global Const $MOVE_FILE_DELAY_UNTIL_REBOOT = 0x0004
Global Const $MOVE_FILE_FAIL_IF_NOT_TRACKABLE = 0x0020
Global Const $MOVE_FILE_REPLACE_EXISTING = 0x0001
Global Const $MOVE_FILE_WRITE_THROUGH = 0x0008
Global Const $PROGRESS_CONTINUE = 0
Global Const $PROGRESS_CANCEL = 1
Global Const $PROGRESS_STOP = 2
Global Const $PROGRESS_QUIET = 3
Global Const $FILE_APPEND_DATA = 0x0004
Global Const $FILE_DELETE_CHILD = 0x0040
Global Const $FILE_EXECUTE = 0x0020
Global Const $FILE_READ_ATTRIBUTES = 0x0080
Global Const $FILE_READ_DATA = 0x0001
Global Const $FILE_READ_EA = 0x0008
Global Const $FILE_WRITE_ATTRIBUTES = 0x0100
Global Const $FILE_WRITE_DATA = 0x0002
Global Const $FILE_WRITE_EA = 0x0010
Global Const $FILE_ADD_FILE = $FILE_WRITE_DATA
Global Const $FILE_ADD_SUBDIRECTORY = $FILE_APPEND_DATA
Global Const $FILE_CREATE_PIPE_INSTANCE = $FILE_APPEND_DATA
Global Const $FILE_LIST_DIRECTORY = $FILE_READ_DATA
Global Const $FILE_TRAVERSE = $FILE_EXECUTE
Global Const $FILE_ALL_ACCESS = 0x001F01FF
Global Const $FILE_FLAG_BACKUP_SEMANTICS = 0x02000000
Global Const $FILE_FLAG_DELETE_ON_CLOSE = 0x04000000
Global Const $FILE_FLAG_NO_BUFFERING = 0x20000000
Global Const $FILE_FLAG_OPEN_NO_RECALL = 0x00100000
Global Const $FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000
Global Const $FILE_FLAG_OVERLAPPED = 0x40000000
Global Const $FILE_FLAG_POSIX_SEMANTICS = 0x0100000
Global Const $FILE_FLAG_RANDOM_ACCESS = 0x10000000
Global Const $FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000
Global Const $FILE_FLAG_WRITE_THROUGH = 0x80000000
Global Const $SECURITY_ANONYMOUS = 0x00000000
Global Const $SECURITY_CONTEXT_TRACKING = 0x00040000
Global Const $SECURITY_DELEGATION = 0x00030000
Global Const $SECURITY_EFFECTIVE_ONLY = 0x00080000
Global Const $SECURITY_IDENTIFICATION = 0x00010000
Global Const $SECURITY_IMPERSONATION = 0x00020000
Global Const $SEC_COMMIT = 0x08000000
Global Const $SEC_IMAGE = 0x01000000
Global Const $SEC_LARGE_PAGES = 0x80000000
Global Const $SEC_NOCACHE = 0x10000000
Global Const $SEC_RESERVE = 0x04000000
Global Const $SEC_WRITECOMBINE = 0x40000000
Global Const $SECTION_EXTEND_SIZE = 0x0010
Global Const $SECTION_MAP_EXECUTE = 0x0008
Global Const $SECTION_MAP_READ = 0x0004
Global Const $SECTION_MAP_WRITE = 0x0002
Global Const $SECTION_QUERY = 0x0001
Global Const $SECTION_ALL_ACCESS = 0x001F001F
Global Const $FILE_MAP_COPY = 0x0001
Global Const $FILE_MAP_EXECUTE = 0x0020
Global Const $FILE_MAP_READ = 0x0004
Global Const $FILE_MAP_WRITE = 0x0002
Global Const $FILE_MAP_ALL_ACCESS = $SECTION_ALL_ACCESS
Global Const $DDD_EXACT_MATCH_ON_REMOVE = 0x04
Global Const $DDD_NO_BROADCAST_SYSTEM = 0x08
Global Const $DDD_RAW_TARGET_PATH = 0x01
Global Const $DDD_REMOVE_DEFINITION = 0x02
Global Const $FSCTL_ALLOW_EXTENDED_DASD_IO = 0x00090083
Global Const $FSCTL_CREATE_OR_GET_OBJECT_ID = 0x000900C0
Global Const $FSCTL_CREATE_USN_JOURNAL = 0x000900E7
Global Const $FSCTL_DELETE_OBJECT_ID = 0x000900A0
Global Const $FSCTL_DELETE_REPARSE_POINT = 0x000900AC
Global Const $FSCTL_DELETE_USN_JOURNAL = 0x000900F8
Global Const $FSCTL_DISMOUNT_VOLUME = 0x00090020
Global Const $FSCTL_DUMP_PROPERTY_DATA = 0x00090097
Global Const $FSCTL_ENABLE_UPGRADE = 0x000980D0
Global Const $FSCTL_ENCRYPTION_FSCTL_IO = 0x000900DB
Global Const $FSCTL_ENUM_USN_DATA = 0x000900B3
Global Const $FSCTL_EXTEND_VOLUME = 0x000900F0
Global Const $FSCTL_FILESYSTEM_GET_STATISTICS = 0x00090060
Global Const $FSCTL_FIND_FILES_BY_SID = 0x0009008F
Global Const $FSCTL_GET_COMPRESSION = 0x0009003C
Global Const $FSCTL_GET_NTFS_FILE_RECORD = 0x00090068
Global Const $FSCTL_GET_NTFS_VOLUME_DATA = 0x00090064
Global Const $FSCTL_GET_OBJECT_ID = 0x0009009C
Global Const $FSCTL_GET_REPARSE_POINT = 0x000900A8
Global Const $FSCTL_GET_RETRIEVAL_POINTERS = 0x00090073
Global Const $FSCTL_GET_VOLUME_BITMAP = 0x0009006F
Global Const $FSCTL_HSM_DATA = 0x0009C113
Global Const $FSCTL_HSM_MSG = 0x0009C108
Global Const $FSCTL_INVALIDATE_VOLUMES = 0x00090054
Global Const $FSCTL_IS_PATHNAME_VALID = 0x0009002C
Global Const $FSCTL_IS_VOLUME_DIRTY = 0x00090078
Global Const $FSCTL_IS_VOLUME_MOUNTED = 0x00090028
Global Const $FSCTL_LOCK_VOLUME = 0x00090018
Global Const $FSCTL_MARK_AS_SYSTEM_HIVE = 0x0009004F
Global Const $FSCTL_MARK_HANDLE = 0x000900FC
Global Const $FSCTL_MARK_VOLUME_DIRTY = 0x00090030
Global Const $FSCTL_MOVE_FILE = 0x00090074
Global Const $FSCTL_OPBATCH_ACK_CLOSE_PENDING = 0x00090010
Global Const $FSCTL_OPLOCK_BREAK_ACK_NO_2 = 0x00090050
Global Const $FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = 0x0009000C
Global Const $FSCTL_OPLOCK_BREAK_NOTIFY = 0x00090014
Global Const $FSCTL_QUERY_ALLOCATED_RANGES = 0x000940CF
Global Const $FSCTL_QUERY_FAT_BPB = 0x00090058
Global Const $FSCTL_QUERY_RETRIEVAL_POINTERS = 0x0009003B
Global Const $FSCTL_QUERY_USN_JOURNAL = 0x000900F4
Global Const $FSCTL_READ_FILE_USN_DATA = 0x000900EB
Global Const $FSCTL_READ_PROPERTY_DATA = 0x00090087
Global Const $FSCTL_READ_RAW_ENCRYPTED = 0x000900E3
Global Const $FSCTL_READ_USN_JOURNAL = 0x000900BB
Global Const $FSCTL_RECALL_FILE = 0x00090117
Global Const $FSCTL_REQUEST_BATCH_OPLOCK = 0x00090008
Global Const $FSCTL_REQUEST_FILTER_OPLOCK = 0x0009005C
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_1 = 0x00090000
Global Const $FSCTL_REQUEST_OPLOCK_LEVEL_2 = 0x00090004
Global Const $FSCTL_SECURITY_ID_CHECK = 0x000940B7
Global Const $FSCTL_SET_COMPRESSION = 0x0009C040
Global Const $FSCTL_SET_ENCRYPTION = 0x000900D7
Global Const $FSCTL_SET_OBJECT_ID = 0x00090098
Global Const $FSCTL_SET_OBJECT_ID_EXTENDED = 0x000900BC
Global Const $FSCTL_SET_REPARSE_POINT = 0x000900A4
Global Const $FSCTL_SET_SPARSE = 0x000900C4
Global Const $FSCTL_SET_ZERO_DATA = 0x000980C8
Global Const $FSCTL_SIS_COPYFILE = 0x00090100
Global Const $FSCTL_SIS_LINK_FILES = 0x0009C104
Global Const $FSCTL_UNLOCK_VOLUME = 0x0009001C
Global Const $FSCTL_WRITE_PROPERTY_DATA = 0x0009008B
Global Const $FSCTL_WRITE_RAW_ENCRYPTED = 0x000900DF
Global Const $FSCTL_WRITE_USN_CLOSE_RECORD = 0x000900EF
Global Const $IOCTL_AACS_END_SESSION = 0x003350CC
Global Const $IOCTL_AACS_GENERATE_BINDING_NONCE = 0x0033D0F0
Global Const $IOCTL_AACS_GET_CERTIFICATE = 0x003350D4
Global Const $IOCTL_AACS_GET_CHALLENGE_KEY = 0x003350D8
Global Const $IOCTL_AACS_READ_BINDING_NONCE = 0x003350EC
Global Const $IOCTL_AACS_READ_MEDIA_ID = 0x003350E8
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK = 0x003350C4
Global Const $IOCTL_AACS_READ_MEDIA_KEY_BLOCK_SIZE = 0x003350C0
Global Const $IOCTL_AACS_READ_SERIAL_NUMBER = 0x003350E4
Global Const $IOCTL_AACS_READ_VOLUME_ID = 0x003350E0
Global Const $IOCTL_AACS_SEND_CERTIFICATE = 0x003350D0
Global Const $IOCTL_AACS_SEND_CHALLENGE_KEY = 0x003350DC
Global Const $IOCTL_AACS_START_SESSION = 0x003350C8
Global Const $IOCTL_ATA_PASS_THROUGH = 0x0004D02C
Global Const $IOCTL_ATA_PASS_THROUGH_DIRECT = 0x0004D030
Global Const $IOCTL_CDROM_CHECK_VERIFY = 0x00024800
Global Const $IOCTL_CDROM_DISK_TYPE = 0x00020040
Global Const $IOCTL_CDROM_EJECT_MEDIA = 0x00024808
Global Const $IOCTL_CDROM_FIND_NEW_DEVICES = 0x00024818
Global Const $IOCTL_CDROM_GET_CONFIGURATION = 0x00024058
Global Const $IOCTL_CDROM_GET_CONTROL = 0x00024034
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY = 0x0002404C
Global Const $IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX = 0x00024050
Global Const $IOCTL_CDROM_GET_LAST_SESSION = 0x00024038
Global Const $IOCTL_CDROM_GET_VOLUME = 0x00024014
Global Const $IOCTL_CDROM_LOAD_MEDIA = 0x0002480C
Global Const $IOCTL_CDROM_MEDIA_REMOVAL = 0x00024804
Global Const $IOCTL_CDROM_PAUSE_AUDIO = 0x0002400C
Global Const $IOCTL_CDROM_PLAY_AUDIO_MSF = 0x00024018
Global Const $IOCTL_CDROM_RAW_READ = 0x0002403E
Global Const $IOCTL_CDROM_READ_Q_CHANNEL = 0x0002402C
Global Const $IOCTL_CDROM_READ_TOC = 0x00024000
Global Const $IOCTL_CDROM_READ_TOC_EX = 0x00024054
Global Const $IOCTL_CDROM_RELEASE = 0x00024814
Global Const $IOCTL_CDROM_RESERVE = 0x00024810
Global Const $IOCTL_CDROM_RESUME_AUDIO = 0x00024010
Global Const $IOCTL_CDROM_SEEK_AUDIO_MSF = 0x00024004
Global Const $IOCTL_CDROM_SET_VOLUME = 0x00024028
Global Const $IOCTL_CDROM_STOP_AUDIO = 0x00024008
Global Const $IOCTL_CDROM_UNLOAD_DRIVER = 0x00025008
Global Const $IOCTL_DISK_CHECK_VERIFY = 0x00074800
Global Const $IOCTL_DISK_CONTROLLER_NUMBER = 0x00070044
Global Const $IOCTL_DISK_CREATE_DISK = 0x0007C058
Global Const $IOCTL_DISK_DELETE_DRIVE_LAYOUT = 0x0007C100
Global Const $IOCTL_DISK_EJECT_MEDIA = 0x00074808
Global Const $IOCTL_DISK_FIND_NEW_DEVICES = 0x00074818
Global Const $IOCTL_DISK_FORMAT_TRACKS = 0x0007C018
Global Const $IOCTL_DISK_FORMAT_TRACKS_EX = 0x0007C02C
Global Const $IOCTL_DISK_GET_CACHE_INFORMATION = 0x000740D4
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY = 0x00070000
Global Const $IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 0x000700A0
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT = 0x0007400C
Global Const $IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 0x00070050
Global Const $IOCTL_DISK_GET_LENGTH_INFO = 0x0007405C
Global Const $IOCTL_DISK_GET_MEDIA_TYPES = 0x00070C00
Global Const $IOCTL_DISK_GET_PARTITION_INFO = 0x00074004
Global Const $IOCTL_DISK_GET_PARTITION_INFO_EX = 0x00070048
Global Const $IOCTL_DISK_GET_WRITE_CACHE_STATE = 0x000740DC
Global Const $IOCTL_DISK_GROW_PARTITION = 0x0007C0D0
Global Const $IOCTL_DISK_HISTOGRAM_DATA = 0x00070034
Global Const $IOCTL_DISK_HISTOGRAM_RESET = 0x00070038
Global Const $IOCTL_DISK_HISTOGRAM_STRUCTURE = 0x00070030
Global Const $IOCTL_DISK_INTERNAL_CLEAR_VERIFY = 0x00070407
Global Const $IOCTL_DISK_INTERNAL_SET_NOTIFY = 0x00070408
Global Const $IOCTL_DISK_INTERNAL_SET_VERIFY = 0x00070403
Global Const $IOCTL_DISK_IS_WRITABLE = 0x00070024
Global Const $IOCTL_DISK_LOAD_MEDIA = 0x0007480C
Global Const $IOCTL_DISK_LOGGING = 0x00070028
Global Const $IOCTL_DISK_MEDIA_REMOVAL = 0x00074804
Global Const $IOCTL_DISK_PERFORMANCE = 0x00070020
Global Const $IOCTL_DISK_PERFORMANCE_OFF = 0x00070060
Global Const $IOCTL_DISK_REASSIGN_BLOCKS = 0x0007C01C
Global Const $IOCTL_DISK_RELEASE = 0x00074814
Global Const $IOCTL_DISK_REQUEST_DATA = 0x00070040
Global Const $IOCTL_DISK_REQUEST_STRUCTURE = 0x0007003C
Global Const $IOCTL_DISK_RESERVE = 0x00074810
Global Const $IOCTL_DISK_SET_CACHE_INFORMATION = 0x0007C0D8
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT = 0x0007C010
Global Const $IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 0x0007C054
Global Const $IOCTL_DISK_SET_PARTITION_INFO = 0x0007C008
Global Const $IOCTL_DISK_SET_PARTITION_INFO_EX = 0x0007C04C
Global Const $IOCTL_DISK_UPDATE_DRIVE_SIZE = 0x0007C0C8
Global Const $IOCTL_DISK_UPDATE_PROPERTIES = 0x00070140
Global Const $IOCTL_DISK_VERIFY = 0x00070014
Global Const $IOCTL_DVD_END_SESSION = 0x0033500C
Global Const $IOCTL_DVD_GET_REGION = 0x00335014
Global Const $IOCTL_DVD_READ_KEY = 0x00335004
Global Const $IOCTL_DVD_READ_STRUCTURE = 0x00335140
Global Const $IOCTL_DVD_SEND_KEY = 0x00335008
Global Const $IOCTL_DVD_SEND_KEY2 = 0x0033D018
Global Const $IOCTL_DVD_SET_READ_AHEAD = 0x00335010
Global Const $IOCTL_DVD_START_SESSION = 0x00335000
Global Const $IOCTL_MOUNTDEV_LINK_CREATED = 0x004D0010
Global Const $IOCTL_MOUNTDEV_LINK_DELETED = 0x004D0014
Global Const $IOCTL_MOUNTDEV_QUERY_STABLE_GUID = 0x004D0018
Global Const $IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME = 0x004D000C
Global Const $IOCTL_MOUNTDEV_QUERY_UNIQUE_ID = 0x004D0000
Global Const $IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY = 0x004D0004
Global Const $IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS = 0x006DC014
Global Const $IOCTL_MOUNTMGR_CHANGE_NOTIFY = 0x006D4020
Global Const $IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES = 0x006D4028
Global Const $IOCTL_MOUNTMGR_CREATE_POINT = 0x006DC000
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS = 0x006DC004
Global Const $IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY = 0x006DC00C
Global Const $IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE = 0x006DC024
Global Const $IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER = 0x006DC010
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH = 0x006D0030
Global Const $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS = 0x006D0034
Global Const $IOCTL_MOUNTMGR_QUERY_POINTS = 0x006D0008
Global Const $IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION = 0x006D402C
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED = 0x006DC018
Global Const $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED = 0x006DC01C
Global Const $IOCTL_SCSI_GET_INQUIRY_DATA = 0x0004100C
Global Const $IOCTL_SCSI_GET_CAPABILITIES = 0x00041010
Global Const $IOCTL_SCSI_GET_ADDRESS = 0x00041018
Global Const $IOCTL_SCSI_MINIPORT = 0x0004D008
Global Const $IOCTL_SCSI_PASS_THROUGH = 0x0004D004
Global Const $IOCTL_SCSI_PASS_THROUGH_DIRECT = 0x0004D014
Global Const $IOCTL_SCSI_RESCAN_BUS = 0x0004101C
Global Const $IOCTL_STORAGE_BREAK_RESERVATION = 0x002D5014
Global Const $IOCTL_STORAGE_CHECK_VERIFY = 0x002D4800
Global Const $IOCTL_STORAGE_CHECK_VERIFY2 = 0x002D0800
Global Const $IOCTL_STORAGE_EJECT_MEDIA = 0x002D4808
Global Const $IOCTL_STORAGE_EJECTION_CONTROL = 0x002D0940
Global Const $IOCTL_STORAGE_FIND_NEW_DEVICES = 0x002D4818
Global Const $IOCTL_STORAGE_GET_DEVICE_NUMBER = 0x002D1080
Global Const $IOCTL_STORAGE_GET_HOTPLUG_INFO = 0x002D0C14
Global Const $IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = 0x002D0C10
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES = 0x002D0C00
Global Const $IOCTL_STORAGE_GET_MEDIA_TYPES_EX = 0x002D0C04
Global Const $IOCTL_STORAGE_LOAD_MEDIA = 0x002D480C
Global Const $IOCTL_STORAGE_LOAD_MEDIA2 = 0x002D080C
Global Const $IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = 0x002D9404
Global Const $IOCTL_STORAGE_MCN_CONTROL = 0x002D0944
Global Const $IOCTL_STORAGE_MEDIA_REMOVAL = 0x002D4804
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_IN = 0x002D5018
Global Const $IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = 0x002D501C
Global Const $IOCTL_STORAGE_PREDICT_FAILURE = 0x002D1100
Global Const $IOCTL_STORAGE_QUERY_PROPERTY = 0x002D1400
Global Const $IOCTL_STORAGE_RELEASE = 0x002D4814
Global Const $IOCTL_STORAGE_RESERVE = 0x002D4810
Global Const $IOCTL_STORAGE_RESET_BUS = 0x002D5000
Global Const $IOCTL_STORAGE_RESET_DEVICE = 0x002D5004
Global Const $IOCTL_STORAGE_SET_HOTPLUG_INFO = 0x002DCC18
Global Const $IOCTL_STORAGE_SET_READ_AHEAD = 0x002D4400
Global Const $IOCTL_VOLUME_GET_GPT_ATTRIBUTES = 0x00560038
Global Const $IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 0x00560000
Global Const $IOCTL_VOLUME_IS_CLUSTERED = 0x00560030
Global Const $IOCTL_VOLUME_IS_IO_CAPABLE = 0x00560014
Global Const $IOCTL_VOLUME_IS_OFFLINE = 0x00560010
Global Const $IOCTL_VOLUME_IS_PARTITION = 0x00560028
Global Const $IOCTL_VOLUME_LOGICAL_TO_PHYSICAL = 0x00560020
Global Const $IOCTL_VOLUME_OFFLINE = 0x0056C00C
Global Const $IOCTL_VOLUME_ONLINE = 0x0056C008
Global Const $IOCTL_VOLUME_PHYSICAL_TO_LOGICAL = 0x00560024
Global Const $IOCTL_VOLUME_QUERY_FAILOVER_SET = 0x00560018
Global Const $IOCTL_VOLUME_QUERY_VOLUME_NUMBER = 0x0056001C
Global Const $IOCTL_VOLUME_READ_PLEX = 0x0056402E
Global Const $IOCTL_VOLUME_SET_GPT_ATTRIBUTES = 0x00560034
Global Const $IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE = 0x00560004
Global Const $SMART_GET_VERSION = 0x00074080
Global Const $SMART_RCV_DRIVE_DATA = 0x0007C088
Global Const $SMART_SEND_DRIVE_COMMAND = 0x0007C084
Global Const $FILE_ENCRYPTABLE = 0
Global Const $FILE_IS_ENCRYPTED = 1
Global Const $FILE_READ_ONLY = 8
Global Const $FILE_ROOT_DIR = 3
Global Const $FILE_SYSTEM_ATTR = 2
Global Const $FILE_SYSTEM_DIR = 4
Global Const $FILE_SYSTEM_NOT_SUPPORT = 6
Global Const $FILE_UNKNOWN = 5
Global Const $FILE_USER_DISALLOWED = 7
Global Const $SCS_32BIT_BINARY = 0
Global Const $SCS_64BIT_BINARY = 6
Global Const $SCS_DOS_BINARY = 1
Global Const $SCS_OS216_BINARY = 5
Global Const $SCS_PIF_BINARY = 3
Global Const $SCS_POSIX_BINARY = 4
Global Const $SCS_WOW_BINARY = 2
Global Const $DRIVE_BUS_TYPE_UNKNOWN = 0x00
Global Const $DRIVE_BUS_TYPE_SCSI = 0x01
Global Const $DRIVE_BUS_TYPE_ATAPI = 0x02
Global Const $DRIVE_BUS_TYPE_ATA = 0x03
Global Const $DRIVE_BUS_TYPE_1394 = 0x04
Global Const $DRIVE_BUS_TYPE_SSA = 0x05
Global Const $DRIVE_BUS_TYPE_FIBRE = 0x06
Global Const $DRIVE_BUS_TYPE_USB = 0x07
Global Const $DRIVE_BUS_TYPE_RAID = 0x08
Global Const $DRIVE_BUS_TYPE_ISCSI = 0x09
Global Const $DRIVE_BUS_TYPE_SAS = 0x0A
Global Const $DRIVE_BUS_TYPE_SATA = 0x0B
Global Const $DRIVE_BUS_TYPE_SD = 0x0C
Global Const $DRIVE_BUS_TYPE_MMC = 0x0D
Global Const $DRIVE_UNKNOWN = 0
Global Const $DRIVE_NO_ROOT_DIR = 1
Global Const $DRIVE_REMOVABLE = 2
Global Const $DRIVE_FIXED = 3
Global Const $DRIVE_REMOTE = 4
Global Const $DRIVE_CDROM = 5
Global Const $DRIVE_RAMDISK = 6
Global Const $FILE_TYPE_CHAR = 0x0002
Global Const $FILE_TYPE_DISK = 0x0001
Global Const $FILE_TYPE_PIPE = 0x0003
Global Const $FILE_TYPE_REMOTE = 0x8000
Global Const $FILE_TYPE_UNKNOWN = 0x0000
Global Const $FILE_NAME_NORMALIZED = 0x0
Global Const $FILE_NAME_OPENED = 0x8
Global Const $VOLUME_NAME_DOS = 0x0
Global Const $VOLUME_NAME_GUID = 0x1
Global Const $VOLUME_NAME_NONE = 0x4
Global Const $VOLUME_NAME_NT = 0x2
Global Const $IMAGE_FILE_MACHINE_UNKNOWN = 0x0000
Global Const $IMAGE_FILE_MACHINE_AM33 = 0x01D3
Global Const $IMAGE_FILE_MACHINE_AMD64 = 0x8664
Global Const $IMAGE_FILE_MACHINE_ARM = 0x01C0
Global Const $IMAGE_FILE_MACHINE_EBC = 0x0EBC
Global Const $IMAGE_FILE_MACHINE_I386 = 0x014C
Global Const $IMAGE_FILE_MACHINE_IA64 = 0x0200
Global Const $IMAGE_FILE_MACHINE_M32R = 0x9041
Global Const $IMAGE_FILE_MACHINE_MIPS16 = 0x0266
Global Const $IMAGE_FILE_MACHINE_MIPSFPU = 0x0366
Global Const $IMAGE_FILE_MACHINE_MIPSFPU16 = 0x0466
Global Const $IMAGE_FILE_MACHINE_POWERPC = 0x01F0
Global Const $IMAGE_FILE_MACHINE_POWERPCFP = 0x01F1
Global Const $IMAGE_FILE_MACHINE_R4000 = 0x0166
Global Const $IMAGE_FILE_MACHINE_SH3 = 0x01A2
Global Const $IMAGE_FILE_MACHINE_SH3DSP = 0x01A3
Global Const $IMAGE_FILE_MACHINE_SH4 = 0x01A6
Global Const $IMAGE_FILE_MACHINE_SH5 = 0x01A8
Global Const $IMAGE_FILE_MACHINE_THUMB = 0x01C2
Global Const $IMAGE_FILE_MACHINE_WCEMIPSV2 = 0x0169
Global Const $FILE_CASE_PRESERVED_NAMES = 0x00000002
Global Const $FILE_CASE_SENSITIVE_SEARCH = 0x00000001
Global Const $FILE_FILE_COMPRESSION = 0x00000010
Global Const $FILE_NAMED_STREAMS = 0x00040000
Global Const $FILE_PERSISTENT_ACLS = 0x00000008
Global Const $FILE_READ_ONLY_VOLUME = 0x00080000
Global Const $FILE_SEQUENTIAL_WRITE_ONCE = 0x00100000
Global Const $FILE_SUPPORTS_ENCRYPTION = 0x00020000
Global Const $FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x00800000
Global Const $FILE_SUPPORTS_HARD_LINKS = 0x00400000
Global Const $FILE_SUPPORTS_OBJECT_IDS = 0x00010000
Global Const $FILE_SUPPORTS_OPEN_BY_FILE_ID = 0x01000000
Global Const $FILE_SUPPORTS_REPARSE_POINTS = 0x00000080
Global Const $FILE_SUPPORTS_SPARSE_FILES = 0x00000040
Global Const $FILE_SUPPORTS_TRANSACTIONS = 0x00200000
Global Const $FILE_SUPPORTS_USN_JOURNAL = 0x02000000
Global Const $FILE_UNICODE_ON_DISK = 0x00000004
Global Const $FILE_VOLUME_IS_COMPRESSED = 0x00008000
Global Const $FILE_VOLUME_QUOTAS = 0x00000020
Global Const $FILE_DEVICE_8042_PORT = 0x0027
Global Const $FILE_DEVICE_ACPI = 0x0032
Global Const $FILE_DEVICE_BATTERY = 0x0029
Global Const $FILE_DEVICE_BEEP = 0x0001
Global Const $FILE_DEVICE_BUS_EXTENDER = 0x002A
Global Const $FILE_DEVICE_CD_ROM = 0x0002
Global Const $FILE_DEVICE_CD_ROM_FILE_SYSTEM = 0x0003
Global Const $FILE_DEVICE_CHANGER = 0x0030
Global Const $FILE_DEVICE_CONTROLLER = 0x0004
Global Const $FILE_DEVICE_DATALINK = 0x0005
Global Const $FILE_DEVICE_DFS = 0x0006
Global Const $FILE_DEVICE_DFS_FILE_SYSTEM = 0x0035
Global Const $FILE_DEVICE_DFS_VOLUME = 0x0036
Global Const $FILE_DEVICE_DISK = 0x0007
Global Const $FILE_DEVICE_DISK_FILE_SYSTEM = 0x0008
Global Const $FILE_DEVICE_DVD = 0x0033
Global Const $FILE_DEVICE_FILE_SYSTEM = 0x0009
Global Const $FILE_DEVICE_FIPS = 0x003A
Global Const $FILE_DEVICE_FULLSCREEN_VIDEO = 0x0034
Global Const $FILE_DEVICE_INPORT_PORT = 0x000A
Global Const $FILE_DEVICE_KEYBOARD = 0x000B
Global Const $FILE_DEVICE_KS = 0x002F
Global Const $FILE_DEVICE_KSEC = 0x0039
Global Const $FILE_DEVICE_MAILSLOT = 0x000C
Global Const $FILE_DEVICE_MASS_STORAGE = 0x002D
Global Const $FILE_DEVICE_MIDI_IN = 0x000D
Global Const $FILE_DEVICE_MIDI_OUT = 0x000E
Global Const $FILE_DEVICE_MODEM = 0x002B
Global Const $FILE_DEVICE_MOUSE = 0x000F
Global Const $FILE_DEVICE_MULTI_UNC_PROVIDER = 0x0010
Global Const $FILE_DEVICE_NAMED_PIPE = 0x0011
Global Const $FILE_DEVICE_NETWORK = 0x0012
Global Const $FILE_DEVICE_NETWORK_BROWSER = 0x0013
Global Const $FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x0014
Global Const $FILE_DEVICE_NETWORK_REDIRECTOR = 0x0028
Global Const $FILE_DEVICE_NULL = 0x0015
Global Const $FILE_DEVICE_PARALLEL_PORT = 0x0016
Global Const $FILE_DEVICE_PHYSICAL_NETCARD = 0x0017
Global Const $FILE_DEVICE_PRINTER = 0x0018
Global Const $FILE_DEVICE_SCANNER = 0x0019
Global Const $FILE_DEVICE_SCREEN = 0x001C
Global Const $FILE_DEVICE_SERENUM = 0x0037
Global Const $FILE_DEVICE_SERIAL_MOUSE_PORT = 0x001A
Global Const $FILE_DEVICE_SERIAL_PORT = 0x001B
Global Const $FILE_DEVICE_SMARTCARD = 0x0031
Global Const $FILE_DEVICE_SMB = 0x002E
Global Const $FILE_DEVICE_SOUND = 0x001D
Global Const $FILE_DEVICE_STREAMS = 0x001E
Global Const $FILE_DEVICE_TAPE = 0x001F
Global Const $FILE_DEVICE_TAPE_FILE_SYSTEM = 0x0020
Global Const $FILE_DEVICE_TERMSRV = 0x0038
Global Const $FILE_DEVICE_TRANSPORT = 0x0021
Global Const $FILE_DEVICE_UNKNOWN = 0x0022
Global Const $FILE_DEVICE_VDM = 0x002C
Global Const $FILE_DEVICE_VIDEO = 0x0023
Global Const $FILE_DEVICE_VIRTUAL_DISK = 0x0024
Global Const $FILE_DEVICE_WAVE_IN = 0x0025
Global Const $FILE_DEVICE_WAVE_OUT = 0x0026
Global Const $FILE_ANY_ACCESS = 0x00
Global Const $FILE_SPECIAL_ACCESS = $FILE_ANY_ACCESS
Global Const $FILE_READ_ACCESS = 0x01
Global Const $FILE_WRITE_ACCESS = 0x02
Global Const $METHOD_BUFFERED = 0
Global Const $METHOD_IN_DIRECT = 1
Global Const $METHOD_OUT_DIRECT = 2
Global Const $METHOD_NEITHER = 3
Global Const $FILE_NOTIFY_CHANGE_FILE_NAME = 0x0001
Global Const $FILE_NOTIFY_CHANGE_DIR_NAME = 0x0002
Global Const $FILE_NOTIFY_CHANGE_ATTRIBUTES = 0x0004
Global Const $FILE_NOTIFY_CHANGE_SIZE = 0x0008
Global Const $FILE_NOTIFY_CHANGE_LAST_WRITE = 0x0010
Global Const $FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x0020
Global Const $FILE_NOTIFY_CHANGE_CREATION = 0x0040
Global Const $FILE_NOTIFY_CHANGE_SECURITY = 0x0100
Global Const $FILE_ACTION_ADDED = 0x0001
Global Const $FILE_ACTION_REMOVED = 0x0002
Global Const $FILE_ACTION_MODIFIED = 0x0003
Global Const $FILE_ACTION_RENAMED_OLD_NAME = 0x0004
Global Const $FILE_ACTION_RENAMED_NEW_NAME = 0x0005
Global Const $REPLACEFILE_WRITE_THROUGH = 0x01
Global Const $REPLACEFILE_IGNORE_MERGE_ERRORS = 0x02
Global Const $REPLACEFILE_IGNORE_ACL_ERRORS = 0x04
Global Const $BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 0x00000001
Global Const $BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 0x00010000
Global Const $BASE_SEARCH_PATH_PERMANENT = 0x00008000
#Region Global Variables and Constants
Global $__g_iHeapSize = 8388608
Global Const $tagFILEINFO = 'uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes'
Global Const $tagFILE_ID_DESCRIPTOR = 'dword Size;uint Type;' & $tagGUID
Global Const $tagWIN32_FIND_STREAM_DATA = 'int64 StreamSize;wchar StreamName[296]'
Global Const $tagWIN32_STREAM_ID = 'dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;wchar StreamName[1]'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_BackupRead($hFile, $pBuffer, $iLength, ByRef $iBytes, ByRef $pContext, $bSecurity = False)
$iBytes = 0
Local $aRet = DllCall('kernel32.dll', 'bool', 'BackupRead', 'handle', $hFile, 'struct*', $pBuffer, 'dword', $iLength,  'dword*', 0, 'bool', 0, 'bool', $bSecurity, 'ptr*', $pContext)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
$iBytes = $aRet[4]
$pContext = $aRet[7]
Return $aRet[0]
EndFunc
Func _WinAPI_BackupReadAbort(ByRef $pContext)
Local $aRet = DllCall('kernel32.dll', 'bool', 'BackupRead', 'handle', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'bool', 1,  'bool', 0, 'ptr*', $pContext)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
$pContext = $aRet[7]
Return $aRet[0]
EndFunc
Func _WinAPI_BackupSeek($hFile, $iSeek, ByRef $iBytes, ByRef $pContext)
$iBytes = 0
Local $aRet = DllCall('kernel32.dll', 'bool', 'BackupSeek', 'handle', $hFile, 'dword', _WinAPI_LoDWord($iSeek),  'dword', _WinAPI_HiDWord($iSeek), 'dword*', 0, 'dword*', 0, 'ptr*', $pContext)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
$iBytes = __WinAPI_MakeQWord($aRet[4], $aRet[5])
$pContext = $aRet[6]
Return $aRet[0]
EndFunc
Func _WinAPI_BackupWrite($hFile, $pBuffer, $iLength, ByRef $iBytes, ByRef $pContext, $bSecurity = False)
$iBytes = 0
Local $aRet = DllCall('kernel32.dll', 'bool', 'BackupWrite', 'handle', $hFile, 'struct*', $pBuffer, 'dword', $iLength,  'dword*', 0, 'bool', 0, 'bool', $bSecurity, 'ptr*', $pContext)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
$iBytes = $aRet[4]
$pContext = $aRet[7]
Return $aRet[0]
EndFunc
Func _WinAPI_BackupWriteAbort(ByRef $pContext)
Local $aRet = DllCall('kernel32.dll', 'bool', 'BackupWrite', 'handle', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'bool', 1,  'bool', 0, 'ptr*', $pContext)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
$pContext = $aRet[7]
Return $aRet[0]
EndFunc
Func _WinAPI_CopyFileEx($sExistingFile, $sNewFile, $iFlags = 0, $pProgressProc = 0, $pData = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'CopyFileExW', 'wstr', $sExistingFile, 'wstr', $sNewFile,  'ptr', $pProgressProc, 'struct*', $pData, 'bool*', 0, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateDirectory($sDir, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'CreateDirectoryW', 'wstr', $sDir, 'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateDirectoryEx($sNewDir, $sTemplateDir, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'CreateDirectoryExW', 'wstr', $sTemplateDir, 'wstr', $sNewDir, 'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateFileEx($sFilePath, $iCreation, $iAccess = 0, $iShare = 0, $iFlagsAndAttributes = 0, $tSecurity = 0, $hTemplate = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateFileW', 'wstr', $sFilePath, 'dword', $iAccess, 'dword', $iShare,  'struct*', $tSecurity, 'dword', $iCreation, 'dword', $iFlagsAndAttributes, 'handle', $hTemplate)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = Ptr(-1) Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateFileMapping($hFile, $iSize = 0, $sName = '', $iProtect = 0x0004, $tSecurity = 0)
Local $sTypeOfName = 'wstr'
If Not StringStripWS($sName, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfName = 'ptr'
$sName = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateFileMappingW', 'handle', $hFile, 'struct*', $tSecurity,  'dword', $iProtect, 'dword', _WinAPI_HiDWord($iSize), 'dword', _WinAPI_LoDWord($iSize),  $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended(_WinAPI_GetLastError(), $aRet[0])
EndFunc
Func _WinAPI_CreateHardLink($sNewFile, $sExistingFile)
Local $aRet = DllCall('kernel32.dll', 'bool', 'CreateHardLinkW', 'wstr', $sNewFile, 'wstr', $sExistingFile, 'ptr', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateObjectID($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tFOID = DllStructCreate('byte[16];byte[48]')
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x000900C0, 'ptr', 0,  'dword', 0, 'struct*', $tFOID, 'dword', DllStructGetSize($tFOID), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, 0)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_MoveMemory($tGUID, $tFOID, 16)
Return $tGUID
EndFunc
Func _WinAPI_CreateSymbolicLink($sSymlink, $sTarget, $bDirectory = False)
If $bDirectory Then
$bDirectory = 1
EndIf
Local $aRet = DllCall('kernel32.dll', 'boolean', 'CreateSymbolicLinkW', 'wstr', $sSymlink, 'wstr', $sTarget, 'dword', $bDirectory)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DecryptFile($sFilePath)
Local $aRet = DllCall('advapi32.dll', 'bool', 'DecryptFileW', 'wstr', $sFilePath, 'dword', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DefineDosDevice($sDevice, $iFlags, $sFilePath = '')
Local $sTypeOfPath = 'wstr'
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfPath = 'ptr'
$sFilePath = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'DefineDosDeviceW', 'dword', $iFlags, 'wstr', $sDevice, $sTypeOfPath, $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DeleteFile($sFilePath)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeleteFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DeleteObjectID($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_WRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x000900A0, 'ptr', 0,  'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DeleteVolumeMountPoint($sMountedPath)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeleteVolumeMountPointW', 'wstr', $sMountedPath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DeviceIoControl($hDevice, $iControlCode, $pInBuffer = 0, $iInBufferSize = 0, $pOutBuffer = 0, $iOutBufferSize = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hDevice, 'dword', $iControlCode,  'struct*', $pInBuffer, 'dword', $iInBufferSize, 'struct*', $pOutBuffer, 'dword', $iOutBufferSize,  'dword*', 0, 'ptr', 0)
If @error Then Return SetError(@error, @extended, False)
Return SetExtended($aRet[7], $aRet[0])
EndFunc
Func _WinAPI_DuplicateEncryptionInfoFile($sSrcFilePath, $sDestFilePath, $iCreation = 2, $iAttributes = 0, $tSecurity = 0)
Local $aRet = DllCall('advapi32.dll', 'dword', 'DuplicateEncryptionInfoFile', 'wstr', $sSrcFilePath, 'wstr', $sDestFilePath,  'dword', $iCreation, 'dword', $iAttributes, 'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_EjectMedia($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D4808, 'ptr', 0,  'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EncryptFile($sFilePath)
Local $aRet = DllCall('advapi32.dll', 'bool', 'EncryptFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EncryptionDisable($sDir, $bDisable)
Local $aRet = DllCall('advapi32.dll', 'bool', 'EncryptionDisable', 'wstr', $sDir, 'bool', $bDisable)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumFiles($sDir, $iFlag = 0, $sTemplate = '', $bExclude = False)
Local $aRet = 0, $iError = 0
Local $aData[501][7] = [[0]]
Local $hDir = _WinAPI_CreateFileEx($sDir, $OPEN_EXISTING, 0x00000001, $FILE_SHARE_ANY, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $pBuffer = __HeapAlloc($__g_iHeapSize)
If @error Then
$iError = @error
Else
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
$aRet = DllCall('ntdll.dll', 'uint', 'ZwQueryDirectoryFile', 'handle', $hDir, 'ptr', 0, 'ptr', 0, 'ptr', 0,  'struct*', $tIOSB, 'struct*', $pBuffer, 'ulong', 8388608, 'uint', 1, 'boolean', 0, 'ptr', 0, 'boolean', 1)
If @error Or $aRet[0] Then
$iError = @error + 40
EndIf
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hDir)
If $iError Then
__HeapFree($pBuffer, 1)
If IsArray($aRet) Then
Return SetError(10, $aRet[0], 0)
Else
Return SetError($iError, 0, 0)
EndIf
EndIf
Local $tFDI, $iAttrib, $sTarget, $iLength = 0, $iOffset = 0
Do
$iLength += $iOffset
$tFDI = DllStructCreate('ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pBuffer + $iLength + 60), 1) / 2) & ']', $pBuffer + $iLength)
$sTarget = DllStructGetData($tFDI, 11)
$iAttrib = DllStructGetData($tFDI, 9)
$iOffset = DllStructGetData($tFDI, 1)
Switch $sTarget
Case '.', '..'
ContinueLoop
Case Else
Switch $iFlag
Case 1, 2
If BitAND($iAttrib, 0x00000010) Then
If $iFlag = 1 Then
ContinueLoop
EndIf
Else
If $iFlag = 2 Then
ContinueLoop
EndIf
EndIf
EndSwitch
If $sTemplate Then
$aRet = DllCall('shlwapi.dll', 'int', 'PathMatchSpecW', 'wstr', $sTarget, 'wstr', $sTemplate)
If @error Or ($aRet[0] And $bExclude) Or (Not $aRet[0] And Not $bExclude) Then
ContinueLoop
EndIf
EndIf
EndSwitch
__Inc($aData, 500)
$aData[$aData[0][0]][0] = $sTarget
$aData[$aData[0][0]][1] = DllStructGetData($tFDI, 3)
$aData[$aData[0][0]][2] = DllStructGetData($tFDI, 4)
$aData[$aData[0][0]][3] = DllStructGetData($tFDI, 5)
$aData[$aData[0][0]][4] = DllStructGetData($tFDI, 7)
$aData[$aData[0][0]][5] = DllStructGetData($tFDI, 8)
$aData[$aData[0][0]][6] = $iAttrib
Until Not $iOffset
__HeapFree($pBuffer)
__Inc($aData, -1)
Return $aData
EndFunc
Func _WinAPI_EnumFileStreams($sFilePath)
Local $tData = DllStructCreate('byte[32768]')
Local $pData = DllStructGetPtr($tData)
Local $aData[101][2] = [[0]]
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'ptr', $pData,  'ulong', 32768, 'uint', 22)
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iError Then Return SetError($iError, 0, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $tFSI, $iLength = 0, $iOffset = 0
Do
$iLength += $iOffset
$tFSI = DllStructCreate('ulong;ulong;int64;int64;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pData + $iLength + 4), 1) / 2) & ']', $pData + $iLength)
__Inc($aData)
$aData[$aData[0][0]][0] = DllStructGetData($tFSI, 5)
$aData[$aData[0][0]][1] = DllStructGetData($tFSI, 3)
$iOffset = DllStructGetData($tFSI, 1)
Until Not $iOffset
__Inc($aData, -1)
Return $aData
EndFunc
Func _WinAPI_EnumHardLinks($sFilePath)
Local $tData = DllStructCreate('byte[32768]')
Local $pData = DllStructGetPtr($tData)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'ptr', $pData,  'ulong', 32768, 'uint', 46)
If @error Or $aRet[0] Then
$iError = @error + 10
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $aRet Then Return SetError($iError, 0, 0)
If $aRet[0] Then Return SetError(10, $iError, 0)
EndIf
Local $iCount = DllStructGetData(DllStructCreate('ulong;ulong', $pData), 2)
Local $aData[$iCount + 1] = [$iCount]
Local $tFLEI, $hPath, $sPath, $iLength = 8
For $i = 1 To $iCount
$tFLEI = DllStructCreate('ulong;int64;ulong;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pData + $iLength + 16), 1)) & ']', $pData + $iLength)
$iError = 0
Do
$hPath = _WinAPI_OpenFileById($hFile, DllStructGetData($tFLEI, 2), 0x00100080, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$sPath = _WinAPI_GetFinalPathNameByHandleEx($hPath)
If @error Then
$iError = @error + 200
ExitLoop
EndIf
Until 1
If $hPath Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hPath)
EndIf
If $iError Then ExitLoop
$aData[$i] = _WinAPI_PathAppend($sPath, DllStructGetData($tFLEI, 4))
$iLength += DllStructGetData($tFLEI, 1)
Next
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iError Then Return SetError($iError, 0, 0)
Return $aData
EndFunc
Func _WinAPI_FileEncryptionStatus($sFilePath)
Local $aRet = DllCall('advapi32.dll', 'bool', 'FileEncryptionStatusW', 'wstr', $sFilePath, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, -1)
Return $aRet[2]
EndFunc
Func _WinAPI_FileExists($sFilePath)
If Not FileExists($sFilePath) Then Return 0
If _WinAPI_PathIsDirectory($sFilePath) Then Return SetExtended(1, 0)
Return 1
EndFunc
Func _WinAPI_FileInUse($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_READ)
If @error Then
If @extended = 32 Then Return 1
Return SetError(@error, @extended, 0)
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
Return 0
EndFunc
Func _WinAPI_FindClose($hSearch)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FindClose', 'handle', $hSearch)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FindCloseChangeNotification($hChange)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FindCloseChangeNotification', 'handle', $hChange)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FindFirstChangeNotification($sDirectory, $iFlags, $bSubtree = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindFirstChangeNotificationW', 'wstr', $sDirectory, 'bool', $bSubtree,  'dword', $iFlags)
If @error Or ($aRet[0] = Ptr(-1)) Then Return SetError(@error + 10, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FindFirstFile($sFilePath, $tData)
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindFirstFileW', 'wstr', $sFilePath, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = Ptr(-1) Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FindFirstFileName($sFilePath, ByRef $sLink)
$sLink = ''
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindFirstFileNameW', 'wstr', $sFilePath, 'dword', 0, 'dword*', 4096, 'wstr', '')
If @error Or ($aRet[0] = Ptr(-1)) Then Return SetError(@error + 10, @extended, 0)
$sLink = $aRet[4]
Return $aRet[0]
EndFunc
Func _WinAPI_FindFirstStream($sFilePath, $tData)
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindFirstStreamW', 'wstr', $sFilePath, 'uint', 0, 'struct*', $tData, 'dword', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = Ptr(-1) Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FindNextChangeNotification($hChange)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FindNextChangeNotification', 'handle', $hChange)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FindNextFile($hSearch, $tData)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, False)
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FindNextFileName($hSearch, ByRef $sLink)
$sLink = ''
Local $aRet = DllCall('kernel32.dll', 'bool', 'FindNextFileNameW', 'handle', $hSearch, 'dword*', 4096, 'wstr', '')
If @error Then Return SetError(@error, @extended, False)
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), 0)
$sLink = $aRet[3]
Return $aRet[0]
EndFunc
Func _WinAPI_FindNextStream($hSearch, $tData)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FindNextStreamW', 'handle', $hSearch, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, False)
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FlushFileBuffers($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "FlushFileBuffers", "handle", $hFile)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FlushViewOfFile($pAddress, $iBytes = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FlushViewOfFile', 'struct*', $pAddress, 'dword', $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetBinaryType($sFilePath)
Local $aRet = DllCall('kernel32.dll', 'int', 'GetBinaryTypeW', 'wstr', $sFilePath, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then $aRet[2] = 0
Return SetExtended($aRet[2], $aRet[0])
EndFunc
Func _WinAPI_GetCDType($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tagSCSI_PASS_THROUGH = 'struct;ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];endstruct'
Local $tSPT = DllStructCreate($tagSCSI_PASS_THROUGH & ';byte Hdr[8]')
Local $tCDB = DllStructCreate('byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]', DllStructGetPtr($tSPT, 'Cdb'))
Local $tHDR = DllStructCreate('byte[4];byte;byte;byte[2]', DllStructGetPtr($tSPT, 'Hdr'))
Local $iSize = DllStructGetPtr($tSPT, 'Hdr') - DllStructGetPtr($tSPT)
DllStructSetData($tSPT, 'Length', $iSize)
DllStructSetData($tSPT, 'ScsiStatus', 0)
DllStructSetData($tSPT, 'PathId', 0)
DllStructSetData($tSPT, 'TargetId', 0)
DllStructSetData($tSPT, 'Lun', 0)
DllStructSetData($tSPT, 'CdbLength', 12)
DllStructSetData($tSPT, 'SenseInfoLength', 0)
DllStructSetData($tSPT, 'DataIn', 1)
DllStructSetData($tSPT, 'DataTransferLength', 8)
DllStructSetData($tSPT, 'TimeOutValue', 86400)
DllStructSetData($tSPT, 'DataBufferOffset', $iSize)
DllStructSetData($tSPT, 'SenseInfoOffset', 0)
DllStructSetData($tCDB, 1, 0x46)
DllStructSetData($tCDB, 2, 0)
DllStructSetData($tCDB, 3, 0, 1)
DllStructSetData($tCDB, 3, 0, 2)
DllStructSetData($tCDB, 5, 0, 1)
DllStructSetData($tCDB, 5, 8, 2)
DllStructSetData($tCDB, 6, 0)
DllStructSetData($tCDB, 7, 0, 1)
DllStructSetData($tCDB, 7, 0, 2)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0004D004, 'struct*', $tSPT,  'dword', $iSize, 'struct*', $tSPT, 'dword', DllStructGetSize($tSPT), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, 0)
Return BitOR(BitShift(DllStructGetData($tHDR, 4, 1), -8), DllStructGetData($tHDR, 4, 2))
EndFunc
Func _WinAPI_GetCompressedFileSize($sFilePath)
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetCompressedFileSizeW', 'wstr', $sFilePath, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = -1 Then
Local $iLastError = _WinAPI_GetLastError()
If $aRet[2] = 0 Then Return SetError(10, $iLastError, 0)
If $iLastError Then Return SetError(11, $iLastError, 0)
EndIf
Return __WinAPI_MakeQWord($aRet[0], $aRet[2])
EndFunc
Func _WinAPI_GetCompression($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0009003C, 'ptr', 0, 'dword', 0,  'ushort*', 0, 'dword', 2, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, -1)
Return $aRet[5]
EndFunc
Func _WinAPI_GetCurrentDirectory()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetCurrentDirectoryW', 'dword', 4096, 'wstr', '')
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], $aRet[2])
EndFunc
Func _WinAPI_GetDiskFreeSpaceEx($sDrive)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetDiskFreeSpaceEx', 'str', $sDrive, 'int64*', 0, 'int64*', 0, 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[3]
For $i = 0 To 2
$aResult[$i] = $aRet[$i + 2]
Next
Return $aResult
EndFunc
Func _WinAPI_GetDriveBusType($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, -1)
Local $tagSTORAGE_PROPERTY_QUERY = 'ulong PropertyId;ulong QueryType;byte AdditionalParameters[1]'
Local $tSPQ = DllStructCreate($tagSTORAGE_PROPERTY_QUERY)
Local $tSDD = DllStructCreate('ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]')
DllStructSetData($tSPQ, 'PropertyId', 0)
DllStructSetData($tSPQ, 'QueryType', 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D1400, 'struct*', $tSPQ,  'dword', DllStructGetSize($tSPQ), 'struct*', $tSDD, 'dword', DllStructGetSize($tSDD),  'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, -1)
Return DllStructGetData($tSDD, 'BusType')
EndFunc
Func _WinAPI_GetDriveGeometryEx($iDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\PhysicalDrive' & $iDrive, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tDGEX = DllStructCreate('uint64;dword;dword;dword;dword;uint64')
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x000700A0, 'ptr', 0,  'dword', 0, 'struct*', $tDGEX, 'dword', DllStructGetSize($tDGEX), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, 0)
Local $aResult[6]
For $i = 0 To 5
$aResult[$i] = DllStructGetData($tDGEX, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetDriveNumber($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tSDN = DllStructCreate('dword;ulong;ulong')
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D1080, 'ptr', 0,  'dword', 0, 'struct*', $tSDN, 'dword', DllStructGetSize($tSDN), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, 0)
Local $aResult[3]
For $i = 0 To 2
$aResult[$i] = DllStructGetData($tSDN, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetDriveType($sDrive = '')
Local $iTypeOfDrive = 'str'
If Not StringStripWS($sDrive, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$iTypeOfDrive = 'ptr'
$sDrive = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'uint', 'GetDriveType', $iTypeOfDrive, $sDrive)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetFileAttributes($sFilePath)
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetFileAttributesW', 'wstr', $sFilePath)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetFileID($hFile)
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'int64*', 0,  'ulong', 8, 'uint', 6)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[3]
EndFunc
Func _WinAPI_GetFileInformationByHandle($hFile)
Local $tBHFI = DllStructCreate('dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword')
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetFileInformationByHandle', 'handle', $hFile, 'struct*', $tBHFI)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[8]
$aResult[0] = DllStructGetData($tBHFI, 1)
For $i = 1 To 3
If DllStructGetData($tBHFI, $i + 1) Then
$aResult[$i] = DllStructCreate($tagFILETIME)
_WinAPI_MoveMemory($aResult[$i], DllStructGetPtr($tBHFI, $i + 1), 8)
Else
$aResult[$i] = 0
EndIf
Next
$aResult[4] = DllStructGetData($tBHFI, 5)
$aResult[5] = __WinAPI_MakeQWord(DllStructGetData($tBHFI, 7), DllStructGetData($tBHFI, 6))
$aResult[6] = DllStructGetData($tBHFI, 8)
$aResult[7] = __WinAPI_MakeQWord(DllStructGetData($tBHFI, 9), DllStructGetData($tBHFI, 10))
Return $aResult
EndFunc
Func _WinAPI_GetFileInformationByHandleEx($hFile)
Local $tFI = DllStructCreate($tagFILEINFO)
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'struct*', $tFI,  'ulong', DllStructGetSize($tFI), 'uint', 4)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tFI
EndFunc
Func _WinAPI_GetFilePointerEx($hFile)
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'int64*', 0,  'ulong', 8, 'uint', 14)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetFileSizeEx($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hFile, "int64*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, -1)
Return $aResult[2]
EndFunc
Func _WinAPI_GetFileSizeOnDisk($sFilePath)
Local $iSize = FileGetSize($sFilePath)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetDiskFreeSpaceW',  'wstr', _WinAPI_PathStripToRoot(_WinAPI_GetFullPathName($sFilePath)), 'dword*', 0, 'dword*', 0,  'dword*', 0, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return Ceiling($iSize / ($aRet[2] * $aRet[3])) * ($aRet[2] * $aRet[3])
EndFunc
Func _WinAPI_GetFileTitle($sFilePath)
Local $aRet = DllCall('comdlg32.dll', 'short', 'GetFileTitleW', 'wstr', $sFilePath, 'wstr', '', 'word', 4096)
If @error Or $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetFileType($hFile)
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetFileType', 'handle', $hFile)
If @error Then Return SetError(@error, @extended, -1)
Local $iLastError = _WinAPI_GetLastError()
If Not $aRet[0] And $iLastError Then Return SetError(10, $iLastError, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetFinalPathNameByHandle($hFile)
Local $tFNI = DllStructCreate('ulong;wchar[4096]')
Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryInformationFile', 'handle', $hFile, 'struct*', $tIOSB, 'struct*', $tFNI,  'ulong', DllStructGetSize($tFNI), 'uint', 9)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $iLength = DllStructGetData($tFNI, 1)
If Not $iLength Then Return SetError(12, 0, '')
Return DllStructGetData(DllStructCreate('wchar[' & ($iLength / 2) & ']', DllStructGetPtr($tFNI, 2)), 1)
EndFunc
Func _WinAPI_GetFinalPathNameByHandleEx($hFile, $iFlags = 0)
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetFinalPathNameByHandleW', 'handle', $hFile, 'wstr', '', 'dword', 4096,  'dword', $iFlags)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetFullPathName($sFilePath)
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetFullPathNameW', 'wstr', $sFilePath, 'dword', 4096, 'wstr', '', 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetLogicalDrives()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetLogicalDrives')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetObjectID($sFilePath)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tFOID = DllStructCreate('byte[16];byte[48]')
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0009009C, 'ptr', 0,  'dword', 0, 'struct*', $tFOID, 'dword', DllStructGetSize($tFOID), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, 0)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_MoveMemory($tGUID, $tFOID, 16)
Return $tGUID
EndFunc
Func _WinAPI_GetOverlappedResult($hFile, $tOverlapped, ByRef $iBytes, $bWait = False)
Local $aResult = DllCall("kernel32.dll", "bool", "GetOverlappedResult", "handle", $hFile, "struct*", $tOverlapped, "dword*", 0,  "bool", $bWait)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, False)
$iBytes = $aResult[3]
Return $aResult[0]
EndFunc
Func _WinAPI_GetPEType($sFilePath)
Local $tData = DllStructCreate('ushort[2]')
Local $tUInt = DllStructCreate('uint', DllStructGetPtr($tData))
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0, $iVal
Do
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReadFile', 'handle', $hFile, 'struct*', $tData, 'dword', 2, 'dword*', 0, 'ptr', 0)
If @error Or (Not $aRet[0]) Or ($aRet[4] <> 2) Then
$iError = @error + 30
ExitLoop
EndIf
$iVal = DllStructGetData($tData, 1, 1)
If $iVal <> 0x00005A4D Then
$iError = 3
ExitLoop
EndIf
If Not _WinAPI_SetFilePointerEx($hFile, 0x0000003C) Then
$iError = @error + 40
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadFile', 'handle', $hFile, 'struct*', $tData, 'dword', 4, 'dword*', 0, 'ptr', 0)
If @error Or (Not $aRet[0]) Or ($aRet[4] <> 4) Then
$iError = @error + 50
ExitLoop
EndIf
If Not _WinAPI_SetFilePointerEx($hFile, DllStructGetData($tUInt, 1)) Then
$iError = @error + 60
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadFile', 'handle', $hFile, 'struct*', $tData, 'dword', 4, 'dword*', 0, 'ptr', 0)
If @error Or (Not $aRet[0]) Or ($aRet[4] <> 4) Then
$iError = @error + 70
ExitLoop
EndIf
$iVal = DllStructGetData($tUInt, 1)
If $iVal <> 0x00004550 Then
$iError = 4
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadFile', 'handle', $hFile, 'struct*', $tData, 'dword', 2, 'dword*', 0, 'ptr', 0)
If @error Or (Not $aRet[0]) Or ($aRet[4] <> 2) Then
$iError = @error + 80
ExitLoop
EndIf
$iVal = DllStructGetData($tData, 1, 1)
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iError Then Return SetError($iError, 0, 0)
Return $iVal
EndFunc
Func _WinAPI_GetProfilesDirectory()
Local $aRet = DllCall('userenv.dll', 'bool', 'GetProfilesDirectoryW', 'wstr', '', 'dword*', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetTempFileName($sFilePath, $sPrefix = '')
Local $aRet = DllCall('kernel32.dll', 'uint', 'GetTempFileNameW', 'wstr', $sFilePath, 'wstr', $sPrefix, 'uint', 0, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[4]
EndFunc
Func _WinAPI_GetVolumeInformation($sRoot = '')
Local $sTypeOfRoot = 'wstr'
If Not StringStripWS($sRoot, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfRoot = 'ptr'
$sRoot = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVolumeInformationW', $sTypeOfRoot, $sRoot, 'wstr', '', 'dword', 4096,  'dword*', 0, 'dword*', 0, 'dword*', 0, 'wstr', '', 'dword', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[5]
For $i = 0 To 4
Switch $i
Case 0
$aResult[$i] = $aRet[2]
Case Else
$aResult[$i] = $aRet[$i + 3]
EndSwitch
Next
Return $aResult
EndFunc
Func _WinAPI_GetVolumeInformationByHandle($hFile)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVolumeInformationByHandleW', 'handle', $hFile, 'wstr', '', 'dword', 4096,  'dword*', 0, 'dword*', 0, 'dword*', 0, 'wstr', '', 'dword', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[5]
For $i = 0 To 4
Switch $i
Case 0
$aResult[$i] = $aRet[2]
Case Else
$aResult[$i] = $aRet[$i + 3]
EndSwitch
Next
Return $aResult
EndFunc
Func _WinAPI_GetVolumeNameForVolumeMountPoint($sMountedPath)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVolumeNameForVolumeMountPointW', 'wstr', $sMountedPath, 'wstr', '', 'dword', 80)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_IOCTL($iDeviceType, $iFunction, $iMethod, $iAccess)
Return BitOR(BitShift($iDeviceType, -16), BitShift($iAccess, -14), BitShift($iFunction, -2), $iMethod)
EndFunc
Func _WinAPI_IsDoorOpen($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, False)
Local $tSPT = DllStructCreate('ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]' & (@AutoItX64 ? ';byte[4]' : '') & ';byte Hdr[8]')
Local $tCDB = DllStructCreate('byte;byte;byte[6];byte[2];byte;byte;byte[4]', DllStructGetPtr($tSPT, 'Cdb'))
Local $tHDR = DllStructCreate('byte;byte;byte[3];byte;byte[2]', DllStructGetPtr($tSPT, 'Hdr'))
Local $iSize = DllStructGetPtr($tSPT, 'Hdr') - DllStructGetPtr($tSPT)
DllStructSetData($tSPT, 'Length', $iSize)
DllStructSetData($tSPT, 'ScsiStatus', 0)
DllStructSetData($tSPT, 'PathId', 0)
DllStructSetData($tSPT, 'TargetId', 0)
DllStructSetData($tSPT, 'Lun', 0)
DllStructSetData($tSPT, 'CdbLength', 12)
DllStructSetData($tSPT, 'SenseInfoLength', 0)
DllStructSetData($tSPT, 'DataIn', 1)
DllStructSetData($tSPT, 'DataTransferLength', 8)
DllStructSetData($tSPT, 'TimeOutValue', 86400)
DllStructSetData($tSPT, 'DataBufferOffset', $iSize)
DllStructSetData($tSPT, 'SenseInfoOffset', 0)
DllStructSetData($tCDB, 1, 0xBD)
DllStructSetData($tCDB, 2, 0)
DllStructSetData($tCDB, 4, 0, 1)
DllStructSetData($tCDB, 4, 8, 2)
DllStructSetData($tCDB, 5, 0)
DllStructSetData($tCDB, 6, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0004D004, 'struct*', $tSPT,  'dword', $iSize, 'struct*', $tSPT, 'dword', DllStructGetSize($tSPT), 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, False)
Return (BitAND(DllStructGetData($tHDR, 2), 0x10) = 0x10)
EndFunc
Func _WinAPI_IsPathShared($sFilePath)
If Not __DLL('ntshrui.dll') Then Return SetError(103, 0, 0)
Local $aRet = DllCall('ntshrui.dll', 'bool', 'IsPathSharedW', 'wstr', _WinAPI_PathRemoveBackslash($sFilePath), 'int', 1)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_IsWritable($sDrive)
DriveGetFileSystem($sDrive)
If @error Then Return SetError(40 + @error, _WinAPI_GetLastError(), 0)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x00070024, 'ptr', 0, 'dword', 0,  'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
Local Const $ERROR_WRITE_PROTECT = 19
If __CheckErrorCloseHandle($aRet, $hFile, 1) <> 10 And @extended = $ERROR_WRITE_PROTECT Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadMedia($sDrive)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D480C, 'ptr', 0, 'dword', 0,  'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LockDevice($sDrive, $bLock)
Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
If @error Then Return SetError(@error + 20, @extended, False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x002D4804, 'boolean*', $bLock,  'dword', 1, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LockFile($hFile, $iOffset, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'LockFile', 'handle', $hFile,  'dword', _WinAPI_LoDWord($iOffset), 'dword', _WinAPI_HiDWord($iOffset),  'dword', _WinAPI_LoDWord($iLength), 'dword', _WinAPI_HiDWord($iLength))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MapViewOfFile($hMapping, $iOffset = 0, $iBytes = 0, $iAccess = 0x0006)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'MapViewOfFile', 'handle', $hMapping, 'dword', $iAccess,  'dword', _WinAPI_HiDWord($iOffset), 'dword', _WinAPI_LoDWord($iOffset), 'ulong_ptr', $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MoveFileEx($sExistingFile, $sNewFile, $iFlags = 0, $pProgressProc = 0, $pData = 0)
Local $sTypeOfNewFile = 'wstr'
If Not StringStripWS($sNewFile, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfNewFile = 'ptr'
$sNewFile = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'MoveFileWithProgressW', 'wstr', $sExistingFile, $sTypeOfNewFile, $sNewFile,  'ptr', $pProgressProc, 'ptr', $pData, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenFileById($hFile, $vID, $iAccess = 0, $iShare = 0, $iFlags = 0)
Local $tFIDD = DllStructCreate('dword;uint;int64;int64')
Local $hObj, $aRet, $iType, $iError = 0
Select
Case IsString($vID)
$aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $vID, 'ptr', DllStructGetPtr($tFIDD, 3))
If @error Or $aRet[0] Then
Return SetError(@error + 30, 0, 0)
EndIf
$iType = 1
Case IsDllStruct($vID)
If Not _WinAPI_MoveMemory(DllStructGetPtr($tFIDD, 3), DllStructGetPtr($vID), 16) Then
Return SetError(@error + 40, 0, 0)
EndIf
$iType = 1
Case Else
DllStructSetData($tFIDD, 3, $vID)
$iType = 0
EndSelect
DllStructSetData($tFIDD, 1, DllStructGetSize($tFIDD))
DllStructSetData($tFIDD, 2, $iType)
If IsString($hFile) Then
$hObj = _WinAPI_CreateFileEx($hFile, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Else
$hObj = $hFile
EndIf
$aRet = DllCall('kernel32.dll', 'handle', 'OpenFileById', 'handle', $hObj, 'struct*', $tFIDD, 'dword', $iAccess,  'dword', $iShare, 'ptr', 0, 'dword', $iFlags)
If @error Or ($aRet[0] = Ptr(-1)) Then $iError = @error + 10
If IsString($hFile) Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObj)
EndIf
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenFileMapping($sName, $iAccess = 0x0006, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenFileMappingW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsDirectoryEmpty($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsDirectoryEmptyW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryDosDevice($sDevice)
Local $sTypeOfDevice = 'wstr'
If Not StringStripWS($sDevice, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfDevice = 'ptr'
$sDevice = 0
EndIf
Local $tData = DllStructCreate('wchar[16384]')
Local $aRet = DllCall('kernel32.dll', 'dword', 'QueryDosDeviceW', $sTypeOfDevice, $sDevice, 'struct*', $tData, 'dword', 16384)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Local $aResult = _WinAPI_StructToArray($tData)
If IsString($sDevice) Then
$aResult = $aResult[1]
EndIf
Return $aResult
EndFunc
Func _WinAPI_ReadDirectoryChanges($hDirectory, $iFilter, $pBuffer, $iLength, $bSubtree = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReadDirectoryChangesW', 'handle', $hDirectory, 'struct*', $pBuffer,  'dword', $iLength - Mod($iLength, 4), 'bool', $bSubtree, 'dword', $iFilter, 'dword*', 0, 'ptr', 0, 'ptr', 0)
If @error Or Not $aRet[0] Or (Not $aRet[6]) Then Return SetError(@error + 10, @extended, 0)
$pBuffer = $aRet[2]
Local $aData[101][2] = [[0]]
Local $tFNI, $iBuffer = 0, $iOffset = 0
Do
$iBuffer += $iOffset
$tFNI = DllStructCreate('dword NextEntryOffset;dword Action;dword FileNameLength;wchar FileName[' & (DllStructGetData(DllStructCreate('dword FileNameLength', $pBuffer + $iBuffer + 8), 1) / 2) & ']', $pBuffer + $iBuffer)
__Inc($aData)
$aData[$aData[0][0]][0] = DllStructGetData($tFNI, "FileName")
$aData[$aData[0][0]][1] = DllStructGetData($tFNI, "Action")
$iOffset = DllStructGetData($tFNI, "NextEntryOffset")
Until Not $iOffset
__Inc($aData, -1)
Return $aData
EndFunc
Func _WinAPI_RemoveDirectory($sDirPath)
Local $aRet = DllCall('kernel32.dll', 'bool', 'RemoveDirectoryW', 'wstr', $sDirPath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ReOpenFile($hFile, $iAccess, $iShare, $iFlags = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'ReOpenFile', 'handle', $hFile, 'dword', $iAccess, 'dword', $iShare, 'dword', $iFlags)
If @error Or ($aRet[0] = Ptr(-1)) Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ReplaceFile($sReplacedFile, $sReplacementFile, $sBackupFile = '', $iFlags = 0)
Local $sTypeOfBackupFile = 'wstr'
If Not StringStripWS($sBackupFile, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfBackupFile = 'ptr'
$sBackupFile = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReplaceFileW', 'wstr', $sReplacedFile, 'wstr', $sReplacementFile,  $sTypeOfBackupFile, $sBackupFile, 'dword', $iFlags, 'ptr', 0, 'ptr', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SearchPath($sFilePath, $sSearchPath = '')
Local $sTypeOfPath = 'wstr'
If Not StringStripWS($sSearchPath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfPath = 'ptr'
$sSearchPath = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'dword', 'SearchPathW', $sTypeOfPath, $sSearchPath, 'wstr', $sFilePath, 'ptr', 0, 'dword', 4096, 'wstr', '', 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_SetCompression($sFilePath, $iCompression)
Local $hFile = _WinAPI_CreateFileEx($sFilePath, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'DeviceIoControl', 'handle', $hFile, 'dword', 0x0009C040,  'ushort*', $iCompression, 'dword', 2, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)
If __CheckErrorCloseHandle($aRet, $hFile) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_SetCurrentDirectory($sDir)
Local $aRet = DllCall('kernel32.dll', 'int', 'SetCurrentDirectoryW', 'wstr', $sDir)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetEndOfFile($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $hFile)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFileAttributes($sFilePath, $iAttributes)
Local $aRet = DllCall('kernel32.dll', 'int', 'SetFileAttributesW', 'wstr', $sFilePath, 'dword', $iAttributes)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetFileInformationByHandleEx($hFile, $tFILEINFO)
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwSetInformationFile', 'handle', $hFile, 'struct*', $tFILEINFO,  'struct*', $tFILEINFO, 'ulong', DllStructGetSize($tFILEINFO), 'uint', 4)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_SetFilePointer($hFile, $iPos, $iMethod = 0)
Local $aResult = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hFile, "long", $iPos, "ptr", 0, "long", $iMethod)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFilePointerEx($hFile, $iPos, $iMethod = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetFilePointerEx', 'handle', $hFile, 'int64', $iPos, 'int64*', 0, 'dword', $iMethod)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetFileShortName($hFile, $sShortName)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetFileShortNameW', 'handle', $hFile, 'wstr', $sShortName)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetFileValidData($hFile, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetFileValidData', 'handle', $hFile, 'int64', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetSearchPathMode($iFlags)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetSearchPathMode', 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetVolumeMountPoint($sFilePath, $sGUID)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetVolumeMountPointW', 'wstr', $sFilePath, 'wstr', $sGUID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SfcIsFileProtected($sFilePath)
If Not __DLL('sfc.dll') Then Return SetError(103, 0, False)
Local $aRet = DllCall('sfc.dll', 'bool', 'SfcIsFileProtected', 'handle', 0, 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UnlockFile($hFile, $iOffset, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'UnlockFile', 'handle', $hFile,  'dword', _WinAPI_LoDWord($iOffset), 'dword', _WinAPI_HiDWord($iOffset),  'dword', _WinAPI_LoDWord($iLength), 'dword', _WinAPI_HiDWord($iLength))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnmapViewOfFile($pAddress)
Local $aRet = DllCall('kernel32.dll', 'bool', 'UnmapViewOfFile', 'ptr', $pAddress)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Wow64EnableWow64FsRedirection($bEnable)
Local $aRet = DllCall('kernel32.dll', 'boolean', 'Wow64EnableWow64FsRedirection', 'boolean', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __WinAPI_MakeQWord($iLoDWORD, $iHiDWORD)
Local $tInt64 = DllStructCreate("uint64")
Local $tDwords = DllStructCreate("dword;dword", DllStructGetPtr($tInt64))
DllStructSetData($tDwords, 1, $iLoDWORD)
DllStructSetData($tDwords, 2, $iHiDWORD)
Return DllStructGetData($tInt64, 1)
EndFunc
#EndRegion Internal Functions
Global Const $CREATE_BREAKAWAY_FROM_JOB = 0x01000000
Global Const $CREATE_DEFAULT_ERROR_MODE = 0x04000000
Global Const $CREATE_NEW_CONSOLE = 0x00000010
Global Const $CREATE_NEW_PROCESS_GROUP = 0x00000200
Global Const $CREATE_NO_WINDOW = 0x08000000
Global Const $CREATE_PROTECTED_PROCESS = 0x00040000
Global Const $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000
Global Const $CREATE_SEPARATE_WOW_VDM = 0x00000800
Global Const $CREATE_SHARED_WOW_VDM = 0x00001000
Global Const $CREATE_SUSPENDED = 0x00000004
Global Const $CREATE_UNICODE_ENVIRONMENT = 0x00000400
Global Const $LIST_MODULES_32BIT = 1
Global Const $LIST_MODULES_64BIT = 2
Global Const $LIST_MODULES_ALL = 3
Global Const $LIST_MODULES_DEFAULT = 0
Global Const $ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000
Global Const $BELOW_NORMAL_PRIORITY_CLASS = 0x00004000
Global Const $HIGH_PRIORITY_CLASS = 0x00000080
Global Const $IDLE_PRIORITY_CLASS = 0x00000040
Global Const $NORMAL_PRIORITY_CLASS = 0x00000020
Global Const $REALTIME_PRIORITY_CLASS = 0x00000100
Global Const $PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000
Global Const $PROCESS_MODE_BACKGROUND_END = 0x00200000
Global Const $MUTEX_MODIFY_STATE = 0x0001
Global Const $MUTEX_ALL_ACCESS = 0x001F0001
Global Const $JOB_OBJECT_ASSIGN_PROCESS = 0x0001
Global Const $JOB_OBJECT_QUERY = 0x0004
Global Const $JOB_OBJECT_SET_ATTRIBUTES = 0x0002
Global Const $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 0x0010
Global Const $JOB_OBJECT_TERMINATE = 0x0008
Global Const $JOB_OBJECT_ALL_ACCESS = 0x001F001F
Global Const $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 0x00000008
Global Const $JOB_OBJECT_LIMIT_AFFINITY = 0x00000010
Global Const $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x00000800
Global Const $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400
Global Const $JOB_OBJECT_LIMIT_JOB_MEMORY = 0x00000200
Global Const $JOB_OBJECT_LIMIT_JOB_TIME = 0x00000004
Global Const $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x00002000
Global Const $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 0x00000040
Global Const $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 0x00000020
Global Const $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 0x00000100
Global Const $JOB_OBJECT_LIMIT_PROCESS_TIME = 0x00000002
Global Const $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 0x00000080
Global Const $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x00001000
Global Const $JOB_OBJECT_LIMIT_WORKINGSET = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_DESKTOP = 0x00000040
Global Const $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 0x00000010
Global Const $JOB_OBJECT_UILIMIT_EXITWINDOWS = 0x00000080
Global Const $JOB_OBJECT_UILIMIT_GLOBALATOMS = 0x00000020
Global Const $JOB_OBJECT_UILIMIT_HANDLES = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_READCLIPBOARD = 0x00000002
Global Const $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008
Global Const $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 0x00000004
Global Const $JOB_OBJECT_SECURITY_FILTER_TOKENS = 0x00000008
Global Const $JOB_OBJECT_SECURITY_NO_ADMIN = 0x00000001
Global Const $JOB_OBJECT_SECURITY_ONLY_TOKEN = 0x00000004
Global Const $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x00000002
Global Const $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
Global Const $JOB_OBJECT_POST_AT_END_OF_JOB = 1
Global Const $SEMAPHORE_MODIFY_STATE = 0x0002
Global Const $SEMAPHORE_QUERY_STATE = 0x0001
Global Const $SEMAPHORE_ALL_ACCESS = 0x001F0003
Global Const $ES_AWAYMODE_REQUIRED = 0x00000040
Global Const $ES_CONTINUOUS = 0x80000000
Global Const $ES_DISPLAY_REQUIRED = 0x00000002
Global Const $ES_SYSTEM_REQUIRED = 0x00000001
Global Const $ES_USER_PRESENT = 0x00000004
#Region Global Variables and Constants
Global Const $tagIO_COUNTERS = 'struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;endstruct'
Global Const $tagJOBOBJECT_ASSOCIATE_COMPLETION_PORT = 'ulong_ptr CompletionKey;ptr CompletionPort'
Global Const $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = 'struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;endstruct'
Global Const $tagJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & ';' & $tagIO_COUNTERS
Global Const $tagJOBOBJECT_BASIC_LIMIT_INFORMATION = 'struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct'
Global Const $tagJOBOBJECT_BASIC_PROCESS_ID_LIST = 'dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList'
Global Const $tagJOBOBJECT_BASIC_UI_RESTRICTIONS = 'dword UIRestrictionsClass'
Global Const $tagJOBOBJECT_END_OF_JOB_TIME_INFORMATION = 'dword EndOfJobTimeAction'
Global Const $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $tagJOBOBJECT_BASIC_LIMIT_INFORMATION & ';' & $tagIO_COUNTERS & ';ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed'
Global Const $tagJOBOBJECT_GROUP_INFORMATION = ''
Global Const $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION = 'dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids'
Global Const $tagMODULEINFO = 'ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint'
Global Const $tagPROCESSENTRY32 = 'dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_AdjustTokenPrivileges($hToken, $aPrivileges, $iAttributes, ByRef $aAdjust)
$aAdjust = 0
If Not $aPrivileges And IsNumber($aPrivileges) Then Return 0
Local $tTP1 = 0, $tTP2, $iCount, $aRet, $bDisable = False
If $aPrivileges = -1 Then
$tTP2 = DllStructCreate('dword')
$aRet = DllCall('advapi32.dll', 'bool', 'AdjustTokenPrivileges', 'handle', $hToken, 'bool', 1, 'ptr', 0,  'dword', 0, 'struct*', $tTP2, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
Local $iLastError = _WinAPI_GetLastError()
Switch $iLastError
Case 122
$tTP2 = DllStructCreate('dword;dword[' & ($aRet[6] / 4 - 1) & ']')
If @error Then
ContinueCase
EndIf
Case Else
Return SetError(10, $iLastError, 0)
EndSwitch
$bDisable = True
Else
Local $aPrev = 0
If Not IsArray($aPrivileges) Then
Dim $aPrev[1][2]
$aPrev[0][0] = $aPrivileges
$aPrev[0][1] = $iAttributes
Else
If Not UBound($aPrivileges, $UBOUND_COLUMNS) Then
$iCount = UBound($aPrivileges)
Dim $aPrev[$iCount][2]
For $i = 0 To $iCount - 1
$aPrev[$i][0] = $aPrivileges[$i]
$aPrev[$i][1] = $iAttributes
Next
EndIf
EndIf
If IsArray($aPrev) Then
$aPrivileges = $aPrev
EndIf
Local $tagStruct = 'dword;dword[' & (3 * UBound($aPrivileges)) & ']'
$tTP1 = DllStructCreate($tagStruct)
$tTP2 = DllStructCreate($tagStruct)
If @error Then Return SetError(@error + 20, 0, 0)
DllStructSetData($tTP1, 1, UBound($aPrivileges))
For $i = 0 To UBound($aPrivileges) - 1
DllStructSetData($tTP1, 2, $aPrivileges[$i][1], 3 * $i + 3)
$aRet = DllCall('advapi32.dll', 'bool', 'LookupPrivilegeValueW', 'ptr', 0, 'wstr', $aPrivileges[$i][0],  'ptr', DllStructGetPtr($tTP1, 2) + 12 * $i)
If @error Or Not $aRet[0] Then Return SetError(@error + 100, @extended, 0)
Next
EndIf
$aRet = DllCall('advapi32.dll', 'bool', 'AdjustTokenPrivileges', 'handle', $hToken, 'bool', $bDisable,  'struct*', $tTP1, 'dword', DllStructGetSize($tTP2), 'struct*', $tTP2, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 200, @extended, 0)
Local $iResult
Switch _WinAPI_GetLastError()
Case 1300
$iResult = 1
Case Else
$iResult = 0
EndSwitch
$iCount = DllStructGetData($tTP2, 1)
If $iCount Then
Local $tData = DllStructCreate('wchar[128]')
Dim $aPrivileges[$iCount][2]
For $i = 0 To $iCount - 1
$aRet = DllCall('advapi32.dll', 'bool', 'LookupPrivilegeNameW', 'ptr', 0,  'ptr', DllStructGetPtr($tTP2, 2) + 12 * $i, 'struct*', $tData, 'dword*', 128)
If @error Or Not $aRet[0] Then Return SetError(@error + 300, @extended, 0)
$aPrivileges[$i][1] = DllStructGetData($tTP2, 2, 3 * $i + 3)
$aPrivileges[$i][0] = DllStructGetData($tData, 1)
Next
$aAdjust = $aPrivileges
EndIf
Return SetExtended($iResult, 1)
EndFunc
Func _WinAPI_AssignProcessToJobObject($hJob, $hProcess)
Local $aRet = DllCall('kernel32.dll', 'bool', 'AssignProcessToJobObject', 'handle', $hJob, 'handle', $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AttachConsole($iPID = -1)
Local $aResult = DllCall("kernel32.dll", "bool", "AttachConsole", "dword", $iPID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_AttachThreadInput($iAttach, $iAttachTo, $bAttach)
Local $aResult = DllCall("user32.dll", "bool", "AttachThreadInput", "dword", $iAttach, "dword", $iAttachTo, "bool", $bAttach)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateEvent($tAttributes = 0, $bManualReset = True, $bInitialState = True, $sName = "")
Local $sNameType = "wstr"
If $sName = "" Then
$sName = 0
$sNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "CreateEventW", "struct*", $tAttributes, "bool", $bManualReset,  "bool", $bInitialState, $sNameType, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateJobObject($sName = '', $tSecurity = 0)
Local $sTypeOfName = 'wstr'
If Not StringStripWS($sName, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfName = 'ptr'
$sName = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateJobObjectW', 'struct*', $tSecurity, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateMutex($sMutex, $bInitial = True, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateMutexW', 'struct*', $tSecurity, 'bool', $bInitial, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateProcess($sAppName, $sCommand, $tSecurity, $tThread, $bInherit, $iFlags, $pEnviron, $sDir, $tStartupInfo, $tProcess)
Local $tCommand = 0
Local $sAppNameType = "wstr", $sDirType = "wstr"
If $sAppName = "" Then
$sAppNameType = "ptr"
$sAppName = 0
EndIf
If $sCommand <> "" Then
$tCommand = DllStructCreate("wchar Text[" & 260 + 1 & "]")
DllStructSetData($tCommand, "Text", $sCommand)
EndIf
If $sDir = "" Then
$sDirType = "ptr"
$sDir = 0
EndIf
Local $aResult = DllCall("kernel32.dll", "bool", "CreateProcessW", $sAppNameType, $sAppName, "struct*", $tCommand,  "struct*", $tSecurity, "struct*", $tThread, "bool", $bInherit, "dword", $iFlags, "struct*", $pEnviron, $sDirType, $sDir,  "struct*", $tStartupInfo, "struct*", $tProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateProcessWithToken($sApp, $sCmd, $iFlags, $tStartupInfo, $tProcessInfo, $hToken, $iLogon = 0, $pEnvironment = 0, $sDir = '')
Local $sTypeOfApp = 'wstr', $sTypeOfCmd = 'wstr', $sTypeOfDir = 'wstr'
If Not StringStripWS($sApp, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfApp = 'ptr'
$sApp = 0
EndIf
If Not StringStripWS($sCmd, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfCmd = 'ptr'
$sCmd = 0
EndIf
If Not StringStripWS($sDir, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfDir = 'ptr'
$sDir = 0
EndIf
Local $aRet = DllCall('advapi32.dll', 'bool', 'CreateProcessWithTokenW', 'handle', $hToken, 'dword', $iLogon,  $sTypeOfApp, $sApp, $sTypeOfCmd, $sCmd, 'dword', $iFlags, 'struct*', $pEnvironment,  $sTypeOfDir, $sDir, 'struct*', $tStartupInfo, 'struct*', $tProcessInfo)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateSemaphoreW', 'struct*', $tSecurity, 'long', $iInitial,  'long', $iMaximum, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DuplicateTokenEx($hToken, $iAccess, $iLevel, $iType = 1, $tSecurity = 0)
Local $aRet = DllCall('advapi32.dll', 'bool', 'DuplicateTokenEx', 'handle', $hToken, 'dword', $iAccess,  'struct*', $tSecurity, 'int', $iLevel, 'int', $iType, 'handle*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[6]
EndFunc
Func _WinAPI_EmptyWorkingSet($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000500 : 0x00001100),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EmptyWorkingSet', 'handle', $hProcess[0])
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EnumChildProcess($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or ($hSnapshot[0] = Ptr(-1)) Then Return SetError(@error + 10, @extended, 0)
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
Local $aResult[101][2] = [[0]]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ParentProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0][0]][0] = DllStructGetData($tPROCESSENTRY32, 'ProcessID')
$aResult[$aResult[0][0]][1] = DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0][0] Then Return SetError($iError + 20, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumDeviceDrivers()
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumDeviceDrivers', 'ptr', 0, 'dword', 0, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $iSize
If @AutoItX64 Then
$iSize = $aRet[3] / 8
Else
$iSize = $aRet[3] / 4
EndIf
Local $tData = DllStructCreate('ptr[' & $iSize & ']')
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumDeviceDrivers', 'struct*', $tData,  'dword', DllStructGetSize($tData), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Local $aResult[$iSize + 1] = [$iSize]
For $i = 1 To $iSize
$aResult[$i] = DllStructGetData($tData, 1, $i)
Next
Return $aResult
EndFunc
Func _WinAPI_EnumProcessHandles($iPID = 0, $iType = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $aResult[101][4] = [[0]]
Local $tSHI = DllStructCreate('ulong;byte[4194304]')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQuerySystemInformation', 'uint', 16, 'struct*', $tSHI,  'ulong', DllStructGetSize($tSHI), 'ulong*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $pData = DllStructGetPtr($tSHI, 2)
Local $tHandle
For $i = 1 To DllStructGetData($tSHI, 1)
$tHandle = DllStructCreate('align 4;ulong;byte;byte;ushort;ptr;ulong', $pData + (@AutoItX64 ? (4 + ($i - 1) * 24) : (($i - 1) * 16)))
If (DllStructGetData($tHandle, 1) = $iPID) And ((Not $iType) Or ($iType = DllStructGetData($tHandle, 2))) Then
__Inc($aResult)
$aResult[$aResult[0][0]][0] = Ptr(DllStructGetData($tHandle, 4))
$aResult[$aResult[0][0]][1] = DllStructGetData($tHandle, 2)
$aResult[$aResult[0][0]][2] = DllStructGetData($tHandle, 3)
$aResult[$aResult[0][0]][3] = DllStructGetData($tHandle, 6)
EndIf
Next
If Not $aResult[0][0] Then Return SetError(11, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessModules($iPID = 0, $iFlag = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $iCount, $aRet, $iError = 0
Do
If $__WINVER >= 0x0600 Then
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModulesEx', 'handle', $hProcess[0], 'ptr', 0,  'dword', 0, 'dword*', 0, 'dword', $iFlag)
Else
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModules', 'handle', $hProcess[0], 'ptr', 0,  'dword', 0, 'dword*', 0)
EndIf
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
If @AutoItX64 Then
$iCount = $aRet[4] / 8
Else
$iCount = $aRet[4] / 4
EndIf
Local $tPtr = DllStructCreate('ptr[' & $iCount & ']')
If @error Then
$iError = @error + 30
ExitLoop
EndIf
If $__WINVER >= 0x0600 Then
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModulesEx', 'handle', $hProcess[0], 'struct*', $tPtr,  'dword', DllStructGetSize($tPtr), 'dword*', 0, 'dword', $iFlag)
Else
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModules', 'handle', $hProcess[0], 'struct*', $tPtr,  'dword', DllStructGetSize($tPtr), 'dword*', 0)
EndIf
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop
EndIf
Local $aResult[$iCount + 1][2] = [[$iCount]]
For $i = 1 To $iCount
$aResult[$i][0] = DllStructGetData($tPtr, 1, $i)
$aResult[$i][1] = _WinAPI_GetModuleFileNameEx($hProcess[0], $aResult[$i][0])
Next
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessThreads($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local Const $tagTHREADENTRY32 = 'dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags'
Local $tTHREADENTRY32 = DllStructCreate($tagTHREADENTRY32)
Local $aResult[101] = [0]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Thread32First', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
While Not @error And $aRet[0]
If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Thread32Next', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0] Then Return SetError(1, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessWindows($iPID = 0, $bVisible = True)
Local $aThreads = _WinAPI_EnumProcessThreads($iPID)
If @error Then Return SetError(@error, @extended, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
For $i = 1 To $aThreads[0]
DllCall('user32.dll', 'bool', 'EnumThreadWindows', 'dword', $aThreads[$i], 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', $bVisible)
If @error Then
ExitLoop
EndIf
Next
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then Return SetError(11, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FatalAppExit($sMessage)
DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $sMessage)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_GetCurrentProcessExplicitAppUserModelID()
Local $aRet = DllCall('shell32.dll', 'long', 'GetCurrentProcessExplicitAppUserModelID', 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $sID = _WinAPI_GetString($aRet[1])
_WinAPI_CoTaskMemFree($aRet[1])
Return $sID
EndFunc
Func _WinAPI_GetCurrentProcessID()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentProcessId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThread()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThreadId()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDeviceDriverBaseName($pDriver)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetDeviceDriverBaseNameW', 'ptr', $pDriver, 'wstr', '',  'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetDeviceDriverFileName($pDriver)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetDeviceDriverFileNameW', 'ptr', $pDriver, 'wstr', '',  'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetExitCodeProcess($hProcess)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetExitCodeProcess', 'handle', $hProcess, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetGuiResources($iFlag = 0, $hProcess = -1)
If $hProcess = -1 Then $hProcess = _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hProcess, "dword", $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetModuleFileNameEx($hProcess, $hModule = 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetModuleFileNameExW', 'handle', $hProcess, 'handle', $hModule,  'wstr', '', 'int', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetModuleInformation($hProcess, $hModule = 0)
Local $tMODULEINFO = DllStructCreate($tagMODULEINFO)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetModuleInformation', 'handle', $hProcess, 'handle', $hModule,  'struct*', $tMODULEINFO, 'dword', DllStructGetSize($tMODULEINFO))
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tMODULEINFO
EndFunc
Func _WinAPI_GetParentProcess($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
Local $iResult = 0
$hSnapshot = $hSnapshot[0]
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $iPID Then
$iResult = DllStructGetData($tPROCESSENTRY32, 'ParentProcessID')
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $iResult Then Return SetError($iError, 0, 0)
Return $iResult
EndFunc
Func _WinAPI_GetPriorityClass($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetPriorityClass', 'handle', $hProcess[0])
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetProcessAffinityMask($hProcess)
Local $aResult = DllCall("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $hProcess, "dword_ptr*", 0, "dword_ptr*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Local $aMask[3]
$aMask[0] = True
$aMask[1] = $aResult[2]
$aMask[2] = $aResult[3]
Return $aMask
EndFunc
Func _WinAPI_GetProcessCommandLine($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
$hProcess = $hProcess[0]
Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
Local $tCMD
Local $aRet, $iError = 0
Do
$aRet = DllCall('ntdll.dll', 'long', 'NtQueryInformationProcess', 'handle', $hProcess, 'ulong', 0, 'struct*', $tPBI,  'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
If @error Or $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'struct*', $tPEB,  'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 40
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'struct*', $tUPP,  'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 50
ExitLoop
EndIf
$tCMD = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCommandLine') & ']')
If @error Then
$iError = @error + 60
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tUPP, 'CommandLine'), 'struct*', $tCMD,  'ulong_ptr', DllStructGetSize($tCMD), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 70
ExitLoop
EndIf
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If $iError Then Return SetError($iError, 0, '')
Return StringStripWS(_WinAPI_PathGetArgs(_WinAPI_GetString(DllStructGetPtr($tCMD, 1))), $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndFunc
Func _WinAPI_GetProcessFileName($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
Local $sPath = _WinAPI_GetModuleFileNameEx($hProcess[0])
Local $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError(@error, 0, '')
Return $sPath
EndFunc
Func _WinAPI_GetProcessHandleCount($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessHandleCount', 'handle', $hProcess[0], 'dword*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetProcessID($hProcess)
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetProcessId', 'handle', $hProcess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetProcessIoCounters($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tIO_COUNTERS = DllStructCreate('uint64[6]')
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessIoCounters', 'handle', $hProcess[0], 'struct*', $tIO_COUNTERS)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[6]
For $i = 0 To 5
$aResult[$i] = DllStructGetData($tIO_COUNTERS, 1, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetProcessMemoryInfo($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tPMC_EX = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr')
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetProcessMemoryInfo', 'handle', $hProcess[0], 'struct*', $tPMC_EX,  'int', DllStructGetSize($tPMC_EX))
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[10]
For $i = 0 To 9
$aResult[$i] = DllStructGetData($tPMC_EX, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_GetProcessName($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 20, @extended, '')
$hSnapshot = $hSnapshot[0]
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $iPID Then
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If $iError Then Return SetError($iError, 0, '')
If Not $aRet[0] Then SetError(10, 0, '')
Return DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndFunc
Func _WinAPI_GetProcessTimes($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tFILETIME = DllStructCreate($tagFILETIME)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessTimes', 'handle', $hProcess[0], 'struct*', $tFILETIME, 'uint64*', 0,  'uint64*', 0, 'uint64*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[3]
$aResult[0] = $tFILETIME
$aResult[1] = $aRet[4]
$aResult[2] = $aRet[5]
Return $aResult
EndFunc
Func _WinAPI_GetProcessUser($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $tSID, $hToken, $aRet
Local $iError = 0
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Do
$hToken = _WinAPI_OpenProcessToken(0x00000008, $hProcess[0])
If Not $hToken Then
$iError = @error + 10
ExitLoop
EndIf
$tSID = DllStructCreate('ptr;byte[1024]')
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 1, 'struct*', $tSID,  'dword', DllStructGetSize($tSID), 'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('advapi32.dll', 'bool', 'LookupAccountSidW', 'ptr', 0, 'ptr', DllStructGetData($tSID, 1), 'wstr', '',  'dword*', 2048, 'wstr', '', 'dword*', 2048, 'uint*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop
EndIf
Until 1
If $hToken Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Local $aResult[2]
$aResult[0] = $aRet[3]
$aResult[1] = $aRet[5]
Return $aResult
EndFunc
Func _WinAPI_GetProcessWorkingDirectory($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $aRet, $iError = 0
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
$hProcess = $hProcess[0]
Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
Local $tDIR
Do
$aRet = DllCall('ntdll.dll', 'long', 'NtQueryInformationProcess', 'handle', $hProcess, 'ulong', 0, 'struct*', $tPBI,  'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
If @error Or ($aRet[0]) Then
$iError = @error + 10
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'struct*', $tPEB,  'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'struct*', $tUPP,  'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 40
ExitLoop
EndIf
$tDIR = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCurrentDirectory') & ']')
If @error Then
$iError = @error + 50
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tUPP, 'CurrentDirectory'), 'struct*', $tDIR,  'ulong_ptr', DllStructGetSize($tDIR), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 60
ExitLoop
EndIf
$iError = 0
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If $iError Then Return SetError($iError, 0, '')
Return _WinAPI_PathRemoveBackslash(_WinAPI_GetString(DllStructGetPtr($tDIR)))
EndFunc
Func _WinAPI_GetThreadDesktop($iThreadId)
Local $aRet = DllCall('user32.dll', 'handle', 'GetThreadDesktop', 'dword', $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetThreadErrorMode()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetThreadErrorMode')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWindowFileName($hWnd)
Local $iPID = 0
Local $aResult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hWnd)
If $aResult[0] Then
$aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
$iPID = $aResult[2]
EndIf
If Not $iPID Then Return SetError(1, 0, '')
Local $sResult = _WinAPI_GetProcessFileName($iPID)
If @error Then Return SetError(@error, @extended, '')
Return $sResult
EndFunc
Func _WinAPI_IsElevated()
Local $iElev, $aRet, $iError = 0
Local $hToken = _WinAPI_OpenProcessToken(0x0008)
If Not $hToken Then Return SetError(@error + 10, @extended, False)
Do
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 20, 'uint*', 0, 'dword', 4,  'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
$iElev = $aRet[3]
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 18, 'uint*', 0, 'dword', 4,  'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 20
ExitLoop
EndIf
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
If $iError Then Return SetError($iError, 0, False)
Return SetExtended($aRet[0] - 1, $iElev)
EndFunc
Func _WinAPI_IsProcessInJob($hProcess, $hJob = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsProcessInJob', 'handle', $hProcess, 'handle', $hJob, 'bool*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
Return $aRet[3]
EndFunc
Func _WinAPI_OpenJobObject($sName, $iAccess = $JOB_OBJECT_ALL_ACCESS, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenJobObjectW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenMutex($sMutex, $iAccess = $MUTEX_ALL_ACCESS, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenMutexW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func _WinAPI_OpenProcessToken($iAccess, $hProcess = 0)
If Not $hProcess Then
$hProcess = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
$hProcess = $hProcess[0]
EndIf
Local $aRet = DllCall('advapi32.dll', 'bool', 'OpenProcessToken', 'handle', $hProcess, 'dword', $iAccess, 'handle*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_OpenSemaphore($sSemaphore, $iAccess = 0x001F0003, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenSemaphoreW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryInformationJobObject($hJob, $iJobObjectInfoClass, ByRef $tJobObjectInfo)
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryInformationJobObject', 'handle', $hJob, 'int', $iJobObjectInfoClass,  'struct*', $tJobObjectInfo, 'dword', DllStructGetSize($tJobObjectInfo), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[5]
EndFunc
Func _WinAPI_ReleaseMutex($hMutex)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseMutex', 'handle', $hMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseSemaphore', 'handle', $hSemaphore, 'long', $iIncrease, 'long*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_ResetEvent($hEvent)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ResetEvent', 'handle', $hEvent)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetEvent($hEvent)
Local $aResult = DllCall("kernel32.dll", "bool", "SetEvent", "handle", $hEvent)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetInformationJobObject($hJob, $iJobObjectInfoClass, $tJobObjectInfo)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetInformationJobObject', 'handle', $hJob, 'int', $iJobObjectInfoClass,  'struct*', $tJobObjectInfo, 'dword', DllStructGetSize($tJobObjectInfo))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPriorityClass($iPriority, $iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000600 : 0x00001200),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 10, @extended, 0)
Local $iError = 0
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetPriorityClass', 'handle', $hProcess[0], 'dword', $iPriority)
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetProcessAffinityMask($hProcess, $iMask)
Local $aResult = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hProcess, "ulong_ptr", $iMask)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetThreadDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'SetThreadDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetThreadErrorMode($iMode)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetThreadErrorMode', 'dword', $iMode, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_SetThreadExecutionState($iFlags)
Local $aRet = DllCall('kernel32.dll', 'dword', 'SetThreadExecutionState', 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TerminateJobObject($hJob, $iExitCode = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'TerminateJobObject', 'handle', $hJob, 'uint', $iExitCode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TerminateProcess($hProcess, $iExitCode = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'TerminateProcess', 'handle', $hProcess, 'uint', $iExitCode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UserHandleGrantAccess($hObject, $hJob, $bGrant)
Local $aRet = DllCall('kernel32.dll', 'bool', 'UserHandleGrantAccess', 'handle', $hObject, 'handle', $hJob, 'bool', $bGrant)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_WaitForInputIdle($hProcess, $iTimeout = -1)
Local $aResult = DllCall("user32.dll", "dword", "WaitForInputIdle", "handle", $hProcess, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForMultipleObjects($iCount, $paHandles, $bWaitAll = False, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $iCount, "struct*", $paHandles, "bool", $bWaitAll, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForSingleObject($hHandle, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hHandle, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WriteConsole($hConsole, $sText)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteConsoleW", "handle", $hConsole, "wstr", $sText,  "dword", StringLen($sText), "dword*", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
$aGameName = "Atlas"
Global $aFolderTemp = @ScriptDir & "\" & $aGameName & "UtilFiles\"
If Not FileExists($aFolderTemp) Then
Do
DirCreate($aFolderTemp)
Until FileExists($aFolderTemp)
EndIf
FileInstall("G:\Game Server Files\AutoIT\AtlasServerUpdateUtility\Resources\AtlasUtilFiles\i_button_green_left1.png", $aFolderTemp, 0)
FileInstall("G:\Game Server Files\AutoIT\AtlasServerUpdateUtility\Resources\AtlasUtilFiles\i_button_red_left1.png", $aFolderTemp, 0)
FileInstall("G:\Game Server Files\AutoIT\AtlasServerUpdateUtility\Resources\AtlasUtilFiles\i_check_gray_left1.png", $aFolderTemp, 0)
FileInstall("G:\Game Server Files\AutoIT\AtlasServerUpdateUtility\Resources\AtlasUtilFiles\i_check_green_left1.png", $aFolderTemp, 0)
FileInstall("G:\Game Server Files\AutoIT\AtlasServerUpdateUtility\Resources\AtlasUtilFiles\i_toggle_off_left0.png", $aFolderTemp, 0)
FileInstall("G:\Game Server Files\AutoIT\AtlasServerUpdateUtility\Resources\AtlasUtilFiles\i_toggle_on_left0.png", $aFolderTemp, 0)
$aUtilVerStable = "v1.8.0"
$aUtilVerBeta = "v1.8.0"
Global $aUtilVerNumber = 16
$aUtilName = "AtlasServerUpdateUtility"
$aServerEXE = "ShooterGameServer.exe"
$aConfigFile = "ServerGrid.json"
$aExperimentalString = "latest_experimental"
$aServerVer = 0
Global $aDuplicateErrorFile = @ScriptDir & "\__DUPLICATE_PORTS_IN_" & $aConfigFile & "__.txt"
Global $oErrorHandler = ObjEvent("AutoIt.Error", "_ErrFunc")
Global $aObjErrFunc = "System"
Func _ErrFunc($oError = 0)
$tErr = @ScriptName & " (" & $oError.scriptline & ") : ==> COM Error intercepted !" & @CRLF & @TAB & "err.number is: " & @TAB & @TAB & "0x" & Hex($oError.number) & @CRLF & @TAB & "err.windescription:" & @TAB & $oError.windescription & @CRLF & @TAB & "err.description is: " & @TAB & $oError.description & @CRLF & @TAB & "err.source is: " & @TAB & @TAB & $oError.source & @CRLF & @TAB & "err.helpfile is: " & @TAB & $oError.helpfile & @CRLF & @TAB & "err.helpcontext is: " & @TAB & $oError.helpcontext & @CRLF & @TAB & "err.lastdllerror is: " & @TAB & $oError.lastdllerror & @CRLF & @TAB & "err.scriptline is: " & @TAB & $oError.scriptline & @CRLF & @TAB & "err.retcode is: " & @TAB & "0x" & Hex($oError.retcode) & @CRLF
LogWrite(" [" & $aObjErrFunc & "] Error in ObjEvent:0x" & Hex($oError.number) & " Description:" & $oError.description, " [" & $aObjErrFunc & "] " & $tErr)
EndFunc
Global $aSteamAppID = "1006030"
Global $aSteamDBURLPublic = "https://steamdb.info/app/" & $aSteamAppID & "/depots/?branch=public"
Global $aSteamDBURLExperimental = "https://steamdb.info/app/" & $aSteamAppID & "/depots/?branch=public"
Global $aRCONBroadcastCMD = "broadcast"
Global $aRCONSaveGameCMD = "saveworld"
Global $aRCONShutdownCMD = "DoExit"
Global $aServerWorldFriendlyName = "temp"
Global $aModAppWorkshop = "appworkshop_834910.acf"
Global $aRebootReason = ""
Global $xCustomRCONRebootNumber = -1
Global $aServerName = $aGameName
$aServerUpdateLinkVerStable = "http://www.phoenix125.com/share/atlas/atlaslatestver.txt"
$aServerUpdateLinkVerBeta = "http://www.phoenix125.com/share/atlas/atlaslatestbeta.txt"
$aServerUpdateLinkDLStable = "http://www.phoenix125.com/share/atlas/AtlasServerUpdateUtility.zip"
$aServerUpdateLinkDLBeta = "http://www.phoenix125.com/share/atlas/AtlasServerUpdateUtilityBeta.zip"
$aServerBatchFile = @ScriptDir & "\_start_" & $aUtilName & ".bat"
Global $aWebsite = "http://www.phoenix125.com/AtlasServerUpdateUtil.html"
Global $aIniFailFileFull = @ScriptDir & "\___INI_FAIL_VARIABLES___.txt"
Global $aIniFailFileBasic = $aFolderTemp & "IniFailBasic.txt"
Local $aServerSummaryFile = @ScriptDir & "\_SERVER_SUMMARY_.txt"
Global $aEventSaveFile = @ScriptDir & "\_EVENT_SCHEDULE_.txt"
Global $aUtilUpdateFile = @ScriptDir & "\__UTIL_UPDATE_AVAILABLE___.txt"
Global $aDiscordSendWebhookEXE = @ScriptDir & "\DiscordSendWebhook.exe"
Global $aUseKeepAliveYN = "yes"
Local $aKeepAliveFileVersion = "v1.4"
Global $aKeepAliveConfigFileName = $aUtilName & "KeepAlive.ini"
Global $aKeepAliveConfigFileFull = @ScriptDir & "\" & $aKeepAliveConfigFileName
Global $aKeepAliveFileName = $aUtilName & "KeepAlive_" & $aKeepAliveFileVersion
Global $aKeepAliveFileExe = $aUtilName & "KeepAlive_" & $aKeepAliveFileVersion & ".exe"
Global $aKeepAliveFileZip = $aUtilName & "KeepAlive_" & $aKeepAliveFileVersion & ".zip"
Global $aFirstModBoot = True
Global $iIniErrorCRLF = ""
Global $aModMsgInGame[10]
Global $aModMsgDiscord[10]
Global $aModMsgTwitch[10]
Global $aFirstBoot = True
Local $aFirstStartDiscordAnnounce = True
Global $aShowUpdate = False
Global $aConfigFolder = @ScriptDir & "\_Config"
Global $aPreviousVersionsNameFolder = "\Previous_Versions"
Global $aPreviousVersionsFolder = @ScriptDir & $aPreviousVersionsNameFolder
Global $aIniFile = $aConfigFolder & "\" & $aUtilName & ".ini"
Global $aGridSelectFile = $aConfigFolder & "\" & $aUtilName & "GridStartSelect.ini"
Global $aPIDRedisFile = $aFolderTemp & $aUtilName & "_lastpidredis.tmp"
Global $aPIDServerFile = $aFolderTemp & $aUtilName & "_lastpidserver.tmp"
Global $aUtilCFGFile = $aFolderTemp & $aUtilName & "_cfg.ini"
Global $aParametersFile = $aConfigFolder & "\GridParameters.csv"
Global $aFolderLog = @ScriptDir & "\_Log\"
Global $aSteamCMDDir = @ScriptDir & "\SteamCMD"
Global $aExportDataFolder = @ScriptDir & "\ExportData"
Global $aExportMainGUIGridFile = $aExportDataFolder & "\MainGUIData.txt"
Global $aOnlinePlayerWebFile = $aExportDataFolder & "\OnlineUsers.txt"
Global $aBatFolder = @ScriptDir & "\Batch Files (to run " & $aGameName & " manually)"
Global $aBatUpdateGame = "Update" & $aGameName & ".bat"
Global $aPIDServerReadYetTF = False
Global $aPIDRedisreadYetTF = False
Global $aServerUseRedis = "yes"
Global $aCloseServerTF = False
Global $aSteamUpdateNow = False
Global $aRCONError = False
Global $aServerReadyTF = False
$aServerReadyOnce = True
Global $aNoExistingPID = True
Global $aGUIW = 500
Global $aGUIH = 250
Global $aPlayerCountShowTF = True
Global $aPlayerCountWindowTF = False
Global $wOnlinePlayers = 0
Global $gOnlinePlayerWindow = 0
Global $tOnlinePlayerReady = False
Global $tTotalLocalPlayers = 0
Global $aGridSomeRemoteTF = False
Global $aShowGUI = True
Global $aGUIMainActive = False
Global $aGUILogWindowText = ""
Global $aGUIReady = False
Global $sGridIniReWrite = False
Global $LabelUtilReadyStatus = 0
Global $xServerAltSaveDir
Global $tUtilUpdateAvailableTF = False
Global $IconReady = 0
Global $aSelectServers = False
Global $tSelectServersTxt = ""
Global $aExitGUIW2 = False
Global $aExitGUIW1 = False
Global $aExitGUIW3 = False
Global $aExitGUIT1 = False
Global $aExitGUISF1 = False
Global $wSelectFolder = 99999
Global $aWizardSelect = 99999
Global $ConfigEditWindow = 99999
Global $wGridConfig = 99999, $wToolsWindow = 99999
Global $aGUITools = 99999
Global $aConfigEditWindow = False
Global $LogWindow = 99999
Global $MainWindow = -1, $gOnlinePlayerWindow = 99999, $wGUIMainWindow = -1
Global $WizardWindowNew = 99999, $WizardWindowExist = 99999, $WizardWindowSelect = 99999
Global $aCPUOverallTracker, $fPercent
Global $aCPUOverallTracker = _CPUOverallUsageTracker_Create()
Global $aConfigSettingsImported = False
Global $iIniRead = False
Global $aPIDKeepAlive = 0
Global $aUtilityVer = 0, $aRemoteRestartIP = 0, $aRemoteRestartPort = 0, $aRemoteRestartUse = 0
Global $tSplashTF = True
Global $xServerRCONPort
Global $aServerGridTotal
Global $aWizExistFinished = False
$aServerRedisCmd = "redis-server.exe"
$aServerRedisDir = "\AtlasTools\RedisDatabase"
Global $aServerPIDRedis = 0
Global $aServersMax = 400
Global $xTelnetCMD[$aServersMax]
Global $xServerStart[$aServersMax]
Global $aServerPID[$aServersMax]
Global $yServerAltSaveDir[$aServersMax]
Global $xServerModList[50]
Global $aServerModList = ""
Global $xServerGridExtraCMD[$aServersMax]
Global $xGridStartDelay[$aServersMax]
Global $xServerCrashNumber[$aServersMax]
Global $xServerCPU[$aServersMax]
Global $aSteamRunCount = 0
Global $aSteamFailCount = 0
If @Compiled = 0 Then
Global $aIconFile = "AtlasServerUpdateUtility_Icons.exe"
Else
Global $aIconFile = @ScriptName
EndIf
#OnAutoItStartRegister "OnAutoItStart"
Global $__Restart = False
Global $cSWRunning = "0x388E3C"
Global $cSWOffline = "0xE65100"
Global $cSWDisabled = "0x666666"
Global $cSWCrashed = "0xc40233"
Global $cSWStarting = "0x0c62ef"
Global $cMWBackground = "0x646464"
Global $cMWMemCPU = "0xFFFF00"
Global $cSWButtonStartServer = "0xA5B89B"
Global $cSWButtonStopServer = "0xB89B9B"
Global $cSWButtonRestartUtil = "0xD3D17F"
Global $cSWBackground = "0xC8C8C8"
Global $cLWBackground = "0x808080"
Global $cSWTextHL2 = "0xc40233"
Global $cFWBackground = "0xE0E0E0"
Global $fFWFixedFont = "Courier New"
Global $cFWTabBackground = "0xE0E0E0"
Global $cW1Background = "0x979A9A"
Global $cW2Background = "0x979A9A"
Global $cW3Background = "0x979A9A"
Global $cT1Background = "0x979A9A"
Global $cGGridButtonActive = "0xFFFF00"
Global $cGGridButtonInactive = "0xD7DBDD"
Global $cGGridSaveButtonActive = "0xFEAF69"
Global $cGGridButtonSave = "0xA5B89B"
Global $cTextActive = "0x10240E"
Global $cTextInactive = "0x7F8C8D"
Global $cTextHighlight = "0xFDFFD3"
Global $cTextUnHighlight = "0xF0F0F0"
Global $cButtonFadedBlue = "0xCBDDFF"
Global $aTotalPlayersOnline = "0"
$aTelnetCheckYN = "no"
$aTelnetCheckSec = "300"
$aTelnetPort = "27520"
$aTelnetPass = "TeLneT_PaSsWoRd"
$aServerVer = "0"
$aServerIP = "127.0.0.1"
#Region
Global $aLogFile = $aFolderLog & $aUtilName & "_Log_" & @YEAR & "-" & @MON & "-" & @MDAY & ".txt"
Global $aLogDebugFile = $aFolderLog & $aUtilName & "_LogFull_" & @YEAR & "-" & @MON & "-" & @MDAY & ".txt"
Global $aOnlinePlayerFile = $aFolderLog & $aUtilName & "_OnlineUserLog_" & @YEAR & "-" & @MON & "-" & @MDAY & ".txt"
Global $aTimeCheck0 = _NowCalc()
Global $aTimeCheck1 = _NowCalc()
Global $aTimeCheck2 = _NowCalc()
Global $aTimeCheck3 = _NowCalc()
Global $aTimeCheck4 = _NowCalc()
Global $aTimeCheck5 = _NowCalc()
Global $aTimeCheck6 = _NowCalc()
Global $aTimeCheck7 = _NowCalc()
Global $aTimeCheck8 = _NowCalc()
$aBeginDelayedShutdown = 0
Global $aUpdateVerify = "no"
$aFailCount = 0
$aShutdown = 0
$aAnnounceCount1 = 0
$aErrorShutdown = 0
Global $aIniForceWrite = False
#EndRegion
Global Enum $WinHttpRequestOption_UserAgentString, $WinHttpRequestOption_URL, $WinHttpRequestOption_URLCodePage, $WinHttpRequestOption_EscapePercentInURL, $WinHttpRequestOption_SslErrorIgnoreFlags, $WinHttpRequestOption_SelectCertificate, $WinHttpRequestOption_EnableRedirects, $WinHttpRequestOption_UrlEscapeDisable, $WinHttpRequestOption_UrlEscapeDisableQuery, $WinHttpRequestOption_SecureProtocols, $WinHttpRequestOption_EnableTracing, $WinHttpRequestOption_RevertImpersonationOverSsl, $WinHttpRequestOption_EnableHttpsToHttpRedirects, $WinHttpRequestOption_EnablePassportAuthentication, $WinHttpRequestOption_MaxAutomaticRedirects, $WinHttpRequestOption_MaxResponseHeaderSize, $WinHttpRequestOption_MaxResponseDrainSize, $WinHttpRequestOption_EnableHttp1_1, $WinHttpRequestOption_EnableCertificateRevocationCheck
Global Const $WinHttpRequestOption_SslErrorIgnoreFlags_UnknownCA = 0x0100
Global Const $WinHttpRequestOption_SslErrorIgnoreFlags_CertWrongUsage = 0x0200
Global Const $WinHttpRequestOption_SslErrorIgnoreFlags_CertCNInvalid = 0x1000
Global Const $WinHttpRequestOption_SslErrorIgnoreFlags_CertDateInvalid = 0x2000
Global Const $WinHttpRequestOption_SslErrorIgnoreFlags_IgnoreAll = 0x3300
Opt("GUIOnEventMode", 1)
#Region
OnAutoItExitRegister("Gamercide")
Global $aCFGLastVerNumber = IniRead($aUtilCFGFile, "CFG", "aCFGLastVerNumber", 0)
If $aCFGLastVerNumber < 12 Then
Local $xUtilBetaYN = IniRead(@ScriptDir & "\AtlasServerUpdateUtility.ini", " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", $aUtilName & " version: (0)Stable, (1)Beta ###", 0)
Else
Local $xUtilBetaYN = IniRead($aIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", $aUtilName & " version: (0)Stable, (1)Beta ###", 0)
EndIf
Local $xUtilBetaYN = IniRead($aIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", $aUtilName & " version: (0)Stable, (1)Beta ###", 0)
If $xUtilBetaYN = "1" Then
Global $aUtilVersion = $aUtilVerBeta
Else
Global $aUtilVersion = $aUtilVerStable
EndIf
Global $aUtilityVer = $aUtilName & " " & $aUtilVersion
If FileExists($aFolderTemp) = 0 Then DirCreate($aFolderTemp)
If FileExists($aFolderLog) = 0 Then DirCreate($aFolderLog)
If FileExists($aExportDataFolder) = 0 Then DirCreate($aExportDataFolder)
If FileExists($aConfigFolder) = 0 Then DirCreate($aConfigFolder)
LogWrite(" ============================ " & $aUtilName & " " & $aUtilVersion & " Started ============================")
Global $aIniExist = False
If FileExists($aIniFile) Then
_FileWriteToLine($aIniFile, 3, "Version  :  " & $aUtilityVer, True)
$aIniExist = True
Else
If FileExists(@ScriptDir & "\AtlasServerUpdateUtility.ini") Then $aIniExist = True
If FileExists(@ScriptDir & "\Config\AtlasServerUpdateUtility.ini") Then $aIniExist = True
EndIf
Global $aStartText = $aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF
Global $aSplashStartUp = _Splash($aStartText, 0, 475)
FileDelete($aServerBatchFile)
FileWrite($aServerBatchFile, "@echo off" & @CRLF & "START """ & $aUtilName & """ """ & @ScriptDir & "\" & $aUtilName & "_" & $aUtilVersion & ".exe""" & @CRLF & "EXIT")
If $aUseKeepAliveYN = "yes" Then
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "Program to Keep Alive ###", $aUtilName & "_" & $aUtilVersion & ".exe")
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "Program to run ###", @ScriptDir & "\" & $aUtilName & "_" & $aUtilVersion & ".exe")
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Close AtlasServerUpdateUtilityKeepAlive? (Checked prior to restarting above Program... used when purposely shutting down above Program)(yes/no) ###", "no")
If @Compiled = 1 Then
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Is program compiled? (yes/no) ###", "yes")
Else
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Is program compiled? (yes/no) ###", "no")
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "Program to run ###", @AutoItExe & ' "' & @ScriptFullPath & '" ' & $CmdLineRaw)
EndIf
KeepUtilAliveCounter()
AdlibRegister("KeepUtilAliveCounter", 60000)
EndIf
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Importing settings from " & $aUtilName & "_cfg.ini")
ReadCFG($aUtilCFGFile)
If FileExists(@ScriptDir & "\" & $aUtilName & "_lastpidredis.tmp") Then FileMove(@ScriptDir & "\" & $aUtilName & "_lastpidredis.tmp", $aPIDRedisFile)
If FileExists(@ScriptDir & "\" & $aUtilName & "_lastpidserver.tmp") Then FileMove(@ScriptDir & "\" & $aUtilName & "_lastpidserver.tmp", $aPIDServerFile)
FileMove(@ScriptDir & "\mod_*.tmp", $aFolderTemp & "*.*", 1)
FileMove(@ScriptDir & "\*.log*", $aFolderLog & "*.*", 1)
If $aCFGLastVerNumber < 1 And $aIniExist Then
$aIniForceWrite = True
Local $aServerAltSaveDirOld = IniRead($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryName(s) (comma separated. Use same order as listed in ServerGrid.json. Leave blank for default 00,01,10, etc) ###", 0)
If $aServerAltSaveDirOld <> "" Then
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames (Use same order as listed in ServerGrid.json. Comma separated) ###", $aServerAltSaveDirOld)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", 3)
Else
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames (Use same order as listed in ServerGrid.json. Comma separated) ###", "")
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", 1)
EndIf
EndIf
If $aCFGLastVerNumber < 2 And $aIniExist Then
$aIniForceWrite = True
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND COUNT --------------- ", "Number of custom RCON Commands to schedule (If changed, util will restart and new custom entries will be added) ###", 1)
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND 1 --------------- ", "1-RCON Command(s) to send (Separated by ~, leave BLANK to skip) ###", "")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND 1 --------------- ", "1-RCON Command send to (0) ALL grids or (1) Local Grids Only ###", 1)
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND 1 --------------- ", "1-File to Execute (leave BLANK to skip) ###", "")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND 1 --------------- ", "1-Scheduled Event days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", 0)
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND 1 --------------- ", "1-Scheduled Event hours (comma separated 00-23 ex.04,16) ###", 4)
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND 1 --------------- ", "1-Scheduled Event minute (00-59) ###", "00")
IniWrite($aUtilCFGFile, "CFG", "aCFGRCONCustomLastCount", 1)
IniWrite($aUtilCFGFile, "CFG", "aCFGRCONCustomShowConfig", "no")
EndIf
If $aCFGLastVerNumber < 4 And $aIniExist Then
$aIniForceWrite = True
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Start servers minimized (for a cleaner look)? (yes/no) ###", "yes")
EndIf
If $aCFGLastVerNumber < 5 And $aIniExist Then
Local $tTmp = IniRead($aIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Check for " & $aUtilName & " updates? (yes/no) ###", "")
If $tTmp = "no" Then
Local $tTmp1 = 0
Else
Local $tTmp1 = 4
EndIf
IniWrite($aIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Check for " & $aUtilName & " updates every __ hours (0 to disable) (0-24) ###", $tTmp1)
IniWrite($aIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Automatically install " & $aUtilName & " updates? (yes/no) ###", "no")
$aIniForceWrite = True
Local $tObfuscatePass = IniRead($aIniFile, " --------------- LOG FILE OPTIONS --------------- ", "Hide passwords in log files? (yes/no) ###", "no")
IniWrite($aIniFile, " --------------- LOG FILE OPTIONS --------------- ", "Hide passwords in log files? (yes/no) ###", $tObfuscatePass)
IniWrite($aIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before STOP SERVER (comma separated 0-60) ###", "1,3")
IniWrite($aIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", "Servers shutting down in \m minute(s) for maintenance.")
IniWrite($aIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", "Server is shutting down in \m minute(s) for maintenance.")
IniWrite($aIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", "Server is shutting down in \m minute(s) for maintenance.")
IniWrite($aIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for STOP SERVER? (yes/no) ###", "no")
IniWrite($aIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for STOP SERVER? (yes/no) ###", "no")
EndIf
If $aCFGLastVerNumber < 6 And $aIniExist Then
Local $tServerAltSaveSelect = IniRead($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", "2")
IniWrite($aIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement grid naming scheme: Use (1) 00 01 (2) A1 A2 (3) 0,0 0,1 ###", "2")
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Grid naming scheme: Use (1) 00 01 (2) A1 A2 (3) 0,0 0,1 ###", $tServerAltSaveSelect)
$aIniForceWrite = True
EndIf
If ($aCFGLastVerNumber < 7) And ($xUtilBetaYN = 1) And $aIniExist Then
IniWrite($aIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Run KeepAlive program to detect util crashes and restart it? (yes/no) ###", "yes")
$aIniForceWrite = True
EndIf
If $aCFGLastVerNumber < 8 And $aIniExist Then
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Max time (minutes) to wait for each mod to download (0-180) (0-No Timeout) ###", 10)
$aIniForceWrite = True
EndIf
If $aCFGLastVerNumber < 9 And $aIniExist Then
$aEventCount = IniRead($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND COUNT --------------- ", "Number of custom RCON Commands to schedule (If changed, util will restart and new custom entries will be added) ###", "")
Global $xCustomRCONCmd[$aEventCount], $xEventDays[$aEventCount]
For $i = 0 To ($aEventCount - 1)
$xCustomRCONCmd[$i] = IniRead($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-RCON Command to send (leave BLANK to skip) ###", "")
$xEventDays[$i] = IniRead($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", "")
$sInGameAnnounce = IniRead($aIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announce messages in-game? (Requires telnet) (yes/no) ###", "")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Event Name ###", "Event " & ($i + 1))
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Months (comma separated 0-Monthly, 1-12) ###", "0")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Days of Month (comma separated 0-Use Weekday Below, 1-31) ###", "0")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-RCON Command(s) to send (Separated by ~, leave BLANK to skip) ###", $xCustomRCONCmd[$i])
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Weekdays (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $xEventDays[$i])
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Restart servers afterward? (with announcements below) (yes/no) ###", "no")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Announcement _ minutes before reboot (comma separated 1-60) ###", "")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-In-Game Message to send (\m - minutes)(leave BLANK to skip) ###", "")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Discord Message to send (\m - minutes)(leave BLANK to skip) ###", "")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Twitch Message to send (\m - minutes)(leave BLANK to skip) ###", "")
IniWrite($aIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announce messages in-game? (Requires RCON) (yes/no) ###", $sInGameAnnounce)
IniWrite($aIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Time to wait for RCON response in milliseconds (100-3000) ###", 1500)
IniWrite($aIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Time to wait for Online Players RCON response in milliseconds (100-3000) ###", 1500)
Next
$aIniForceWrite = True
EndIf
If $aCFGLastVerNumber < 10 And $aIniExist Then
IniWrite($aIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Update the Main Window data every __ seconds (2-60) ###", 10)
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Close AtlasServerUpdateUtilityKeepAlive? (Checked prior to restarting above Program... used when purposely shutting down above Program)(yes/no) ###", "yes")
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Shutting down AtlasServerUpdateUtilityKeepAlive (if running) for update.")
Sleep(5000)
$aIniForceWrite = True
EndIf
If $aCFGLastVerNumber < 11 And $aIniExist Then
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Max hang time before restarting program? (90-600) ###", 180)
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Use scheduled backups? (yes/no) ###", "yes")
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Backup days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", 0)
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Backup hours (comma separated 00-23 ex.04,16) ###", "06,12,18,00")
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Backup minute (00-59) ###", "00")
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Output folder ###", @ScriptDir & "\Backups")
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Number of backups to keep (1-999) ###", 56)
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Max time in seconds to wait for backup to complete (30-999) ###", 300)
$aIniForceWrite = True
EndIf
If $aCFGLastVerNumber < 12 And $aIniExist Then
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Performing one-time update." & @CRLF & "Moving files . . .")
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Redis folder (leave blank to use redis folder above or to disable) ###", "")
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "In-Game announcement when backup initiated (Leave blank to disable) ###", "Server backup in progress.")
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Discord announcement when backup initiated (Leave blank to disable) ###", "")
IniWrite($aIniFile, " --------------- BACKUP --------------- ", "Twitch announcement when backup initiated (Leave blank to disable) ###", "")
IniWrite($aIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Folder to place config files ###", @ScriptDir & "\Config")
DirCreate(@ScriptDir & "\Config")
FileMove(@ScriptDir & "\AtlasServerUpdateUtility.ini", @ScriptDir & "\Config\AtlasServerUpdateUtility.ini", 1)
FileMove(@ScriptDir & "\AtlasServerUpdateUtilityGridStartSelect.ini", @ScriptDir & "\Config\AtlasServerUpdateUtilityGridStartSelect.ini", 1)
FileMove(@ScriptDir & "\*.bak", @ScriptDir & "\Config\*.*", 1)
$aIniForceWrite = True
EndIf
If $aCFGLastVerNumber < 13 And $aIniExist Then
IniWrite($aIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos minute (0-59) ###", "00")
$aIniForceWrite = True
EndIf
If $aCFGLastVerNumber < 14 And $aIniExist Then
IniWrite($aIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Approximate duration to display messages in-game (seconds)? (6-30) ###", "15")
$aIniForceWrite = True
EndIf
If $aCFGLastVerNumber < 15 And $aIniExist Then
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Performing one-time update." & @CRLF & "Moving files . . .")
FileMove(@ScriptDir & "\Config\*.*", $aConfigFolder & "\*.*", $FC_CREATEPATH + $FC_OVERWRITE)
FileMove(@ScriptDir & "\AtlasServerUpdateUtility*.*", $aPreviousVersionsFolder & "\*.*", $FC_CREATEPATH + $FC_OVERWRITE)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Number of Online Player RCON retry attempts (0-3) ###", "3")
DirRemove(@ScriptDir & "\Config")
EndIf
If $aCFGLastVerNumber < 16 And $aIniExist Then
FileCopy($aPreviousVersionsFolder & "\AtlasServerUpdateUtility_v1.7.6.exe", @ScriptDir & "\AtlasServerUpdateUtility_v1.7.6.exe", $FC_CREATEPATH + $FC_OVERWRITE)
EndIf
Local $tFileName = IniRead($aUtilCFGFile, "CFG", "aCFGPreviousVersionToArchive", "")
If $tFileName <> "" Then
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Archiving """ & $tFileName & "" & @CRLF & " to folder: """ & $aPreviousVersionsNameFolder & "\")
FileMove(@ScriptDir & "\" & $tFileName & ".*", $aPreviousVersionsFolder & "\" & $tFileName & ".*", $FC_CREATEPATH + $FC_OVERWRITE)
LogWrite(" [Util] Archived """ & $tFileName & """ to folder: """ & $aPreviousVersionsFolder & "\")
EndIf
If Not FileExists(@ScriptFullPath) Then FileCopy($aPreviousVersionsFolder & "\" & @ScriptName, @ScriptFullPath)
If Not @Compiled Then FileCopy($aPreviousVersionsFolder & "\AtlasServerUpdateUtility_Icons.exe", @ScriptDir)
Local $tPID = WinGetProcess("AtlasServerUpdateUtility v")
If $tPID > 0 Then
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Another instance of Util PID[" & $tPID & "] is running." & @CRLF & "Waiting 5 seconds for it to close.")
Sleep(5000)
Local $tPID = WinGetProcess("AtlasServerUpdateUtility v")
If $tPID > 0 Then
SplashOff()
LogWrite(" [Util] Another instance of " & $aUtilName & " PID[" & $tPID & "] is already running.")
Local $aMsg = "Another instance of " & $aUtilName & " PID[" & $tPID & "] is already running." & @CRLF & @CRLF & "Click (YES) to CLOSE the OTHER instance and continue running this one." & @CRLF & "Click (NO) to continue running this instance." & @CRLF & "Click (CANCEL) to exit utility."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Then
LogWrite(" [Util] Closing the other instance and continue running this one.")
ProcessClose($tPID)
$aSplashStartUp = _Splash("Closing the other instance and continue running this one.", 2000)
If $aUseKeepAliveYN = "yes" Then IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Close AtlasServerUpdateUtilityKeepAlive? (Checked prior to restarting above Program... used when purposely shutting down above Program)(yes/no) ###", "no")
ElseIf $tMB = 7 Then
LogWrite(" [Util] Continuing to run this instance.")
$aSplashStartUp = _Splash("Continuing to run this instance.", 2000)
ElseIf $tMB = 2 Then
LogWrite(" [Util] Exiting utility.")
_Splash($aUtilName & " exiting.", 2000)
Exit
EndIf
EndIf
EndIf
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Importing settings from " & $aUtilName & ".ini.")
Local $tRunConfig = IniRead($aUtilCFGFile, "CFG", "aCFGRCONCustomShowConfig", "no")
Local $aRunWizard = ReadUini($aIniFile, $aLogFile)
If $tRunConfig = "yes" Then
Global $aServerUseRedis = ""
ConfigEdit($aSplashStartUp)
IniWrite($aUtilCFGFile, "CFG", "aCFGRCONCustomShowConfig", "no")
EndIf
If FileExists($aIniFailFileBasic) Then
FileDelete($aIniFailFileBasic)
EndIf
If FileExists($aIniFailFileFull) Then
FileDelete($aIniFailFileFull)
EndIf
Global $aConfigFull = $aServerDirLocal & "\ShooterGame\" & $aConfigFile
Global $aDefaultGame = $aServerDirLocal & "\ShooterGame\Config\DefaultGame.ini"
Global $aDefaultGUS = $aServerDirLocal & "\ShooterGame\Config\DefaultGameUserSettings.ini"
Global $aDefaultEngine = $aServerDirLocal & "\ShooterGame\Config\DefaultEngine.ini"
If ($aCFGLastVersion = "v1.5.0(beta15)") Then
__ReplaceCRwithCRLF($aGridSelectFile)
__ReplaceCRwithCRLF($aConfigFull)
__ReplaceCRwithCRLF($aDefaultGame)
__ReplaceCRwithCRLF($aDefaultGUS)
__ReplaceCRwithCRLF($aDefaultEngine)
EndIf
Func __ReplaceCRwithCRLF($tFile)
Local $tFileOpen = FileOpen($tFile)
Local $tTxt = FileRead($tFileOpen)
Local $tTxt1 = StringRegExpReplace($tTxt, '\r\N', @CRLF)
If @extended > 0 Then
FileClose($tFileOpen)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileBak = $tFile & "_" & $tTime & ".bak"
Local $tTxt2 = StringRegExpReplace($tTxt, '(*BSR_ANYCRLF)\R', @CRLF)
FileMove($tFile, $tFileBak, 1)
FileWrite($tFile, $tTxt2)
EndIf
FileClose($tFileOpen)
EndFunc
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Checking for running server and redis processes.")
If $aUtilBetaYN = "1" Then
$aServerUpdateLinkVerUse = $aServerUpdateLinkVerBeta
$aServerUpdateLinkDLUse = $aServerUpdateLinkDLBeta
$aUtilVersion = $aUtilVerBeta
Else
$aServerUpdateLinkVerUse = $aServerUpdateLinkVerStable
$aServerUpdateLinkDLUse = $aServerUpdateLinkDLStable
$aUtilVersion = $aUtilVerStable
EndIf
$aUtilityVer = $aUtilName & " " & $aUtilVersion
If $aUtilReboot = "no" And ((_DateDiff('n', $aCFGLastUpdate, _NowCalc())) >= $aUpdateCheckInterval) And $aUpdateUtil > 0 Then
UtilUpdate($aServerUpdateLinkVerUse, $aServerUpdateLinkDLUse, $aUtilVersion, $aUtilName, $aSplashStartUp, "show")
If $tUtilUpdateAvailableTF Then $aSplashStartUp = _Splash($aStartText, 0, 475)
Else
UtilUpdate($aServerUpdateLinkVerUse, $aServerUpdateLinkDLUse, $aUtilVersion, $aUtilName, 0, "skip")
EndIf
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Importing settings from " & $aConfigFile & ".")
ImportConfig($aServerDirLocal, $aConfigFile)
$aTelnetPass = $aServerAdminPass
If $aServerAltSaveSelect = 3 Then
Global $xServerAltSaveDir = StringSplit($aServerAltSaveDir, ",", 2)
ElseIf $aServerAltSaveSelect = 2 Then
Global $xServerAltSaveDir[$aServerGridTotal]
For $i = 0 To ($aServerGridTotal - 1)
$xServerAltSaveDir[$i] = Chr(Int($xServergridx[$i]) + 65) & (Int($xServergridy[$i]) + 1)
Next
Else
Global $xServerAltSaveDir[$aServerGridTotal]
For $i = 0 To ($aServerGridTotal - 1)
$xServerAltSaveDir[$i] = $xServergridx[$i] & $xServergridy[$i]
Next
EndIf
If $aCFGLastVerNumber < 8 Then
For $i = 0 To ($aServerGridTotal - 1)
IniWrite($aGridSelectFile, " --------------- ADDITIONAL STARTUP DELAY (in seconds) --------------- ", "Additional startup delay Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (0-600)", 0)
Next
EndIf
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Importing settings from GridStartSelect.ini")
GridStartSelect($aGridSelectFile, $aLogFile)
If ($aCFGLastVerNumber = 6) Or ($aCFGLastVerNumber = 7) Then
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aGridSelectFile & "_" & $tTime & ".bak"
FileMove($aGridSelectFile, $tFile, 1)
UpdateGridSelectINI($aGridSelectFile)
EndIf
If $aServerUseRedis = "yes" Then
$aServerPIDRedis = PIDReadRedis($aPIDRedisFile, $aSplashStartUp)
Else
$aServerPIDRedis = ""
EndIf
$aServerPID = PIDReadServer($aPIDServerFile, $aSplashStartUp)
Global $aServerPlayers[$aServerGridTotal]
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Preparing server startup scripts.")
If ($aServerRCONImport = "yes") Then
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Importing RCON Ports from GameUserSettings.ini files.")
$xServerRCONPort = ImportRCON($aServerDirLocal, $xServerAltSaveDir, $aServerGridTotal, $xLocalGrid)
EndIf
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Importing ServerPVE from GameUserSettings.ini files.")
Global $xServerPVE = ImportServerPVE($aServerDirLocal, $xServerAltSaveDir, $aServerGridTotal, $xLocalGrid)
If ($sInGameAnnounce = "yes") Or ($aTelnetCheckYN = "yes") Or ($aEnableRCON = "yes") And ($aServerWorldFriendlyName <> "TempXY") Then
If $aServerGridTotal <> (UBound($xServerRCONPort) - 1) Then
SplashOff()
Local $aErrorMsg = " [CRITICAL ERROR!] The number of grids does not match the number of RCON ports listed in " & $aUtilName & ".ini." & @CRLF & "Grid Total:" & $aServerGridTotal & ". Number of RCON entries:" & (UBound($xServerRCONPort) - 1) & @CRLF & "Example: Server RCON Port(s) (comma separated, grid order left-to-right ) ###: 57510,57512,57514,57516" & @CRLF & @CRLF & "Please correct the RCON entries using the Wizard or in " & $aUtilName & ".ini file and restart " & $aUtilName & "."
LogWrite($aErrorMsg)
MsgBox($MB_OK, $aUtilityVer, $aErrorMsg)
WizardExisting(3)
If $aWizExistFinished = False Then _RestartUtil(False)
EndIf
EndIf
If $aServerGridTotal <> UBound($xServerAltSaveDir) And ($aServerWorldFriendlyName <> "TempXY") Then
SplashOff()
Local $aErrorMsg = " [CRITICAL ERROR!] The number of grids does not match the number of AltSaveDirectoryNames listed in " & $aUtilName & ".ini." & @CRLF & "Grid Total:" & $aServerGridTotal & ". Number of Server AltSaveDirectoryName entries:" & (UBound($xServerAltSaveDir)) & @CRLF & "Example: Server AltSaveDirectoryName(s) (comma separated. Leave blank for default a00 a01 a10, etc) ###" & @CRLF & @CRLF & "Please correct the AltSaveDirectoryName entries using the Wizard or in " & $aUtilName & ".ini file and restart " & $aUtilName & "."
LogWrite($aErrorMsg)
MsgBox($MB_OK, $aUtilityVer, $aErrorMsg)
WizardExisting(2)
If $aWizExistFinished = False Then _RestartUtil(False)
EndIf
If (($sInGameAnnounce = "yes") Or ($aTelnetCheckYN = "yes") Or ($aEnableRCON = "yes")) And ($aServerRCONImport = "no") Then
For $i = 0 To ($aServerGridTotal - 1)
$xTelnetCMD[$i] = "?RCONEnabled=True?RCONPort=" & $xServerRCONPort[$i + 1]
Next
Else
For $i = 0 To ($aServerGridTotal - 1)
$xTelnetCMD[$i] = ""
Next
EndIf
If Not $aServerMultiHomeIP = "" Then
$aServerMultiHomeFull = "?MultiHome=" & $aServerMultiHomeIP
Else
$aServerMultiHomeFull = ""
EndIf
$aServerDirFull = $aServerDirLocal & "\ShooterGame\Binaries\Win64"
If $aServerRedisFolder = "" Then
$xServerRedis = """" & $aServerDirLocal & $aServerRedisDir & "\" & $aServerRedisCmd & """ """ & $aServerDirLocal & $aServerRedisDir & "\" & $aServerRedisConfig & """"
Else
$xServerRedis = """" & $aServerRedisFolder & "\" & $aServerRedisCmd & """ """ & $aServerRedisFolder & "\" & $aServerRedisConfig & """"
EndIf
If $aServerModYN = "yes" Then
$aServerModCMD = " -manualmanagedmods"
Local $aMods = StringSplit($aServerModList, ",")
Global $aModName[$aMods[0] + 1]
If $aUtilReboot = "no" And ((_DateDiff('n', $aCFGLastUpdate, _NowCalc())) >= $aUpdateCheckInterval) Then
CheckMod($aServerModList, $aSteamCMDDir, $aServerDirLocal, $aSplashStartUp, True)
EndIf
Else
$aServerModCMD = ""
EndIf
$aFirstModBoot = False
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Preparing server start files.")
For $i = 0 To ($aServerGridTotal - 1)
$xServerStart[$i] = """" & $aServerDirFull & "\" & $aServerEXE & """ Ocean?ServerX=" & $xServergridx[$i] & "?ServerY=" & $xServergridy[$i] & "?AltSaveDirectoryName=" & $xServerAltSaveDir[$i] & "?ServerAdminPassword=" & $aServerAdminPass & "?MaxPlayers=" & $aServerMaxPlayers & "?ReservedPlayerSlots=" & $aServerReservedSlots & "?QueryPort=" & $xServerport[$i] & "?Port=" & $xServergameport[$i] & "?SeamlessIP=" & $xServerIP[$i] & $aServerMultiHomeFull & $xTelnetCMD[$i] & $xServerGridExtraCMD[$i] & $aServerExtraCMD & $aServerModCMD
If ($xStartGrid[$i] = "yes") Then
LogWrite("", " Imported from " & $aConfigFile & ": Server " & _ServerNamingScheme($i, $aNamingScheme) & " Port:" & $xServergameport[$i] & " GamePort:" & $xServerport[$i] & " SeamlessIP:" & $xServerIP[$i] & " RCONPort:" & $xServerRCONPort[$i + 1] & " Folder:" & $xServerAltSaveDir[$i])
EndIf
Next
Global $aSteamAppFile = $aServerDirLocal & "\steamapps\appmanifest_" & $aSteamAppID & ".acf"
If $aUtilReboot = "no" Then
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Checking for existance of external files.")
FileExistsFunc($aSplashStartUp)
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Checking for existance of external scripts (if enabled).")
EndIf
ExternalScriptExist()
If $aUseKeepAliveYN = "yes" Then
_DownloadAndExtractFile($aKeepAliveFileName, "http://www.phoenix125.com/share/atlas/" & $aKeepAliveFileZip, "https://github.com/phoenix125/AtlasServerUpdateUtilityKeepAlive/releases/download/LatestVersion/" & $aKeepAliveFileZip, $aSplashStartUp)
$aPIDKeepAlive = IniRead($aUtilCFGFile, "CFG", "aKeepAlivePID", 99999)
If Not ProcessExists($aPIDKeepAlive) Then
$aPIDKeepAlive = WinGetProcess("[CLASS:AutoIt v3 GUI]", "AtlasServerUpdateUtilityKeepAlive")
If $aPIDKeepAlive < 1 Then $aPIDKeepAlive = Run(@ScriptDir & "\" & $aKeepAliveFileExe)
IniWrite($aUtilCFGFile, "CFG", "aKeepAlivePID", $aPIDKeepAlive)
EndIf
EndIf
If $aRemoteRestartUse = "yes" Then
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Initializing Remote Restart.")
TCPStartup()
Local $aRemoteRestartSocket = TCPListen($aRemoteRestartIP, $aRemoteRestartPort, 100)
If $aRemoteRestartSocket = -1 Then
SplashOff()
FileDelete($aFolderTemp & "pid.txt")
Local $tCMD = @ComSpec & " /c netstat -a -n -o >> """ & $aFolderTemp & "pid.txt"""
Local $mOut = Run($tCMD, $aFolderTemp, @SW_HIDE)
$tErr = ProcessWaitClose($mOut, 1)
If $tErr = 0 Then
$aPIDError = True
Else
$tFile = FileOpen($aFolderTemp & "pid.txt")
$tRead = FileRead($tFile)
FileClose($tFile)
$tTxt1 = _StringBetween($tRead, $aRemoteRestartIP & ":" & $aRemoteRestartPort, "CP")
If $tTxt1 = "" Then
Else
Local $tTxt = _StringBetween($tTxt1[0], "LISTENING", "T")
$tPID = StringRegExp($tTxt[0], '\d+', 1)
If @error Then
Else
Local $tProgPID = _ProcessGetName($tPID[0])
Local $aMsg = "Could not bind to [" & $aRemoteRestartIP & "] Check server IP, disable Remote Restart in INI, or check for multiple instances of this util using the same port." & @CRLF & @CRLF & "The Remote Restart port is being used by" & @CRLF & "Program:" & $tProgPID & @CRLF & "PID:" & $tPID[0] & @CRLF & "Port:" & $aRemoteRestartPort & @CRLF & @CRLF & "Click (YES) to close the above program and restart Remote Restart." & @CRLF & "Click (NO) to continue (Remote Restart will likely not function.)" & @CRLF & "Click (CANCEL) to exit utility."
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Then
LogWrite(" [Remote Restart] Program(" & $tProgPID & "), PID(" & $tPID[0] & ") terminated. Remote Restart initialized.")
ProcessClose($tPID[0])
Local $aRemoteRestartSocket = TCPListen($aRemoteRestartIP, $aRemoteRestartPort, 100)
_Splash($aStartText & "Program terminated." & @CRLF & "Initializing Remote Restart.", 2000, 475)
$aSplashStartUp = _Splash($aStartText & "Program terminated." & @CRLF & "Initializing Remote Restart.", 0, 475)
ElseIf $tMB = 7 Then
$aSplashStartUp = _Splash($aStartText & "Continuing startup.", 0, 475)
ElseIf $tMB = 2 Then
_Splash($aUtilName & " exiting.", 2000)
_ExitUtil()
ElseIf $tMB = -1 Then
$aSplashStartUp = _Splash($aStartText & "No response. Continuing startup.", 0, 475)
EndIf
EndIf
EndIf
EndIf
Else
If $sObfuscatePass = "no" Then
LogWrite(" [Remote Restart] Listening for restart request at http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/?" & $aRemoteRestartKey & "=" & $aRemoteRestartCode & " OR http://" & $xServerIP[0] & ":" & $aRemoteRestartPort & "/?" & $aRemoteRestartKey & "=" & $aRemoteRestartCode)
LogWrite(" [Remote RCON] Listening for RCON commands at http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@[command] (no brackets , use % as [space]) OR http://" & $xServerIP[0] & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@[command]")
LogWrite(" [Remote RCON] To send [space], use [%] without brackets. ex: http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@broadcast%Admin%Says%Hi OR http://" & $xServerIP[0] & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@DoExit")
Else
LogWrite(" [Remote Restart] Listening for restart request at http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/?[key]=[password]" & " OR http://" & $xServerIP[0] & ":" & $aRemoteRestartPort & "/?[key]=[password]")
LogWrite(" [Remote RCON] Listening for RCON commands at http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/[server_password]@[command] (no brackets , use % as [space]) OR http://" & $xServerIP[0] & ":" & $aRemoteRestartPort & "/[server_password]@[command]")
LogWrite(" [Remote RCON] To send [space], use [%] without brackets. ex: http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/[server_password]@broadcast%Admin%Says%Hi OR http://" & $xServerIP[0] & ":" & $aRemoteRestartPort & "/[server_password]@DoExit")
EndIf
EndIf
EndIf
LogWrite(" [Update] Running initial update check . . ")
$aFirstBoot = True
If $aUtilReboot = "no" And ((_DateDiff('n', $aCFGLastUpdate, _NowCalc())) >= $aUpdateCheckInterval) Or $aExternalScriptValidateYN = "yes" Or $aExecuteExternalScript = "yes" Then
RunExternalScriptBeforeSteam($aSplashStartUp)
UpdateCheck(False, $aSplashStartUp)
RunExternalScriptAfterSteam($aSplashStartUp)
EndIf
$aFirstBoot = False
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Creating _SERVER_SUMMARY_.txt file.")
MakeServerSummaryFile($aServerSummaryFile)
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Scanning for running servers.")
If Not ProcessExists($aServerPIDRedis) And $aServerUseRedis = "yes" Then
$aBeginDelayedShutdown = 0
$aServerPIDRedis = ""
If $aServerMinimizedYN = "no" Then
If $aServerRedisFolder = "" Then
$aServerPIDRedis = Run($xServerRedis, $aServerDirLocal & $aServerRedisDir)
Else
$aServerPIDRedis = Run($xServerRedis, $aServerRedisFolder)
EndIf
Else
If $aServerRedisFolder = "" Then
$aServerPIDRedis = Run($xServerRedis, $aServerDirLocal & $aServerRedisDir, "", @SW_MINIMIZE)
Else
$aServerPIDRedis = Run($xServerRedis, $aServerRedisFolder, "", @SW_MINIMIZE)
EndIf
EndIf
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
LogWrite(" [Redis started (PID: " & $aServerPIDRedis & ")]", " [Redis started (PID: " & $aServerPIDRedis & ")] " & $xServerRedis)
EndIf
Local $tStartedServersTF = False
Local $tServersToStart = ""
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) = 0 And $xLocalGrid[$i] = "yes" And ($aShutdown = 0) Then
If $xStartGrid[$i] = "yes" Then
$tStartedServersTF = True
$tServersToStart &= _ServerNamingScheme($i, $aNamingScheme) & " "
EndIf
EndIf
Next
If $xServerIP[0] = "1.2.3.4" Then
$tStartedServersTF = False
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then
$xStartGrid[$i] = "no"
$aGridSomeDisable = True
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", "no")
EndIf
Next
EndIf
If $tStartedServersTF Then
Local $aMsg = "The following Server(s) need to be started:" & @CRLF & $tServersToStart & @CRLF & @CRLF & "Click (YES) to start servers (or wait 10 seconds)." & @CRLF & "Click (NO) to DISABLE ALL SERVERS and continue utility." & @CRLF & "Click (CANCEL) to exit utility."
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 10)
If $tMB = 6 Then
$aSplashStartUp = _Splash($aStartText, 0, 475)
ElseIf $tMB = -1 Then
$aSplashStartUp = _Splash($aStartText, 0, 475)
ElseIf $tMB = 7 Then
Local $aMsg = "Are you sure you wish to disable all grids?" & @CRLF & @CRLF & "Click (YES) to DISABLE ALL SERVERS and continue utility." & @CRLF & "Click (NO) or (CANCEL) to exit utility."
$tMB1 = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg)
If $tMB1 = 6 Then
_Splash($aStartText & "Disabling grids.", 2000, 475)
$aSplashStartUp = _Splash($aStartText & "Disabling grids.", 0, 475)
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then
$xStartGrid[$i] = "no"
$aGridSomeDisable = True
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", "no")
EndIf
Next
Else
_Splash("Exiting utility. . .", 2000)
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
_ExitUtil()
EndIf
ElseIf $tMB = 2 Then
_Splash("Exiting utility. . .", 2000)
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
_ExitUtil()
Else
_Splash("Exiting utility. . .", 2000)
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
_ExitUtil()
EndIf
EndIf
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Starting servers.")
Local $tFirstGrid = True
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) = 0 And $xLocalGrid[$i] = "yes" And ($aShutdown = 0) Then
If $xStartGrid[$i] = "yes" Then
Local $tDelay = Int($aServerStartDelay) + ($xGridStartDelay[$i])
If $tFirstGrid = False Then
For $x = 0 To ($tDelay - 1)
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Starting server " & _ServerNamingScheme($i, $aNamingScheme) & " in " & ($tDelay - $x) & " seconds.")
Sleep(1000)
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
Next
Else
$tFirstGrid = False
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Starting server " & _ServerNamingScheme($i, $aNamingScheme) & " in 1 seconds.")
Sleep(1000)
EndIf
If $aServerMinimizedYN = "no" Then
$aServerPID[$i] = Run($xServerStart[$i])
Else
$aServerPID[$i] = Run($xServerStart[$i], "", @SW_MINIMIZE)
EndIf
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
$aTimeCheck6 = _NowCalc()
$xServerCPU[$i] = _ProcessUsageTracker_Create("", $aServerPID[$i])
LogWrite(" [Server " & _ServerNamingScheme($i, $aNamingScheme) & " started (PID: " & $aServerPID[$i] & ")]", " [Server " & _ServerNamingScheme($i, $aNamingScheme) & "]" & " started (PID: " & $aServerPID[$i] & ")] " & $xServerStart[$i])
Else
LogWrite(" [Server " & _ServerNamingScheme($i, $aNamingScheme) & " -*NOT*- STARTED] because it is set to ""no"" in " & $aGridSelectFile)
EndIf
EndIf
Next
PIDSaveServer($aServerPID, $aPIDServerFile)
BatchFilesCreate($aSplashStartUp)
If $aUtilReboot = "yes" Then
$aUtilReboot = "no"
IniWrite($aUtilCFGFile, "CFG", "aUtilReboot", $aUtilReboot)
EndIf
#EndRegion
#Region
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "Preparing GUI. Getting server information.")
$aStartText = ""
Opt("TrayMenuMode", 3)
Opt("TrayOnEventMode", 1)
Local $iTrayShowGUI = TrayCreateItem("- SHOW GUI -")
TrayItemSetOnEvent(-1, "Tray_ShowGUI")
Local $iTrayShowConfig = TrayCreateItem("Show Config")
TrayItemSetOnEvent(-1, "Tray_ShowConfig")
TrayCreateItem("")
Local $iTrayAbout = TrayCreateItem("About")
TrayItemSetOnEvent(-1, "Tray_About")
Local $iTrayUpdateUtilCheck = TrayCreateItem("Check for Util Update")
TrayItemSetOnEvent(-1, "Tray_UtilUpdate")
Local $iTrayUpdateUtilPause = TrayCreateItem("Pause Util")
TrayItemSetOnEvent(-1, "Tray_PauseUtil")
TrayCreateItem("")
Local $iTraySendMessage = TrayCreateItem("Send message")
TrayItemSetOnEvent(-1, "Tray_AllSendMsg")
Local $iTraySendRCON = TrayCreateItem("Send RCON command")
TrayItemSetOnEvent(-1, "Tray_AllSendRCON")
Local $iTrayPlayerCount = TrayCreateItem("Show Online Players")
TrayItemSetOnEvent(-1, "Tray_ShowOnlinePlayers")
TrayItemSetState(-1, $TRAY_ENABLE)
Local $iTrayPlayerCheckPause = TrayCreateItem("Disable Online Players Check/Log")
TrayItemSetOnEvent(-1, "Tray_OnlinePlayersCheckDisable")
Local $iTrayPlayerCheckUnPause = TrayCreateItem("Enable Online Players Check/Log")
TrayItemSetOnEvent(-1, "Tray_OnlinePlayersCheckEnable")
TrayCreateItem("")
Local $iTrayUpdateServCheck = TrayCreateItem("Check for Server Update")
TrayItemSetOnEvent(-1, "Tray_ServerUpdateCheck")
Local $iTrayUpdateServPause = TrayCreateItem("Disable Server Update Check")
TrayItemSetOnEvent(-1, "Tray_ServerUpdateDisable")
Local $iTrayUpdateServUnPause = TrayCreateItem("Enable Server Update Check")
TrayItemSetOnEvent(-1, "Tray_ServerUpdateEnable")
TrayCreateItem("")
Local $iTrayRemoteRestart = TrayCreateItem("Initiate Remote Restart")
TrayItemSetOnEvent(-1, "Tray_RemoteRestart")
Local $iTrayRestartNow = TrayCreateItem("Restart Servers Now")
TrayItemSetOnEvent(-1, "Tray_RestartServersNow")
TrayCreateItem("")
Local $iTrayExitCloseN = TrayCreateItem("Exit: Do NOT Shut Down Servers")
TrayItemSetOnEvent(-1, "Tray_ExitShutDownN")
Local $iTrayExitCloseY = TrayCreateItem("Exit: Shut Down Servers")
TrayItemSetOnEvent(-1, "Tray_ExitShutDownY")
If $aCheckForUpdate = "yes" Then
TrayItemSetState($iTrayUpdateServPause, $TRAY_ENABLE)
TrayItemSetState($iTrayUpdateServUnPause, $TRAY_DISABLE)
Else
TrayItemSetState($iTrayUpdateServPause, $TRAY_DISABLE)
TrayItemSetState($iTrayUpdateServUnPause, $TRAY_ENABLE)
EndIf
If $aServerOnlinePlayerYN = "yes" Then
TrayItemSetState($iTrayPlayerCheckPause, $TRAY_ENABLE)
TrayItemSetState($iTrayPlayerCheckUnPause, $TRAY_DISABLE)
Else
TrayItemSetState($iTrayPlayerCheckPause, $TRAY_DISABLE)
TrayItemSetState($iTrayPlayerCheckUnPause, $TRAY_ENABLE)
EndIf
TraySetState($TRAY_ICONSTATE_SHOW)
#EndRegion
Opt("GUIResizeMode", $GUI_DOCKAUTO)
$aGUIH = 70 + $aServerGridTotal * 15
If $aGUIH > 800 Then $aGUIH = 800
ShowMainGUI($aSplashStartUp)
$aGUIReady = True
GUIRegisterMsg($WM_SIZE, "_WM_SIZE")
SplashOff()
If $xServerIP[0] = "1.2.3.4" Then
Local $tMsg = "Congrats! " & $aUtilName & " installation complete." & @CRLF & @CRLF & "Click (YES) to run the Startup Wizard." & @CRLF & "Click (NO) to edit the config file." & @CRLF & "Click (CANCEL) to continue."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $tMsg, 30)
If $tMB = 6 Then
WizardSelect()
ElseIf $tMB = 7 Then
ConfigEdit($aSplashStartUp)
ElseIf $tMB = 2 Then
EndIf
Else
Local $tMsg = "NOTICE!!! As of v1.7.5 !!! " & @CRLF & @CRLF & "- The AtlasServerUpateUtility.ini and " & @CRLF & "AtlasServerUpateUtilityGridSelect.ini files" & @CRLF & "were moved to ""\_Config"" folder ..."
MsgBox(0, $aUtilName, $tMsg, 15)
EndIf
If $aUpdateUtil > 0 Then AdlibRegister("RunUtilUpdate", $aUpdateUtil * 3600000)
Local $aSliderPrev = GUICtrlRead($UpdateIntervalSlider)
$aServerCheck = TimerInit()
Local $iSelected = -1
Global $lLogTabWindow = 0, $lBasicEdit = 0, $lDetailedEdit = 0, $lOnlinePlayersEdit = 0, $lServerSummaryEdit = 0, $lConfigEdit = 0, $lGridSelectEdit = 0, $lServerGridEdit = 0, $lDefaultGameEdit = 0, $lDefaultGUSEdit = 0, $lDefaultEngineEdit = 0
Global $aRet[3], $iWidth = 1001, $iHeight = 701
Local $tLVlast = 0, $tLVclick = 0
While True
$aSliderNow = GUICtrlRead($UpdateIntervalSlider)
If $aSliderNow <> $aSliderPrev Then
GUICtrlSetData($UpdateIntervalEdit, $aSliderNow)
$aSliderPrev = $aSliderNow
EndIf
$vRet = _GUIListViewEx_EventMonitor()
If @error Then
EndIf
Switch @extended
Case 0
Case 1
Case 2
Case 3
Case 4
Case 9
ControlClick("AtlasServerUpdateUtility v", "", "[CLASS:SysListView32; INSTANCE:1]", "left", 1, $iWidth - 156, $iHeight - 20)
If $vRet[2] > 3 Then
GridConfiguratorGUI($vRet[1])
EndIf
EndSwitch
If WinExists($LogWindow) Then
$iTab = _GUICtrlTab_GetCurSel($lLogTabWindow)
Switch $iTab
Case 0
ControlShow($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 1
ControlHide($LogWindow, "", $lBasicEdit)
ControlShow($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 2
ControlHide($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlShow($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 3
ControlHide($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlShow($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 4
ControlHide($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlShow($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 5
ControlHide($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlShow($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 6
ControlHide($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlShow($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 7
ControlHide($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlShow($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 8
ControlHide($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlShow($LogWindow, "", $lDefaultGUSEdit)
ControlHide($LogWindow, "", $lDefaultEngineEdit)
Case 9
ControlHide($LogWindow, "", $lBasicEdit)
ControlHide($LogWindow, "", $lDetailedEdit)
ControlHide($LogWindow, "", $lOnlinePlayersEdit)
ControlHide($LogWindow, "", $lServerSummaryEdit)
ControlHide($LogWindow, "", $lConfigEdit)
ControlHide($LogWindow, "", $lGridSelectEdit)
ControlHide($LogWindow, "", $lServerGridEdit)
ControlHide($LogWindow, "", $lDefaultGameEdit)
ControlHide($LogWindow, "", $lDefaultGUSEdit)
ControlShow($LogWindow, "", $lDefaultEngineEdit)
EndSwitch
EndIf
If TimerDiff($aServerCheck) > ($aMainGUIRefreshTime * 1000) Then
SetStatusBusy("Server process check in progress...", "Updating Server Info")
PIDSaveServer($aServerPID, $aPIDServerFile)
If GUICtrlRead($gPollOnlinePlayers) = $GUI_CHECKED Then
If $aServerOnlinePlayerYN = "yes" Then
Else
$aServerOnlinePlayerYN = "yes"
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for, and log, online players? (yes/no) ###", $aServerOnlinePlayerYN)
EndIf
Else
If $aServerOnlinePlayerYN = "no" Then
Else
$aServerOnlinePlayerYN = "no"
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for, and log, online players? (yes/no) ###", $aServerOnlinePlayerYN)
EndIf
EndIf
If GUICtrlRead($gPollRemoteServersCB) = $GUI_CHECKED Then
If $aPollRemoteServersYN = "yes" Then
Else
$aPollRemoteServersYN = "yes"
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for online players on remote servers? (yes/no) ###", $aPollRemoteServersYN)
EndIf
Else
If $aPollRemoteServersYN = "no" Then
Else
$aPollRemoteServersYN = "no"
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for online players on remote servers? (yes/no) ###", $aPollRemoteServersYN)
EndIf
EndIf
$aSliderNow = GUICtrlRead($UpdateIntervalSlider)
Local $aUpdateIntervalEdit = GUICtrlRead($UpdateIntervalEdit)
If $aUpdateIntervalEdit <> $aSliderNow Then
GUICtrlSetData($UpdateIntervalSlider, $aUpdateIntervalEdit)
EndIf
If $aUpdateIntervalEdit <> $aServerOnlinePlayerSec Then
If $UpdateIntervalEdit <> $aServerOnlinePlayerSec Then
$aServerOnlinePlayerSec = $aUpdateIntervalEdit
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for online players every _ seconds (30-600) ###", $aServerOnlinePlayerSec)
EndIf
EndIf
SetStatusBusy("Server process check in progress...", "Updating Main Window")
GUIUpdateQuick()
#Region
SetStatusBusy("Server process check in progress...", "Check: Remote Restart")
If $aRemoteRestartUse = "yes" Then
Local $sRestart = _RemoteRestart($aRemoteRestartSocket, $aRemoteRestartCode, $aRemoteRestartKey, $sObfuscatePass, $aRemoteRestartIP, $aServerName, True)
Switch @error
Case 0
If $aBeginDelayedShutdown = 0 Then
LogWrite(" [" & $aServerName & "] " & $sRestart)
If ($sUseDiscordBotDaily = "yes") Or ($sUseDiscordBotUpdate = "yes") Or ($sUseTwitchBotDaily = "yes") Or ($sUseTwitchBotUpdate = "yes") Or ($sInGameAnnounce = "yes") Then
$aRebootReason = "remoterestart"
$aBeginDelayedShutdown = 1
$aTimeCheck0 = _NowCalc()
Else
RunExternalRemoteRestart()
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
EndIf
EndIf
Case 1 To 4
LogWrite(" " & $sRestart & @CRLF)
EndSwitch
EndIf
#EndRegion
#Region
SetStatusBusy("Server process check in progress...", "Check: Redis Running")
If Not ProcessExists($aServerPIDRedis) And $aServerUseRedis = "yes" Then
$aBeginDelayedShutdown = 0
If $aServerMinimizedYN = "no" Then
$aServerPIDRedis = Run($xServerRedis, $aServerDirLocal & $aServerRedisDir)
Else
$aServerPIDRedis = Run($xServerRedis, $aServerDirLocal & $aServerRedisDir, "", @SW_MINIMIZE)
EndIf
LogWrite(" [Redis started (PID: " & $aServerPIDRedis & ")]", " [Redis started (PID: " & $aServerPIDRedis & ")] " & $xServerRedis)
EndIf
SplashOff()
Local $tFirstGrid = True
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then
SetStatusBusy("Server process check in progress...", "Check: Server " & _ServerNamingScheme($i, $aNamingScheme))
If ProcessExists($aServerPID[$i]) = 0 And $xLocalGrid[$i] = "yes" And ($aShutdown = 0) Then
If $tFirstGrid = False Then
Local $tDelay = Int($aServerStartDelay) + ($xGridStartDelay[$i])
For $x = 0 To ($tDelay - 1)
SetStatusBusy("Starting Server " & _ServerNamingScheme($i, $aNamingScheme) & " in " & ($tDelay - $x))
Sleep(1000)
Next
Else
$tFirstGrid = False
SetStatusBusy("Starting Server " & _ServerNamingScheme($i, $aNamingScheme) & " in 1")
Sleep(1000)
EndIf
If $aServerMinimizedYN = "no" Then
$aServerPID[$i] = Run($xServerStart[$i])
Else
$aServerPID[$i] = Run($xServerStart[$i], "", @SW_MINIMIZE)
EndIf
$xServerCPU[$i] = _ProcessUsageTracker_Create("", $aServerPID[$i])
LogWrite(" [Server " & _ServerNamingScheme($i, $aNamingScheme) & " started (PID: " & $aServerPID[$i] & ")]", " [Server " & _ServerNamingScheme($i, $aNamingScheme) & " started (PID: " & $aServerPID[$i] & ")] " & $xServerStart[$i])
EndIf
EndIf
Next
#EndRegion
#Region
If $aServerOnlinePlayerYN = "yes" Then
If ((_DateDiff('s', $aTimeCheck8, _NowCalc())) >= $aServerOnlinePlayerSec) Then
SetStatusBusy("Server process check in progress...", "Check: Online Players")
$aOnlinePlayers = GetPlayerCount(0)
ShowPlayerCount()
If $aServerReadyTF And $aServerReadyOnce Then
Local $aSendServerReadyTF = False
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then $aSendServerReadyTF = True
Next
If $aSendServerReadyTF Then
If $aNoExistingPID Then
If $sUseDiscordBotServersUpYN = "yes" Then
Local $aAnnounceCount3 = 0
If $aRebootReason = "remoterestart" And $sUseDiscordBotRemoteRestart = "yes" Then
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement sent . . .")
SendDiscordMsg($sDiscordWebHookURLs, $sDiscordServersUpMessage, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
$aAnnounceCount3 = $aAnnounceCount3 + 1
EndIf
If $aRebootReason = "stopservers" And $sUseDiscordBotStopServer = "yes" And ($aAnnounceCount3 = 0) Then
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement sent . . .")
SendDiscordMsg($sDiscordWebHookURLs, $sDiscordServersUpMessage, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
$aAnnounceCount3 = $aAnnounceCount3 + 1
EndIf
If $aRebootReason = "update" And $sUseDiscordBotUpdate = "yes" And ($aAnnounceCount3 = 0) Then
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement sent . . .")
SendDiscordMsg($sDiscordWebHookURLs, $sDiscordServersUpMessage, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
$aAnnounceCount3 = $aAnnounceCount3 + 1
EndIf
If $aRebootReason = "mod" And $sUseDiscordBotUpdate = "yes" And ($aAnnounceCount3 = 0) Then
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement sent . . .")
SendDiscordMsg($sDiscordWebHookURLs, $sDiscordServersUpMessage, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
$aAnnounceCount3 = $aAnnounceCount3 + 1
EndIf
If $aRebootReason = "daily" And $sUseDiscordBotDaily = "yes" And ($aAnnounceCount3 = 0) Then
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement sent . . .")
SendDiscordMsg($sDiscordWebHookURLs, $sDiscordServersUpMessage, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
$aAnnounceCount3 = $aAnnounceCount3 + 1
EndIf
If $xCustomRCONRebootNumber > -1 Then
If $aRebootReason = "custom" And $xEventAnnounceInGame[$xCustomRCONRebootNumber] <> "" And ($aAnnounceCount3 = 0) Then
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement sent . . .")
SendDiscordMsg($sDiscordWebHookURLs, $sDiscordServersUpMessage, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
$aAnnounceCount3 = $aAnnounceCount3 + 1
$xCustomRCONRebootNumber = -1
EndIf
EndIf
If $aFirstStartDiscordAnnounce And ($aAnnounceCount3 = 0) Then
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement sent . . .")
SendDiscordMsg($sDiscordWebHookURLs, $sDiscordServersUpMessage, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
$aFirstStartDiscordAnnounce = False
EndIf
Else
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement NOT sent. Enable first announcement and/or daily, mod, update, remote restart annoucements in config if desired.", 0, 400, 200)
$xCustomRCONRebootNumber = -1
EndIf
Else
_Splash(" All servers online and ready for connection." & @CRLF & @CRLF & "Discord announcement SKIPPED because servers were already running or feature disabled in config.")
$aNoExistingPID = True
$xCustomRCONRebootNumber = -1
EndIf
$aServerReadyOnce = False
Sleep(5000)
SplashOff()
EndIf
EndIf
$aTimeCheck8 = _NowCalc()
EndIf
EndIf
#EndRegion
GUICtrlSetData($LabelUtilReadyStatus, "Updating Server Info")
If ($aDestroyWildDinosYN) = "yes" Then
If ((_DateDiff('n', $aTimeCheck7, _NowCalc())) >= 1) Then
SetStatusBusy("Server process check in progress...", "Check: DestroyWildDinos")
If RespawnDinosCheck($aDestroyWildDinosDays, $aDestroyWildDinosHours, $aDestroyWildDinosMinute) Then
$aTimeCheck7 = _NowCalc()
DestroyWildDinos()
EndIf
EndIf
EndIf
#Region
If (($aRestartDaily = "yes") And ((_DateDiff('n', $aTimeCheck2, _NowCalc())) >= 1) And (DailyRestartCheck($aRestartDays, $aRestartHours, $aRestartMin)) And ($aBeginDelayedShutdown = 0)) Then
SetStatusBusy("Server process check in progress...", "Check: Daily Restart")
LogWrite(" [" & $aServerName & "] - Daily restart requested by " & $aUtilName & ".")
If $aDelayShutdownTime Not = 0 Then
$aBeginDelayedShutdown = 1
$aRebootReason = "daily"
$aTimeCheck0 = _NowCalc()
$aAnnounceCount1 = $aAnnounceCount1 + 1
Else
RunExternalScriptDaily()
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
EndIf
$aTimeCheck2 = _NowCalc()
EndIf
#EndRegion
#Region
If ($aBackupYN = "yes") And ((_DateDiff('n', $aTimeCheck4, _NowCalc())) >= 1) And (BackupCheck($aBackupDays, $aBackupHours, $aBackupMin)) Then
SetStatusBusy("Server process check in progress...", "Check: Backup Game")
_BackupGame(True)
$aTimeCheck4 = _NowCalc()
EndIf
#EndRegion
If ((_DateDiff('n', $aTimeCheck5, _NowCalc())) >= 1) Then
SetStatusBusy("Server process check in progress...", "Check: Event Scheduler")
For $t = 0 To ($aMax6moAll - 1)
If $xEventTimePastTF[$t] = False Then
Local $tDateDiff = _DateDiff('n', _NowCalc(), _DateAdd('n', 1, $xEventRestartTimeAll[$t][0]))
If $tDateDiff <= 0 Then
$xEventTimePastTF[$t] = True
$i = $xEventRestartTimeAll[$t][1]
If $xCustomRCONCmd[$i] <> "" Then
Local $xCustomRCONSplitCmd = StringSplit($xCustomRCONCmd[$i], "~", 2)
For $x = 0 To (UBound($xCustomRCONSplitCmd) - 1)
If $xCustomRCONAllorLocal[$i] = "1" Then
LogWrite(" [Scheduled Event " & $i & "] Sending RCON command to Local servers: " & $xCustomRCONSplitCmd[$x])
F_SendRCON("local", $xCustomRCONSplitCmd[$x])
Else
LogWrite(" [Scheduled Event " & $i & "] Sending RCON command to ALL servers: " & $xCustomRCONSplitCmd[$x])
F_SendRCON("all", $xCustomRCONSplitCmd[$x])
EndIf
Next
EndIf
If $xEventFile[$i] <> "" Then
LogWrite(" [Scheduled Event " & $i & "] Executing file: " & $xEventFile[$i])
Run($xEventFile[$i])
EndIf
If $xCustomRCONRestartYN[$i] = "yes" Then
$aRebootReason = "Custom"
$aBeginDelayedShutdown = 1
$aTimeCheck0 = _NowCalc()
$xCustomRCONRebootNumber = $i
EndIf
EndIf
EndIf
Next
$aTimeCheck5 = StringTrimRight(_NowCalc(), 2) & "00"
EndIf
#Region
If $aServerModYN = "yes" And ((_DateDiff('n', $aTimeCheck0, _NowCalc())) >= $aUpdateCheckInterval) And ($aBeginDelayedShutdown = 0) Then
SetStatusBusy("Check: Mod Update")
CheckMod($aServerModList, $aSteamCMDDir, $aServerDirLocal, 0, False)
SetStatusIdle()
EndIf
If ((_DateDiff('n', $aTimeCheck0, _NowCalc())) >= $aUpdateCheckInterval) And ($aBeginDelayedShutdown = 0) Then
If $aCheckForUpdate = "yes" Then
SetStatusBusy("Check: Server Update")
UpdateCheck(False, 0, False)
SetStatusIdle()
EndIf
$aTimeCheck0 = _NowCalc()
EndIf
#EndRegion
#Region
If $aDelayShutdownTime Not = 0 Then
If $tTotalLocalPlayers > 0 Then
If $aBeginDelayedShutdown = 1 Then
SetStatusBusy("Server process check in progress...", "Check: Restart Due")
RunExternalScriptAnnounce()
If $aRebootReason = "daily" Then
$aAnnounceCount0 = $aDailyCnt
$aAnnounceCount1 = $aAnnounceCount0 - 1
If $aAnnounceCount1 = 0 Then
$aDelayShutdownTime = 0
$aBeginDelayedShutdown = 3
Else
$aDelayShutdownTime = $aDailyTime[$aAnnounceCount0] - $aDailyTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aDailyMsgInGame[$aAnnounceCount0])
EndIf
If $sUseDiscordBotDaily = "yes" Then
SendDiscordMsg($sDiscordWebHookURLs, $aDailyMsgDiscord[$aAnnounceCount0], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotDaily = "yes" Then
TwitchMsgLog($aDailyMsgTwitch[$aAnnounceCount0])
EndIf
EndIf
If $aRebootReason = "remoterestart" Then
$aAnnounceCount0 = $aRemoteCnt
$aAnnounceCount1 = $aAnnounceCount0 - 1
$aDelayShutdownTime = $aRemoteTime[$aAnnounceCount0] - $aRemoteTime[$aAnnounceCount1] + 1
If $aAnnounceCount1 = 0 Then
$aDelayShutdownTime = 0
$aBeginDelayedShutdown = 3
Else
$aDelayShutdownTime = $aRemoteTime[$aAnnounceCount0] - $aRemoteTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aRemoteMsgInGame[$aAnnounceCount0])
EndIf
If $sUseDiscordBotRemoteRestart = "yes" Then
SendDiscordMsg($sDiscordWebHookURLs, $aRemoteMsgDiscord[$aAnnounceCount0], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotRemoteRestart = "yes" Then
TwitchMsgLog($aRemoteMsgTwitch[$aAnnounceCount0])
EndIf
EndIf
If $aRebootReason = "stopservers" Then
$aAnnounceCount0 = $aStopServerCnt
$aAnnounceCount1 = $aAnnounceCount0 - 1
$aDelayShutdownTime = $aStopServerTime[$aAnnounceCount0] - $aStopServerTime[$aAnnounceCount1] + 1
If $aAnnounceCount1 = 0 Then
$aDelayShutdownTime = 0
$aBeginDelayedShutdown = 3
Else
$aDelayShutdownTime = $aStopServerTime[$aAnnounceCount0] - $aStopServerTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aStopServerMsgInGame[$aAnnounceCount0])
EndIf
If $sUseDiscordBotStopServer = "yes" Then
SendDiscordMsg($sDiscordWebHookURLs, $aStopServerMsgDiscord[$aAnnounceCount0], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotStopServer = "yes" Then
TwitchMsgLog($aStopServerMsgTwitch[$aAnnounceCount0])
EndIf
EndIf
If $aRebootReason = "update" Then
$aAnnounceCount0 = $aUpdateCnt
$aAnnounceCount1 = $aAnnounceCount0 - 1
$aDelayShutdownTime = $aUpdateTime[$aAnnounceCount0] - $aUpdateTime[$aAnnounceCount1] + 1
If $aAnnounceCount1 = 0 Then
$aDelayShutdownTime = 0
$aBeginDelayedShutdown = 3
Else
$aDelayShutdownTime = $aUpdateTime[$aAnnounceCount0] - $aUpdateTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aUpdateMsgInGame[$aAnnounceCount0])
EndIf
If $sUseDiscordBotUpdate = "yes" Then
SendDiscordMsg($sDiscordWebHookURLs, $aUpdateMsgDiscord[$aAnnounceCount0], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotUpdate = "yes" Then
TwitchMsgLog($aUpdateMsgTwitch[$aAnnounceCount0])
EndIf
EndIf
If $aRebootReason = "mod" Then
$aAnnounceCount0 = $aModCnt
$aAnnounceCount1 = $aAnnounceCount0 - 1
$aDelayShutdownTime = $aModTime[$aAnnounceCount0] - $aModTime[$aAnnounceCount1] + 1
If $aAnnounceCount1 = 0 Then
$aDelayShutdownTime = 0
$aBeginDelayedShutdown = 3
Else
$aDelayShutdownTime = $aModTime[$aAnnounceCount0] - $aModTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aModMsgInGame[$aAnnounceCount0])
EndIf
If $sUseDiscordBotUpdate = "yes" Then
SendDiscordMsg($sDiscordWebHookURLs, $aModMsgDiscord[$aAnnounceCount0], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotUpdate = "yes" Then
TwitchMsgLog($aModMsgTwitch[$aAnnounceCount0])
EndIf
EndIf
If $aRebootReason = "Custom" Then
$aAnnounceCount0 = $aCustomCnt[$xCustomRCONRebootNumber]
$aAnnounceCount1 = $aAnnounceCount0 - 1
$aDelayShutdownTime = ($aCustomTime[$xCustomRCONRebootNumber])[$aAnnounceCount0] - ($aCustomTime[$xCustomRCONRebootNumber])[$aAnnounceCount1] + 1
If $aAnnounceCount1 = 0 Then
$aDelayShutdownTime = 0
$aBeginDelayedShutdown = 3
Else
$aDelayShutdownTime = ($aCustomTime[$xCustomRCONRebootNumber])[$aAnnounceCount0] - ($aCustomTime[$xCustomRCONRebootNumber])[$aAnnounceCount1]
EndIf
If $xEventAnnounceInGame[$xCustomRCONRebootNumber] <> "" Then
SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, ($sCustomMsgInGame[$xCustomRCONRebootNumber])[$aAnnounceCount0])
EndIf
If $xEventAnnounceDiscord[$xCustomRCONRebootNumber] <> "" Then
SendDiscordMsg($sDiscordWebHookURLs, ($sCustomMsgDiscord[$xCustomRCONRebootNumber])[$aAnnounceCount0], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $xEventAnnounceTwitch[$xCustomRCONRebootNumber] <> "" Then
TwitchMsgLog(($sCustomMsgTwitch[$xCustomRCONRebootNumber])[$aAnnounceCount0])
EndIf
EndIf
$aBeginDelayedShutdown = 2
$aTimeCheck0 = _NowCalc()
ElseIf ($aBeginDelayedShutdown > 2 And ((_DateDiff('n', $aTimeCheck0, _NowCalc())) >= $aDelayShutdownTime)) Then
$aBeginDelayedShutdown = 0
$aTimeCheck0 = _NowCalc()
If $aRebootReason = "daily" Then
SplashTextOn($aUtilName & ": " & $aServerName, "Daily server requested. Restarting server . . .", 350, 50, -1, -1, $DLG_MOVEABLE, "")
RunExternalScriptDaily()
EndIf
If $aRebootReason = "update" Then
SplashTextOn($aUtilName & ": " & $aServerName, "New server update. Restarting server . . .", 350, 50, -1, -1, $DLG_MOVEABLE, "")
RunExternalScriptUpdate()
EndIf
If $aRebootReason = "remoterestart" Then
SplashTextOn($aUtilName & ": " & $aServerName, "Remote Restart requested. Restarting server . . .", 350, 50, -1, -1, $DLG_MOVEABLE, "")
RunExternalRemoteRestart()
EndIf
If $aRebootReason = "stopservers" Then
SplashTextOn($aUtilName & ": " & $aServerName, "Stop Servers requested. " & @CRLF & "Shutting down " & $tSelectServersTxt & "servers.", 450, 80, -1, -1, $DLG_MOVEABLE, "")
EndIf
If $sInGameAnnounce = "yes" Then
SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $sInGame10SecondMessage)
Sleep(10000)
EndIf
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
ElseIf ($aBeginDelayedShutdown = 2) And (_DateDiff('n', $aTimeCheck0, _NowCalc()) >= $aDelayShutdownTime) Then
If $aRebootReason = "daily" Then
If $aAnnounceCount1 > 1 Then
$aDelayShutdownTime = $aDailyTime[$aAnnounceCount1] - $aDailyTime[($aAnnounceCount1 - 1)]
Else
$aDelayShutdownTime = $aDailyTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
If $aDailyTime[($aAnnounceCount1)] > 0 Then SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aDailyMsgInGame[$aAnnounceCount1])
EndIf
If $sUseDiscordBotDaily = "yes" And ($sUseDiscordBotFirstAnnouncement = "no") Then
If $aDailyTime[($aAnnounceCount1)] > 0 Then SendDiscordMsg($sDiscordWebHookURLs, $aDailyMsgDiscord[$aAnnounceCount1], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotDaily = "yes" And ($sUseTwitchFirstAnnouncement = "no") Then
If $aDailyTime[($aAnnounceCount1)] > 0 Then TwitchMsgLog($aDailyMsgTwitch[$aAnnounceCount1])
EndIf
EndIf
If $aRebootReason = "remoterestart" Then
If $aAnnounceCount1 > 1 Then
$aDelayShutdownTime = $aRemoteTime[$aAnnounceCount1] - $aRemoteTime[($aAnnounceCount1 - 1)]
Else
$aDelayShutdownTime = $aRemoteTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
If $aRemoteTime[($aAnnounceCount1)] > 0 Then SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aRemoteMsgInGame[$aAnnounceCount1])
EndIf
If ($sUseDiscordBotRemoteRestart = "yes") And ($sUseDiscordBotFirstAnnouncement = "no") Then
If $aRemoteTime[($aAnnounceCount1)] > 0 Then SendDiscordMsg($sDiscordWebHookURLs, $aRemoteMsgDiscord[$aAnnounceCount1], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotRemoteRestart = "yes" And ($sUseTwitchFirstAnnouncement = "no") Then
If $aRemoteTime[($aAnnounceCount1)] > 0 Then TwitchMsgLog($aRemoteMsgTwitch[$aAnnounceCount1])
EndIf
EndIf
If $aRebootReason = "stopservers" Then
If $aAnnounceCount1 > 1 Then
$aDelayShutdownTime = $aStopServerTime[$aAnnounceCount1] - $aStopServerTime[($aAnnounceCount1 - 1)]
Else
$aDelayShutdownTime = $aStopServerTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
If $aStopServerTime[($aAnnounceCount1)] > 0 Then SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aStopServerMsgInGame[$aAnnounceCount1])
EndIf
If ($sUseDiscordBotStopServer = "yes") And ($sUseDiscordBotFirstAnnouncement = "no") Then
If $aStopServerTime[($aAnnounceCount1)] > 0 Then SendDiscordMsg($sDiscordWebHookURLs, $aStopServerMsgDiscord[$aAnnounceCount1], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotStopServer = "yes" And ($sUseTwitchFirstAnnouncement = "no") Then
If $aStopServerTime[($aAnnounceCount1)] > 0 Then TwitchMsgLog($aStopServerMsgTwitch[$aAnnounceCount1])
EndIf
EndIf
If $aRebootReason = "update" Then
If $aAnnounceCount1 > 1 Then
$aDelayShutdownTime = $aUpdateTime[$aAnnounceCount1] - $aUpdateTime[($aAnnounceCount1 - 1)]
Else
$aDelayShutdownTime = $aUpdateTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
If $aUpdateTime[($aAnnounceCount1)] > 0 Then SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aUpdateMsgInGame[$aAnnounceCount1])
EndIf
If $sUseDiscordBotUpdate = "yes" And ($sUseDiscordBotFirstAnnouncement = "no") Then
If $aUpdateTime[($aAnnounceCount1)] > 0 Then SendDiscordMsg($sDiscordWebHookURLs, $aUpdateMsgDiscord[$aAnnounceCount1], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotUpdate = "yes" And ($sUseTwitchFirstAnnouncement = "no") Then
If $aUpdateTime[($aAnnounceCount1)] > 0 Then TwitchMsgLog($aUpdateMsgTwitch[$aAnnounceCount1])
EndIf
EndIf
If $aRebootReason = "mod" Then
If $aAnnounceCount1 > 1 Then
$aDelayShutdownTime = $aModTime[$aAnnounceCount1] - $aModTime[($aAnnounceCount1 - 1)]
Else
$aDelayShutdownTime = $aModTime[$aAnnounceCount1]
EndIf
If $sInGameAnnounce = "yes" Then
If $aModTime[($aAnnounceCount1)] > 0 Then SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, $aModMsgInGame[$aAnnounceCount1])
EndIf
If $sUseDiscordBotUpdate = "yes" And ($sUseDiscordBotFirstAnnouncement = "no") Then
If $aModTime[($aAnnounceCount1)] > 0 Then SendDiscordMsg($sDiscordWebHookURLs, $aModMsgDiscord[$aAnnounceCount1], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotUpdate = "yes" And ($sUseTwitchFirstAnnouncement = "no") Then
If $aModTime[($aAnnounceCount1)] > 0 Then TwitchMsgLog($aModMsgTwitch[$aAnnounceCount1])
EndIf
EndIf
If $aRebootReason = "Custom" Then
If $aAnnounceCount1 > 1 Then
$aDelayShutdownTime = ($aCustomTime[$xCustomRCONRebootNumber])[$aAnnounceCount1] - ($aCustomTime[$xCustomRCONRebootNumber])[($aAnnounceCount1 - 1)]
Else
$aDelayShutdownTime = ($aCustomTime[$xCustomRCONRebootNumber])[$aAnnounceCount1]
EndIf
If $xEventAnnounceInGame[$xCustomRCONRebootNumber] <> "" Then
SendInGame($aServerIP, $aTelnetPort, $aTelnetPass, ($sCustomMsgInGame[$xCustomRCONRebootNumber])[$aAnnounceCount1])
EndIf
If $xEventAnnounceDiscord[$xCustomRCONRebootNumber] <> "" And ($sUseDiscordBotFirstAnnouncement = "no") Then
SendDiscordMsg($sDiscordWebHookURLs, ($sCustomMsgDiscord[$xCustomRCONRebootNumber])[$aAnnounceCount1], $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $xEventAnnounceTwitch[$xCustomRCONRebootNumber] <> "" And ($sUseTwitchFirstAnnouncement = "no") Then
TwitchMsgLog(($sCustomMsgTwitch[$xCustomRCONRebootNumber])[$aAnnounceCount1])
EndIf
EndIf
$aAnnounceCount1 = $aAnnounceCount1 - 1
If $aAnnounceCount1 = 0 Then
$aBeginDelayedShutdown = 3
EndIf
$aTimeCheck0 = _NowCalc()
EndIf
ElseIf $aBeginDelayedShutdown > 0 Then
_Splash($aGameName & " server reboot requested." & @CRLF & @CRLF & "No players on LOCAL grids, so skipping countdown announcements.", 4000)
If $aRebootReason = "daily" Then
If $sUseDiscordBotDaily = "yes" Then
Local $tDiscord = AnnounceReplaceTime(0, $sDiscordDailyMessage, True)
SendDiscordMsg($sDiscordWebHookURLs, $tDiscord, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotDaily = "yes" Then
Local $tTwitch = AnnounceReplaceTime(0, $sTwitchDailyMessage, True)
TwitchMsgLog($tTwitch)
EndIf
EndIf
If $aRebootReason = "remoterestart" Then
If $sUseDiscordBotRemoteRestart = "yes" Then
Local $tDiscord = AnnounceReplaceTime(0, $sDiscordRemoteRestartMessage, True)
SendDiscordMsg($sDiscordWebHookURLs, $tDiscord, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotRemoteRestart = "yes" Then
Local $tTwitch = AnnounceReplaceTime(0, $sTwitchRemoteRestartMessage, True)
TwitchMsgLog($tTwitch)
EndIf
EndIf
If $aRebootReason = "stopservers" Then
If $sUseDiscordBotStopServer = "yes" Then
Local $tDiscord = AnnounceReplaceTime(0, $sDiscordStopServerMessage, True)
SendDiscordMsg($sDiscordWebHookURLs, $tDiscord, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotStopServer = "yes" Then
Local $tTwitch = AnnounceReplaceTime(0, $sTwitchStopServerMessage, True)
TwitchMsgLog($tTwitch)
EndIf
EndIf
If $aRebootReason = "update" Then
If $sUseDiscordBotUpdate = "yes" Then
Local $tDiscord = AnnounceReplaceTime(0, $sDiscordUpdateMessage, True)
SendDiscordMsg($sDiscordWebHookURLs, $tDiscord, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotUpdate = "yes" Then
Local $tTwitch = AnnounceReplaceTime(0, $sTwitchUpdateMessage, True)
TwitchMsgLog($tTwitch)
EndIf
EndIf
If $aRebootReason = "mod" Then
If $sUseDiscordBotUpdate = "yes" Then
Local $tDiscord = AnnounceReplaceTime(0, $sDiscordModUpdateMessage, True)
SendDiscordMsg($sDiscordWebHookURLs, $tDiscord, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $sUseTwitchBotUpdate = "yes" Then
Local $tTwitch = AnnounceReplaceTime(0, $sTwitchModUpdateMessage, True)
TwitchMsgLog($tTwitch)
EndIf
EndIf
If $aRebootReason = "Custom" Then
If $xEventAnnounceDiscord[$xCustomRCONRebootNumber] <> "" And ($sUseDiscordBotFirstAnnouncement = "no") Then
Local $tDiscord = AnnounceReplaceTime(0, $sCustomMsgDiscord, True)
SendDiscordMsg($sDiscordWebHookURLs, $tDiscord, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $xEventAnnounceTwitch[$xCustomRCONRebootNumber] <> "" And ($sUseTwitchFirstAnnouncement = "no") Then
Local $tTwitch = AnnounceReplaceTime(0, $sCustomMsgTwitch, True)
TwitchMsgLog($tTwitch)
EndIf
EndIf
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
$aBeginDelayedShutdown = 0
EndIf
Else
$aBeginDelayedShutdown = 0
EndIf
#EndRegion
$aServerCheck = TimerInit()
SetStatusIdle()
EndIf
Sleep(100)
WEnd
#Region
Func GUI_Main_Close()
GUISetState(@SW_HIDE, $wGUIMainWindow)
$aShowGUI = False
$aGUIMainActive = False
TrayItemSetState($iTrayShowGUI, $TRAY_ENABLE)
EndFunc
Func GUI_Main_B_Tools()
ShowGUITools()
EndFunc
Func GUI_Main_B_Players()
F_ShowPlayerCount()
EndFunc
Func GUI_Main_B_Config()
ConfigEdit()
EndFunc
Func GUI_Main_B_LogFile()
LogWindow(1)
EndFunc
Func GUI_Main_B_ExitShutDownY()
F_ExitCloseY()
EndFunc
Func GUI_Main_B_ExitShutDownN()
F_ExitCloseN()
EndFunc
Func GUI_Main_I_DiscordServer()
F_DiscordServer()
EndFunc
Func GUI_Main_I_DiscussionForum()
F_DiscussionForum()
EndFunc
Func GUI_Main_I_Help()
F_Help()
EndFunc
Func GUI_Main_I_MainWebpage()
F_MainWebpage()
EndFunc
Func GUI_Main_I_About()
F_About()
EndFunc
Func GUI_Main_I_Pause()
F_UpdateUtilPause()
EndFunc
Func GUI_Main_I_CheckForUtilUpdates()
F_UpdateUtilCheck()
EndFunc
Func GUI_Main_I_UtilConfig()
LogWindow(5)
EndFunc
Func GUI_Main_B_SelectAll()
For $i = 0 To ($aServerGridTotal - 1)
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, True)
Next
EndFunc
Func GUI_Main_B_SelectNone()
For $i = 0 To ($aServerGridTotal - 1)
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, False)
Next
EndFunc
Func GUI_Main_B_Invert()
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, False)
Else
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, True)
EndIf
Next
EndFunc
Func GUI_Main_B_Local()
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, True)
Else
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, False)
EndIf
Next
EndFunc
Func GUI_Main_B_Remote()
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, False)
Else
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, True)
EndIf
Next
EndFunc
Func GUI_Main_B_PVP()
For $i = 0 To ($aServerGridTotal - 1)
If $xServerPVE[$i] = False Then
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, True)
Else
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, False)
EndIf
Next
EndFunc
Func GUI_Main_B_PVE()
For $i = 0 To ($aServerGridTotal - 1)
If $xServerPVE[$i] = True Then
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, True)
Else
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, False)
EndIf
Next
EndFunc
Func GUI_Main_B_BackupMenu()
Local $aMsg = "Backup menu coming soon!" & @CRLF & "Edit the config file to adjust backup schedule." & @CRLF & @CRLF & "Click (YES) to make a backup now." & @CRLF & "Click (NO) Or (CANCEL) to cancel backup."
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Then
_Splash("Backup up Atlas files now.")
_BackupGame(False)
SplashOff()
EndIf
EndFunc
Func GUI_Main_B_GridConfigurator()
GridConfiguratorGUI(0)
EndFunc
Func GUI_Main_B_EventScheduler()
Run("notepad.exe " & $aEventSaveFile)
Sleep(500)
MsgBox($MB_OK, $aUtilName, "Event Scheduler is unfinished.  It is fully functional, but a simpler entry method and an interactive calendar are coming soon!" & @CRLF & @CRLF & "See AtlasServerUpdateUtility.ini file (or click CONFIG) to edit scheduler.", 30)
EndFunc
Func GUI_Main_B_ModUpdates()
F_ModUpdate()
EndFunc
Func GUI_Main_B_UpdateGame()
F_UpdateServCheck()
EndFunc
Func GUI_Main_B_UpdateUtil()
F_UpdateUtilCheck()
EndFunc
Func GUI_Main_B_AllRmtRestart()
F_RemoteRestart()
EndFunc
Func GUI_Main_B_AllRestartNow()
F_RestartNow()
EndFunc
Func GUI_Main_B_StopServerAll()
F_StopServer()
$aServerReadyOnce = False
EndFunc
Func GUI_Main_B_StartServerAll()
F_StartServer()
EndFunc
Func GUI_Main_B_AllSendRCON()
F_SendRCON("all")
EndFunc
Func GUI_Main_B_AllSendMsg()
F_SendMessage("all")
EndFunc
Func GUI_Main_B_SelectSendRCON()
F_SendRCON("sel")
EndFunc
Func GUI_Main_B_SelectSendMsg()
F_SendMessage("sel")
EndFunc
Func GUI_Main_B_SelectStartServers()
SelectServersStart()
EndFunc
Func GUI_Main_B_SelectStopServers()
SelectServersStop()
$aServerReadyOnce = False
EndFunc
Func GUI_Main_I_IconRefreshPlayers()
$tSplash = _Splash("")
$aOnlinePlayers = GetPlayerCount($tSplash, False, True)
_Splash("Online players scan complete.", 2000)
ShowPlayerCount()
EndFunc
Func GUI_Main_CB_PollRemoteServers()
EndFunc
Func GUI_Main_CB_PollOnlinePlayers()
EndFunc
Func GUI_Main_E_UpdateIntervalEdit()
EndFunc
Func GUI_OnlinePlayers_Close()
GUIDelete($gOnlinePlayerWindow)
$aPlayerCountWindowTF = False
$aPlayerCountShowTF = False
GUICtrlSetState($Players, $GUI_ENABLE)
TrayItemSetState($iTrayPlayerCount, $TRAY_ENABLE)
EndFunc
Func Tray_ShowGUI()
$aShowGUI = True
$aGUIMainActive = False
GUISetState(@SW_SHOWNORMAL, $wGUIMainWindow)
EndFunc
Func Tray_ShowConfig()
ShellExecute($aIniFile)
EndFunc
Func Tray_About()
F_About()
EndFunc
Func Tray_UtilUpdate()
F_UpdateUtilCheck()
EndFunc
Func Tray_PauseUtil()
F_UpdateUtilPause()
EndFunc
Func Tray_AllSendMsg()
F_SendMessage()
EndFunc
Func Tray_AllSendRCON()
F_SendRCON("all")
EndFunc
Func Tray_ShowOnlinePlayers()
F_ShowPlayerCount()
EndFunc
Func Tray_OnlinePlayersCheckDisable()
TrayShowPlayerCheckPause()
EndFunc
Func Tray_OnlinePlayersCheckEnable()
TrayShowPlayerCheckUnPause()
EndFunc
Func Tray_ServerUpdateCheck()
F_UpdateServCheck()
EndFunc
Func Tray_ServerUpdateDisable()
TrayUpdateServPause()
EndFunc
Func Tray_ServerUpdateEnable()
TrayUpdateServUnPause()
EndFunc
Func Tray_RemoteRestart()
F_RemoteRestart()
EndFunc
Func Tray_RestartServersNow()
F_RestartNow()
EndFunc
Func Tray_ExitShutDownN()
F_ExitCloseN()
EndFunc
Func Tray_ExitShutDownY()
F_ExitCloseY()
EndFunc
Func GUI_Log_Close()
GUIDelete($LogWindow)
EndFunc
Func GUI_Log_Basic_B_Button()
Local $i = @GUI_CtrlId - $lBasicBDay[0]
Local $tFileName = $aFolderLog & $aUtilName & "_Log_" & StringRegExpReplace($lBasicDDate[$i], "/", "-") & ".txt"
Local $tFileOpen = FileOpen($tFileName)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
If $tTxt = "" Then
$tTxt = "[No file found]"
For $i = 0 To 50
$tTxt &= @CRLF
Next
EndIf
GUICtrlSetData($lBasicEdit, $tTxt)
EndFunc
Func GUI_Log_Detailed_B_Button()
Local $i = @GUI_CtrlId - $lDetailedBDay[0]
Local $tFileName = $aFolderLog & $aUtilName & "_LogFull_" & StringRegExpReplace($lDetailedDDate[$i], "/", "-") & ".txt"
Local $tFileOpen = FileOpen($tFileName)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
If $tTxt = "" Then
$tTxt = "[No file found]"
For $i = 0 To 50
$tTxt &= @CRLF
Next
EndIf
GUICtrlSetData($lDetailedEdit, $tTxt)
EndFunc
Func GUI_Log_OnlinePlayers_B_Button()
Local $i = @GUI_CtrlId - $lOnlinePlayersBDay[0]
Local $tFileName = $aFolderLog & $aUtilName & "_OnlineUserLog_" & StringRegExpReplace($lOnlinePlayersDDate[$i], "/", "-") & ".txt"
Local $tFileOpen = FileOpen($tFileName)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
If $tTxt = "" Then
$tTxt = "[No file found]"
For $i = 0 To 50
$tTxt &= @CRLF
Next
EndIf
GUICtrlSetData($lOnlinePlayersEdit, $tTxt)
EndFunc
Func GUI_Log_ServerSummary_B_Button()
MakeServerSummaryFile($aServerSummaryFile)
Local $tFileOpen = FileOpen($aServerSummaryFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lServerSummaryEdit, $tTxt)
EndFunc
Func GUI_Log_Config_B_Save()
Local $tTxt = ReplaceCRwithCRLF(GUICtrlRead($lConfigEdit))
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aIniFile & "_" & $tTime & ".bak"
FileMove($aIniFile, $tFile, 1)
FileWrite($aIniFile, $tTxt)
_Splash($aUtilName & ".ini updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $aUtilName & "_" & $tTime & ".bak", 3000, 475)
EndFunc
Func GUI_Log_Config_B_Reset()
Local $tFileOpen = FileOpen($aIniFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lConfigEdit, $tTxt)
EndFunc
Func GUI_Log_GridSelect_B_Save()
Local $tTxt = ReplaceCRwithCRLF(GUICtrlRead($lGridSelectEdit))
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aGridSelectFile & "_" & $tTime & ".bak"
FileMove($aGridSelectFile, $tFile, 1)
FileWrite($aGridSelectFile, $tTxt)
_Splash($aUtilName & "GridStartSelect.ini updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $aUtilName & "GridStartSelect.ini_" & $tTime & ".bak", 3000, 525)
EndFunc
Func GUI_Log_GridSelect_B_Reset()
Local $tFileOpen = FileOpen($aGridSelectFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lGridSelectEdit, $tTxt)
EndFunc
Func GUI_Log_ServerGrid_B_Save()
Local $tTxt = ReplaceCRwithCRLF(GUICtrlRead($lServerGridEdit))
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aConfigFull & "_" & $tTime & ".bak"
FileMove($aConfigFull, $tFile, 1)
FileWrite($aConfigFull, $tTxt)
_Splash($aConfigFile & " updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $aConfigFile & "_" & $tTime & ".bak", 3000, 525)
EndFunc
Func GUI_Log_ServerGrid_B_Reset()
Local $tFileOpen = FileOpen($aConfigFull)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lServerGridEdit, $tTxt)
EndFunc
Func GUI_Log_DefaultGame_B_Save()
Local $tTxt = ReplaceCRwithCRLF(GUICtrlRead($lDefaultGameEdit))
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aDefaultGame & "_" & $tTime & ".bak"
FileMove($aDefaultGame, $tFile, 1)
FileWrite($aDefaultGame, $tTxt)
_Splash("DefaultGame.ini updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & "DefaultGame.ini_" & $tTime & ".bak", 3000, 525)
EndFunc
Func GUI_Log_DefaultGame_B_Reset()
Local $tFileOpen = FileOpen($aDefaultGame)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lDefaultGameEdit, $tTxt)
EndFunc
Func GUI_Log_DefaultGUS_B_Save()
Local $tTxt = ReplaceCRwithCRLF(GUICtrlRead($lDefaultGUSEdit))
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aDefaultGUS & "_" & $tTime & ".bak"
FileMove($aDefaultGUS, $tFile, 1)
FileWrite($aDefaultGUS, $tTxt)
_Splash("DefaultGameUserSettings.ini updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & "DefaultGameUserSettings.ini_" & $tTime & ".bak", 3000, 525)
EndFunc
Func GUI_Log_DefaultGUS_B_Reset()
Local $tFileOpen = FileOpen($aDefaultGUS)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lDefaultGUSEdit, $tTxt)
EndFunc
Func GUI_Log_DefaultEngine_B_Save()
Local $tTxt = ReplaceCRwithCRLF(GUICtrlRead($lDefaultEngineEdit))
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aDefaultEngine & "_" & $tTime & ".bak"
FileMove($aDefaultEngine, $tFile, 1)
FileWrite($aDefaultEngine, $tTxt)
_Splash("DefaultEngine.ini updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & "DefaultEngine.ini_" & $tTime & ".bak", 3000, 525)
EndFunc
Func GUI_Log_DefaultEngine_B_Reset()
Local $tFileOpen = FileOpen($aDefaultEngine)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lDefaultEngineEdit, $tTxt)
EndFunc
#EndRegion
Func WM_NOTIFY($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam
Local $hWndFrom, $iIDFrom, $iCode, $tNMHDR, $hWndListView, $tInfo
$hWndListView = $wMainListViewWindow
If Not IsHWnd($wMainListViewWindow) Then $hWndListView = GUICtrlGetHandle($wMainListViewWindow)
$tNMHDR = DllStructCreate($tagNMHDR, $lParam)
$hWndFrom = HWnd(DllStructGetData($tNMHDR, "hWndFrom"))
$iIDFrom = DllStructGetData($tNMHDR, "IDFrom")
$iCode = DllStructGetData($tNMHDR, "Code")
Switch $hWndFrom
Case $hWndListView
Switch $iCode
Case $LVN_COLUMNCLICK
$tInfo = DllStructCreate($tagNMLISTVIEW, $lParam)
$tClickType = "Header"
$tClickHead = DllStructGetData($tInfo, "SubItem")
$tClickRow = -1
$tClickCol = -1
Case $NM_CLICK
$tInfo = DllStructCreate($tagNMITEMACTIVATE, $lParam)
$tClickType = "L1"
$tClickHead = -1
$tClickRow = DllStructGetData($tInfo, "Index")
$tClickCol = DllStructGetData($tInfo, "SubItem")
Case $NM_DBLCLK
$tInfo = DllStructCreate($tagNMITEMACTIVATE, $lParam)
$tClickType = "L2"
$tClickHead = -1
$tClickRow = DllStructGetData($tInfo, "Index")
$tClickCol = DllStructGetData($tInfo, "SubItem")
Case $NM_RCLICK
$tInfo = DllStructCreate($tagNMITEMACTIVATE, $lParam)
$tClickType = "R1"
$tClickHead = -1
$tClickRow = DllStructGetData($tInfo, "Index")
$tClickCol = DllStructGetData($tInfo, "SubItem")
Case $NM_RDBLCLK
$tInfo = DllStructCreate($tagNMITEMACTIVATE, $lParam)
$tClickType = "R2"
$tClickHead = -1
$tClickRow = DllStructGetData($tInfo, "Index")
$tClickCol = DllStructGetData($tInfo, "SubItem")
EndSwitch
EndSwitch
Return $GUI_RUNDEFMSG
EndFunc
Func F_DiscordServer()
Run(@ComSpec & " /c " & "start http://discord.gg/EU7pzPs", "")
EndFunc
Func F_DiscussionForum()
Run(@ComSpec & " /c " & "start http://phoenix125.createaforum.com/index.php", "")
EndFunc
Func F_Help()
Run(@ComSpec & " /c " & "start http://www.phoenix125.com/AtlasHelp.html", "")
EndFunc
Func F_MainWebpage()
Run(@ComSpec & " /c " & "start " & $aWebsite, "")
EndFunc
Func F_About()
MsgBox($MB_SYSTEMMODAL, $aUtilName, $aUtilName & @CRLF & "Version: " & $aUtilVersion & @CRLF & @CRLF & "Install Path: " & @ScriptDir & @CRLF & @CRLF & "Discord: http://discord.gg/EU7pzPs" & @CRLF & "Website: http://www.phoenix125.com", 15)
EndFunc
Func F_ModUpdate()
SetStatusBusy("Check: Mod Update")
CheckMod($aServerModList, $aSteamCMDDir, $aServerDirLocal, 0, True)
SetStatusIdle()
SplashOff()
EndFunc
#Region
Func ReadUini($sIniFile, $sLogFile, $tUseWizard = False)
Global $iIniError = ""
Global $iIniFail = 0
$iIniRead = True
Local $iniCheck = ""
Local $aChar[3]
For $i = 1 To 13
$aChar[0] = Chr(Random(97, 122, 1))
$aChar[1] = Chr(Random(48, 57, 1))
$iniCheck &= $aChar[Random(0, 1, 1)]
Next
Global $aServerDirLocal = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " DIR ###", $iniCheck)
Global $aServerExtraCMD = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " extra commandline parameters (ex.?serverpve-pve -NoCrashDialog) ###", $iniCheck)
Global $aServerMultiHomeIP = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server multi-home IP (Leave blank to disable) ###", $iniCheck)
Global $aSteamExtraCMD = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "SteamCMD extra commandline parameters (ex. -latest_experimental) ###", $iniCheck)
Global $aServerMinimizedYN = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Start servers minimized (for a cleaner look)? (yes/no) ###", $iniCheck)
Global $aServerAdminPass = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Admin password ###", $iniCheck)
Global $aServerMaxPlayers = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Max players ###", $iniCheck)
Global $aServerReservedSlots = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Reserved slots ###", $iniCheck)
Global $aServerRCONImport = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Import RCON ports from GameUserSettings.ini files? (yes/no) ###", $iniCheck)
Global $aServerRCONIP = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "RCON IP (ex. 127.0.0.1 - Leave BLANK for server IP) ###", $iniCheck)
Global $aServerRCONPort = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server RCON Port(s) (comma separated, grid order as in ServerGrid.json, ignore if importing RCON ports) ###", $iniCheck)
Global $aServerAltSaveSelect = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", $iniCheck)
Global $aServerAltSaveDir = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames (Use same order as listed in ServerGrid.json. Comma separated) ###", $iniCheck)
Global $aServerModYN = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Use this util to install mods and check for mod updates (as listed in ServerGrid.json)? (yes/no) ###", $iniCheck)
Global $aServerModTimeoutMin = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Max time (minutes) to wait for each mod to download (0-180) (0-No Timeout) ###", $iniCheck)
Global $aServerOnlinePlayerYN = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for, and log, online players? (yes/no) ###", $iniCheck)
Global $aServerOnlinePlayerSec = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for online players every _ seconds (30-600) ###", $iniCheck)
Global $aPollRemoteServersYN = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for online players on remote servers? (yes/no) ###", $iniCheck)
Global $aOnlinePlayersRetryAttempts = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Number of Online Player RCON retry attempts (0-3) ###", $iniCheck)
Global $aServerUseRedis = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Autostart and keep-alive redis-server.exe? Use NO to manage redis-server.exe yourself (yes/no) ###", $iniCheck)
Global $aServerRedisConfig = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Redis-server config file (Not used if autostart is NO above) ###", $iniCheck)
Global $aServerRedisFolder = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Redis-server.exe and config DIR (Not used if autostart is NO above) Leave BLANK for default DIR ###", $iniCheck)
Global $aServerStartDelay = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Delay in seconds between grid server starts (0-600) ###", $iniCheck)
Global $aServerShutdownDelay = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Delay in seconds between grid server shutdowns (0-600) ###", $iniCheck)
Global $aShutDnWait = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Seconds allowed for GameSave before taskkilling servers during reboots (10-600) ###", $iniCheck)
Global $aNamingScheme = IniRead($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Grid naming scheme: Use (1) 00 01 (2) A1 A2 (3) 0,0 0,1 ###", $iniCheck)
Global $aCheckForUpdate = IniRead($sIniFile, " --------------- CHECK FOR UPDATE --------------- ", "Check for server updates? (yes/no) ###", $iniCheck)
Global $aUpdateCheckInterval = IniRead($sIniFile, " --------------- CHECK FOR UPDATE --------------- ", "Update check interval in Minutes (05-59) ###", $iniCheck)
Global $aBackupYN = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Use scheduled backups? (yes/no) ###", $iniCheck)
Global $aBackupDays = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Backup days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $iniCheck)
Global $aBackupHours = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Backup hours (comma separated 00-23 ex.04,16) ###", $iniCheck)
Global $aBackupMin = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Backup minute (00-59) ###", $iniCheck)
Global $aBackupOutputFolder = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Output folder ###", $iniCheck)
Global $aBackupRedisFolder = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Redis folder (leave blank to use redis folder above or to disable) ###", $iniCheck)
Global $aBackupNumberToKeep = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Number of backups to keep (1-999) ###", $iniCheck)
Global $aBackupTimeoutSec = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Max time in seconds to wait for backup to complete (30-999) ###", $iniCheck)
Global $aBackupInGame = IniRead($sIniFile, " --------------- BACKUP --------------- ", "In-Game announcement when backup initiated (Leave blank to disable) ###", $iniCheck)
Global $aBackupDiscord = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Discord announcement when backup initiated (Leave blank to disable) ###", $iniCheck)
Global $aBackupTwitch = IniRead($sIniFile, " --------------- BACKUP --------------- ", "Twitch announcement when backup initiated (Leave blank to disable) ###", $iniCheck)
Global $aEventCount = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND COUNT --------------- ", "Number of custom RCON Commands to schedule (If changed, util will restart and new custom entries will be added) ###", $iniCheck)
If $iniCheck = $aEventCount Then
$aEventCount = 1
$aEventCntIniCheck = True
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONCount, "
Else
$aEventCntIniCheck = False
EndIf
Global $xCustomRCONCmd[$aEventCount], $xEventDays[$aEventCount], $xEventHours[$aEventCount], $xEventMinute[$aEventCount]
Global $xCustomRCONAllorLocal[$aEventCount], $xEventFile[$aEventCount], $xCustomRCONRestartYN[$aEventCount]
Global $xEventAnnounceMinutes[$aEventCount], $xEventAnnounceInGame[$aEventCount], $xEventAnnounceDiscord[$aEventCount]
Global $xEventMonthDate[$aEventCount], $xEventAnnounceTwitch[$aEventCount], $xEventMonths[$aEventCount], $xEventName[$aEventCount]
For $i = 0 To ($aEventCount - 1)
$xEventName[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Event Name ###", $iniCheck)
$xCustomRCONCmd[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-RCON Command(s) to send (Separated by ~, leave BLANK to skip) ###", $iniCheck)
$xCustomRCONAllorLocal[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-RCON Command send to (0) ALL grids or (1) Local Grids Only ###", $iniCheck)
$xEventFile[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-File to Execute (leave BLANK to skip) ###", $iniCheck)
$xEventMonths[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Months (comma separated 0-Monthly, 1-12) ###", $iniCheck)
$xEventMonthDate[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Days of Month (comma separated 0-Use Weekday Below, 1-31) ###", $iniCheck)
$xEventDays[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Weekdays (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $iniCheck)
$xEventHours[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event hours (comma separated 00-23 ex.04,16) ###", $iniCheck)
$xEventMinute[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event minute (00-59) ###", $iniCheck)
$xCustomRCONRestartYN[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Restart servers afterward? (with announcements below) (yes/no) ###", $iniCheck)
$xEventAnnounceMinutes[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Announcement _ minutes before reboot (comma separated 1-60) ###", $iniCheck)
$xEventAnnounceInGame[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-In-Game Message to send (\m - minutes)(leave BLANK to skip) ###", $iniCheck)
$xEventAnnounceDiscord[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Discord Message to send (\m - minutes)(leave BLANK to skip) ###", $iniCheck)
$xEventAnnounceTwitch[$i] = IniRead($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Twitch Message to send (\m - minutes)(leave BLANK to skip) ###", $iniCheck)
Next
Global $aDestroyWildDinosYN = IniRead($sIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos? (yes/no) ###", $iniCheck)
Global $aDestroyWildDinosDays = IniRead($sIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $iniCheck)
Global $aDestroyWildDinosHours = IniRead($sIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos hours (comma separated 00-23 ex.04,16) ###", $iniCheck)
Global $aDestroyWildDinosMinute = IniRead($sIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos minute (0-59) ###", $iniCheck)
Global $aRemoteRestartUse = IniRead($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Use Remote Restart? (yes/no) ###", $iniCheck)
Global $aRemoteRestartIP = IniRead($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Server Local IP (ex. 192.168.1.10) ###", $iniCheck)
Global $aRemoteRestartPort = IniRead($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Restart Port ###", $iniCheck)
Global $aRemoteRestartKey = IniRead($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Restart Key ###", $iniCheck)
Global $aRemoteRestartCode = IniRead($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Restart Code ###", $iniCheck)
Global $aRestartDaily = IniRead($sIniFile, " --------------- SCHEDULED RESTARTS --------------- ", "Use scheduled restarts? (yes/no) ###", $iniCheck)
Global $aRestartDays = IniRead($sIniFile, " --------------- SCHEDULED RESTARTS --------------- ", "Restart days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $iniCheck)
Global $bRestartHours = IniRead($sIniFile, " --------------- SCHEDULED RESTARTS --------------- ", "Restart hours (comma separated 00-23 ex.04,16) ###", $iniCheck)
Global $bRestartMin = IniRead($sIniFile, " --------------- SCHEDULED RESTARTS --------------- ", "Restart minute (00-59) ###", $iniCheck)
Global $sAnnounceNotifyDaily = IniRead($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before DAILY reboot (comma separated 0-60) ###", $iniCheck)
Global $sAnnounceNotifyUpdate = IniRead($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before UPDATES reboot (comma separated 0-60) ###", $iniCheck)
Global $sAnnounceNotifyRemote = IniRead($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before REMOTE RESTART reboot (comma separated 0-60) ###", $iniCheck)
Global $sAnnounceNotifyStopServer = IniRead($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before STOP SERVER (comma separated 0-60) ###", $iniCheck)
Global $sAnnounceNotifyModUpdate = IniRead($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before MOD UPDATE reboot (comma separated 0-60) ###", $iniCheck)
Global $sAnnounceNamingScheme = IniRead($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement grid naming scheme: Use (1) 00 01 (2) A1 A2 (3) 0,0 0,1 ###", $iniCheck)
Global $sInGameAnnounce = IniRead($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announce messages in-game? (Requires RCON) (yes/no) ###", $iniCheck)
Global $sInGameMessageDuration = IniRead($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Approximate duration to display messages in-game (seconds)? (6-30) ###", $iniCheck)
Global $sInGameDailyMessage = IniRead($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement DAILY (\m - minutes) ###", $iniCheck)
Global $sInGameUpdateMessage = IniRead($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement UPDATES (\m - minutes) ###", $iniCheck)
Global $sInGameRemoteRestartMessage = IniRead($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement REMOTE RESTART (\m - minutes) ###", $iniCheck)
Global $sInGameStopServerMessage = IniRead($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", $iniCheck)
Global $sInGameModUpdateMessage = IniRead($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement MOD UPDATE (\m - minutes, \x - Mod ID) ###", $iniCheck)
Global $sInGame10SecondMessage = IniRead($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement 10 seconds before reboot ###", $iniCheck)
Global $sUseDiscordBotDaily = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for DAILY reboot? (yes/no) ###", $iniCheck)
Global $sUseDiscordBotUpdate = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for UPDATE reboot? (yes/no) ###", $iniCheck)
Global $sUseDiscordBotRemoteRestart = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for REMOTE RESTART reboot? (yes/no) ###", $iniCheck)
Global $sUseDiscordBotStopServer = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for STOP SERVER? (yes/no) ###", $iniCheck)
Global $sUseDiscordBotModUpdate = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for MOD UPDATE reboot? (yes/no) ###", $iniCheck)
Global $sUseDiscordBotServersUpYN = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message when all servers are back online (yes/no) ###", $iniCheck)
Global $sUseDiscordBotFirstAnnouncement = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for first ANNOUNCEMENT only? (reduces bot spam)(yes/no) ###", $iniCheck)
Global $sDiscordDailyMessage = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement DAILY (\m - minutes) ###", $iniCheck)
Global $sDiscordUpdateMessage = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement UPDATES (\m - minutes) ###", $iniCheck)
Global $sDiscordRemoteRestartMessage = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement REMOTE RESTART (\m - minutes) ###", $iniCheck)
Global $sDiscordStopServerMessage = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", $iniCheck)
Global $sDiscordModUpdateMessage = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement MOD UPDATE (\m - minutes, \x - Mod ID) ###", $iniCheck)
Global $sDiscordServersUpMessage = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement Servers back online ###", $iniCheck)
Global $sDiscordWebHookURLs = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "WebHook URL ###", $iniCheck)
Global $sDiscordBotName = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Bot Name ###", $iniCheck)
Global $bDiscordBotUseTTS = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Use TTS? (yes/no) ###", $iniCheck)
Global $sDiscordBotAvatar = IniRead($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Bot Avatar Link ###", $iniCheck)
Global $sUseTwitchBotDaily = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for DAILY reboot? (yes/no) ###", $iniCheck)
Global $sUseTwitchBotUpdate = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for UPDATE reboot? (yes/no) ###", $iniCheck)
Global $sUseTwitchBotRemoteRestart = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for REMOTE RESTART reboot? (yes/no) ###", $iniCheck)
Global $sUseTwitchBotStopServer = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for STOP SERVER? (yes/no) ###", $iniCheck)
Global $sUseTwitchBotModUpdate = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for MOD UPDATE reboot? (yes/no) ###", $iniCheck)
Global $sUseTwitchFirstAnnouncement = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for first announcement only? (reduces bot spam)(yes/no) ###", $iniCheck)
Global $sTwitchDailyMessage = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement DAILY (\m - minutes) ###", $iniCheck)
Global $sTwitchUpdateMessage = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement UPDATES (\m - minutes) ###", $iniCheck)
Global $sTwitchRemoteRestartMessage = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement REMOTE RESTART (\m - minutes) ###", $iniCheck)
Global $sTwitchStopServerMessage = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", $iniCheck)
Global $sTwitchModUpdateMessage = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement MOD UPDATE (\m - minutes, \x - Mod ID) ###", $iniCheck)
Global $sTwitchNick = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Nick ###", $iniCheck)
Global $sChatOAuth = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "ChatOAuth ###", $iniCheck)
Global $sTwitchChannels = IniRead($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Channels ###", $iniCheck)
Global $aExecuteExternalScript = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT BEFORE SteamCMD UPDATE AND SERVER START --------------- ", "1-Execute external script BEFORE update? (yes/no) ###", $iniCheck)
Global $aExternalScriptDir = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT BEFORE SteamCMD UPDATE AND SERVER START --------------- ", "1-Script directory ###", $iniCheck)
Global $aExternalScriptName = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT BEFORE SteamCMD UPDATE AND SERVER START --------------- ", "1-Script filename ###", $iniCheck)
Global $aExternalScriptWait = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT BEFORE SteamCMD UPDATE AND SERVER START --------------- ", "1-Wait for script to complete before continuing? (yes/no) ###", $iniCheck)
Global $aExternalScriptValidateYN = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT AFTER SteamCMD BUT BEFORE SERVER START --------------- ", "2-Execute external script AFTER update but BEFORE server start? (yes/no) ###", $iniCheck)
Global $aExternalScriptValidateDir = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT AFTER SteamCMD BUT BEFORE SERVER START --------------- ", "2-Script directory ###", $iniCheck)
Global $aExternalScriptValidateName = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT AFTER SteamCMD BUT BEFORE SERVER START --------------- ", "2-Script filename ###", $iniCheck)
Global $aExternalScriptValidateWait = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT AFTER SteamCMD BUT BEFORE SERVER START --------------- ", "2-Wait for script to complete before continuing? (yes/no) ###", $iniCheck)
Global $aExternalScriptUpdateYN = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR SERVER *UPDATE* --------------- ", "3-Execute external script for server update restarts? (yes/no) ###", $iniCheck)
Global $aExternalScriptUpdateDir = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR SERVER *UPDATE* --------------- ", "3-Script directory ###", $iniCheck)
Global $aExternalScriptUpdateFileName = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR SERVER *UPDATE* --------------- ", "3-Script filename ###", $iniCheck)
Global $aExternalScriptUpdateWait = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR SERVER *UPDATE* --------------- ", "3-Wait for script to complete before continuing? (yes/no) ###", $iniCheck)
Global $aExternalScriptDailyYN = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *DAILY* SERVER RESTART --------------- ", "4-Execute external script for daily server restarts? (yes/no) ###", $iniCheck)
Global $aExternalScriptDailyDir = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *DAILY* SERVER RESTART --------------- ", "4-Script directory ###", $iniCheck)
Global $aExternalScriptDailyFileName = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *DAILY* SERVER RESTART --------------- ", "4-Script filename ###", $iniCheck)
Global $aExternalScriptDailyWait = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *DAILY* SERVER RESTART --------------- ", "4-Wait for script to complete before continuing? (yes/no) ###", $iniCheck)
Global $aExternalScriptAnnounceYN = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN FIRST RESTART ANNOUNCEMENT IS MADE --------------- ", "5-Execute external script when first restart announcement is made? (yes/no) ###", $iniCheck)
Global $aExternalScriptAnnounceDir = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN FIRST RESTART ANNOUNCEMENT IS MADE --------------- ", "5-Script directory ###", $iniCheck)
Global $aExternalScriptAnnounceFileName = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN FIRST RESTART ANNOUNCEMENT IS MADE --------------- ", "5-Script filename ###", $iniCheck)
Global $aExternalScriptAnnounceWait = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN FIRST RESTART ANNOUNCEMENT IS MADE --------------- ", "5-Wait for script to complete before continuing? (yes/no) ###", $iniCheck)
Global $aExternalScriptRemoteYN = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT DURING RESTART WHEN REMOTE RESTART REQUEST IS MADE --------------- ", "6-Execute external script during restart when a remote restart request is made? (yes/no) ###", $iniCheck)
Global $aExternalScriptRemoteDir = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT DURING RESTART WHEN REMOTE RESTART REQUEST IS MADE --------------- ", "6-Script directory ###", $iniCheck)
Global $aExternalScriptRemoteFileName = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT DURING RESTART WHEN REMOTE RESTART REQUEST IS MADE --------------- ", "6-Script filename ###", $iniCheck)
Global $aExternalScriptRemoteWait = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT DURING RESTART WHEN REMOTE RESTART REQUEST IS MADE --------------- ", "6-Wait for script to complete before continuing? (yes/no) ###", $iniCheck)
Global $aExternalScriptModYN = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *MOD UPDATE* SERVER RESTART --------------- ", "7-Execute external script when mod update required (prior to server shutdown)? (yes/no) ###", $iniCheck)
Global $aExternalScriptModDir = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *MOD UPDATE* SERVER RESTART --------------- ", "7-Script directory ###", $iniCheck)
Global $aExternalScriptModFileName = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *MOD UPDATE* SERVER RESTART --------------- ", "7-Script filename ###", $iniCheck)
Global $aExternalScriptModWait = IniRead($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *MOD UPDATE* SERVER RESTART --------------- ", "7-Wait for script to complete before continuing? (yes/no) ###", $iniCheck)
Global $aLogQuantity = IniRead($sIniFile, " --------------- LOG FILE OPTIONS --------------- ", "Delete util log files older than __ days ###", $iniCheck)
Global $sObfuscatePass = IniRead($sIniFile, " --------------- LOG FILE OPTIONS --------------- ", "Hide passwords in log files? (yes/no) ###", $iniCheck)
Global $aEnableRCON = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Enable RCON? Required for clean shutdown (yes/no) ###", $iniCheck)
Global $aValidate = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Validate files with SteamCMD update? (yes/no) ###", $iniCheck)
Global $aUpdateSource = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "For update checks, use (0)SteamCMD or (1)SteamDB.com ###", $iniCheck)
Global $aUpdateUtil = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Check for " & $aUtilName & " updates every __ hours (0 to disable) (0-24) ###", $iniCheck)
Global $aUpdateAutoUtil = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Automatically install " & $aUtilName & " updates? (yes/no) ###", $iniCheck)
Global $aUseKeepAliveYN = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Run KeepAlive program to detect util crashes and restart it? (yes/no) ###", $iniCheck)
Global $aUtilBetaYN = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", $aUtilName & " version: (0)Stable, (1)Beta ###", $iniCheck)
Global $aExternalScriptHideYN = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Hide external scripts when executed? (if yes, scripts may not execute properly) (yes/no) ###", $iniCheck)
Global $aRCONResponseWaitms = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Time to wait for RCON response in milliseconds (100-3000) ###", $iniCheck)
Global $aOnlinePlayerWaitms = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Time to wait for Online Players RCON response in milliseconds (100-3000) ###", $iniCheck)
Global $aMainGUIRefreshTime = IniRead($sIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Update the Main Window data every __ seconds (2-60) ###", $iniCheck)
If $iniCheck = $aServerDirLocal Then
$aServerDirLocal = "D:\Game Servers\" & $aGameName & " Dedicated Server"
$iIniFail += 1
$iIniError = $iIniError & "ServerDirLocal, "
EndIf
If $iniCheck = $aServerAltSaveSelect Then
$aServerAltSaveSelect = 2
$iIniFail += 1
$iIniError = $iIniError & "Server AltSaveDirectoryNames Pattern, "
EndIf
If $iniCheck = $aServerAltSaveDir Then
$aServerAltSaveDir = ""
$iIniFail += 1
$iIniError = $iIniError & "Server AltSaveDirectoryNames, "
EndIf
If $iniCheck = $aServerExtraCMD Then
$aServerExtraCMD = "-log -server -servergamelog -NoBattlEye"
$iIniFail += 1
$iIniError = $iIniError & "ServerExtraCMD, "
EndIf
If $iniCheck = $aSteamExtraCMD Then
$aSteamExtraCMD = ""
$iIniFail += 1
$iIniError = $iIniError & "SteamExtraCMD, "
EndIf
If $iniCheck = $aServerMultiHomeIP Then
$aServerMultiHomeIP = ""
$iIniFail += 1
$iIniError = $iIniError & "ServerMultiHomeIP, "
EndIf
If $iniCheck = $aServerMinimizedYN Then
$aServerMinimizedYN = "yes"
$iIniFail += 1
$iIniError = $iIniError & "ServerMinimizedYN, "
EndIf
If $iniCheck = $aValidate Then
$aValidate = "no"
$iIniFail += 1
$iIniError = $iIniError & "Validate, "
EndIf
If StringLeft($aServerExtraCMD, 1) = "-" Then
$aServerExtraCMD = " " & $aServerExtraCMD
EndIf
If $iniCheck = $aServerAdminPass Then
$aServerAdminPass = "AdMiN_PaSsWoRd"
$iIniFail += 1
$iIniError = $iIniError & "ServerAdminPass, "
EndIf
If $iniCheck = $aServerMaxPlayers Then
$aServerMaxPlayers = "40"
$iIniFail += 1
$iIniError = $iIniError & "ServerMaxPlayers, "
EndIf
If $iniCheck = $aServerReservedSlots Then
$aServerReservedSlots = "10"
$iIniFail += 1
$iIniError = $iIniError & "ServerReservedSlots, "
EndIf
If $iniCheck = $aServerRCONIP Then
$aServerRCONIP = ""
$iIniFail += 1
$iIniError = $iIniError & "ServerRCONIP, "
EndIf
If $iniCheck = $aServerRCONImport Then
$aServerRCONImport = "no"
$iIniFail += 1
$iIniError = $iIniError & "ServerRCONImport, "
EndIf
If $iniCheck = $aServerRCONPort Then
$aServerRCONPort = "25720"
$iIniFail += 1
$iIniError = $iIniError & "ServerRCONPort, "
EndIf
If $iniCheck = $aServerModYN Then
$aServerModYN = "yes"
$iIniFail += 1
$iIniError = $iIniError & "ServerModYN, "
EndIf
If $iniCheck = $aServerModTimeoutMin Then
$aServerModTimeoutMin = "10"
$iIniFail += 1
$iIniError = $iIniError & "ServerModTimeout, "
ElseIf $aServerModTimeoutMin < 0 Then
$aServerModTimeoutMin = 0
ElseIf $aServerModTimeoutMin > 180 Then
$aServerModTimeoutMin = 180
EndIf
If $iniCheck = $aServerOnlinePlayerYN Then
$aServerOnlinePlayerYN = "yes"
$iIniFail += 1
$iIniError = $iIniError & "ServerOnlinePlayerYN, "
EndIf
If $iniCheck = $aServerOnlinePlayerSec Then
$aServerOnlinePlayerSec = "60"
$iIniFail += 1
$iIniError = $iIniError & "ServerOnlinePlayerSec, "
ElseIf $aServerOnlinePlayerSec < 30 Then
$aServerOnlinePlayerSec = 30
ElseIf $aServerOnlinePlayerSec > 600 Then
$aServerOnlinePlayerSec = 600
EndIf
If $iniCheck = $aPollRemoteServersYN Then
$aPollRemoteServersYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "PollRemoteServersYN, "
EndIf
If $iniCheck = $aOnlinePlayersRetryAttempts Then
$aOnlinePlayersRetryAttempts = "3"
$iIniFail += 1
$iIniError = $iIniError & "OnlinePlayersRetryAttempts, "
ElseIf $aOnlinePlayersRetryAttempts < 0 Then
$aOnlinePlayersRetryAttempts = 0
ElseIf $aOnlinePlayersRetryAttempts > 5 Then
$aOnlinePlayersRetryAttempts = 5
EndIf
If $iniCheck = $aServerUseRedis Then
$aServerUseRedis = "yes"
$iIniFail += 1
$iIniError = $iIniError & "ServerUseRedis, "
EndIf
If $iniCheck = $aServerRedisConfig Then
$aServerRedisConfig = "redis.conf"
$iIniFail += 1
$iIniError = $iIniError & "ServerRedisConfig, "
EndIf
If $iniCheck = $aServerRedisFolder Then
$aServerRedisFolder = ""
$iIniFail += 1
$iIniError = $iIniError & "ServerRedisFolder, "
EndIf
If $iniCheck = $aServerStartDelay Then
$aServerStartDelay = "5"
$iIniFail += 1
$iIniError = $iIniError & "ServerStartDelay, "
ElseIf $aServerStartDelay < 0 Then
$aServerStartDelay = 0
ElseIf $aServerStartDelay > 600 Then
$aServerStartDelay = 600
EndIf
If $iniCheck = $aServerShutdownDelay Then
$aServerShutdownDelay = "2"
$iIniFail += 1
$iIniError = $iIniError & "ServerShutdownDelay, "
ElseIf $aServerShutdownDelay < 0 Then
$aServerShutdownDelay = 0
ElseIf $aServerShutdownDelay > 600 Then
$aServerShutdownDelay = 600
EndIf
If $iniCheck = $aShutDnWait Then
$aShutDnWait = "30"
$iIniFail += 1
$iIniError = $iIniError & "ShutdownWait, "
ElseIf $aShutDnWait < 10 Then
$aServerStartDelay = 10
ElseIf $aShutDnWait > 600 Then
$aShutDnWait = 600
EndIf
If $iniCheck = $aEnableRCON Then
$aEnableRCON = "yes"
$iIniFail += 1
$iIniError = $iIniError & "EnableRCON, "
EndIf
If $iniCheck = $aRemoteRestartUse Then
$aRemoteRestartUse = "no"
$iIniFail += 1
$iIniError = $iIniError & "RemoteRestartUse, "
EndIf
If $iniCheck = $aRemoteRestartIP Then
$aRemoteRestartIP = @IPAddress1
$iIniFail += 1
$iIniError = $iIniError & "RemoteRestartIP, "
EndIf
If $iniCheck = $aRemoteRestartPort Then
$aRemoteRestartPort = "57520"
$iIniFail += 1
$iIniError = $iIniError & "RemoteRestartPort, "
EndIf
If $iniCheck = $aRemoteRestartKey Then
$aRemoteRestartKey = "restart"
$iIniFail += 1
$iIniError = $iIniError & "RemoteRestartKey, "
EndIf
If $iniCheck = $aRemoteRestartCode Then
$aRemoteRestartCode = "password"
$iIniFail += 1
$iIniError = $iIniError & "RemoteRestartCode, "
EndIf
$aTelnetRequired = 0
If $iniCheck = $sObfuscatePass Then
$sObfuscatePass = "no"
$iIniFail += 1
$iIniError = $iIniError & "ObfuscatePass, "
EndIf
If $iniCheck = $aNamingScheme Then
$aNamingScheme = 2
$iIniFail += 1
$iIniError = $iIniError & "GridNamingScheme, "
EndIf
If $iniCheck = $aCheckForUpdate Then
$aCheckForUpdate = "yes"
$iIniFail += 1
$iIniError = $iIniError & "CheckForUpdate, "
EndIf
If $iniCheck = $aUpdateCheckInterval Then
$aUpdateCheckInterval = "15"
$iIniFail += 1
$iIniError = $iIniError & "UpdateCheckInterval, "
ElseIf $aUpdateCheckInterval < 5 Then
$aUpdateCheckInterval = 5
EndIf
If $iniCheck = $aDestroyWildDinosYN Then
$aDestroyWildDinosYN = "yes"
$iIniFail += 1
$iIniError = $iIniError & "DestroyWildDinosYN, "
EndIf
If $iniCheck = $aDestroyWildDinosDays Then
$aDestroyWildDinosDays = "2,6"
$iIniFail += 1
$iIniError = $iIniError & "DestroyWildDinosDays, "
EndIf
If $iniCheck = $aDestroyWildDinosHours Then
$aDestroyWildDinosHours = "03"
$iIniFail += 1
$iIniError = $iIniError & "DestroyWildDinosHours, "
EndIf
If $iniCheck = $aDestroyWildDinosMinute Then
$aDestroyWildDinosMinute = "00"
$iIniFail += 1
$iIniError = $iIniError & "DestroyWildDinosMinute, "
EndIf
If $iniCheck = $aEventCount Or $aEventCntIniCheck Then
$aEventCount = 1
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONCount, "
Global $xCustomRCONCmd[$aEventCount], $xEventDays[$aEventCount], $xEventHours[$aEventCount], $xEventMinute[$aEventCount], $xCustomRCONAllorLocal[$aEventCount], $xEventFile[$aEventCount], $xCustomRCONRestartYN[$aEventCount]
Global $xEventAnnounceMinutes[$aEventCount], $xEventAnnounceInGame[$aEventCount], $xEventAnnounceDiscord[$aEventCount]
Global $xEventMonthDate[$aEventCount], $xEventAnnounceTwitch[$aEventCount], $xEventMonths[$aEventCount]
Else
For $i = 0 To ($aEventCount - 1)
If $iniCheck = $xEventName[$i] Then
$xEventName[$i] = "Event " & ($i + 1)
$iIniFail += 1
$iIniError = $iIniError & "EventName" & $i & ", "
EndIf
If $iniCheck = $xCustomRCONCmd[$i] Then
$xCustomRCONCmd[$i] = ""
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONCmd" & $i & ", "
EndIf
If $iniCheck = $xCustomRCONAllorLocal[$i] Then
$xCustomRCONAllorLocal[$i] = "1"
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONAllorLocal" & $i & ", "
EndIf
If $iniCheck = $xEventFile[$i] Then
$xEventFile[$i] = ""
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONFile" & $i & ", "
EndIf
If $iniCheck = $xEventMonths[$i] Then
$xEventMonths[$i] = "0"
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONMonths" & $i & ", "
EndIf
If $iniCheck = $xEventMonthDate[$i] Then
$xEventMonthDate[$i] = "0"
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONMonthDate" & $i & ", "
EndIf
If $iniCheck = $xEventDays[$i] Then
$xEventDays[$i] = "0"
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONDays" & $i & ", "
EndIf
If $iniCheck = $xEventHours[$i] Then
$xEventHours[$i] = "04"
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONHours" & $i & ", "
EndIf
If $iniCheck = $xEventMinute[$i] Then
$xEventMinute[$i] = "00"
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONMinute" & $i & ", "
EndIf
If $iniCheck = $xCustomRCONRestartYN[$i] Then
$xCustomRCONRestartYN[$i] = "no"
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONRestartYN" & $i & ", "
EndIf
If $iniCheck = $xEventAnnounceMinutes[$i] Then
If $xCustomRCONRestartYN[$i] = "yes" Then
$xEventAnnounceMinutes[$i] = "1"
Else
$xEventAnnounceMinutes[$i] = ""
EndIf
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONAnnounceMinutes" & $i & ", "
EndIf
If $iniCheck = $xEventAnnounceInGame[$i] Then
$xEventAnnounceInGame[$i] = ""
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONAnnounceInGame" & $i & ", "
EndIf
If $iniCheck = $xEventAnnounceDiscord[$i] Then
$xEventAnnounceDiscord[$i] = ""
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONAnnounceDiscord" & $i & ", "
EndIf
If $iniCheck = $xEventAnnounceTwitch[$i] Then
$xEventAnnounceTwitch[$i] = ""
$iIniFail += 1
$iIniError = $iIniError & "CustomRCONAnnounceTwitch" & $i & ", "
EndIf
Next
EndIf
If $aCFGRCONCustomLastCount <> $aEventCount Then
IniWrite($aUtilCFGFile, "CFG", "aCFGRCONCustomLastCount", $aEventCount)
IniWrite($aUtilCFGFile, "CFG", "aCFGRCONCustomShowConfig", "yes")
If FileExists($sIniFile) Then
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $sIniFile & "_" & $tTime & ".bak"
FileMove($sIniFile, $tFile, 1)
EndIf
UpdateIni($sIniFile)
If FileExists($aIniFailFileBasic) Then
FileDelete($aIniFailFileBasic)
EndIf
FileWrite($aIniFailFileBasic, "[--------------- SCHEDULED USER DEFINED RCON COMMAND ---------------]" & @CRLF & "Number of custom RCON Commands to schedule ...")
Global $xCustomRCONCmd[$aEventCount], $xEventDays[$aEventCount], $xEventHours[$aEventCount], $xEventMinute[$aEventCount]
Local $aMsg = "Custom RCON Command count changed!" & @CRLF & @CRLF & "Click (YES) to restart util and run config editor." & @CRLF & "Click (NO) Or (CANCEL) to continue running utility WITHOUT changes."
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Then
F_ExitCloseN(True)
EndIf
EndIf
If $iniCheck = $aRestartDaily Then
$aRestartDaily = "yes"
$iIniFail += 1
$iIniError = $iIniError & "RestartDaily, "
EndIf
If $iniCheck = $aRestartDays Then
$aRestartDays = "0"
$iIniFail += 1
$iIniError = $iIniError & "RestartDays, "
EndIf
If $iniCheck = $bRestartHours Then
$bRestartHours = "04,16"
$iIniFail += 1
$iIniError = $iIniError & "RestartHours, "
EndIf
If $iniCheck = $bRestartMin Then
$bRestartMin = "00"
$iIniFail += 1
$iIniError = $iIniError & "RestartMin, "
EndIf
If $iniCheck = $aBackupYN Then
$aBackupYN = "yes"
$iIniFail += 1
$iIniError = $iIniError & "BackupYN, "
EndIf
If $iniCheck = $aBackupDays Then
$aBackupDays = "0"
$iIniFail += 1
$iIniError = $iIniError & "BackupDays, "
EndIf
If $iniCheck = $aBackupHours Then
$aBackupHours = "06,12,18,00"
$iIniFail += 1
$iIniError = $iIniError & "BackupHours, "
EndIf
If $iniCheck = $aBackupMin Then
$aBackupMin = "00"
$iIniFail += 1
$iIniError = $iIniError & "BackupMin, "
EndIf
If $iniCheck = $aBackupOutputFolder Then
$aBackupOutputFolder = @ScriptDir & "\Backups"
$iIniFail += 1
$iIniError = $iIniError & "BackupOutputFolder, "
EndIf
If $iniCheck = $aBackupRedisFolder Then
$aBackupRedisFolder = ""
$iIniFail += 1
$iIniError = $iIniError & "BackupRedisFolder, "
EndIf
If $iniCheck = $aBackupNumberToKeep Then
$aBackupNumberToKeep = "56"
$iIniFail += 1
$iIniError = $iIniError & "BackupDeleteOlder, "
ElseIf $aBackupNumberToKeep < 0 Then
$aBackupNumberToKeep = 1
ElseIf $aBackupNumberToKeep > 999 Then
$aBackupNumberToKeep = 999
EndIf
If $iniCheck = $aBackupTimeoutSec Then
$aBackupTimeoutSec = "300"
$iIniFail += 1
$iIniError = $iIniError & "BackupTimeoutSec, "
ElseIf $aBackupTimeoutSec < 30 Then
$aBackupTimeoutSec = 30
ElseIf $aBackupTimeoutSec > 999 Then
$aBackupTimeoutSec = 999
EndIf
If $iniCheck = $aBackupInGame Then
$aBackupInGame = "Server backup in progress."
$iIniFail += 1
$iIniError = $iIniError & "BackupInGame, "
EndIf
If $iniCheck = $aBackupDiscord Then
$aBackupDiscord = ""
$iIniFail += 1
$iIniError = $iIniError & "BackupDiscord, "
EndIf
If $iniCheck = $aBackupTwitch Then
$aBackupTwitch = ""
$iIniFail += 1
$iIniError = $iIniError & "BackupTwitch, "
EndIf
If $iniCheck = $aLogQuantity Then
$aLogQuantity = "30"
$iIniFail += 1
$iIniError = $iIniError & "LogQuantity, "
EndIf
If $iniCheck = $sAnnounceNotifyDaily Then
$sAnnounceNotifyDaily = "1,2,5,10,15"
$iIniFail += 1
$iIniError = $iIniError & "AnnounceNotifyDaily, "
EndIf
If $iniCheck = $sAnnounceNotifyUpdate Then
$sAnnounceNotifyUpdate = "1,2,5"
$iIniFail += 1
$iIniError = $iIniError & "AnnounceNotifyUpdate, "
EndIf
If $iniCheck = $sAnnounceNotifyRemote Then
$sAnnounceNotifyRemote = "1,3"
$iIniFail += 1
$iIniError = $iIniError & "AnnounceNotifyRemote, "
EndIf
If $iniCheck = $sAnnounceNotifyStopServer Then
$sAnnounceNotifyStopServer = "1,3"
$iIniFail += 1
$iIniError = $iIniError & "AnnounceNotifyStopServer, "
EndIf
If $iniCheck = $sAnnounceNotifyModUpdate Then
$sAnnounceNotifyModUpdate = "1,2,5"
$iIniFail += 1
$iIniError = $iIniError & "AnnounceNotifyModUpdate, "
EndIf
If $iniCheck = $sAnnounceNamingScheme Then
$sAnnounceNamingScheme = $aServerAltSaveSelect
$iIniFail += 1
$iIniError = $iIniError & "AnnounceNamingScheme, "
EndIf
If $iniCheck = $sInGameDailyMessage Then
$sInGameDailyMessage = "Daily server restart begins in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "InGameDailyMessage, "
EndIf
If $iniCheck = $sInGameUpdateMessage Then
$sInGameUpdateMessage = "A new server update has been released. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "InGameUpdateMessage, "
EndIf
If $iniCheck = $sInGameRemoteRestartMessage Then
$sInGameRemoteRestartMessage = "Admin has requested a server reboot. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "InGameRemoteRestartMessage, "
EndIf
If $iniCheck = $sInGameStopServerMessage Then
$sInGameStopServerMessage = "Servers shutting down in \m minute(s) for maintenance."
$iIniFail += 1
$iIniError = $iIniError & "InGameStopServerMessage, "
EndIf
If $iniCheck = $sInGameModUpdateMessage Then
$sInGameModUpdateMessage = "Mod \x released an update. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "InGameModUpdateMessage, "
EndIf
If $iniCheck = $sInGame10SecondMessage Then
$sInGame10SecondMessage = "FINAL WARNING! Rebooting server in 10 seconds..."
$iIniFail += 1
$iIniError = $iIniError & "InGameMod10SecondMessage, "
EndIf
If $iniCheck = $sDiscordDailyMessage Then
$sDiscordDailyMessage = "Daily server restart begins in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "DiscordDailyMessage, "
EndIf
If $iniCheck = $sDiscordUpdateMessage Then
$sDiscordUpdateMessage = "A new server update has been released. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "DiscordUpdateMessage, "
EndIf
If $iniCheck = $sDiscordRemoteRestartMessage Then
$sDiscordRemoteRestartMessage = "Admin has requested a server reboot. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "DiscordRemoteRestartMessage, "
EndIf
If $iniCheck = $sDiscordStopServerMessage Then
$sDiscordStopServerMessage = "Servers shutting down in \m minute(s) for maintenance."
$iIniFail += 1
$iIniError = $iIniError & "DiscordStopServerMessage, "
EndIf
If $iniCheck = $sDiscordModUpdateMessage Then
$sDiscordModUpdateMessage = "Mod \x released an update. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "DiscordModUpdateMessage, "
EndIf
If $iniCheck = $sDiscordServersUpMessage Then
$sDiscordServersUpMessage = $aGameName & " server online and ready for connection."
$iIniFail += 1
$iIniError = $iIniError & "DiscordServersUpMessage, "
EndIf
If $iniCheck = $sTwitchDailyMessage Then
$sTwitchDailyMessage = "Daily server restart begins in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "TwitchDailyMessage, "
EndIf
If $iniCheck = $sTwitchUpdateMessage Then
$sTwitchUpdateMessage = "A new server update has been released. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "TwitchUpdateMessage, "
EndIf
If $iniCheck = $sTwitchRemoteRestartMessage Then
$sTwitchRemoteRestartMessage = "Admin has requested a server reboot. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "TwitchRemoteRestartMessage, "
EndIf
If $iniCheck = $sTwitchStopServerMessage Then
$sTwitchStopServerMessage = "Servers shutting down in \m minute(s) for maintenance."
$iIniFail += 1
$iIniError = $iIniError & "TwitchStopServerMessage, "
EndIf
If $iniCheck = $sTwitchModUpdateMessage Then
$sTwitchModUpdateMessage = "Mod \x released an update. Server is rebooting in \m minute(s)."
$iIniFail += 1
$iIniError = $iIniError & "TwitchModUpdateMessage, "
EndIf
If $iniCheck = $sInGameAnnounce Then
$sInGameAnnounce = "yes"
$iIniFail += 1
$iIniError = $iIniError & "InGameAnnounce, "
EndIf
If $iniCheck = $sInGameMessageDuration Then
$sInGameMessageDuration = 15
$iIniFail += 1
$iIniError = $iIniError & "InGameMessageDuration, "
ElseIf $sInGameMessageDuration < 6 Then
$sInGameMessageDuration = 6
ElseIf $sInGameMessageDuration > 30 Then
$sInGameMessageDuration = 30
EndIf
If $iniCheck = $sUseDiscordBotDaily Then
$sUseDiscordBotDaily = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseDiscordBotDaily, "
EndIf
If $iniCheck = $sUseDiscordBotUpdate Then
$sUseDiscordBotUpdate = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseDiscordBotUpdate, "
EndIf
If $iniCheck = $sUseDiscordBotRemoteRestart Then
$sUseDiscordBotRemoteRestart = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseDiscordBotRemoteRestart, "
EndIf
If $iniCheck = $sUseDiscordBotStopServer Then
$sUseDiscordBotStopServer = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseDiscordBotStopServer, "
EndIf
If $iniCheck = $sUseDiscordBotModUpdate Then
$sUseDiscordBotModUpdate = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseDiscordBotModUpdate, "
EndIf
If $iniCheck = $sUseDiscordBotServersUpYN Then
$sUseDiscordBotServersUpYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseDiscordBotServersUpYN, "
EndIf
If $iniCheck = $sUseDiscordBotFirstAnnouncement Then
$sUseDiscordBotFirstAnnouncement = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseDiscordBotFirstAnnouncement, "
EndIf
If $iniCheck = $sDiscordWebHookURLs Then
$sDiscordWebHookURLs = "https://discordapp.com/api/webhooks/XXXXXX/XXXX<-NO TRAILING SLASH AND USE FULL URL FROM WEBHOOK URL ON DISCORD"
$iIniFail += 1
$iIniError = $iIniError & "DiscordWebHookURLs, "
EndIf
If $iniCheck = $sDiscordBotName Then
$sDiscordBotName = $aGameName & " Bot"
$iIniFail += 1
$iIniError = $iIniError & "DiscordBotName, "
EndIf
If $iniCheck = $bDiscordBotUseTTS Then
$bDiscordBotUseTTS = "yes"
$iIniFail += 1
$iIniError = $iIniError & "DiscordBotUseTTS, "
EndIf
If $iniCheck = $sDiscordBotAvatar Then
$sDiscordBotAvatar = ""
$iIniFail += 1
$iIniError = $iIniError & "DiscordBotAvatar, "
EndIf
If $iniCheck = $sUseTwitchBotDaily Then
$sUseTwitchBotDaily = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseTwitchBotDaily, "
EndIf
If $iniCheck = $sUseTwitchBotUpdate Then
$sUseTwitchBotUpdate = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseTwitchBotUpdate, "
EndIf
If $iniCheck = $sUseTwitchBotRemoteRestart Then
$sUseTwitchBotRemoteRestart = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseTwitchBotRemoteRestart, "
EndIf
If $iniCheck = $sUseTwitchBotStopServer Then
$sUseTwitchBotStopServer = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseTwitchBotStopServer, "
EndIf
If $iniCheck = $sUseTwitchBotModUpdate Then
$sUseTwitchBotModUpdate = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseTwitchBotModUpdate, "
EndIf
If $iniCheck = $sUseTwitchFirstAnnouncement Then
$sUseTwitchFirstAnnouncement = "no"
$iIniFail += 1
$iIniError = $iIniError & "UseDiscordBotFirstAnnouncement, "
EndIf
If $iniCheck = $sTwitchNick Then
$sTwitchNick = "twitchbotusername"
$iIniFail += 1
$iIniError = $iIniError & "TwitchNick, "
EndIf
If $iniCheck = $sChatOAuth Then
$sChatOAuth = "oauth:1234(Generate OAuth Token Here: https://twitchapps.com/tmi)"
$iIniFail += 1
$iIniError = $iIniError & "ChatOAuth, "
EndIf
If $iniCheck = $sTwitchChannels Then
$sTwitchChannels = "channel1,channel2,channel3"
$iIniFail += 1
$iIniError = $iIniError & "TwitchChannels, "
EndIf
If $iniCheck = $aExecuteExternalScript Then
$aExecuteExternalScript = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExecuteExternalScript, "
EndIf
If $iniCheck = $aExternalScriptDir Then
$aExternalScriptDir = "D:\Game Servers\" & $aGameName & " Dedicated Server\Scripts"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptDir, "
EndIf
If $iniCheck = $aExternalScriptName Then
$aExternalScriptName = "beforesteamcmd.bat"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptName, "
EndIf
If $iniCheck = $aExternalScriptWait Then
$aExternalScriptWait = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptWait, "
EndIf
If $iniCheck = $aExternalScriptValidateYN Then
$aExternalScriptValidateYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptValidateYN, "
EndIf
If $iniCheck = $aExternalScriptValidateDir Then
$aExternalScriptValidateDir = "D:\Game Servers\" & $aGameName & " Server\Scripts"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptValidateDir, "
EndIf
If $iniCheck = $aExternalScriptValidateName Then
$aExternalScriptValidateName = "aftersteamcmd.bat"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptValidateName, "
EndIf
If $iniCheck = $aExternalScriptValidateWait Then
$aExternalScriptValidateWait = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptValidateWait, "
EndIf
If $iniCheck = $aExternalScriptUpdateYN Then
$aExternalScriptUpdateYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptUpdateYN, "
EndIf
If $iniCheck = $aExternalScriptUpdateDir Then
$aExternalScriptUpdateDir = "D:\Game Servers\" & $aGameName & " Dedicated Server\Scripts"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptUpdateDir, "
EndIf
If $iniCheck = $aExternalScriptUpdateFileName Then
$aExternalScriptUpdateFileName = "update.bat"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptUpdateFileName, "
EndIf
If $iniCheck = $aExternalScriptUpdateWait Then
$aExternalScriptUpdateWait = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptUpdateWait, "
EndIf
If $iniCheck = $aExternalScriptDailyYN Then
$aExternalScriptDailyYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptDailyYN, "
EndIf
If $iniCheck = $aExternalScriptDailyDir Then
$aExternalScriptDailyDir = "D:\Game Servers\" & $aGameName & " Dedicated Server\Scripts"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptDailyDir, "
EndIf
If $iniCheck = $aExternalScriptDailyFileName Then
$aExternalScriptDailyFileName = "daily.bat"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptDailyFileName, "
EndIf
If $iniCheck = $aExternalScriptDailyWait Then
$aExternalScriptDailyWait = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptDailyWait, "
EndIf
If $iniCheck = $aExternalScriptAnnounceYN Then
$aExternalScriptAnnounceYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptAnnounceYN, "
EndIf
If $iniCheck = $aExternalScriptAnnounceDir Then
$aExternalScriptAnnounceDir = "D:\Game Servers\" & $aGameName & " Dedicated Server\Scripts"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptAnnounceDir, "
EndIf
If $iniCheck = $aExternalScriptAnnounceFileName Then
$aExternalScriptAnnounceFileName = "firstannounce.bat"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptAnnounceFileName, "
EndIf
If $iniCheck = $aExternalScriptAnnounceWait Then
$aExternalScriptAnnounceWait = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptAnnounceWait, "
EndIf
If $iniCheck = $aExternalScriptRemoteYN Then
$aExternalScriptRemoteYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptRemoteYN, "
EndIf
If $iniCheck = $aExternalScriptRemoteDir Then
$aExternalScriptRemoteDir = "D:\Game Servers\" & $aGameName & " Dedicated Server\Scripts"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptRemoteDir, "
EndIf
If $iniCheck = $aExternalScriptRemoteFileName Then
$aExternalScriptRemoteFileName = "remoterestart.bat"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptRemoteFileName, "
EndIf
If $iniCheck = $aExternalScriptRemoteWait Then
$aExternalScriptRemoteWait = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptRemoteWait, "
EndIf
If $iniCheck = $aExternalScriptModYN Then
$aExternalScriptModYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptModYN, "
EndIf
If $iniCheck = $aExternalScriptModDir Then
$aExternalScriptModDir = "D:\Game Servers\" & $aGameName & " Dedicated Server\Scripts"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptModDir, "
EndIf
If $iniCheck = $aExternalScriptModFileName Then
$aExternalScriptModFileName = "modupdate.bat"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptModFileName, "
EndIf
If $iniCheck = $aExternalScriptModWait Then
$aExternalScriptModWait = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptModWait, "
EndIf
If $iniCheck = $aExternalScriptHideYN Then
$aExternalScriptHideYN = "no"
$iIniFail += 1
$iIniError = $iIniError & "ExternalScriptHideYN, "
EndIf
If $iniCheck = $aUpdateSource Then
$aUpdateSource = "0"
$iIniFail += 1
$iIniError = $iIniError & "UpdateSource, "
EndIf
If $iniCheck = $aUpdateUtil Then
$aUpdateUtil = "4"
$iIniFail += 1
$iIniError = $iIniError & "UpdateUtil, "
ElseIf $aUpdateUtil < 0 Then
$aUpdateUtil = 0
ElseIf $aUpdateUtil > 24 Then
$aUpdateUtil = 24
EndIf
If $iniCheck = $aUpdateAutoUtil Then
$aUpdateAutoUtil = "no"
$iIniFail += 1
$iIniError = $iIniError & "UpdateAutoUtil, "
EndIf
If $iniCheck = $aUseKeepAliveYN Then
$aUseKeepAliveYN = "yes"
$iIniFail += 1
$iIniError = $iIniError & "UseKeepAliveYN, "
EndIf
If $iniCheck = $aUtilBetaYN Then
$aUtilBetaYN = "0"
$iIniFail += 1
$iIniError = $iIniError & "UtilBetaYN, "
EndIf
If $iniCheck = $aRCONResponseWaitms Then
$aRCONResponseWaitms = 1500
$iIniFail += 1
$iIniError = $iIniError & "RCONResponseWaitms, "
ElseIf $aRCONResponseWaitms < 100 Then
$aRCONResponseWaitms = 100
ElseIf $aRCONResponseWaitms > 3000 Then
$aRCONResponseWaitms = 3000
EndIf
If $iniCheck = $aOnlinePlayerWaitms Then
$aOnlinePlayerWaitms = 1500
$iIniFail += 1
$iIniError = $iIniError & "RCONResponseWaitms, "
ElseIf $aOnlinePlayerWaitms < 100 Then
$aOnlinePlayerWaitms = 100
ElseIf $aOnlinePlayerWaitms > 3000 Then
$aOnlinePlayerWaitms = 3000
EndIf
If $iniCheck = $aMainGUIRefreshTime Then
$aMainGUIRefreshTime = 10
$iIniFail += 1
$iIniError = $iIniError & "MainGUIRefreshTime, "
ElseIf $aMainGUIRefreshTime < 2 Then
$aMainGUIRefreshTime = 2
ElseIf $aMainGUIRefreshTime > 60 Then
$aMainGUIRefreshTime = 60
EndIf
If ($aUpdateSource = "1") And ($aUpdateCheckInterval < 30) Then
$aUpdateCheckInterval = 30
LogWrite(" [Update] NOTICE: SteamDB will ban your IP if you check too often. Update check interval set to 30 minutes")
$iIniFail += 1
$iIniError = $iIniError & "NOTICE: SteamDB will ban your IP if you check too often. Update check interval set to 30 minutes, "
EndIf
If $aIniForceWrite Then
If FileExists($sIniFile) Then
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $sIniFile & "_" & $tTime & ".bak"
FileMove($sIniFile, $tFile, 1)
EndIf
UpdateIni($sIniFile)
Local $tIniFail = True
Else
If $iIniFail > 0 Then
iniFileCheck($sIniFile, $iIniFail, $iIniError, $tUseWizard)
Local $tIniFail = True
Else
Local $tIniFail = False
EndIf
EndIf
If $bDiscordBotUseTTS = "yes" Then
$bDiscordBotUseTTS = True
Else
$bDiscordBotUseTTS = False
EndIf
Global $aDelayShutdownTime = 0
If ($sUseDiscordBotDaily = "yes") Or ($sUseDiscordBotUpdate = "yes") Or ($sUseTwitchBotDaily = "yes") Or ($sUseTwitchBotUpdate = "yes") Or ($sInGameAnnounce = "yes") Then
$aDelayShutdownTime = $sAnnounceNotifyDaily
EndIf
LogWrite(" Importing settings from " & $aUtilName & ".ini.")
$aServerDirLocal = RemoveInvalidCharacters($aServerDirLocal)
$aServerDirLocal = RemoveTrailingSlash($aServerDirLocal)
$aServerDirLocal = RemoveShooterGame($aServerDirLocal)
$aServerRedisFolder = RemoveInvalidCharacters($aServerRedisFolder)
$aServerRedisFolder = RemoveTrailingSlash($aServerRedisFolder)
$aExternalScriptDir = RemoveInvalidCharacters($aExternalScriptDir)
$aExternalScriptDir = RemoveTrailingSlash($aExternalScriptDir)
$aExternalScriptName = RemoveInvalidCharacters($aExternalScriptName)
$aExternalScriptValidateDir = RemoveInvalidCharacters($aExternalScriptValidateDir)
$aExternalScriptValidateDir = RemoveTrailingSlash($aExternalScriptValidateDir)
$aExternalScriptValidateName = RemoveInvalidCharacters($aExternalScriptValidateName)
$aExternalScriptUpdateDir = RemoveInvalidCharacters($aExternalScriptUpdateDir)
$aExternalScriptUpdateDir = RemoveTrailingSlash($aExternalScriptUpdateDir)
$aExternalScriptUpdateFileName = RemoveInvalidCharacters($aExternalScriptUpdateFileName)
$aExternalScriptAnnounceDir = RemoveInvalidCharacters($aExternalScriptAnnounceDir)
$aExternalScriptAnnounceDir = RemoveTrailingSlash($aExternalScriptAnnounceDir)
$aExternalScriptAnnounceFileName = RemoveInvalidCharacters($aExternalScriptAnnounceFileName)
$aExternalScriptDailyDir = RemoveInvalidCharacters($aExternalScriptDailyDir)
$aExternalScriptDailyDir = RemoveTrailingSlash($aExternalScriptDailyDir)
$aExternalScriptDailyFileName = RemoveInvalidCharacters($aExternalScriptDailyFileName)
$aExternalScriptModDir = RemoveInvalidCharacters($aExternalScriptModDir)
$aExternalScriptModDir = RemoveTrailingSlash($aExternalScriptModDir)
$aExternalScriptModFileName = RemoveInvalidCharacters($aExternalScriptModFileName)
$sDiscordWebHookURLs = StringRegExpReplace($sDiscordWebHookURLs, "<-NO TRAILING SLASH AND USE FULL URL FROM WEBHOOK URL ON DISCORD", "")
$aServerRCONPort = RemoveTrailingComma($aServerRCONPort)
$aServerAltSaveDir = RemoveTrailingComma($aServerAltSaveDir)
If $aServerRCONImport = "no" Then
Global $xServerRCONPort = StringSplit($aServerRCONPort, ",")
EndIf
If $sUseTwitchBotModUpdate = "yes" Or $sUseDiscordBotModUpdate = "yes" Or $sUseDiscordBotRemoteRestart = "yes" Or $sUseDiscordBotDaily = "yes" Or $sUseDiscordBotUpdate = "yes" Or $sUseTwitchBotRemoteRestart = "yes" Or $sUseTwitchBotDaily = "yes" Or $sUseTwitchBotUpdate = "yes" Or $sInGameAnnounce = "yes" Then
$sAnnounceNotifyDaily = AddZero($sAnnounceNotifyDaily)
$sAnnounceNotifyUpdate = AddZero($sAnnounceNotifyUpdate)
$sAnnounceNotifyRemote = AddZero($sAnnounceNotifyRemote)
$sAnnounceNotifyStopServer = AddZero($sAnnounceNotifyStopServer)
$sAnnounceNotifyModUpdate = AddZero($sAnnounceNotifyModUpdate)
Global $aDailyMsgInGame = AnnounceReplaceTime($sAnnounceNotifyDaily, $sInGameDailyMessage)
Global $aDailyMsgDiscord = AnnounceReplaceTime($sAnnounceNotifyDaily, $sDiscordDailyMessage)
Global $aDailyMsgTwitch = AnnounceReplaceTime($sAnnounceNotifyDaily, $sTwitchDailyMessage)
Global $aDailyTime = StringSplit($sAnnounceNotifyDaily, ",")
Global $aDailyCnt = Int($aDailyTime[0])
Global $aUpdateMsgInGame = AnnounceReplaceTime($sAnnounceNotifyUpdate, $sInGameUpdateMessage)
Global $aUpdateMsgDiscord = AnnounceReplaceTime($sAnnounceNotifyUpdate, $sDiscordUpdateMessage)
Global $aUpdateMsgTwitch = AnnounceReplaceTime($sAnnounceNotifyUpdate, $sTwitchUpdateMessage)
Global $aUpdateTime = StringSplit($sAnnounceNotifyUpdate, ",")
Global $aUpdateCnt = Int($aUpdateTime[0])
Global $aRemoteMsgInGame = AnnounceReplaceTime($sAnnounceNotifyRemote, $sInGameRemoteRestartMessage)
Global $aRemoteMsgDiscord = AnnounceReplaceTime($sAnnounceNotifyRemote, $sDiscordRemoteRestartMessage)
Global $aRemoteMsgTwitch = AnnounceReplaceTime($sAnnounceNotifyRemote, $sTwitchRemoteRestartMessage)
Global $aRemoteTime = StringSplit($sAnnounceNotifyRemote, ",")
Global $aRemoteCnt = Int($aRemoteTime[0])
Global $sModMsgInGame = AnnounceReplaceTime($sAnnounceNotifyModUpdate, $sInGameModUpdateMessage)
Global $sModMsgDiscord = AnnounceReplaceTime($sAnnounceNotifyModUpdate, $sDiscordModUpdateMessage)
Global $sModMsgTwitch = AnnounceReplaceTime($sAnnounceNotifyModUpdate, $sTwitchModUpdateMessage)
Global $aModTime = StringSplit($sAnnounceNotifyModUpdate, ",")
Global $aModCnt = Int($aModTime[0])
EventsCreateCalendarAndOffset()
Global $aDelayShutdownTime = Int($aDailyTime[$aDailyCnt])
DailyRestartOffset($bRestartHours, $bRestartMin, $aDelayShutdownTime)
Else
Global $aDelayShutdownTime = 0
DailyRestartOffset($bRestartHours, $bRestartMin, $aDelayShutdownTime)
EventsCreateCalendarAndOffset()
EndIf
Global $aStopServerMsgInGame = AnnounceReplaceTime($sAnnounceNotifyStopServer, $sInGameStopServerMessage)
Global $aStopServerMsgDiscord = AnnounceReplaceTime($sAnnounceNotifyStopServer, $sDiscordStopServerMessage)
Global $aStopServerMsgTwitch = AnnounceReplaceTime($sAnnounceNotifyStopServer, $sTwitchStopServerMessage)
Global $aStopServerTime = StringSplit($sAnnounceNotifyStopServer, ",")
Global $aStopServerCnt = Int($aStopServerTime[0])
LogWrite("", " . . . Server Folder = " & $aServerDirLocal)
LogWrite("", " . . . SteamCMD Folder = " & $aSteamCMDDir)
Return $tIniFail
EndFunc
Func iniFileCheck($sIniFile, $iIniFail, $iIniError, $tUseWizard)
If FileExists($sIniFile) Then
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aIniFile & "_" & $tTime & ".bak"
FileMove($sIniFile, $tFile, 1)
UpdateIni($sIniFile)
$iIniErrorCRLF = StringRegExpReplace($iIniError, ", ", @CRLF & @TAB)
FileWriteLine($aIniFailFileFull, _NowCalc() & @CRLF & " ---------- Parameters missing or changed ----------" & @CRLF & @CRLF & @TAB & $iIniErrorCRLF)
FileWriteLine($aIniFailFileBasic, $iIniErrorCRLF)
LogWrite(" [Util] New or changed INI Parameters: Parameters missing or changed: " & $iIniFail, " [Util] New or changed INI Parameters: Found " & $iIniFail & " missing or changed variable(s) in " & $aUtilName & ".ini. Backup created and all existing settings transfered to new INI. Please make any desired changes to INI.")
If $tUseWizard Then
_Splash($aStartText & $aUtilName & ".ini file changed. Restarting utility.", 3000, 475)
IniWrite($aUtilCFGFile, "CFG", "aCFGRCONCustomShowConfig", "yes")
F_ExitCloseN(True)
Else
SplashOff()
Run("notepad " & $aIniFailFileFull, @WindowsDir)
$tMB = MsgBox($MB_YESNOCANCEL, "New or changed INI Parameters", "INI FILE WAS UPDATED." & @CRLF & "Found " & $iIniFail & " missing or changes variable(s) in " & $aUtilName & ".ini:" & @CRLF & @CRLF & $iIniError & @CRLF & @CRLF & "Backup created and all existing settings transfered to new INI." & @CRLF & @CRLF & "Please make any desired changes to INI." & @CRLF & @CRLF & "File created: ___INI_FAIL_VARIABLES___.txt" & @CRLF & @CRLF & "Click OK to continue.", 30)
ConfigEdit()
EndIf
Else
UpdateIni($sIniFile)
EndIf
EndFunc
Func UpdateIni($sIniFile)
FileWriteLine($sIniFile, "[ --------------- " & StringUpper($aUtilName) & " INFORMATION --------------- ]")
FileWriteLine($sIniFile, "Author   :  Phoenix125")
FileWriteLine($sIniFile, "Version  :  " & $aUtilityVer)
FileWriteLine($sIniFile, "Website  :  http://www.Phoenix125.com")
FileWriteLine($sIniFile, "Discord  :  http://discord.gg/EU7pzPs")
FileWriteLine($sIniFile, "Forum    :  https://phoenix125.createaforum.com/index.php")
FileWriteLine($sIniFile, @CRLF)
FileWriteLine($sIniFile, "[ --------------- GAME SERVER CONFIGURATION --------------- ]")
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " DIR ###", $aServerDirLocal)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", $aServerAltSaveSelect)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames (Use same order as listed in ServerGrid.json. Comma separated) ###", $aServerAltSaveDir)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " extra commandline parameters (ex.?serverpve-pve -NoCrashDialog) ###", $aServerExtraCMD)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "SteamCMD extra commandline parameters (ex. -latest_experimental) ###", $aSteamExtraCMD)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server multi-home IP (Leave blank to disable) ###", $aServerMultiHomeIP)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Admin password ###", $aServerAdminPass)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Max players ###", $aServerMaxPlayers)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Reserved slots ###", $aServerReservedSlots)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Start servers minimized (for a cleaner look)? (yes/no) ###", $aServerMinimizedYN)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Grid naming scheme: Use (1) 00 01 (2) A1 A2 (3) 0,0 0,1 ###", $aNamingScheme)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "RCON IP (ex. 127.0.0.1 - Leave BLANK for server IP) ###", $aServerRCONIP)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Import RCON ports from GameUserSettings.ini files? (yes/no) ###", $aServerRCONImport)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server RCON Port(s) (comma separated, grid order as in ServerGrid.json, ignore if importing RCON ports) ###", $aServerRCONPort)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Delay in seconds between grid server starts (0-600) ###", $aServerStartDelay)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Delay in seconds between grid server shutdowns (0-600) ###", $aServerShutdownDelay)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Seconds allowed for GameSave before taskkilling servers during reboots (10-600) ###", $aShutDnWait)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Use this util to install mods and check for mod updates (as listed in ServerGrid.json)? (yes/no) ###", $aServerModYN)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Max time (minutes) to wait for each mod to download (0-180) (0-No Timeout) ###", $aServerModTimeoutMin)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for, and log, online players? (yes/no) ###", $aServerOnlinePlayerYN)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for online players every _ seconds (30-600) ###", $aServerOnlinePlayerSec)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for online players on remote servers? (yes/no) ###", $aPollRemoteServersYN)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Number of Online Player RCON retry attempts (0-3) ###", $aOnlinePlayersRetryAttempts)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Autostart and keep-alive redis-server.exe? Use NO to manage redis-server.exe yourself (yes/no) ###", $aServerUseRedis)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Redis-server config file (Not used if autostart is NO above) ###", $aServerRedisConfig)
IniWrite($sIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Redis-server.exe and config DIR (Not used if autostart is NO above) Leave BLANK for default DIR ###", $aServerRedisFolder)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- CHECK FOR UPDATE --------------- ", "Check for server updates? (yes/no) ###", $aCheckForUpdate)
IniWrite($sIniFile, " --------------- CHECK FOR UPDATE --------------- ", "Update check interval in minutes (05-59) ###", $aUpdateCheckInterval)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- SCHEDULED RESTARTS --------------- ", "Use scheduled restarts? (yes/no) ###", $aRestartDaily)
IniWrite($sIniFile, " --------------- SCHEDULED RESTARTS --------------- ", "Restart days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $aRestartDays)
IniWrite($sIniFile, " --------------- SCHEDULED RESTARTS --------------- ", "Restart hours (comma separated 00-23 ex.04,16) ###", $bRestartHours)
IniWrite($sIniFile, " --------------- SCHEDULED RESTARTS --------------- ", "Restart minute (00-59) ###", $bRestartMin)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Use scheduled backups? (yes/no) ###", $aBackupYN)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Backup days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $aBackupDays)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Backup hours (comma separated 00-23 ex.04,16) ###", $aBackupHours)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Backup minute (00-59) ###", $aBackupMin)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Output folder ###", $aBackupOutputFolder)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Redis folder (leave blank to use redis folder above or to disable) ###", $aBackupRedisFolder)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Number of backups to keep (1-999) ###", $aBackupNumberToKeep)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Max time in seconds to wait for backup to complete (30-999) ###", $aBackupTimeoutSec)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "In-Game announcement when backup initiated (Leave blank to disable) ###", $aBackupInGame)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Discord announcement when backup initiated (Leave blank to disable) ###", $aBackupDiscord)
IniWrite($sIniFile, " --------------- BACKUP --------------- ", "Twitch announcement when backup initiated (Leave blank to disable) ###", $aBackupTwitch)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND COUNT --------------- ", "Number of custom RCON Commands to schedule (If changed, util will restart and new custom entries will be added) ###", $aEventCount)
For $i = 0 To ($aEventCount - 1)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Event Name ###", $xEventName[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-RCON Command(s) to send (Separated by ~, leave BLANK to skip) ###", $xCustomRCONCmd[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-RCON Command send to (0) ALL grids or (1) Local Grids Only ###", $xCustomRCONAllorLocal[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-File to Execute (leave BLANK to skip) ###", $xEventFile[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Months (comma separated 0-Monthly, 1-12) ###", $xEventMonths[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Days of Month (comma separated 0-Use Weekday Below, 1-31) ###", $xEventMonthDate[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event Weekdays (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $xEventDays[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event hours (comma separated 00-23 ex.04,16) ###", $xEventHours[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Scheduled Event minute (00-59) ###", $xEventMinute[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Restart servers afterward? (with announcements below) (yes/no) ###", $xCustomRCONRestartYN[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Announcement _ minutes before reboot (comma separated 1-60) ###", $xEventAnnounceMinutes[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-In-Game Message to send (\m - minutes)(leave BLANK to skip) ###", $xEventAnnounceInGame[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Discord Message to send (\m - minutes)(leave BLANK to skip) ###", $xEventAnnounceDiscord[$i])
IniWrite($sIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-Twitch Message to send (\m - minutes)(leave BLANK to skip) ###", $xEventAnnounceTwitch[$i])
Next
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos? (yes/no) ###", $aDestroyWildDinosYN)
IniWrite($sIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos days (comma separated 0-Everyday 1-Sunday 7-Saturday 0-7 ex.2,4,6) ###", $aDestroyWildDinosDays)
IniWrite($sIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos hours (comma separated 00-23 ex.04,16) ###", $aDestroyWildDinosHours)
IniWrite($sIniFile, " --------------- SCHEDULED DESTROYWILDDINOS --------------- ", "Send DestroyWildDinos minute (0-59) ###", $aDestroyWildDinosMinute)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Use Remote Restart? (yes/no) ###", $aRemoteRestartUse)
IniWrite($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Server Local IP (ex. 192.168.1.10) ###", $aRemoteRestartIP)
IniWrite($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Restart Port ###", $aRemoteRestartPort)
IniWrite($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Restart Key ###", $aRemoteRestartKey)
IniWrite($sIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Restart Code ###", $aRemoteRestartCode)
FileWriteLine($sIniFile, "(Usage example: http://192.168.1.10:57520/?restart=password)")
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before DAILY reboot (comma separated 0-60) ###", $sAnnounceNotifyDaily)
IniWrite($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before UPDATES reboot (comma separated 0-60) ###", $sAnnounceNotifyUpdate)
IniWrite($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before REMOTE RESTART reboot (comma separated 0-60) ###", $sAnnounceNotifyRemote)
IniWrite($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before STOP SERVER (comma separated 0-60) ###", $sAnnounceNotifyStopServer)
IniWrite($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement _ minutes before MOD UPDATE reboot (comma separated 0-60) ###", $sAnnounceNotifyModUpdate)
IniWrite($sIniFile, " --------------- ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement grid naming scheme: Use (1) 00 01 (2) A1 A2 (3) 0,0 0,1 ###", $sAnnounceNamingScheme)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announce messages in-game? (Requires RCON) (yes/no) ###", $sInGameAnnounce)
IniWrite($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Approximate duration to display messages in-game (seconds)? (6-30) ###", $sInGameMessageDuration)
IniWrite($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement DAILY (\m - minutes) ###", $sInGameDailyMessage)
IniWrite($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement UPDATES (\m - minutes) ###", $sInGameUpdateMessage)
IniWrite($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement REMOTE RESTART (\m - minutes) ###", $sInGameRemoteRestartMessage)
IniWrite($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", $sInGameStopServerMessage)
IniWrite($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement MOD UPDATE (\m - minutes, \x - Mod ID) ###", $sInGameModUpdateMessage)
IniWrite($sIniFile, " --------------- IN-GAME ANNOUNCEMENT CONFIGURATION --------------- ", "Announcement 10 seconds before reboot ###", $sInGame10SecondMessage)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for DAILY reboot? (yes/no) ###", $sUseDiscordBotDaily)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for UPDATE reboot? (yes/no) ###", $sUseDiscordBotUpdate)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for REMOTE RESTART reboot? (yes/no) ###", $sUseDiscordBotRemoteRestart)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for STOP SERVER? (yes/no) ###", $sUseDiscordBotStopServer)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for MOD UPDATE reboot? (yes/no) ###", $sUseDiscordBotModUpdate)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message when all servers are back online (yes/no) ###", $sUseDiscordBotServersUpYN)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for first announcement only? (reduces bot spam)(yes/no) ###", $sUseDiscordBotFirstAnnouncement)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement DAILY (\m - minutes) ###", $sDiscordDailyMessage)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement UPDATES (\m - minutes) ###", $sDiscordUpdateMessage)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement REMOTE RESTART (\m - minutes) ###", $sDiscordRemoteRestartMessage)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", $sDiscordStopServerMessage)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement MOD UPDATE (\m - minutes, \x - Mod ID) ###", $sDiscordModUpdateMessage)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Announcement Servers back online ###", $sDiscordServersUpMessage)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "WebHook URL ###", $sDiscordWebHookURLs)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Bot Name ###", $sDiscordBotName)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Use TTS? (yes/no) ###", $bDiscordBotUseTTS)
IniWrite($sIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Bot Avatar Link ###", $sDiscordBotAvatar)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for DAILY reboot? (yes/no) ###", $sUseTwitchBotDaily)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for UPDATE reboot? (yes/no) ###", $sUseTwitchBotUpdate)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for REMOTE RESTART reboot? (yes/no) ###", $sUseTwitchBotRemoteRestart)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for STOP SERVER? (yes/no) ###", $sUseTwitchBotStopServer)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for MOD UPDATE reboot? (yes/no) ###", $sUseTwitchBotModUpdate)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Send Twitch message for first announcement only? (reduces bot spam)(yes/no) ###", $sUseTwitchFirstAnnouncement)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement DAILY (\m - minutes) ###", $sTwitchDailyMessage)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement UPDATES (\m - minutes) ###", $sTwitchUpdateMessage)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement REMOTE RESTART (\m - minutes) ###", $sTwitchRemoteRestartMessage)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement STOP SERVER (\m - minutes) ###", $sTwitchStopServerMessage)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Announcement MOD UPDATE (\m - minutes, \x - Mod ID) ###", $sTwitchModUpdateMessage)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Nick ###", $sTwitchNick)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "ChatOAuth ###", $sChatOAuth)
IniWrite($sIniFile, " --------------- TWITCH INTEGRATION --------------- ", "Channels ###", $sTwitchChannels)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT BEFORE SteamCMD UPDATE AND SERVER START --------------- ", "1-Execute external script BEFORE update? (yes/no) ###", $aExecuteExternalScript)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT BEFORE SteamCMD UPDATE AND SERVER START --------------- ", "1-Script directory ###", $aExternalScriptDir)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT BEFORE SteamCMD UPDATE AND SERVER START --------------- ", "1-Script filename ###", $aExternalScriptName)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT BEFORE SteamCMD UPDATE AND SERVER START --------------- ", "1-Wait for script to complete before continuing? (yes/no) ###", $aExternalScriptWait)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT AFTER SteamCMD BUT BEFORE SERVER START --------------- ", "2-Execute external script AFTER update but BEFORE server start? (yes/no) ###", $aExternalScriptValidateYN)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT AFTER SteamCMD BUT BEFORE SERVER START --------------- ", "2-Script directory ###", $aExternalScriptValidateDir)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT AFTER SteamCMD BUT BEFORE SERVER START --------------- ", "2-Script filename ###", $aExternalScriptValidateName)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT AFTER SteamCMD BUT BEFORE SERVER START --------------- ", "2-Wait for script to complete before continuing? (yes/no) ###", $aExternalScriptValidateWait)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR SERVER *UPDATE* --------------- ", "3-Execute external script for server update restarts? (yes/no) ###", $aExternalScriptUpdateYN)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR SERVER *UPDATE* --------------- ", "3-Script directory ###", $aExternalScriptUpdateDir)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR SERVER *UPDATE* --------------- ", "3-Script filename ###", $aExternalScriptUpdateFileName)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR SERVER *UPDATE* --------------- ", "3-Wait for script to complete before continuing? (yes/no) ###", $aExternalScriptUpdateWait)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *DAILY* SERVER RESTART --------------- ", "4-Execute external script for daily server restarts? (yes/no) ###", $aExternalScriptDailyYN)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *DAILY* SERVER RESTART --------------- ", "4-Script directory ###", $aExternalScriptDailyDir)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *DAILY* SERVER RESTART --------------- ", "4-Script filename ###", $aExternalScriptDailyFileName)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *DAILY* SERVER RESTART --------------- ", "4-Wait for script to complete before continuing? (yes/no) ###", $aExternalScriptDailyWait)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN FIRST RESTART ANNOUNCEMENT IS MADE --------------- ", "5-Execute external script when first restart announcement is made? (yes/no) ###", $aExternalScriptAnnounceYN)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN FIRST RESTART ANNOUNCEMENT IS MADE --------------- ", "5-Script directory ###", $aExternalScriptAnnounceDir)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN FIRST RESTART ANNOUNCEMENT IS MADE --------------- ", "5-Script filename ###", $aExternalScriptAnnounceFileName)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN FIRST RESTART ANNOUNCEMENT IS MADE --------------- ", "5-Wait for script to complete before continuing? (yes/no) ###", $aExternalScriptAnnounceWait)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT DURING RESTART WHEN REMOTE RESTART REQUEST IS MADE --------------- ", "6-Execute external script during restart when a remote restart request is made? (yes/no) ###", $aExternalScriptRemoteYN)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT DURING RESTART WHEN REMOTE RESTART REQUEST IS MADE --------------- ", "6-Script directory ###", $aExternalScriptRemoteDir)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT DURING RESTART WHEN REMOTE RESTART REQUEST IS MADE --------------- ", "6-Script filename ###", $aExternalScriptRemoteFileName)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT DURING RESTART WHEN REMOTE RESTART REQUEST IS MADE --------------- ", "6-Wait for script to complete before continuing? (yes/no) ###", $aExternalScriptRemoteWait)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *MOD UPDATE* SERVER RESTART --------------- ", "7-Execute external script when mod update required (prior to server shutdown)? (yes/no) ###", $aExternalScriptModYN)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *MOD UPDATE* SERVER RESTART --------------- ", "7-Script directory ###", $aExternalScriptModDir)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *MOD UPDATE* SERVER RESTART --------------- ", "7-Script filename ###", $aExternalScriptModFileName)
IniWrite($sIniFile, " --------------- EXECUTE EXTERNAL SCRIPT WHEN RESTARTING FOR *MOD UPDATE* SERVER RESTART --------------- ", "7-Wait for script to complete before continuing? (yes/no) ###", $aExternalScriptModWait)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- LOG FILE OPTIONS --------------- ", "Delete util log files older than __ days ###", $aLogQuantity)
IniWrite($sIniFile, " --------------- LOG FILE OPTIONS --------------- ", "Hide passwords in log files? (yes/no) ###", $sObfuscatePass)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Validate files with SteamCMD update? (yes/no) ###", $aValidate)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Enable RCON? Required for clean shutdown (yes/no) ###", $aEnableRCON)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "For update checks, use (0)SteamCMD or (1)SteamDB.com ###", $aUpdateSource)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Check for " & $aUtilName & " updates every __ hours (0 to disable) (0-24) ###", $aUpdateUtil)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Automatically install " & $aUtilName & " updates? (yes/no) ###", $aUpdateAutoUtil)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", $aUtilName & " version: (0)Stable, (1)Beta ###", $aUtilBetaYN)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Run KeepAlive program to detect util crashes and restart it? (yes/no) ###", $aUseKeepAliveYN)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Hide external scripts when executed? (if yes, scripts may not execute properly) (yes/no) ###", $aExternalScriptHideYN)
FileWriteLine($sIniFile, @CRLF)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Time to wait for RCON response in milliseconds (100-3000) ###", $aRCONResponseWaitms)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Time to wait for Online Players RCON response in milliseconds (100-3000) ###", $aOnlinePlayerWaitms)
IniWrite($sIniFile, " --------------- " & StringUpper($aUtilName) & " ADVANCED OPTIONS --------------- ", "Update the Main Window data every __ seconds (2-60) ###", $aMainGUIRefreshTime)
EndFunc
#EndRegion
Func ReadCFG($sIniFile)
Local $iIniFail = 0
Local $iniCheck = ""
If FileExists($sIniFile) Then
Local $aChar[3]
For $i = 1 To 13
$aChar[0] = Chr(Random(97, 122, 1))
$aChar[1] = Chr(Random(48, 57, 1))
$iniCheck &= $aChar[Random(0, 1, 1)]
Next
Global $aUtilReboot = IniRead($sIniFile, "CFG", "aUtilReboot", $iniCheck)
Global $aUtilLastClose = IniRead($sIniFile, "CFG", "aUtilLastClose", $iniCheck)
Global $aCFGLastUpdate = IniRead($sIniFile, "CFG", "aCFGLastUpdate", $iniCheck)
Global $aCFGLastVersion = IniRead($sIniFile, "CFG", "aCFGLastVersion", $iniCheck)
Global $aCFGLastVerNumber = IniRead($sIniFile, "CFG", "aCFGLastVerNumber", $iniCheck)
Global $aCFGRCONCustomLastCount = IniRead($sIniFile, "CFG", "aCFGRCONCustomLastCount", $iniCheck)
If $iniCheck = $aUtilReboot Then
$aUtilReboot = "no"
$iIniFail += 1
EndIf
If $iniCheck = $aUtilLastClose Then
$aUtilLastClose = _NowCalc()
$iIniFail += 1
EndIf
If $iniCheck = $aCFGLastUpdate Then
$aCFGLastUpdate = _NowCalc()
$iIniFail += 1
EndIf
If $iniCheck = $aCFGRCONCustomLastCount Then
$aCFGRCONCustomLastCount = 1
$iIniFail += 1
EndIf
If $iIniFail > 0 Then
IniWrite($sIniFile, "CFG", "aUtilReboot", $aUtilReboot)
IniWrite($sIniFile, "CFG", "aUtilLastClose", $aUtilLastClose)
IniWrite($sIniFile, "CFG", "aCFGLastUpdate", $aCFGLastUpdate)
EndIf
IniWrite($sIniFile, "CFG", "aCFGLastVersion", $aUtilVersion)
IniWrite($sIniFile, "CFG", "aCFGLastVerNumber", $aUtilVerNumber)
Else
Global $aUtilReboot = "no"
Global $aUtilLastClose = _NowCalc()
Global $aCFGLastUpdate = _NowCalc()
Global $aCFGRCONCustomLastCount = 1
Global $aCFGLastVersion = $aUtilVersion
Global $aCFGLastVerNumber = $aUtilVerNumber
IniWrite($sIniFile, "CFG", "aUtilReboot", $aUtilReboot)
IniWrite($sIniFile, "CFG", "aUtilLastClose", $aUtilLastClose)
IniWrite($sIniFile, "CFG", "aCFGLastUpdate", $aCFGLastUpdate)
IniWrite($sIniFile, "CFG", "aCFGLastVersion", $aUtilVersion)
IniWrite($sIniFile, "CFG", "aCFGLastVerNumber", $aUtilVerNumber)
EndIf
EndFunc
Func AddZero($tString)
Local $tArray = StringSplit($tString, ",")
If $tArray[0] < 2 Then
$tString = "0," & $tString
EndIf
Return $tString
EndFunc
Func EventsCreateCalendarAndOffset()
Global $sCustomMsgInGame[$aEventCount], $sCustomMsgDiscord[$aEventCount], $aCustomTime[$aEventCount], $aCustomCnt[$aEventCount]
Global $sCustomMsgTwitch[$aEventCount]
Global $aMax6moAll = 0, $aMax6mo[$aEventCount]
For $i = 0 To ($aEventCount - 1)
If $xEventMonths[$i] = 0 Then
Local $tMax1 = 6
Else
Local $tSplit1 = StringSplit($xEventMonths[$i], ",")
Local $tMax1 = Int($tSplit1[0])
EndIf
If $xEventMonthDate[$i] = 0 Then
Local $tMax2 = 1
If $xEventDays[$i] = 0 Then
Local $tMax3 = 31
Else
Local $tSplit3 = StringSplit($xEventDays[$i], ",")
Local $tMax3 = Int($tSplit3[0]) * 4.3
EndIf
Else
Local $tMax3 = 1
Local $tSplit2 = StringSplit($xEventMonthDate[$i], ",")
Local $tMax2 = Int($tSplit2[0])
EndIf
Local $tSplit4 = StringSplit($xEventHours[$i], ",")
Local $tMax4 = Int($tSplit4[0])
$aMax6mo[$i] = Int($tMax1 * $tMax2 * $tMax3 * $tMax4)
$aMax6moAll += $aMax6mo[$i] + 6
Next
Global $xEventRestartTimes[$aEventCount][$aMax6moAll]
Global $aEventMinute[$aEventCount], $aEventHours[$aEventCount], $aEventMonthDate[$aEventCount]
For $i = 0 To ($aEventCount - 1)
Local $tCount = 1
If $xEventAnnounceInGame[$i] <> "" Then $sCustomMsgInGame[$i] = AnnounceReplaceTime($xEventAnnounceMinutes[$i], $xEventAnnounceInGame[$i])
If $xEventAnnounceDiscord[$i] <> "" Then $sCustomMsgDiscord[$i] = AnnounceReplaceTime($xEventAnnounceMinutes[$i], $xEventAnnounceDiscord[$i])
If $xEventAnnounceTwitch[$i] <> "" Then $sCustomMsgTwitch = AnnounceReplaceTime($xEventAnnounceMinutes[$i], $xEventAnnounceTwitch[$i])
If $xEventAnnounceDiscord[$i] <> "" Or $xEventAnnounceInGame[$i] <> "" Or $xEventAnnounceTwitch[$i] <> "" Then
Else
$xEventAnnounceMinutes[$i] = 0
EndIf
$aCustomTime[$i] = StringSplit($xEventAnnounceMinutes[$i], ",")
$aCustomCnt[$i] = Int(($aCustomTime[$i])[0])
$tMonSelect = StringSplit($xEventMonths[$i], ",")
If $xEventMonths[$i] <> 0 Then
$tMonSelect = StringSplit($xEventMonths[$i], ",")
EndIf
Local $sYear = @YEAR
Local $sMon = @MON - 1
For $iMon = 0 To 5
$sMon += 1
If $sMon = 13 Then
$sMon = 1
$sYear += 1
EndIf
If $xEventMonths[$i] <> 0 Then
For $tMon1 = 1 To $tMonSelect[0]
If $sMon = $tMonSelect[$tMon1] Then
Local $tRun = True
ExitLoop
Else
Local $tRun = False
EndIf
Next
Else
Local $tRun = True
EndIf
If $tRun Then
If $xEventMonthDate[$i] > 0 Then
Local $sMDay = StringSplit($xEventMonthDate[$i], ",")
Local $tMDay = ""
For $iMDay = 1 To $sMDay[0]
Local $sHour = StringSplit($xEventHours[$i], ",")
Local $tHour = ""
For $iHour = 1 To $sHour[0]
Local $tMin = ""
Local $sMin = StringSplit($xEventMinute[$i], ",")
Local $sDelay = StringSplit($xEventAnnounceMinutes[$i], ",")
For $iMin = 1 To $sMin[0]
Local $aDateBefore[7]
$aDateBefore[1] = $sYear
$aDateBefore[2] = $sMon
$aDateBefore[3] = $sMDay[$iMDay]
$aDateBefore[4] = $sHour[$iHour]
$aDateBefore[5] = $sMin[$iMin]
Local $tMaxTimeRestart = (0 - $sDelay[$sDelay[0]])
Local $aDateAfter = _DateChange("n", $tMaxTimeRestart, $aDateBefore)
If $aDateAfter[0] = 0 Then
Else
$xEventRestartTimes[$i][$tCount] = $aDateAfter[0]
$tCount += 1
$tMin = $tMin & "," & Int($aDateAfter[5])
EndIf
Next
$tHour = $tHour & "," & Int($aDateAfter[4])
Next
$tMDay = $tMDay & "," & Int($aDateAfter[3])
Next
$aEventMinute[$i] = StringTrimLeft($tMin, 1)
$aEventHours[$i] = StringTrimLeft($tHour, 1)
$aEventMonthDate[$i] = StringTrimLeft($tMDay, 1)
Else
If $xEventDays[$i] = 0 Then
Local $tMDay = ""
For $iMDay = 1 To 31
Local $sHour = StringSplit($xEventHours[$i], ",")
Local $tHour = ""
For $iHour = 1 To $sHour[0]
Local $tMin = ""
Local $sMin = StringSplit($xEventMinute[$i], ",")
Local $sDelay = StringSplit($xEventAnnounceMinutes[$i], ",")
For $iMin = 1 To $sMin[0]
Local $aDateBefore[7]
$aDateBefore[1] = $sYear
$aDateBefore[2] = $sMon
$aDateBefore[3] = $iMDay
$aDateBefore[4] = $sHour[$iHour]
$aDateBefore[5] = $sMin[$iMin]
Local $tMaxTimeRestart = (0 - $sDelay[$sDelay[0]])
Local $aDateAfter = _DateChange("n", $tMaxTimeRestart, $aDateBefore)
If $aDateAfter[0] = 0 Then
Else
$xEventRestartTimes[$i][$tCount] = $aDateAfter[0]
$tCount += 1
EndIf
Next
Next
Next
$aEventMinute[$i] = $xEventMinute[$i]
$aEventHours[$i] = $xEventHours[$i]
$aEventMonthDate[$i] = $xEventMonthDate[$i]
Else
Local $sDays = StringSplit($xEventDays[$i], ",")
Local $tDays = ""
For $iMDay = 1 To 31
For $iDays = 1 To $sDays[0]
If _DateToDayOfWeek($sYear, $sMon, $iMDay) = $sDays[$iDays] Then
Local $sHour = StringSplit($xEventHours[$i], ",")
Local $tHour = ""
For $iHour = 1 To $sHour[0]
Local $tMin = ""
Local $sMin = StringSplit($xEventMinute[$i], ",")
Local $sDelay = StringSplit($xEventAnnounceMinutes[$i], ",")
For $iMin = 1 To $sMin[0]
Local $aDateBefore[7]
$aDateBefore[1] = $sYear
$aDateBefore[2] = $sMon
$aDateBefore[3] = $iMDay
$aDateBefore[4] = $sHour[$iHour]
$aDateBefore[5] = $sMin[$iMin]
Local $tMaxTimeRestart = (0 - $sDelay[$sDelay[0]])
Local $aDateAfter = _DateChange("n", $tMaxTimeRestart, $aDateBefore)
If $aDateAfter[0] = 0 Then
Else
$xEventRestartTimes[$i][$tCount] = $aDateAfter[0]
$tCount += 1
EndIf
Next
Next
EndIf
Next
Next
EndIf
EndIf
EndIf
Next
$xEventRestartTimes[$i][0] = $tCount - 1
Next
Global $xEventRestartTimeAll[$aMax6moAll][2]
Local $tCount = 0
For $i = 0 To ($aEventCount - 1)
For $x = 1 To ($xEventRestartTimes[$i][0])
$xEventRestartTimeAll[$tCount][0] = $xEventRestartTimes[$i][$x]
$xEventRestartTimeAll[$tCount][1] = $i
$tCount += 1
Next
Next
$aMax6moAll = $tCount
ReDim $xEventRestartTimeAll[$tCount][2]
_ArraySort($xEventRestartTimeAll, 0, 0, 0, 0)
Global $xEventTimePastTF[$aMax6moAll]
For $i = 0 To ($aMax6moAll - 1)
If _DateDiff('n', $xEventRestartTimeAll[$i][0], _NowCalc()) < 0 Then
$xEventTimePastTF[$i] = False
Else
$xEventTimePastTF[$i] = True
EndIf
Next
Local $tTxt = _NowCalc() & " ----------- Scheduled Events -----------" & @CRLF
For $i = 0 To ($aMax6moAll - 1)
If $xEventTimePastTF[$i] = False Then
Local $tYear = StringTrimRight($xEventRestartTimeAll[$i][0], 15)
Local $tMonth1 = StringTrimRight($xEventRestartTimeAll[$i][0], 12)
Local $tMonth = StringTrimLeft($tMonth1, 5)
Local $tDate1 = StringTrimRight($xEventRestartTimeAll[$i][0], 9)
Local $tDate = StringTrimLeft($tDate1, 8)
Local $tDay1 = _DateToDayOfWeek($tYear, $tMonth, $tDate)
Local $tDay = _DateDayOfWeek($tDay1)
$tTxt &= StringTrimRight($xEventRestartTimeAll[$i][0], 3) & "  Event:" & ($xEventRestartTimeAll[$i][1] + 1) & "  " & $xEventName[$xEventRestartTimeAll[$i][1]] & "  (" & $tDay & ")" & @CRLF
EndIf
Next
FileDelete($aEventSaveFile)
FileWrite($aEventSaveFile, $tTxt)
EndFunc
Func CFGLastClose()
IniWrite($aUtilCFGFile, "CFG", "aUtilLastClose", _NowCalc())
EndFunc
Func CFGUtilReboot($i = True)
IniWrite($aUtilCFGFile, "CFG", "aUtilReboot", $i)
EndFunc
Func RunUtilUpdate()
UtilUpdate($aServerUpdateLinkVerUse, $aServerUpdateLinkDLUse, $aUtilVersion, $aUtilName, 0, "Auto")
PurgeLogFile()
EndFunc
Func ResizeArray($tArray, $tArrayAssignedMax = 0)
Local $tArrayMax = UBound($tArray), $tArrayRange = 0
If $tArrayAssignedMax > $tArrayMax Then
ReDim $tArray[$tArrayAssignedMax]
ElseIf $tArrayAssignedMax = 0 Then
For $tArrayi = 0 To ($tArrayMax - 1)
If $tArray[$tArrayi] = "" Then
$tArrayRange = $tArrayi & "-" & ($tArrayMax - 1)
ExitLoop
EndIf
Next
ElseIf $tArrayAssignedMax = $tArrayMax Then
Return $tArray
Else
$tArrayRange = $tArrayAssignedMax & "-" & ($tArrayMax - 1)
EndIf
If $tArrayRange <> 0 Then _ArrayDelete($tArray, $tArrayRange)
Return $tArray
EndFunc
Func _AddCommasDecimalNo($tNumber)
Return StringRegExpReplace(Int($tNumber), '\G(\d+?)(?=(\d{3})+(\D|$))', '$1,')
EndFunc
#Region
Func Gamercide()
If $aUseKeepAliveYN = "yes" Then IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Close AtlasServerUpdateUtilityKeepAlive? (Checked prior to restarting above Program... used when purposely shutting down above Program)(yes/no) ###", "yes")
Local $aMsg = "Thank you for using " & $aUtilName & "." & @CRLF & "Please report any problems or comments to: " & @CRLF & "Discord: http://discord.gg/EU7pzPs or " & @CRLF & "Forum: http://phoenix125.createaforum.com/index.php. " & @CRLF & @CRLF & "Visit http://www.Phoenix125.com"
If @exitMethod <> 1 Then
If ($aServerUseRedis = "yes") And ($aPIDRedisreadYetTF = False) Or ($aPIDServerReadYetTF = False) Then
LogWrite(" [" & $aServerName & "] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
MsgBox(4096, $aUtilityVer, $aMsg, 20)
LogWrite(" " & $aUtilityVer & " Stopped by User")
_ExitUtil()
Else
If $aServerUseRedis = "yes" Then
$bMsg = "Utility exited unexpectedly or before it was fully initialized." & @CRLF & @CRLF & "Close utility?" & @CRLF & @CRLF & "Click (YES) to shutdown all servers and exit utility." & @CRLF & "Click (NO) to shutdown all servers BUT LEAVE REDIS RUNNING." & @CRLF & "Click (CANCEL) to exit utility but leave servers and redis still running."
Else
$bMsg = "Utility exited unexpectedly or before it was fully initialized." & @CRLF & @CRLF & "Close utility?" & @CRLF & @CRLF & "Click (YES) to shutdown all servers and exit utility." & @CRLF & "Click (NO) or (CANCEL) to exit utility but leave servers running."
EndIf
SplashOff()
$Shutdown = MsgBox($MB_YESNOCANCEL, $aUtilName, $bMsg, 60)
If $Shutdown = 6 Then
LogWrite(" [" & $aServerName & "] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, True, False)
SplashOff()
If ProcessExists($aServerPIDRedis) And $aServerUseRedis = "yes" Then
LogWrite(" [Redis (PID: " & $aServerPIDRedis & ")] Killing Process")
ProcessClose($aServerPIDRedis)
If FileExists($aPIDRedisFile) Then
FileDelete($aPIDRedisFile)
EndIf
EndIf
MsgBox(4096, $aUtilityVer, $aMsg, 20)
LogWrite(" " & $aUtilityVer & " Stopped by User")
If FileExists($aPIDServerFile) Then
FileDelete($aPIDServerFile)
EndIf
_ExitUtil()
ElseIf $Shutdown = 7 Then
If $aServerUseRedis = "yes" Then
LogWrite(" [" & $aServerName & "] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
MsgBox(4096, $aUtilityVer, $aMsg, 20)
LogWrite(" " & $aUtilityVer & " Stopped by User")
Else
LogWrite(" [" & $aServerName & "] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
PIDSaveServer($aServerPID, $aPIDServerFile)
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
MsgBox(4096, $aUtilityVer, $aMsg, 20)
LogWrite(" " & $aUtilityVer & " Stopped by User")
EndIf
_ExitUtil()
ElseIf $Shutdown = 2 Then
LogWrite(" [" & $aServerName & "] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
PIDSaveServer($aServerPID, $aPIDServerFile)
If $aServerUseRedis = "yes" Then
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
EndIf
MsgBox(4096, $aUtilityVer, $aMsg, 20)
LogWrite(" " & $aUtilityVer & " Stopped by User")
EndIf
EndIf
Else
EndIf
_ExitUtil()
EndFunc
#EndRegion
Func CloseServer($ip, $port, $pass, $tCloseRedisTF = True, $tDisableServers = False)
If $aFirstBoot Then
Global $aSplashCloseServer = 0
Else
Global $aSplashCloseServer = SplashTextOn($aUtilName & ": " & $aServerName, "Sending shutdown command to server(s) . . .", 550, 100, -1, -1, $DLG_MOVEABLE, "")
EndIf
$aCloseServerTF = True
If $aRebootReason = "stopservers" Then
If $aSelectServers Then
Else
$tDisableServers = True
$aRebootReason = ""
EndIf
EndIf
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, $aSplashCloseServer)
ControlSetText($aSplashCloseServer, "", "Static1", "Sending shutdown (DoExit) command to server(s) . . .")
$aServerReadyOnce = True
$aServerReadyTF = False
$aShutdown = 1
$aFailCount = 0
LogWrite(" --------- Server(s) shutdown sequence beginning ---------")
If $aSelectServers Then
SetStatusBusy("Stopping select server(s).", "Stop Server ")
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
Local $tTime = TimerInit()
ControlSetText($aSplashCloseServer, "", "Static1", "Sending shutdown command to server: " & _ServerNamingScheme($i, $aNamingScheme))
GUICtrlSetData($LabelUtilReadyStatus, "Stop Server " & _ServerNamingScheme($i, $aNamingScheme))
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, "DoExit", "no", 0)
LogWrite(" [Server] Sending shutdown (DoExit) command to select servers. Server " & _ServerNamingScheme($i, $aNamingScheme))
Local $tDelay = $aServerShutdownDelay - (TimerDiff($tTime) / 1000)
If $tDelay < 0 Then $tDelay = 0
Sleep(1000 * $tDelay)
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
EndIf
Next
Else
For $i = 0 To ($aServerGridTotal - 1)
If ($xStartGrid[$i] = "yes") Then
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
Local $tTime = TimerInit()
$aErrorShutdown = 1
ControlSetText($aSplashCloseServer, "", "Static1", "Sending shutdown command to server: " & _ServerNamingScheme($i, $aNamingScheme))
GUICtrlSetData($LabelUtilReadyStatus, "Stop Server " & _ServerNamingScheme($i, $aNamingScheme))
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $aRCONShutdownCMD, "yes", 0)
Local $tTimeDiff = TimerDiff($tTime) / 1000
Local $tDelay = $aServerShutdownDelay - $tTimeDiff
If $tDelay < 0 Then $tDelay = 0
Sleep(1000 * $tDelay)
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
EndIf
EndIf
Next
EndIf
$aErrorShutdown = 0
LogWrite(" Waiting up to " & $aShutDnWait & " seconds for server(s) to finish saving world . . .")
If $aSelectServers Then
For $k = 1 To $aShutDnWait
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
Local $tTime = TimerInit()
SendCTRLC($aServerPID[$i])
$aErrorShutdown = 1
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $aRCONShutdownCMD, "no", 0)
EndIf
EndIf
Next
If $aErrorShutdown = 1 Then
ControlSetText($aSplashCloseServer, "", "Static1", "Waiting up to " & $aShutDnWait & " seconds for server(s) to finish saving world . . ." & @CRLF & @CRLF & "Countdown: " & ($aShutDnWait - $k))
Local $tDelay = 1000 - (TimerDiff($tTime))
If $tDelay < 0 Then $tDelay = 0
Sleep($tDelay)
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
$aErrorShutdown = 0
Else
ExitLoop
EndIf
Next
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
$aErrorShutdown = 1
ProcessClose($aServerPID[$i])
LogWrite(" [Server (PID: " & $aServerPID[$i] & ")] Warning: Shutdown failed. Killing Process")
$aServerPID[$i] = ""
EndIf
EndIf
Next
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
$xStartGrid[$i] = "no"
$aGridSomeDisable = True
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", "no")
EndIf
Next
$aSelectServers = False
$aStopServerMsgInGame = AnnounceReplaceTime($sAnnounceNotifyStopServer, $sInGameStopServerMessage)
$aStopServerMsgDiscord = AnnounceReplaceTime($sAnnounceNotifyStopServer, $sDiscordStopServerMessage)
$aStopServerMsgTwitch = AnnounceReplaceTime($sAnnounceNotifyStopServer, $sTwitchStopServerMessage)
Else
For $k = 1 To $aShutDnWait
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
Local $tTime = TimerInit()
$aErrorShutdown = 1
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $aRCONShutdownCMD, "no", 0)
SendCTRLC($aServerPID[$i])
EndIf
Next
If $aErrorShutdown = 1 Then
Local $tDelay = 1000 - (TimerDiff($tTime))
If $tDelay < 0 Then $tDelay = 0
ControlSetText($aSplashCloseServer, "", "Static1", "Waiting up to " & $aShutDnWait & " seconds for server(s) to finish saving world . . ." & @CRLF & @CRLF & "Countdown: " & ($aShutDnWait - $k))
Sleep($tDelay)
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
$aErrorShutdown = 0
Else
ExitLoop
EndIf
Next
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) And ($xStartGrid[$i] = "yes") And $xLocalGrid[$i] = "yes" Then
$aErrorShutdown = 1
LogWrite(" [Server (PID: " & $aServerPID[$i] & ")] Warning: Shutdown failed. Killing Process")
ProcessClose($aServerPID[$i])
EndIf
Next
If ($aErrorShutdown = 1) And ($aServerMultiHomeIP <> "") Then
SplashOff()
MsgBox($MB_OK, $aUtilityVer, "[Shutdown Error] The server(s) did not shut down properly." & @CRLF & "- Try removing the IP in: " & @CRLF & "[Server multi-home IP (Leave blank to disable) ###]" & @CRLF & "in " & $aUtilName & ".ini. " & @CRLF & @CRLF & "(This message will disappear in 20 seconds)", 20)
EndIf
For $i = 0 To ($aServerGridTotal - 1)
$aServerPID[$i] = ""
Next
If FileExists($aPIDServerFile) Then
FileDelete($aPIDServerFile)
EndIf
If $aServerUseRedis = "yes" Then
If $tCloseRedisTF Then
If ProcessExists($aServerPIDRedis) And $aServerUseRedis = "yes" Then
LogWrite(" [Redis (PID: " & $aServerPIDRedis & ")] Killing Process")
ProcessClose($aServerPIDRedis)
EndIf
If FileExists($aPIDRedisFile) Then
FileDelete($aPIDRedisFile)
EndIf
Else
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
EndIf
EndIf
If $aSteamUpdateNow Then
SteamUpdate($aSteamExtraCMD, $aSteamCMDDir, $aValidate)
EndIf
$aShutdown = 0
EndIf
LogWrite(" --------------- Server(s) shutdown sequence completed ----------")
If $tDisableServers Then
For $i = 0 To ($aServerGridTotal - 1)
If ($xStartGrid[$i] = "yes") Then
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", "no")
$xStartGrid[$i] = "no"
$aGridSomeDisable = True
EndIf
Next
$tDisableServers = False
EndIf
For $i = 1 To $aServerGridTotal
$t = ProcessClose("mcrcon.exe")
If $t = 0 Then ExitLoop
Next
SplashOff()
EndFunc
#Region
Func ImportConfig($tServerDirLocal, $tConfigFile, $tFromNewWizard = False)
Local $sConfigPath = $aConfigFull
LogWrite(" Importing settings from " & $tConfigFile, " Importing settings from " & $sConfigPath)
Global $xServergridx[$aServersMax]
Global $xServergridy[$aServersMax]
Global $xServerport[$aServersMax]
Global $xServergameport[$aServersMax]
Global $xServerseamlessDataPort[$aServersMax]
Global $xServerIP[$aServersMax]
Global $xServerIsHomeServer[$aServersMax]
Local $sFileExists = FileExists($sConfigPath)
If $sFileExists = 0 Then
Local $sConfigPathOld = $sConfigPath
$sConfigPath = $aFolderTemp & "ServerGrid.json"
Local $tTxt = "{" & @CRLF & '  "WorldFriendlyName": "AtlasServerUpdateUtility Temp ServerGrid.json",' & @CRLF & '  "ModIDs": "",' & @CRLF & '  "totalGridsX": 1,' & @CRLF & '  "totalGridsY": 1,' & @CRLF & '  "servers": [' & @CRLF & '    {' & @CRLF & '      "gridX": 0,' & @CRLF & '      "gridY": 0,' & @CRLF & '      "ip": "1.2.3.4",' & @CRLF & '      "name": "AtlasServerUpdateUtility Temp 1",' & @CRLF & '      "port": 48011,' & @CRLF & '      "gamePort": 48015,' & @CRLF & '      "seamlessDataPort": 48018,' & @CRLF & '      "isHomeServer": True,' & @CRLF & "    }" & @CRLF & "  ]," & @CRLF & '}' & @CRLF
FileDelete($sConfigPath)
FileWrite($sConfigPath, $tTxt)
LogWrite(" !!! ERROR !!! Could not find " & $sConfigPathOld)
SplashOff()
If IniRead($aUtilCFGFile, "CFG", "aCFGGoToSelectWizardWindow", "no") = "yes" Then
$tMB = 6
Else
If $tFromNewWizard Then
Local $aMsg = "Could not find " & $sConfigPathOld & "." & @CRLF & "(This is normal for New Install) " & @CRLF & @CRLF & "Do you wish to continue with installation?" & @CRLF & @CRLF & "Click (YES) to restart Setup Wizard (recommended)." & @CRLF & "Click (NO) to continue using manual config editing. Temp settings will be applied." & @CRLF & "Click (CANCEL) to exit utility."
Else
Local $aMsg = "Could not find " & $sConfigPathOld & "." & @CRLF & "(This is normal for New Install) " & @CRLF & @CRLF & "Do you wish to continue with installation?" & @CRLF & @CRLF & "Click (YES) to run Setup Wizard (recommended)." & @CRLF & "Click (NO) to continue using manual config editing." & @CRLF & "Click (CANCEL) to exit utility."
EndIf
$tMB = MsgBox($MB_YESNOCANCEL, "ServerGrid.json file Not Found", $aMsg, 60)
EndIf
If $tMB = 6 Or $tMB = -1 Then
SplashOff()
If $tFromNewWizard Then
IniWrite($aUtilCFGFile, "CFG", "aCFGGoToSelectWizardWindow", "yes")
_RestartUtil(False)
Else
WizardSelect()
EndIf
ElseIf $tMB = 7 Then
_Splash("Using temporary settings to complete the download and installation of " & $aGameName & " dedicated server." & @CRLF & @CRLF & "Once installation is complete, please exit " & $aUtilName & ", copy your files into the server folder, and rerun " & $aUtilName & ".", 9000, 500, 175)
$aSplashStartUp = _Splash($aStartText, 0, 475)
ElseIf $tMB = 2 Then
LogWrite(" !!! ERROR !!! Could not find " & $sConfigPath & ". Program terminated by user.")
_ExitUtil()
EndIf
EndIf
Local $kServerWorldFriendlyName = "WorldFriendlyName"
Local $kServerModList = "ModIDs"
Local $ktotalGridsX = "totalGridsX"
Local $ktotalGridsY = "totalGridsY"
Local $kServergridx = "gridX"
Local $kServergridy = "gridY"
Local $kServerip = "ip"
Local $kServerport = "port"
Local $kServergameport = "gamePort"
Local $kServerNames = "name"
Local $kServerSeamlessDataPort = "seamlessDataPort"
Local $kServerIsHomeServer = "isHomeServer"
Local $sConfigPathOpen = FileOpen($sConfigPath, 0)
Local $sConfigRead = FileRead($sConfigPathOpen)
FileClose($sConfigPathOpen)
Local $sConfigReadServer = _ArrayToString(_StringBetween($sConfigRead, """servers"": [", "    }" & @CRLF & "  ],"))
$aServerModList = _ArrayToString(_StringBetween($sConfigRead, """" & $kServerModList & """: """, ""","))
Local $xServerWorldFriendlyName = _StringBetween($sConfigRead, """" & $kServerWorldFriendlyName & """: """, """,")
$aServerWorldFriendlyName = _ArrayToString($xServerWorldFriendlyName)
$xServerIP = _StringBetween($sConfigReadServer, """" & $kServerip & """: """, """,")
For $i = 0 To (UBound($xServerIP) - 1)
$xServerIP[$i] = RemoveTrailingSlashT($xServerIP[$i])
Next
Global $xServerNames = _StringBetween($sConfigReadServer, @CRLF & "      """ & $kServerNames & """: """, """," & @CRLF & "      ""port")
For $i = 0 To (UBound($xServerNames) - 1)
$xServerNames[$i] = ReplaceVerticalBarCRwithSlash($xServerNames[$i])
Next
$xtotalGridsX = _ArrayToString(_StringBetween($sConfigRead, """" & $ktotalGridsX & """: ", ","))
$xtotalGridsY = _ArrayToString(_StringBetween($sConfigRead, """" & $ktotalGridsY & """: ", ","))
$xServergridx = _StringBetween($sConfigReadServer, """" & $kServergridx & """: ", ",")
$xServergridy = _StringBetween($sConfigReadServer, """" & $kServergridy & """: ", ",")
$xServerport = _StringBetween($sConfigReadServer, """" & $kServerport & """: ", ",")
$xServergameport = _StringBetween($sConfigReadServer, """" & $kServergameport & """: ", ",")
$xServerseamlessDataPort = _StringBetween($sConfigRead, """" & $kServerSeamlessDataPort & """: ", ",")
$xServerIsHomeServer = _StringBetween($sConfigRead, """" & $kServerIsHomeServer & """: ", ",")
For $i = 0 To (UBound($xServerIsHomeServer) - 1)
If $xServerIsHomeServer[$i] = "true" Then
$xServerIsHomeServer[$i] = True
Else
$xServerIsHomeServer[$i] = False
EndIf
Next
FileClose($sConfigRead)
If $aServerModList = "" Then
If $aServerModYN = "yes" Then
LogWrite(" [MOD] NOTICE: ""Use this util to install mods and check for mod updates""=yes in " & $aUtilName & ".ini but no mods were listed in " & $aConfigFile & ".")
EndIf
$aServerModYN = "no"
Else
$xServerModList = StringSplit($aServerModList, ",")
For $i = 0 To (UBound($xServerModList) - 1)
If $xServerModList[$i] = "" Then
Local $aMsg = "NOTICE! Mod list error in ServerGrid.json file." & @CRLF & @CRLF & "Check the ModIDs line for an extra comma before the ""," & @CRLF & "Proper example: ""ModIDs"": ""1234567890""," & @CRLF & @CRLF & "Click (YES) to exit utility and open ServerGrid.json file in Notepad." & @CRLF & "Click (NO) or (CANCEL) to continue (Mod updater will error but continue to work)"
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 60)
If $tMB = 6 Then
ShellExecute($sConfigPath)
_ExitUtil()
Else
$aSplashStartUp = _Splash($aStartText & "Continuing startup.", 0, 475)
EndIf
EndIf
Next
EndIf
Global $aServerGridTotal = Int($xtotalGridsX) * Int($xtotalGridsY)
EndFunc
#EndRegion
Func _Splash($tTxt, $tTime = 0, $tWidth = 400, $tHeight = 110)
Local $tPID = SplashTextOn($aUtilName, $tTxt, $tWidth, $tHeight, -1, -1, $DLG_MOVEABLE, "")
If $tTime > 0 Then
Sleep($tTime)
SplashOff()
EndIf
Return $tPID
EndFunc
Func _ExitUtil($tSleepYN = True)
If $aUseKeepAliveYN = "yes" Then
IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Close AtlasServerUpdateUtilityKeepAlive? (Checked prior to restarting above Program... used when purposely shutting down above Program)(yes/no) ###", "yes")
If $tSleepYN Then _Splash("Shutting down KeepAlive utility.", 2500)
EndIf
If ProcessExists($aPIDKeepAlive) Then ProcessClose($aPIDKeepAlive)
Exit
EndFunc
Func _CheckForDuplicatePorts()
FileDelete($aDuplicateErrorFile)
Global $aDupError = False
Local $aTxt = "WARNING!!! The following ports are used more than once!" & @CRLF & @CRLF & "Duplicates within the " & $aConfigFile & " file (if any):" & @CRLF
$aTxt &= "----- Duplicate Ports in Same Category -----" & @CRLF
$aTxt &= _ConfigCheckForDuplicates($xServerport, "Query Port")
$aTxt &= _ConfigCheckForDuplicates($xServergameport, "Port")
$aTxt &= _ConfigCheckForDuplicates($xServerseamlessDataPort, "SeamlessDataPort")
$aTxt &= @CRLF & "----- Duplicate RCON Ports in " & $aUtilName & ".ini File -----" & @CRLF
$aTxt &= _ConfigCheckForDuplicates($xServerRCONPort, "RCON Port")
$aTxt &= @CRLF & "----- Duplicate Ports in Same & Multiple Categories -----" & @CRLF
Local $xAllPortsArray = $xServerport
_ArrayConcatenate($xAllPortsArray, $xServerRCONPort)
_ArrayConcatenate($xAllPortsArray, $xServergameport)
_ArrayConcatenate($xAllPortsArray, $xServerseamlessDataPort)
$aTxt &= _ConfigCheckForDuplicates($xAllPortsArray, "(Query/RCON/Port/SeamlessDataPort)")
$aTxt &= @CRLF & "Click (OK) to exit util."
If $aDupError Then
SplashOff()
MsgBox($MB_OK, $aUtilName, $aTxt)
FileWrite($aDuplicateErrorFile, $aTxt)
Run("notepad.exe " & $aDuplicateErrorFile)
ShellExecute($aConfigFull)
Else
_Splash("No duplicate ports found.", 2000)
EndIf
EndFunc
Func _ConfigCheckForDuplicates($tArray, $tParameter)
Local $tTxt = ""
Local $aArray = _ArrayDuplicates($tArray)
If UBound($aArray) > 0 Then
For $i = 0 To (UBound($aArray) - 1)
If $aArray[$i] <> "" Then
$tTxt &= $tParameter & ":" & $aArray[$i] & @CRLF
$aDupError = True
EndIf
Next
EndIf
Return $tTxt
EndFunc
Func _ArrayDuplicates($aArray, $tAddCountToArrayZero = False)
Local $oDict = ObjCreate("Scripting.Dictionary")
Local $vElem
For $i = 0 To UBound($aArray) - 1
$vElem = $aArray[$i]
If $oDict.Exists($vElem) Then
$oDict($vElem) = $oDict($vElem) + 1
Else
$oDict.Item($vElem) = 1
EndIf
Next
If $tAddCountToArrayZero Then
Local $aRet[UBound($aArray) + 1], $iIndex = 0
For $vKey In $oDict
$iCount = $oDict($vKey)
If $iCount > 1 Then
For $i = 1 To $iCount
$iIndex += 1
$aRet[$iIndex] = $vKey
Next
EndIf
Next
$aRet[0] = $iIndex
ReDim $aRet[$iIndex + 1]
Else
Local $aRet[UBound($aArray)], $iIndex = 0
For $vKey In $oDict
$iCount = $oDict($vKey)
If $iCount > 1 Then
For $i = 1 To $iCount
$aRet[$iIndex] = $vKey
$iIndex += 1
Next
EndIf
Next
ReDim $aRet[$iIndex]
EndIf
Return $aRet
EndFunc
Func ImportServerPVE($zServerDirLocal, $zServerAltSaveDir, $zServerGridTotal, $zStartGrid)
Local $tFilePath[$zServerGridTotal]
Local $zServerPVE[$zServerGridTotal]
LogWrite(" Importing ServerPVE from GameUserSettings.ini files")
If UBound($zServerAltSaveDir) < $zServerGridTotal Then
SplashOff()
MsgBox($MB_OK, $aUtilityVer, "!!! ERROR !!! Number of AltSaveDIR in " & $aUtilName & ".ini does not match actual folders available." & @CRLF & "Please ensure your AltSaveFolders is correct in " & $aUtilName & ".ini and restart " & $aUtilName & ".")
WizardExisting(2)
If $aWizExistFinished = False Then _RestartUtil(False)
EndIf
For $i = 0 To ($zServerGridTotal - 1)
If ($xLocalGrid[$i] = "yes") Then
$tFilePath[$i] = $zServerDirLocal & "\ShooterGame\Saved\" & $zServerAltSaveDir[$i] & "\Config\WindowsServer\GameUserSettings.ini"
Local $sFileExists = FileExists($tFilePath[$i])
If ($sFileExists = 0) And ($aServerWorldFriendlyName <> "TempXY") Then
FileWrite($tFilePath[$i], " ")
Else
EndIf
Local $hFileOpen = FileOpen($tFilePath[$i], 0)
Local $hFileRead1 = FileRead($hFileOpen)
If $hFileOpen = -1 Or $sFileExists = 0 Then
$zServerPVE[$i] = False
Else
$zServerPVE[$i] = _ArrayToString(_StringBetween($hFileRead1, "ServerPVE=", @CRLF))
If $zServerPVE[$i] <> "False" & $zServerPVE[$i] <> "True" Then
$zServerPVE[$i] = False
Else
If $zServerPVE[$i] = "True" Then
$zServerPVE[$i] = True
Else
$zServerPVE[$i] = False
EndIf
EndIf
LogWrite("", " Server " & _ServerNamingScheme($i, $aNamingScheme) & " PVE:" & $zServerPVE[$i])
EndIf
FileClose($hFileOpen)
Else
$zServerPVE[$i] = False
EndIf
Next
Return $zServerPVE
EndFunc
#Region
Func ImportRCON($zServerDirLocal, $zServerAltSaveDir, $zServerGridTotal, $zStartGrid)
Local $tFilePath[$zServerGridTotal + 1]
Local $hRCON[$zServerGridTotal + 1]
$hRCON[0] = $zServerGridTotal
LogWrite(" Importing RCON ports from GameUserSettings.ini files")
If UBound($zServerAltSaveDir) < $zServerGridTotal Then
SplashOff()
MsgBox($MB_OK, $aUtilityVer, "!!! ERROR !!! Number of AltSaveDIR in " & $aUtilName & ".ini does not match actual folders available." & @CRLF & "Please ensure your AltSaveFolders is correct in " & $aUtilName & ".ini and restart " & $aUtilName & ".")
WizardExisting(2)
If $aWizExistFinished = False Then _RestartUtil(False)
EndIf
For $i = 1 To ($zServerGridTotal)
If ($zStartGrid[$i - 1] = "yes") Then
$tFilePath[$i] = $zServerDirLocal & "\ShooterGame\Saved\" & $zServerAltSaveDir[$i - 1] & "\Config\WindowsServer\GameUserSettings.ini"
Local $sFileExists = FileExists($tFilePath[$i])
If ($sFileExists = 0) And ($aServerWorldFriendlyName <> "TempXY") Then
Local $aErrorMsg = "!!! ERROR !!! Could not find " & $tFilePath[$i] & "."
LogWrite($aErrorMsg)
SplashOff()
MsgBox($MB_OK, $aUtilityVer, $aErrorMsg & @CRLF & "Please ensure your AltSaveFolders is correct in " & $aUtilName & ".ini and restart " & $aUtilName & ".")
WizardExisting(2)
If $aWizExistFinished = False Then _RestartUtil(False)
Else
Local $hFileOpen = FileOpen($tFilePath[$i], 0)
Local $hFileRead1 = FileRead($hFileOpen)
If $hFileOpen = -1 Then
$hRCON[0] = False
Else
$hRCON[$i] = _ArrayToString(_StringBetween($hFileRead1, "RCONPort=", @CRLF))
If $hRCON[$i] < 1 Then
Local $aErrorMsg = "!!! ERROR !!! RCON Port not assigned in  " & $tFilePath[$i] & "."
LogWrite($aErrorMsg)
SplashOff()
MsgBox($MB_OK, $aUtilityVer, $aErrorMsg & @CRLF & "Please add RCONEnabled=True and RCONPort=[port] to GameUserSettings.ini" & @CRLF & "OR add RCON ports to " & $aUtilName & ".ini and restart " & $aUtilName & ".")
_ExitUtil()
EndIf
LogWrite("", " Server: " & _ServerNamingScheme($i - 1, $aNamingScheme) & " , RCON Port:" & $hRCON[$i])
EndIf
EndIf
FileClose($hFileOpen)
EndIf
Next
Return $hRCON
EndFunc
#EndRegion
#Region
Func GridStartSelect($sGridFile, $sLogFile, $tWizardTF = False)
Global $xStartGrid[$aServerGridTotal + 1]
Global $xLocalGrid[$aServerGridTotal + 1]
Global $aGridSomeDisable = False
Global $aGridIniTitle[4]
Local $tServerGridExtraCMD = False
$aGridIniTitle[0] = " --------------- RUN THE FOLLOWING GRID SERVER(S) (yes/no) --------------- "
$aGridIniTitle[1] = " --------------- LOCAL GRID SERVER(S) (yes-Local, no-Remote) (yes/no) --------------- "
$aGridIniTitle[2] = " --------------- EXTRA COMMANDLINE PARAMETERS PER GRID SERVER --------------- "
$aGridIniTitle[3] = " --------------- ADDITIONAL STARTUP DELAY (in seconds) --------------- "
Local $iIniError = ""
Local $iIniFail = 0
Local $iniCheck = ""
Local $aChar[3]
For $i = 1 To 13
$aChar[0] = Chr(Random(97, 122, 1))
$aChar[1] = Chr(Random(48, 57, 1))
$iniCheck &= $aChar[Random(0, 1, 1)]
Next
For $i = 0 To ($aServerGridTotal - 1)
$xStartGrid[$i] = IniRead($sGridFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", $iniCheck)
If $xStartGrid[$i] = "no" Then
$aGridSomeDisable = True
EndIf
If $iniCheck = $xStartGrid[$i] Then
$xStartGrid[$i] = "yes"
$iIniFail += 1
EndIf
Next
For $i = 0 To ($aServerGridTotal - 1)
$xLocalGrid[$i] = IniRead($sGridFile, $aGridIniTitle[1], "Is Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") Local (yes/no)", $iniCheck)
If $xLocalGrid[$i] = "no" Then
$aGridSomeDisable = True
EndIf
If $iniCheck = $xLocalGrid[$i] Then
$xLocalGrid[$i] = "yes"
$iIniFail += 1
EndIf
Next
For $i = 0 To ($aServerGridTotal - 1)
$xServerGridExtraCMD[$i] = IniRead($sGridFile, $aGridIniTitle[2], "Add to Commandline for Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ")", $iniCheck)
If $iniCheck = $xServerGridExtraCMD[$i] Then
$sGridIniReWrite = True
$xServerGridExtraCMD[$i] = ""
$tServerGridExtraCMD = True
EndIf
If StringLeft($xServerGridExtraCMD[$i], 1) = "-" Then
$xServerGridExtraCMD[$i] = " " & $xServerGridExtraCMD[$i]
EndIf
Next
If $tServerGridExtraCMD Then $iIniError = $iIniError & "Extra Commandline per Grid Server, "
For $i = 0 To ($aServerGridTotal - 1)
$xGridStartDelay[$i] = IniRead($sGridFile, $aGridIniTitle[3], "Additional startup delay Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (0-600)", $iniCheck)
If $xGridStartDelay[$i] < 0 Then
$xGridStartDelay[$i] = 0
EndIf
If $xGridStartDelay[$i] > 600 Then
$xGridStartDelay[$i] = 600
EndIf
If $iniCheck = $xGridStartDelay[$i] Then
$xGridStartDelay[$i] = 0
$iIniFail += 1
EndIf
Next
If $iIniFail > 0 Or $sGridIniReWrite Then
GridFileStartCheck($sGridFile, $iIniFail, $iIniError, $tWizardTF)
EndIf
EndFunc
Func GridFileStartCheck($sGridFile, $iIniFail, $tIniError, $tWizardTF = False)
If FileExists($sGridFile) Then
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aGridSelectFile & "_" & $tTime & ".bak"
FileMove($aGridSelectFile, $tFile, 1)
UpdateGridSelectINI($sGridFile)
LogWrite(" " & $sGridFile & " needs updating. Found " & $iIniFail & " server change(s). Backup created and all existing settings transfered to new INI. Please modify INI and restart.")
If $xServerIP[0] <> "1.2.3.4" Then
If $sGridIniReWrite Then
For $i = 1 To 6
ControlSetText($aSplashStartUp, "", "Static1", $aStartText & "!!NOTICE!! GridStartSelect.ini has new or changed parameter:" & @CRLF & StringTrimRight($tIniError, 2))
Sleep(1000)
ControlSetText($aSplashStartUp, "", "Static1", $aStartText)
Sleep(250)
Next
Else
SplashOff()
Run("notepad " & $sGridFile, @WindowsDir)
MsgBox(4096, $aUtilityVer, "GridStartSelect.ini needs updating. " & @CRLF & "- Found " & $iIniFail & " server change(s). " & @CRLF & @CRLF & "Backup created and all existing settings transfered to new INI." & @CRLF & @CRLF & "Please modify INI and restart.", 15)
_ExitUtil()
EndIf
EndIf
Else
UpdateGridSelectINI($sGridFile)
If $tWizardTF Or $xServerIP[0] = "1.2.3.4" Then
Else
SplashOff()
Run("notepad " & $sGridFile, @WindowsDir)
MsgBox(4096, $aUtilityVer, "Default GridStartSelect.ini file created." & @CRLF & @CRLF & "If you plan to run all grid servers, no change is needed. " & @CRLF & @CRLF & "If you want to only run selected grid servers or have remote servers, please modify the default values and restart program.")
LogWrite(" Default " & $sGridFile & " file created. If you want to only run selected grid server(s), please modify the default values and restart program.")
_ExitUtil()
EndIf
EndIf
EndFunc
Func UpdateGridSelectINI($sGridFile)
For $i = 0 To ($aServerGridTotal - 1)
IniWrite($sGridFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", $xStartGrid[$i])
Next
FileWriteLine($sGridFile, @CRLF)
For $i = 0 To ($aServerGridTotal - 1)
IniWrite($sGridFile, $aGridIniTitle[1], "Is Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") Local (yes/no)", $xLocalGrid[$i])
Next
FileWriteLine($sGridFile, @CRLF)
FileWriteLine($sGridFile, @CRLF)
FileWriteLine($sGridFile, "! Extra commandline parameters used IN ADDITION to the existing parameters set in the " & $aUtilName & ".ini file.")
FileWriteLine($sGridFile, "! Existing parameters: " & $aServerExtraCMD)
For $i = 0 To ($aServerGridTotal - 1)
IniWrite($sGridFile, $aGridIniTitle[2], "Add to Commandline for Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ")", $xServerGridExtraCMD[$i])
Next
FileWriteLine($sGridFile, @CRLF)
FileWriteLine($sGridFile, @CRLF)
FileWriteLine($sGridFile, "! Additional startup delay (in seconds) per grid.  Base delay: " & $aServerStartDelay & " seconds as set in " & $aUtilName & ".ini file.")
For $i = 0 To ($aServerGridTotal - 1)
IniWrite($sGridFile, $aGridIniTitle[3], "Additional startup delay Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (0-600)", $xGridStartDelay[$i])
Next
EndFunc
#EndRegion
#Region
Func FailCountRun()
LogWrite(" [--== CRITICAL ERROR! ==-- ] The " & $aGameName & " Dedicated Server (" & $aServerEXE & ") failed to start at least twice within 1 minute. Please check " & $aGameName & " config files and " & $aUtilName & ".ini file")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, True, False)
MsgBox($MB_OK, $aUtilityVer, "[CRITICAL ERROR!] The " & $aGameName & " Dedicated Server (" & $aServerEXE & ") failed to start at least twice within 1 minute. " & @CRLF & @CRLF & "Please check " & $aGameName & " config files and " & $aUtilName & ".ini file and restart " & $aUtilName & ".")
_ExitUtil()
EndFunc
#EndRegion
Func KeepUtilAliveCounter()
IniWrite($aUtilCFGFile, "CFG", "aCFGKeepUtilAliveTime", _NowCalc())
EndFunc
#Region
Func SendDiscordMsg($sHookURLs, $sBotMessage, $sBotName = "", $sBotTTS = False, $sBotAvatar = "", $aServerPID = "0")
If FileExists($aDiscordSendWebhookEXE) = 0 Then _DownloadAndExtractFile("DiscordSendWebhook", "http://www.phoenix125.com/share/atlas/DiscordSendWebhook.zip", "https://github.com/phoenix125/DiscordSendWebhook/releases/download/DiscordSendWebhook/DiscordSendWebhook.zip", $tSplash)
FileDelete($aFolderTemp & "Discord.txt")
$tCMD = @ComSpec & " /c " & """""" & $aDiscordSendWebhookEXE & """ """ & $sHookURLs & """ """ & $sBotMessage & """ """ & $sBotName & """ > """ & $aFolderTemp & "Discord.txt"""""
Local $mOut = Run($tCMD, $aFolderTemp, @SW_HIDE)
$tErr = ProcessWaitClose($mOut, 4)
If $tErr = 0 Then
$aRCONError = True
EndIf
$tFile = FileOpen($aFolderTemp & "Discord.txt")
$tcrcatch = FileRead($tFile)
FileClose($tFile)
If (StringInStr($tcrcatch, "200") > 0) Or (StringInStr($tcrcatch, "204") > 0) Then
LogWrite(" [Discord] Message sent: " & $sBotMessage, " [Discord] Message sent:[" & $tCMD & "] | Response:[" & ReplaceCRLF($tcrcatch) & "]")
Else
LogWrite(" [Discord] ERROR!!! Send message failed using DiscordSendWebhook.exe: " & $sBotMessage, " [Discord] ERROR!!! Send message failed using DiscordSendWebhook.exe: " & $sBotMessage & ". Response: " & ReplaceCRLF($tcrcatch))
Local $tObjErrFunc = $aObjErrFunc
$aObjErrFunc = "Discord"
Local $sJsonMessage = '{"content" : "' & $sBotMessage & '", "username" : "' & $sBotName & '", "tts" : "' & $sBotTTS & '", "avatar_url" : "' & $sBotAvatar & '"}'
Local $oHTTPOST = ObjCreate("WinHttp.WinHttpRequest.5.1")
$oHTTPOST.Open("POST", StringStripWS($sHookURLs, 3) & "?wait=True", False)
$oHTTPOST.Option(4) = 0x3300
$oHTTPOST.SetRequestHeader("Content-Type", "multipart/form-data")
$oHTTPOST.Send($sJsonMessage)
Local $oStatusCode = $oHTTPOST.Status
Local $oReceived = $oHTTPOST.ResponseText
LogWrite(" [Discord] Message sent using WinHttp.WinHttpRequest.5.1 object: " & $sBotMessage, " [Discord] Message sent using WinHttp.WinHttpRequest.5.1 object. Status Code {" & $oStatusCode & "} " & "Message Response: " & $oReceived)
$aObjErrFunc = $tObjErrFunc
EndIf
Return $tcrcatch
EndFunc
#EndRegion
#Region
Func SendInGame($mIP, $mPort, $mPass, $mMessage)
For $i = 0 To ($aServerGridTotal - 1)
If ($xStartGrid[$i] = "yes") Then
If $aServerRCONIP = "" Then
Local $aMCRCONcmd = @ScriptDir & '\mcrcon.exe -c -s -H ' & $xServerIP[$i] & ' -P ' & $xServerRCONPort[$i + 1] & ' -p ' & $mPass & " """ & $aRCONBroadcastCMD & " " & $mMessage & """"
Else
Local $aMCRCONcmd = @ScriptDir & '\mcrcon.exe -c -s -H ' & $aServerRCONIP & ' -P ' & $xServerRCONPort[$i + 1] & ' -p ' & $mPass & " """ & $aRCONBroadcastCMD & " " & $mMessage & """"
EndIf
LogWrite("", " [RCON In-Game Message] Server (" & _ServerNamingScheme($i, $aNamingScheme) & ") " & $aMCRCONcmd)
Run($aMCRCONcmd, @ScriptDir, @SW_HIDE)
EndIf
Next
LogWrite(" [RCON In-Game Message Sent] " & $mMessage, "no")
EndFunc
#EndRegion
#Region
Func SendRCON($mIP, $mPort, $mPass, $mCommand, $mLogYN = "yes", $mWaitms = 1500)
$aRCONError = False
If StringInStr($mCommand, "broadcast") > 0 Then
Local $tTxt = StringTrimLeft($mCommand, 10)
Local $tTxt1 = SendMessageAddDuration($tTxt)
$mCommand = "broadcast " & $tTxt1
EndIf
If $aServerRCONIP = "" Then
Local $aMCRCONcmd = @ScriptDir & '\mcrcon.exe -c -H ' & $mIP & ' -P ' & $mPort & ' -p ' & $mPass & ' "' & $mCommand & '"'
Else
Local $aMCRCONcmd = @ScriptDir & '\mcrcon.exe -c -H ' & $aServerRCONIP & ' -P ' & $mPort & ' -p ' & $mPass & ' "' & $mCommand & '"'
EndIf
Local $mOut = Run($aMCRCONcmd, @ScriptDir, @SW_HIDE, $STDERR_CHILD + $STDOUT_CHILD)
If $mWaitms > 0 Then
Local $tTimer1 = TimerInit()
Local $tExit = False
While ProcessExists($mOut) And $tExit = False
Sleep(50)
If TimerDiff($tTimer1) > $mWaitms Then $tExit = True
WEnd
ProcessClose($mOut)
Local $tcrcatch = StdoutRead($mOut)
If $aErrorShutdown = 0 Then
If $mLogYN = "yes" Then
If $aServerRCONIP = "" Then
LogWrite(" [RCON] IP: " & $mIP & ". Port:" & $mPort & ". Command:" & $mCommand, " [RCON] " & $aMCRCONcmd & ", Response:" & ReplaceCRLF($tcrcatch))
Else
LogWrite(" [RCON] IP: " & $aServerRCONIP & ". Port:" & $mPort & ". Command:" & $mCommand, " [RCON] " & $aMCRCONcmd & ", Response:" & ReplaceCRLF($tcrcatch))
EndIf
ElseIf $mLogYN = "players" Then
If $aRCONError = True Then LogWrite("", " [RCON] ERROR! " & $aMCRCONcmd & ", Response:" & ReplaceCRLF($tcrcatch))
Else
LogWrite("", " [RCON] " & $aMCRCONcmd & ", Response:" & ReplaceCRLF($tcrcatch))
EndIf
EndIf
Return $tcrcatch
Else
If $mLogYN = "yes" Then
If $aServerRCONIP = "" Then
LogWrite(" [RCON] IP: " & $mIP & ". Port:" & $mPort & ". Command:" & $mCommand, " [RCON] " & $aMCRCONcmd)
Else
LogWrite(" [RCON] IP: " & $aServerRCONIP & ". Port:" & $mPort & ". Command:" & $mCommand, " [RCON] " & $aMCRCONcmd)
EndIf
EndIf
Return "Did not wait for response."
EndIf
EndFunc
#EndRegion
#Region
Func UpdateCheck($tAsk, $tSplash = 0, $tShow = True)
If $aCheckForUpdate = "no" And $tAsk = False Then
LogWrite(" [Update] " & $aGameName & " update check disabled.", " [Update] " & $aGameName & " update check disabled. To enable, change [Check for server updates? (yes/no) ###=no] in " & $aUtilName & ".ini file.")
Return "skipped"
EndIf
_DownloadAndExtractFile("steamcmd", "https://steamcdn-a.akamaihd.net/client/installer/steamcmd.zip", "http://www.phoenix125.com/share/atlas/steamcmd.zip", $tSplash, $aSteamCMDDir)
$aSteamUpdateNow = False
If $aUpdateSource = "1" Then
If ($aFirstBoot Or $tAsk) And $tShow Then
Local $tTxt = $aStartText & "Acquiring latest buildid from SteamDB." & @CRLF & "Please wait up to 2 minutes."
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
EndIf
Local $aLatestVersion = GetLatestVerSteamDB($aSteamAppID, $aServerVer)
Else
If ($aFirstBoot Or $tAsk) And $tShow Then
Local $tTxt = $aStartText & "Acquiring latest buildid from SteamCMD." & @CRLF & "Please wait up to 2 minutes."
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
EndIf
Local $aLatestVersion = GetLatestVersion($aSteamCMDDir)
EndIf
If ($aFirstBoot Or $tAsk) And $tShow Then
Local $tTxt = $aStartText & "Retrieving installed version buildid." & @CRLF & "Please wait up to 2 minutes."
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
EndIf
Local $aInstalledVersion = GetInstalledVersion($aServerDirFull)
IniWrite($aUtilCFGFile, "CFG", "aCFGLastUpdate", _NowCalc())
If $tSplash = 0 Then
SplashOff()
EndIf
If ($aLatestVersion[0] And $aInstalledVersion[0]) Then
If StringCompare($aLatestVersion[1], $aInstalledVersion[1]) = 0 Then
$aSteamRunCount = 0
LogWrite(" [Update] Server is Up to Date. Installed Version: " & $aInstalledVersion[1] & " Latest Version: " & $aLatestVersion[1])
If $tAsk Then
SplashOff()
$tMB = MsgBox($MB_OK, $aUtilityVer, "Server is Up to Date." & @CRLF & @CRLF & "Installed Version: " & $aInstalledVersion[1] & @CRLF & "   Latest Version: " & $aLatestVersion[1], 5)
EndIf
Else
LogWrite(" [Update] Server is Out of Date! Installed Version: " & $aInstalledVersion[1] & " Latest Version: " & $aLatestVersion[1])
If $tAsk Then
SplashOff()
If (($sUseDiscordBotDaily = "yes") Or ($sUseDiscordBotUpdate = "yes") Or ($sUseTwitchBotDaily = "yes") Or ($sUseTwitchBotUpdate = "yes") Or ($sInGameAnnounce = "yes")) Then
Local $aMsg = "Server is Out of Date! Installed Version: " & $aInstalledVersion[1] & " Latest Version: " & $aLatestVersion[1] & @CRLF & @CRLF & "Click (YES) to update " & $aGameName & " NOW with -validate." & @CRLF & "Click (NO) to start update announcements (Discord, In-Game, and/or Twitch), then update." & @CRLF & "Click (CANCEL) to cancel."
Else
Local $aMsg = "Server is Out of Date! Installed Version: " & $aInstalledVersion[1] & " Latest Version: " & $aLatestVersion[1] & @CRLF & @CRLF & "Click (YES) to update " & $aGameName & " NOW with -validate." & @CRLF & "Click (NO) or (CANCEL) to cancel."
EndIf
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 60)
If $tMB = 6 Then
$bUpdateRequired = True
$aSteamUpdateNow = True
$aUpdateVerify = "yes"
RunExternalScriptUpdate()
$TimeStamp = StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_")
SteamcmdDelete($aSteamCMDDir)
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
ElseIf ($tMB = 7) And (($sUseDiscordBotDaily = "yes") Or ($sUseDiscordBotUpdate = "yes") Or ($sUseTwitchBotDaily = "yes") Or ($sUseTwitchBotUpdate = "yes") Or ($sInGameAnnounce = "yes")) Then
$bUpdateRequired = True
$aSteamUpdateNow = True
$aUpdateVerify = "yes"
RunExternalScriptUpdate()
$TimeStamp = StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_")
$aBeginDelayedShutdown = 1
$aRebootReason = "update"
Else
_Splash("Utility update check canceled by user." & @CRLF & "Resuming utility . . .")
EndIf
Else
If $aFirstBoot Then
Local $tTxt = $aStartText & "Server is Out of Date! Updating server." & @CRLF & "Installed Version: " & $aInstalledVersion[1] & ", Latest: " & $aLatestVersion[1]
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
Sleep(4000)
EndIf
If ($sUseDiscordBotDaily = "yes") Or ($sUseDiscordBotUpdate = "yes") Or ($sUseTwitchBotDaily = "yes") Or ($sUseTwitchBotUpdate = "yes") Or ($sInGameAnnounce = "yes") Then
$bUpdateRequired = True
$aSteamUpdateNow = True
$aUpdateVerify = "yes"
RunExternalScriptUpdate()
$TimeStamp = StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_")
$aBeginDelayedShutdown = 1
$aRebootReason = "update"
Else
$bUpdateRequired = True
$aSteamUpdateNow = True
$aUpdateVerify = "yes"
RunExternalScriptUpdate()
$TimeStamp = StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_")
SteamcmdDelete($aSteamCMDDir)
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
EndIf
EndIf
EndIf
ElseIf Not $aLatestVersion[0] And Not $aInstalledVersion[0] Then
LogWrite(" [Update] Something went wrong retrieving Latest & Installed Versions. Running update with -validate")
_Splash("Something went wrong retrieving Latest & Installed Versions." & @CRLF & "- Running update with -validate" & @CRLF & @CRLF & "(Restart will be delayed if 'announce restart' is enabled)", 0, 500, 125)
$bUpdateRequired = True
$aSteamUpdateNow = True
$aUpdateVerify = "yes"
RunExternalScriptUpdate()
$TimeStamp = StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_")
SteamcmdDelete($aSteamCMDDir)
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
ElseIf Not $aInstalledVersion[0] Then
LogWrite(" [Update] Something went wrong retrieving Installed Version. Running update with -validate. (This is normal for new install)")
_Splash("Something went wrong retrieving Installed Version." & @CRLF & "(This is normal for new install)" & @CRLF & "- Running update with -validate" & @CRLF & @CRLF & "(Restart will be delayed if 'announce restart' is enabled)", 0, 450, 175)
$bUpdateRequired = True
$aSteamUpdateNow = True
$aUpdateVerify = "yes"
RunExternalScriptUpdate()
$TimeStamp = StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_")
SteamcmdDelete($aSteamCMDDir)
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
ElseIf Not $aLatestVersion[0] Then
LogWrite(" [Update] Something went wrong retrieving Latest Version.  Skipping this update check.")
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, "Something went wrong retrieving Latest Version. " & @CRLF & @CRLF & "Click (YES) to update " & $aGameName & " NOW with -validate." & @CRLF & "Click (NO) or (CANCEL) to cancel." & @CRLF & @CRLF & "(This window will close in 5 seconds)", 15)
If $tMB = 6 Then
$bUpdateRequired = True
$aSteamUpdateNow = True
$aUpdateVerify = "yes"
RunExternalScriptUpdate()
$TimeStamp = StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_")
SteamcmdDelete($aSteamCMDDir)
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
Else
_Splash("Utility update check canceled by user." & @CRLF & "Resuming utility . . .", 2000)
EndIf
EndIf
EndFunc
Func GetLatestVerSteamDB($bSteamAppID, $bServerVer)
Local $aReturn[2] = [False, ""]
If $bServerVer = 0 Then
Local $aURL = $aSteamDBURLPublic
Local $aBranch = "stable"
Else
Local $aURL = $aSteamDBURLExperimental
Local $aBranch = "experimental"
EndIf
$aSteamDB1 = _IECreate($aURL, 0, 0)
$aSteamDB = _IEDocReadHTML($aSteamDB1)
_IEQuit($aSteamDB1)
FileWrite($aFolderTemp & "SteamDB.tmp", $aSteamDB)
Local Const $sFilePath = $aFolderTemp & "SteamDB.tmp"
Local $hFileOpen = FileOpen($sFilePath, 0)
Local $hFileRead1 = FileRead($hFileOpen)
If $hFileOpen = -1 Then
$aReturn[0] = False
Else
Local $xBuildID = _ArrayToString(_StringBetween($hFileRead1, "buildid:</i> <b>", "</b></li><li><i>timeupdated"))
Local $hBuildID = Int($xBuildID)
LogWrite("", " [Update] Using SteamDB " & $aBranch & " branch. Latest version: " & $hBuildID)
EndIf
FileClose($hFileOpen)
If $hBuildID < 100000 Then
SplashOff()
MsgBox($mb_ok, "ERROR", " [Update] Error retrieving buildid via SteamDB website. Please visit:" & @CRLF & @CRLF & $aURL & @CRLF & @CRLF & "in *Internet Explorer* (NOT Chrome.. must be Internet Explorer) to CAPTCHA authorize your PC or use SteamCMD for updates." & @CRLF & "! Press OK to close " & $aUtilName & " !")
LogWrite("Error retrieving buildid via SteamDB website. Please visit:" & $aURL & "in **Internet Explorer** (NOT Chrome.. must be Internet Explorer) to CAPTCHA authorize your PC or use SteamCMD for updates.")
EndIf
If FileExists($sFilePath) Then
FileDelete($sFilePath)
EndIf
$aReturn[0] = True
$aReturn[1] = $hBuildID
Return $aReturn
EndFunc
Func GetLatestVersion($sCmdDir)
$hBuildID = "0"
Local $aReturn[2] = [False, ""]
DirRemove($sCmdDir & "\appcache", 1)
DirRemove($sCmdDir & "\depotcache", 1)
$sAppInfoTemp = "app_info_" & StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_") & ".tmp"
$aSteamUpdateCheck = '"' & @ComSpec & '" /c "' & $sCmdDir & "\steamcmd.exe"" +login anonymous +app_info_update 1 +app_info_print " & $aSteamAppID & " +app_info_print " & $aSteamAppID & " +app_info_print " & $aSteamAppID & " +exit > " & $sAppInfoTemp
$Timer = TimerInit()
Local $tPID = Run($aSteamUpdateCheck, $aSteamCMDDir, @SW_MINIMIZE)
Do
If Not ProcessExists($tPID) Then ExitLoop
Sleep(500)
Until TimerDiff($Timer) > 20000
If ProcessExists($tPID) Then
ProcessClose($tPID)
EndIf
Local Const $sFilePath = $sCmdDir & "\" & $sAppInfoTemp
Local $hFileOpen = FileOpen($sFilePath, 0)
Local $hFileRead1 = FileRead($hFileOpen)
If $hFileOpen = -1 Then
$aReturn[0] = False
LogWrite(" [Update] SteamCMD update check FAILED to create update file. Skipping this update check.")
Else
If StringInStr($hFileRead1, "buildid") > 0 Then
Local $hFileReadArray = _StringBetween($hFileRead1, "branches", "AppID")
Local $hFileRead = _ArrayToString($hFileReadArray)
If $aServerVer = 0 Then
Local $hString1 = _StringBetween($hFileRead, "public", "timeupdated")
Else
Local $hString1 = _StringBetween($hFileRead, $aExperimentalString, "timeupdated")
EndIf
Local $hString2 = StringSplit($hString1[0], '"', 2)
$hString3 = _ArrayToString($hString2)
Local $hString4 = StringRegExpReplace($hString3, "\t", "")
Local $hString5 = StringRegExpReplace($hString4, @CR & @LF, ".")
Local $hString6 = StringRegExpReplace($hString5, "{", "")
Local $hBuildIDArray = _StringBetween($hString6, "buildid||", "|.")
Local $hBuildID = _ArrayToString($hBuildIDArray)
If $aServerVer = 0 Then
LogWrite("", " [Update] Update Check via Stable Branch. Latest version: " & $hBuildID)
EndIf
If $aServerVer = 1 Then
LogWrite("", " [Update] Update Check via Experimental Branch. Latest version: " & $hBuildID)
EndIf
If FileExists($sFilePath) Then
FileDelete($sFilePath)
EndIf
$aReturn[0] = True
Else
$aReturn[0] = False
LogWrite(" [Update] SteamCMD update check returned a FAILURE response. Skipping this update check.")
EndIf
FileClose($hFileOpen)
EndIf
$aReturn[1] = $hBuildID
Return $aReturn
EndFunc
Func GetInstalledVersion($sGameDir)
Local $aReturn[2] = [False, ""]
Local Const $sFilePath = $aSteamAppFile
Local $hFileOpen = FileOpen($sFilePath, 0)
If $hFileOpen = -1 Then
$aReturn[0] = False
Else
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
$aReturn[0] = True
$aReturn[1] = _ArrayToString(_StringBetween($sFileRead, "buildid""" & @TAB & @TAB & """", """"))
EndIf
Return $aReturn
EndFunc
#EndRegion
Func DailyRestartCheck($sWDays, $sHours, $sMin)
Local $iDay = -1
Local $iHour = -1
Local $aDays = StringSplit($sWDays, ",")
Local $aHours = StringSplit($sHours, ",")
For $d = 1 To $aDays[0]
$iDay = StringStripWS($aDays[$d], 8)
If Int($iDay) = Int(@WDAY) Or Int($iDay) = 0 Then
For $h = 1 To $aHours[0]
$iHour = StringStripWS($aHours[$h], 8)
If Int($iHour) = Int(@HOUR) And Int($sMin) = Int(@MIN) Then
Return True
EndIf
Next
EndIf
Next
Return False
EndFunc
Func BackupCheck($sWDays, $sHours, $sMin)
Local $iDay = -1
Local $iHour = -1
Local $aDays = StringSplit($sWDays, ",")
Local $aHours = StringSplit($sHours, ",")
For $d = 1 To $aDays[0]
$iDay = StringStripWS($aDays[$d], 8)
If Int($iDay) = Int(@WDAY) Or Int($iDay) = 0 Then
For $h = 1 To $aHours[0]
$iHour = StringStripWS($aHours[$h], 8)
If Int($iHour) = Int(@HOUR) And Int($sMin) = Int(@MIN) Then
Return True
EndIf
Next
EndIf
Next
Return False
EndFunc
Func _BackupGame($tMinimizeTF = True)
SetStatusBusy("Backup starting")
If $aBackupInGame <> "" Then
LogWrite(" [Backup] In-Game Announcement sent: " & $aBackupInGame)
For $i = 0 To ($aServerGridTotal - 1)
If ($xStartGrid[$i] = "yes") And ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $aBackupInGame, "no", 0)
EndIf
Next
EndIf
If $aBackupDiscord <> "" Then
SendDiscordMsg($sDiscordWebHookURLs, $aBackupDiscord, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
If $aBackupTwitch <> "" Then
TwitchMsgLog($aBackupTwitch)
EndIf
_DownloadAndExtractFile("7z", "http://www.phoenix125.com/share/atlas/7z.zip", "https://github.com/phoenix125/AtlasServerUpdateUtility/releases/download/Latest/7z.zip", 0, $aFolderTemp, "7z.dll")
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tName = $aGameName & "_Backup_" & $tTime & ".zip"
Local $tFull = $aBackupOutputFolder & "\" & $tName
Local $tRedis = ""
If $aBackupRedisFolder = "" Then
If $aServerRedisFolder = "" Then
$tRedis = " """ & $aServerDirLocal & $aServerRedisDir & """"
Else
$tRedis = " """ & $aServerRedisFolder & """"
EndIf
Else
$tRedis = " """ & $aBackupRedisFolder & """"
EndIf
Local $tCMD = """" & $aFolderTemp & "7z"" a -spf -r -tzip -ssw -x!ocean.*.atlas """ & $tFull & """ """ & $aServerDirLocal & "\ShooterGame\Saved\"" """ & $aServerDirLocal & "\ShooterGame\Server*.json""" & $tRedis & " """ & $aGridSelectFile & """ """ & $aIniFile & """"
LogWrite(" [Backup] Backup started. File:" & $tName, " [Backup] Backup initiated: " & $tCMD)
If $tMinimizeTF Then
Local $tPID = Run($tCMD, "", @SW_MINIMIZE)
Else
Local $tPID = Run($tCMD, "")
EndIf
Local $tTimer1 = TimerInit()
Local $tExit = False
While ProcessExists($tPID) And $tExit = False
SetStatusBusy("Backup Cntdn " & Int($aBackupTimeoutSec - TimerDiff($tTimer1) / 1000))
Sleep(950)
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
If TimerDiff($tTimer1) > ($aBackupTimeoutSec * 1000) Then $tExit = True
WEnd
If ProcessExists($tPID) Then
ProcessClose($tPID)
LogWrite("", " [Backup] ERROR! Backup timed out.")
Else
LogWrite("", " [Backup] Backup completed successfully.")
EndIf
If $tMinimizeTF = False Then _Splash("Backup completed successfully." & @CRLF & @CRLF & $tFull, 3000)
PurgeBackups()
EndFunc
Func PurgeBackups()
Local $aPurgeBackups = $aFolderTemp & $aUtilName & "_PurgeBackups.bat"
Local $sFileExists = FileExists($aPurgeBackups)
If $sFileExists = 1 Then
FileDelete($aPurgeBackups)
EndIf
FileWriteLine($aPurgeBackups, "for /f ""tokens=* skip=" & $aBackupNumberToKeep & """ %%F in " & Chr(40) & "'dir """ & $aBackupOutputFolder & "\" & $aGameName & "_Backup_*.zip"" /o-d /tc /b'" & Chr(41) & " do del """ & $aBackupOutputFolder & "\%%F""")
LogWrite("", " Deleting Backups > " & $aBackupNumberToKeep & " in folder " & $aBackupOutputFolder)
Run($aPurgeBackups, "", @SW_HIDE)
EndFunc
Func TwitchMsgLog($sT_Msg)
Local $aTwitchIRC = SendTwitchMsg($sTwitchNick, $sChatOAuth, $sTwitchChannels, $sT_Msg)
If $aTwitchIRC[0] Then
LogWrite(" [Twitch] Successfully Connected to Twitch IRC")
If $aTwitchIRC[1] Then
LogWrite(" [Twitch] Username and OAuth Accepted. [" & $aTwitchIRC[2] & "]")
If $aTwitchIRC[3] Then
LogWrite(" [Twitch] Successfully sent ( " & $sT_Msg & " ) to all Channels")
Else
LogWrite(" [Twitch] ERROR | Failed sending message ( " & $sT_Msg & " ) to one or more channels")
EndIf
Else
LogWrite(" [Twitch] ERROR | Username and OAuth Denied [" & $aTwitchIRC[2] & "]")
EndIf
Else
LogWrite(" [Twitch] ERROR | Could not connect to Twitch IRC. Is this URL or port blocked? [irc.chat.twitch.tv:6667]")
EndIf
EndFunc
Func SendTwitchMsg($sT_Nick, $sT_OAuth, $sT_Channels, $sT_Message)
Local $aTwitchReturn[4] = [False, False, "", False]
Local $sTwitchIRC = TCPConnect(TCPNameToIP("irc.chat.twitch.tv"), 6667)
If @error Then
TCPCloseSocket($sTwitchIRC)
Return $aTwitchReturn
Else
$aTwitchReturn[0] = True
TCPSend($sTwitchIRC, "PASS " & StringLower($sT_OAuth) & @CRLF)
TCPSend($sTwitchIRC, "NICK " & StringLower($sT_Nick) & @CRLF)
Local $sTwitchReceive = ""
Local $iTimer1 = TimerInit()
While TimerDiff($iTimer1) < 1000
$sTwitchReceive &= TCPRecv($sTwitchIRC, 1)
If @error Then ExitLoop
WEnd
Local $aTwitchReceiveLines = StringSplit($sTwitchReceive, @CRLF, 1)
$aTwitchReturn[2] = $aTwitchReceiveLines[1]
If StringRegExp($aTwitchReceiveLines[$aTwitchReceiveLines[0] - 1], "(?i):tmi.twitch.tv 376 " & $sT_Nick & " :>") Then
$aTwitchReturn[1] = True
Local $aTwitchChannels = StringSplit($sT_Channels, ",")
For $i = 1 To $aTwitchChannels[0]
TCPSend($sTwitchIRC, "PRIVMSG #" & StringLower($aTwitchChannels[$i]) & " :" & $sT_Message & @CRLF)
If @error Then
TCPCloseSocket($sTwitchIRC)
$aTwitchReturn[3] = False
Return $aTwitchReturn
ExitLoop
Else
$aTwitchReturn[3] = True
If $aTwitchChannels[0] > 17 Then
Sleep(1600)
Else
Sleep(100)
EndIf
EndIf
Next
TCPSend($sTwitchIRC, "QUIT")
TCPCloseSocket($sTwitchIRC)
Else
Return $aTwitchReturn
EndIf
EndIf
Return $aTwitchReturn
EndFunc
Func RCONCustomTimeCheck($wDate, $sWDays, $sHours, $sMin)
Local $iDate = -1
Local $iDay = -1
Local $iHour = -1
Local $aDate = StringSplit($wDate, ",")
Local $aDays = StringSplit($sWDays, ",")
Local $aHours = StringSplit($sHours, ",")
If $wDate = "0" Then
For $d = 1 To $aDays[0]
$iDay = StringStripWS($aDays[$d], 8)
If Int($iDay) = Int(@WDAY) Or Int($iDay) = 0 Then
For $h = 1 To $aHours[0]
$iHour = StringStripWS($aHours[$h], 8)
If Int($iHour) = Int(@HOUR) And Int($sMin) = Int(@MIN) Then
Return True
EndIf
Next
EndIf
Next
Else
For $d = 1 To $aDate[0]
$iDate = StringStripWS($aDate[$d], 8)
If Int($iDate) = Int(@MDAY) Or Int($iDate) = 0 Then
For $h = 1 To $aHours[0]
$iHour = StringStripWS($aHours[$h], 8)
If Int($iHour) = Int(@HOUR) And Int($sMin) = Int(@MIN) Then
Return True
EndIf
Next
EndIf
Next
EndIf
Return False
EndFunc
Func RunExternalScriptBeforeSteam($tSplash = 0)
If $aExecuteExternalScript = "yes" Then
LogWrite(" Executing BEFORE SteamCMD UPDATE AND SERVER START external script " & $aExternalScriptDir & "\" & $aExternalScriptName)
If $aExternalScriptWait = "no" Then
If $aExternalScriptHideYN = "yes" Then
Run($aExternalScriptDir & '\' & $aExternalScriptName, $aExternalScriptDir, @SW_HIDE)
Else
Run($aExternalScriptDir & '\' & $aExternalScriptName, $aExternalScriptDir)
EndIf
Else
Local $tTxt = $aStartText & "Waiting for BEFORE SteamCMD UPDATE AND SERVER START external script to finish . . ."
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
If $aExternalScriptHideYN = "yes" Then
RunWait($aExternalScriptDirr & '\' & $aExternalScriptName, $aExternalScriptDir, @SW_HIDE)
Else
RunWait($aExternalScriptDir & '\' & $aExternalScriptName, $aExternalScriptDir)
EndIf
LogWrite(" External BEFORE SteamCMD UPDATE AND SERVER START restart script finished.")
If $tSplash = 0 Then
SplashOff()
EndIf
EndIf
EndIf
EndFunc
Func RunExternalScriptAfterSteam($tSplash = 0)
If $aExternalScriptValidateYN = "yes" Then
LogWrite(" Executing AFTER SteamCMD BUT BEFORE SERVER external script " & $aExternalScriptValidateDir & "\" & $aExternalScriptValidateName)
If $aExternalScriptValidateWait = "no" Then
If $aExternalScriptHideYN = "yes" Then
Run($aExternalScriptValidateDir & '\' & $aExternalScriptValidateName, $aExternalScriptValidateDir, @SW_HIDE)
Else
Run($aExternalScriptValidateDir & '\' & $aExternalScriptValidateName, $aExternalScriptValidateDir)
EndIf
Else
Local $tTxt = $aStartText & "Waiting for AFTER SteamCMD BUT BEFORE SERVER external script to finish . . ."
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
If $aExternalScriptHideYN = "yes" Then
RunWait($aExternalScriptValidateDir & '\' & $aExternalScriptValidateName, $aExternalScriptValidateDir, @SW_HIDE)
Else
RunWait($aExternalScriptValidateDir & '\' & $aExternalScriptValidateName, $aExternalScriptValidateDir)
EndIf
LogWrite(" External AFTER SteamCMD BUT BEFORE SERVER restart script finished.")
If $tSplash = 0 Then
SplashOff()
EndIf
EndIf
EndIf
EndFunc
Func RunExternalScriptDaily()
If $aExternalScriptDailyYN = "yes" Then
LogWrite(" Executing DAILY restart external script " & $aExternalScriptDailyDir & "\" & $aExternalScriptDailyFileName)
If $aExternalScriptDailyWait = "no" Then
If $aExternalScriptHideYN = "yes" Then
Run($aExternalScriptDailyDir & '\' & $aExternalScriptDailyFileName, $aExternalScriptDailyDir, @SW_HIDE)
Else
Run($aExternalScriptDailyDir & '\' & $aExternalScriptDailyFileName, $aExternalScriptDailyDir)
EndIf
Else
_Splash($aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Waiting for DAILY external script to finish . . .")
If $aExternalScriptHideYN = "yes" Then
RunWait($aExternalScriptDailyDir & '\' & $aExternalScriptDailyFileName, $aExternalScriptDailyDir, @SW_HIDE)
Else
RunWait($aExternalScriptDailyDir & '\' & $aExternalScriptDailyFileName, $aExternalScriptDailyDir)
EndIf
LogWrite(" External DAILY restart script finished.")
SplashOff()
EndIf
EndIf
EndFunc
Func RunExternalScriptAnnounce()
If $aExternalScriptAnnounceYN = "yes" Then
LogWrite(" Executing FIRST ANNOUNCEMENT external script " & $aExternalScriptAnnounceDir & "\" & $aExternalScriptAnnounceFileName)
If $aExternalScriptAnnounceWait = "no" Then
If $aExternalScriptHideYN = "yes" Then
Run($aExternalScriptAnnounceDir & '\' & $aExternalScriptAnnounceFileName, $aExternalScriptAnnounceDir, @SW_HIDE)
Else
Run($aExternalScriptAnnounceDir & '\' & $aExternalScriptAnnounceFileName, $aExternalScriptAnnounceDir)
EndIf
Else
_Splash($aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Waiting for FIRST ANNOUNCEMENT external script to finish . . .")
If $aExternalScriptHideYN = "yes" Then
RunWait($aExternalScriptAnnounceDir & '\' & $aExternalScriptAnnounceFileName, $aExternalScriptAnnounceDir, @SW_HIDE)
Else
RunWait($aExternalScriptAnnounceDir & '\' & $aExternalScriptAnnounceFileName, $aExternalScriptAnnounceDir)
EndIf
LogWrite(" External FIRST ANNOUNCEMENT restart script finished.")
SplashOff()
EndIf
EndIf
EndFunc
Func RunExternalRemoteRestart()
If $aExternalScriptRemoteYN = "yes" Then
LogWrite(" Executing REMOTE RESTART external script " & $aExternalScriptRemoteDir & "\" & $aExternalScriptRemoteFileName)
If $aExternalScriptRemoteWait = "no" Then
If $aExternalScriptHideYN = "yes" Then
Run($aExternalScriptRemoteDir & '\' & $aExternalScriptRemoteFileName, $aExternalScriptRemoteDir, @SW_HIDE)
Else
Run($aExternalScriptRemoteDir & '\' & $aExternalScriptRemoteFileName, $aExternalScriptRemoteDir)
EndIf
Else
_Splash($aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Waiting for REMOTE RESTART external script to finish . . .")
If $aExternalScriptHideYN = "yes" Then
RunWait($aExternalScriptRemoteDir & '\' & $aExternalScriptRemoteFileName, $aExternalScriptRemoteDir, @SW_HIDE)
Else
RunWait($aExternalScriptRemoteDir & '\' & $aExternalScriptRemoteFileName, $aExternalScriptRemoteDir)
EndIf
LogWrite(" External REMOTE RESTART script finished.")
SplashOff()
EndIf
EndIf
EndFunc
Func RunExternalScriptUpdate()
If $aExternalScriptUpdateYN = "yes" Then
LogWrite(" Executing Script When Restarting For Server Update: " & $aExternalScriptUpdateDir & "\" & $aExternalScriptUpdateFileName)
If $aExternalScriptUpdateWait = "no" Then
If $aExternalScriptHideYN = "yes" Then
Run($aExternalScriptUpdateDir & '\' & $aExternalScriptUpdateFileName, $aExternalScriptUpdateDir, @SW_HIDE)
Else
Run($aExternalScriptUpdateDir & '\' & $aExternalScriptUpdateFileName, $aExternalScriptUpdateDir)
EndIf
Else
_Splash($aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Waiting for Script When Restarting For Server Update external script to finish . . .")
If $aExternalScriptHideYN = "yes" Then
RunWait($aExternalScriptUpdateDir & '\' & $aExternalScriptUpdateFileName, $aExternalScriptUpdateDir, @SW_HIDE)
Else
RunWait($aExternalScriptUpdateDir & '\' & $aExternalScriptUpdateFileName, $aExternalScriptUpdateDir)
EndIf
LogWrite(" Executing Script When Restarting For Server Update Finished. Continuing Server Start.")
SplashOff()
EndIf
EndIf
EndFunc
Func RunExternalScriptMod()
If $aExternalScriptModYN = "yes" Then
LogWrite(" Executing Script When Restarting For MOD Update: " & $aExternalScriptModDir & "\" & $aExternalScriptModFileName)
If $aExternalScriptModWait = "no" Then
If $aExternalScriptHideYN = "yes" Then
Run($aExternalScriptModDir & '\' & $aExternalScriptModFileName, $aExternalScriptModDir, @SW_HIDE)
Else
Run($aExternalScriptModDir & '\' & $aExternalScriptModFileName, $aExternalScriptModDir)
EndIf
Else
_Splash($aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Waiting for Script When Restarting For MOD Update external script to finish . . .")
If $aExternalScriptHideYN = "yes" Then
RunWait($aExternalScriptModDir & '\' & $aExternalScriptModFileName, $aExternalScriptModDir, @SW_HIDE)
Else
RunWait($aExternalScriptModDir & '\' & $aExternalScriptModFileName, $aExternalScriptModDir)
EndIf
LogWrite(" Executing Script When Restarting For MOD Update Finished. Continuing Server Start.")
SplashOff()
EndIf
EndIf
EndFunc
Func ExternalScriptExist()
Local $sFileExists = FileExists($aBatFolder & "\" & $aBatUpdateGame)
If $sFileExists = 0 Then
Local $tTxt = "start /wait /high """ & $aSteamCMDDir & "\steamcmd.exe ^" & @CRLF & "+login anonymous ^" & @CRLF & "+force_install_dir """ & $aServerDirLocal & """ ^" & @CRLF & "+app_update " & $aSteamAppID & " validate ^" & @CRLF & "+quit"
EndIf
If $aExecuteExternalScript = "yes" Then
Local $sFileExists = FileExists($aExternalScriptDir & "\" & $aExternalScriptName)
If $sFileExists = 0 Then
SplashOff()
Local $ExtScriptNotFound = MsgBox(4100, "External BEFORE update script not found", "Could not find " & $aExternalScriptDir & "\" & $aExternalScriptName & @CRLF & "Would you like to exit now to fix?", 20)
If $ExtScriptNotFound = 6 Then
_ExitUtil()
Else
$aExecuteExternalScript = "no"
LogWrite(" External BEFORE update script execution disabled - Could not find " & $aExternalScriptDir & "\" & $aExternalScriptName)
EndIf
EndIf
EndIf
If $aExternalScriptValidateYN = "yes" Then
Local $sFileExists = FileExists($aExternalScriptValidateDir & "\" & $aExternalScriptValidateName)
If $sFileExists = 0 Then
SplashOff()
Local $ExtScriptNotFound = MsgBox(4100, "External AFTER update script not found", "Could not find " & $aExternalScriptValidateDir & "\" & $aExternalScriptValidateName & @CRLF & "Would you like to exit now to fix?", 20)
If $ExtScriptNotFound = 6 Then
_ExitUtil()
Else
$aExternalScriptValidateYN = "no"
LogWrite(" External AFTER update script execution disabled - Could not find " & $aExternalScriptValidateDir & "\" & $aExternalScriptValidateName)
EndIf
EndIf
EndIf
If $aExternalScriptDailyYN = "yes" Then
Local $sFileExists = FileExists($aExternalScriptDailyDir & "\" & $aExternalScriptDailyFileName)
If $sFileExists = 0 Then
SplashOff()
Local $ExtScriptNotFound = MsgBox(4100, "External DAILY restart script not found", "Could not find " & $aExternalScriptDailyDir & "\" & $aExternalScriptDailyFileName & @CRLF & "Would you like to Exit Now to fix?", 20)
If $ExtScriptNotFound = 6 Then
_ExitUtil()
Else
$aExternalScriptDailyYN = "no"
LogWrite(" External DAILY restart script execution disabled - Could not find " & $aExternalScriptDailyDir & "\" & $aExternalScriptDailyFileName)
EndIf
EndIf
EndIf
If $aExternalScriptUpdateYN = "yes" Then
Local $sFileExists = FileExists($aExternalScriptUpdateDir & "\" & $aExternalScriptUpdateFileName)
If $sFileExists = 0 Then
SplashOff()
Local $ExtScriptNotFound = MsgBox(4100, "External UPDATE restart script not found", "Could not find " & $aExternalScriptUpdateDir & "\" & $aExternalScriptUpdateFileName & @CRLF & "Would you like to Exit Now to fix?", 20)
If $ExtScriptNotFound = 6 Then
_ExitUtil()
Else
$aExternalScriptUpdateYN = "no"
LogWrite(" External UPDATE restart script execution disabled - Could not find " & $aExternalScriptUpdateDir & "\" & $aExternalScriptUpdateFileName)
EndIf
EndIf
EndIf
If $aExternalScriptAnnounceYN = "yes" Then
Local $sFileExists = FileExists($aExternalScriptAnnounceDir & "\" & $aExternalScriptAnnounceFileName)
If $sFileExists = 0 Then
SplashOff()
Local $ExtScriptNotFound = MsgBox(4100, "External FIRST RESTART ANNOUNCEMENT restart script not found", "Could not find " & $aExternalScriptAnnounceDir & "\" & $aExternalScriptAnnounceFileName & @CRLF & "Would you like to Exit Now to fix?", 20)
If $ExtScriptNotFound = 6 Then
_ExitUtil()
Else
$aExternalScriptDailyYN = "no"
LogWrite(" External FIRST RESTART ANNOUNCEMENT restart script execution disabled - Could not find " & $aExternalScriptAnnounceDir & "\" & $aExternalScriptAnnounceFileName)
EndIf
EndIf
EndIf
If $aExternalScriptRemoteYN = "yes" Then
Local $sFileExists = FileExists($aExternalScriptRemoteDir & "\" & $aExternalScriptRemoteFileName)
If $sFileExists = 0 Then
SplashOff()
Local $ExtScriptNotFound = MsgBox(4100, "External REMOTE RESTART script not found", "Could not find " & $aExternalScriptRemoteDir & "\" & $aExternalScriptRemoteFileName & @CRLF & "Would you like to Exit Now to fix?", 20)
If $ExtScriptNotFound = 6 Then
_ExitUtil()
Else
$aExternalScriptDailyYN = "no"
LogWrite(" External REMOTE RESTART script execution disabled - Could not find " & $aExternalScriptRemoteDir & "\" & $aExternalScriptRemoteFileName)
EndIf
EndIf
EndIf
If $aExternalScriptModYN = "yes" Then
Local $sFileExists = FileExists($aExternalScriptModDir & "\" & $aExternalScriptModFileName)
If $sFileExists = 0 Then
SplashOff()
Local $ExtScriptNotFound = MsgBox(4100, "External MOD UPDATE restart script not found", "Could not find " & $aExternalScriptModDir & "\" & $aExternalScriptModFileName & @CRLF & "Would you like to Exit Now to fix?", 20)
If $ExtScriptNotFound = 6 Then
_ExitUtil()
Else
$aExternalScriptModYN = "no"
LogWrite(" External MOD UPDATE restart script execution disabled - Could not find " & $aExternalScriptModDir & "\" & $aExternalScriptModFileName)
EndIf
EndIf
EndIf
For $i = 0 To ($aEventCount - 1)
If $xEventFile[$i] <> "" Then
Local $sFileExists = FileExists($xEventFile[$i])
If $sFileExists = 0 Then
SplashOff()
$xEventFile[$i] = FileOpenDialog("WARNING!!! Scheduled File " & $i & " to Execute not found", @ScriptDir, "All (*.*)", 3, "ScheduledFile" & $i & ".bat")
IniWrite($aIniFile, " --------------- SCHEDULED EVENT OR RCON COMMAND " & ($i + 1) & " --------------- ", ($i + 1) & "-File to Execute (leave BLANK to skip) ###", $xEventFile[$i])
Global $aSplashStartUp = _Splash($aStartText, 0, 475, 110)
F_ExitCloseN(True)
EndIf
EndIf
Next
EndFunc
#Region
Func DailyRestartOffset($bHour0, $sMin, $sTime)
If $bRestartMin - $sTime < 0 Then
Local $tDay = ""
Local $bHour1 = -1
Local $bHour2 = ""
Local $bHour3 = StringSplit($bHour0, ",")
For $bRestartHours = 1 To $bHour3[0]
$bHour1 = StringStripWS($bHour3[$bRestartHours], 8) - 1
If Int($bHour1) = -1 Then
$bHour1 = 23
If $aRestartDays <> "0" Then
Local $tDays = StringSplit($aRestartDays, ",")
For $i = 1 To (UBound($tDays) - 1)
If $tDays[$i] = 1 Then
$tDays[$i] = 7
Else
$tDays[$i] = $tDays[$i] - 1
EndIf
$tDay = $tDay & "," & Int($tDays[$i])
Next
$aRestartDays = StringTrimLeft($tDay, 1)
EndIf
EndIf
$bHour2 = $bHour2 & "," & Int($bHour1)
Next
Global $aRestartMin = 60 - $sTime + $bRestartMin
Global $aRestartHours = StringTrimLeft($bHour2, 1)
Else
Global $aRestartMin = $bRestartMin - $sTime
Global $aRestartHours = $bRestartHours
EndIf
EndFunc
Func _DateChange($tType, $tDiff, $tDateBefore)
If $tDateBefore[0] = "" Then
If $tDateBefore[1] = "" Then $tDateBefore[1] = @YEAR
If $tDateBefore[2] = "" Then $tDateBefore[2] = @MON
If $tDateBefore[3] = "" Then $tDateBefore[3] = @MDAY
If $tDateBefore[4] = "" Then $tDateBefore[4] = @HOUR
If $tDateBefore[5] = "" Then $tDateBefore[5] = @MIN
If $tDateBefore[6] = "" Then $tDateBefore[6] = "00"
Local $tTime1 = $tDateBefore[1] & "/" & $tDateBefore[2] & "/" & $tDateBefore[3] & " " & $tDateBefore[4] & ":" & $tDateBefore[5] & ":" & $tDateBefore[6]
Else
$tTime1 = $tDate[0]
EndIf
Local $tTime2 = _DateAdd($tType, $tDiff, $tTime1)
Local $tDateAfter[7]
$tDateAfter[0] = $tTime2
$tDateAfter[1] = StringLeft($tTime2, 4)
$tDateAfter[2] = StringMid($tTime2, 6, 2)
$tDateAfter[3] = StringMid($tTime2, 9, 2)
$tDateAfter[4] = StringMid($tTime2, 12, 2)
$tDateAfter[5] = StringMid($tTime2, 15, 2)
$tDateAfter[6] = StringMid($tTime2, 18, 2)
Return $tDateAfter
EndFunc
#Region
Func AnnounceReplaceTime($tTime0 = 0, $tMsg0 = 0, $tZero = False)
If $tZero Then
If StringInStr($tMsg0, "\m") = "0" Then
Else
$tMsg1 = StringReplace($tMsg0, "\m", "0")
Return $tMsg1
EndIf
Else
If StringInStr($tMsg0, "\m") = "0" Then
Else
Local $tTime2 = -1
Local $tTime3 = StringSplit($tTime0, ",")
Local $tMsg1 = $tTime3
For $tTime2 = 1 To $tTime3[0]
$tTime1 = StringStripWS($tTime3[$tTime2], 8) - 1
$tMsg1[$tTime2] = StringReplace($tMsg0, "\m", $tTime3[$tTime2])
Next
Return $tMsg1
EndIf
EndIf
EndFunc
#EndRegion
#Region
Func AnnounceReplaceModID($tMsg0, $tTime0, $tMsg)
If $aFirstModBoot Then
Return $tMsg0
Else
Local $tTime2 = -1
Local $tTime3 = StringSplit($tTime0, ",")
Local $tMsg1 = $tTime3
For $tTime2 = 1 To $tTime3[0]
$tMsg1[$tTime2] = StringReplace($tMsg0[$tTime2], "\x", $tMsg)
Next
Return $tMsg1
EndIf
EndFunc
#EndRegion
#Region
Func RemoveInvalidCharacters($aString)
Local $bString = StringRegExpReplace($aString, "[\x3D\x22\x3B\x3C\x3E\x3F\x25\x27\x7C]", "")
If $aString = $bString Then
Else
LogWrite(" [ERROR] Invalid character found in " & $aIniFile & ". Changed parameter from """ & $aString & """ to """ & $bString & """.")
EndIf
Return $bString
EndFunc
#EndRegion
Func RemoveCommas($aString)
Return StringRegExpReplace($aString, ",", "")
EndFunc
#Region
Func RemoveTrailingSlash($aString)
Local $bString = StringRight($aString, 1)
If $bString = "\" Then
$aString = StringTrimRight($aString, 1)
EndIf
Return $aString
EndFunc
#EndRegion
Func RemoveTrailingSlashT($aString)
Local $bString = StringRight($aString, 2)
If $bString = "\t" Then
$cString = StringTrimRight($aString, 2)
Else
$cString = $aString
EndIf
Return $cString
EndFunc
Func RemoveTrailingComma($aString)
Local $bString = StringRight($aString, 1)
If $bString = "," Then
$cString = StringTrimRight($aString, 1)
Else
$cString = $aString
EndIf
Return $cString
EndFunc
Func RemoveShooterGame($aString)
Local $bString = StringRight($aString, 12)
If $bString = "\ShooterGame" Then
$cString = StringTrimRight($aString, 12)
Else
$cString = $aString
EndIf
Return $cString
EndFunc
Func CloseTCP($tIP = $aRemoteRestartIP, $tPort = $aRemoteRestartPort, $tSplash = 0)
Local $tTxt = "Shutting down Remote Restart." & @CRLF & @CRLF
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
If $aRemoteRestartUse = "yes" Then
TCPShutdown()
Sleep(250)
For $iX = 1 To 6
$socket = TCPConnect($tIP, $tPort)
If $socket <> -1 Then
TCPShutdown()
ControlSetText($tSplash, "", "Static1", $tTxt & "Coundown:  " & (6 - $iX))
Else
ExitLoop
EndIf
Sleep(500)
Next
EndIf
If $tSplash = 0 Then
SplashOff()
EndIf
EndFunc
#Region
Func PassCheck($sPass, $sPassString)
Local $aPassReturn[3] = [False, "", ""]
Local $aPasswords = StringSplit($sPassString, ",")
For $i = 1 To $aPasswords[0]
If (StringCompare($sPass, $aPasswords[$i], 1) = 0) Then
Local $aUserPass = StringSplit($aPasswords[$i], "_")
If $aUserPass[0] > 1 Then
$aPassReturn[0] = True
$aPassReturn[1] = $aUserPass[1]
$aPassReturn[2] = $aUserPass[2]
Else
$aPassReturn[0] = True
$aPassReturn[1] = "Anonymous"
$aPassReturn[2] = $aUserPass[1]
EndIf
ExitLoop
EndIf
Next
Return $aPassReturn
EndFunc
Func ObfPass($sObfPassString)
Local $sObfPass = ""
For $i = 1 To (StringLen($sObfPassString) - 3)
If $i <> 4 Then
$sObfPass = $sObfPass & "*"
Else
$sObfPass = $sObfPass & StringMid($sObfPassString, 4, 4)
EndIf
Next
Return $sObfPass
EndFunc
Func _TCP_Server_ClientIP($hSocket)
Local $pSocketAddress, $aReturn
$pSocketAddress = DllStructCreate("short;ushort;uint;char[8]")
$aReturn = DllCall("ws2_32.dll", "int", "getpeername", "int", $hSocket, "ptr", DllStructGetPtr($pSocketAddress), "int*", DllStructGetSize($pSocketAddress))
If @error Or $aReturn[0] <> 0 Then Return $hSocket
$aReturn = DllCall("ws2_32.dll", "str", "inet_ntoa", "int", DllStructGetData($pSocketAddress, 3))
If @error Then Return $hSocket
$pSocketAddress = 0
Return $aReturn[0]
EndFunc
Func CheckHTTPReq($sRequest, $sKey = "restart")
If IsString($sRequest) Then
Local $aRequest = StringRegExp($sRequest, '^GET[[:blank:]]\/\?(?i)' & $sKey & '(?-i)=(\S+)[[:blank:]]HTTP\/\d.\d\R', 2)
If Not @error Then
Return SetError(0, 0, $aRequest[1])
ElseIf @error = 1 Then
Return SetError(1, @extended, "Invalid Request")
ElseIf @error = 2 Then
Return SetError(2, @extended, "Bad pattern, array is invalid. @extended = offset of error in pattern.")
EndIf
Else
Return SetError(3, 0, "Not A String")
EndIf
EndFunc
Func MultipleAttempts($sRemoteIP, $bFailure = False, $bSuccess = False)
Local $aPassFailure[1][3] = [[0, 0, 0]]
For $i = 1 To UBound($aPassFailure, 1) - 1
If StringCompare($aPassFailure[$i][0], $sRemoteIP) = 0 Then
If (_DateDiff('n', $aPassFailure[$i][2], _NowCalc()) >= 10) Or $bSuccess Then
$aPassFailure[$i][1] = 0
$aPassFailure[$i][2] = _NowCalc()
Return SetError(0, 0, "Maximum Attempts Reset")
ElseIf $bFailure Then
$aPassFailure[$i][1] += 1
$aPassFailure[$i][2] = _NowCalc()
EndIf
If $aPassFailure[$i][1] >= 15 Then
Return SetError(1, $aPassFailure[$i][1], "Maximum Number of Attempts Exceeded. Wait 10 minutes before trying again.")
Else
Return SetError(0, $aPassFailure[$i][1], $aPassFailure[$i][1] & " attempts out of 15 used.")
EndIf
ExitLoop
EndIf
Next
ReDim $aPassFailure[(UBound($aPassFailure, 1) + 1)][3]
$aPassFailure[(UBound($aPassFailure, 1) - 1)][0] = $sRemoteIP
$aPassFailure[(UBound($aPassFailure, 1) - 1)][1] = 0
$aPassFailure[(UBound($aPassFailure, 1) - 1)][2] = _NowCalc()
Return SetError(0, 0, "IP Added to List")
EndFunc
Func _RemoteRestart($vMSocket, $sCodes, $sKey, $sHideCodes, $sServIP, $sName, $bDebug = True)
Local $vConnectedSocket = TCPAccept($vMSocket)
If $vConnectedSocket >= 0 Then
Local $sRecvIP = _TCP_Server_ClientIP($vConnectedSocket)
Local $sRECV = TCPRecv($vConnectedSocket, 512)
Local $iError = 0
Local $iExtended = 0
If @error = 0 Then
Local $aRemoteRCONTF = RemoteRCON($sRECV, $aServerAdminPass, $vConnectedSocket, $sServIP, $sName)
If $aRemoteRCONTF Then
Local $sRecvPass = CheckHTTPReq($sRECV, $sKey)
If @error = 0 Then
Local $sCheckMaxAttempts = MultipleAttempts($sRecvIP)
If @error = 1 Then
TCPSend($vConnectedSocket, "HTTP/1.1 429 Too Many Requests" & @CRLF & "Retry-After: 600" & @CRLF & "Connection: close" & @CRLF & "Content-Type: text/html; charset=iso-8859-1" & @CRLF & "Cache-Control: no-cache" & @CRLF & "Server: " & $sServIP & @CRLF & @CRLF)
TCPSend($vConnectedSocket, "<!DOCTYPE HTML><html><head><link rel='icon' href='data:;base64,iVBORw0KGgo='><title>" & $sName & " Remote Restart</title></head><body><h1>429 Too Many Requests</h1><p>You tried to Restart " & $sName & " 15 times in a row.<BR>" & $sCheckMaxAttempts & "</body></html>")
If $vConnectedSocket <> -1 Then TCPCloseSocket($vConnectedSocket)
Return SetError(1, 0, "[Remote Restart] Restart ATTEMPT by Remote Host: " & $sRecvIP & " | Wrong Code was entered 15 times. User must wait 10 minutes before trying again.")
EndIf
Local $aPassCompare = PassCheck($sRecvPass, $sCodes)
If $sHideCodes = "yes" Then
$aPassCompare[2] = ObfPass($aPassCompare[2])
EndIf
If $aPassCompare[0] Then
TCPSend($vConnectedSocket, "HTTP/1.1 200 OK" & @CRLF & "Connection: close" & @CRLF & "Content-Type: text/html; charset=iso-8859-1" & @CRLF & "Cache-Control: no-cache" & @CRLF & "Server: " & $sServIP & @CRLF & @CRLF)
TCPSend($vConnectedSocket, "<!DOCTYPE HTML><html><head><link rel='icon' href='data:;base64,iVBORw0KGgo='><title>" & $sName & " Remote Restart</title></head><body><h1>Authentication Accepted. " & $sName & " Restarting.</h1></body></html>")
If $vConnectedSocket <> -1 Then TCPCloseSocket($vConnectedSocket)
$sCheckMaxAttempts = MultipleAttempts($sRecvIP, False, True)
Return SetError(0, 0, "[Remote Restart] Restart Requested by Remote Host: " & $sRecvIP & " | User: " & $aPassCompare[1] & " | Pass: " & $aPassCompare[2])
Else
TCPSend($vConnectedSocket, "HTTP/1.1 403 Forbidden" & @CRLF & "Connection: close" & @CRLF & "Content-Type: text/html; charset=iso-8859-1" & @CRLF & "Cache-Control: no-cache" & @CRLF & "Server: " & $sServIP & @CRLF & @CRLF)
TCPSend($vConnectedSocket, "<!DOCTYPE HTML><html><head><link rel='icon' href='data:;base64,iVBORw0KGgo='><title>" & $sName & " Remote Restart</title></head><body><h1>403 Forbidden</h1><p>You are not allowed to restart " & $sName & ".<BR> Attempt from <b>" & $sRecvIP & "</b> has been logged.</body></html>")
If $vConnectedSocket <> -1 Then TCPCloseSocket($vConnectedSocket)
$sCheckMaxAttempts = MultipleAttempts($sRecvIP, True, False)
Return SetError(1, 0, "[Remote Restart] Restart ATTEMPT by Remote Host: " & $sRecvIP & " | Unknown Restart Code: " & $sRecvPass)
EndIf
Else
$iError = @error
$iExtended = @extended
TCPSend($vConnectedSocket, "HTTP/1.1 404 Not Found" & @CRLF & "Connection: close" & @CRLF & "Content-Type: text/html; charset=iso-8859-1" & @CRLF & "Cache-Control: no-cache" & @CRLF & "Server: " & $sServIP & @CRLF & @CRLF)
TCPSend($vConnectedSocket, "<!DOCTYPE HTML><html><head><link rel='icon' href='data:;base64,iVBORw0KGgo='><title>404 Not Found</title></head><body><h1>404 Not Found.</h1></body></html>")
If $vConnectedSocket <> -1 Then TCPCloseSocket($vConnectedSocket)
If $iError = 1 Then
$sRECV = "Full TCP Request: " & @CRLF & $sRECV
Return SetError(2, 0, "[Remote Restart] IGNORE THIS MESSAGE: Invalid Restart Request by: " & $sRecvIP & ". Should be in the format of GET /?" & $sKey & "=user_pass HTTP/x.x | " & $sRECV)
Else
$tTxt = StringRegExpReplace("[Remote Restart] CheckHTTPReq Failed with Error: " & $iError & " Extended: " & $iExtended & " [" & $sRecvPass & "] CHECK REMOTE RESTART PORT: Make sure it isn't being used as an RCON port for a server)", @CRLF, "")
Return SetError(3, 0, $tTxt)
EndIf
EndIf
Else
TCPSend($vConnectedSocket, "HTTP/1.1 200 OK" & @CRLF & "Connection: close" & @CRLF & "Content-Type: text/html; charset=iso-8859-1" & @CRLF & "Cache-Control: no-cache" & @CRLF & "Server: " & $sServIP & @CRLF & @CRLF)
TCPSend($vConnectedSocket, "<!DOCTYPE HTML><html><head><link rel='icon' href='data:;base64,iVBORw0KGgo='><title>" & $sName & " Remote Restart</title></head><body><h1>RCON command being sent to all servers: [" & $zCMD[2] & "].</h1></body></html>")
If $vConnectedSocket <> -1 Then TCPCloseSocket($vConnectedSocket)
$sCheckMaxAttempts = MultipleAttempts($sRecvIP, False, True)
EndIf
Else
$iError = @error
$iExtended = @extended
TCPSend($vConnectedSocket, "HTTP/1.1 400 Bad Request" & @CRLF & "Connection: close" & @CRLF & "Content-Type: text/html; charset=iso-8859-1" & @CRLF & "Cache-Control: no-cache" & @CRLF & "Server: " & $sServIP & @CRLF & @CRLF)
TCPSend($vConnectedSocket, "<!DOCTYPE HTML><html><head><link rel='icon' href='data:;base64,iVBORw0KGgo='><title>400 Bad Request</title></head><body><h1>400 Bad Request.</h1></body></html>")
If $vConnectedSocket <> -1 Then TCPCloseSocket($vConnectedSocket)
Return SetError(4, 0, "[Remote Restart] TCPRecv Failed to Complete with Error: " & $iError & " Extended: " & $iExtended)
EndIf
EndIf
Return SetError(-1, 0, "No Connection")
If $vConnectedSocket <> -1 Then TCPCloseSocket($vConnectedSocket)
EndFunc
#EndRegion
Func RotateFile($sFile, $sBackupQty, $bDelOrig = True)
Local $hCreateTime = @YEAR & @MON & @MDAY
For $i = $sBackupQty To 1 Step -1
If FileExists($sFile & $i) Then
$hCreateTime = FileGetTime($sFile & $i, 1)
FileMove($sFile & $i, $sFile & ($i + 1), 1)
FileSetTime($sFile & ($i + 1), $hCreateTime, 1)
EndIf
Next
If FileExists($sFile & ($sBackupQty + 1)) Then
FileDelete($sFile & ($sBackupQty + 1))
EndIf
If FileExists($sFile) Then
If $bDelOrig = True Then
$hCreateTime = FileGetTime($sFile, 1)
FileMove($sFile, $sFile & "1", 1)
FileWriteLine($sFile, _NowCalc() & " " & $sFile & " Rotated")
FileSetTime($sFile & "1", $hCreateTime, 1)
FileSetTime($sFile, @YEAR & @MON & @MDAY, 1)
Else
FileCopy($sFile, $sFile & "1", 1)
EndIf
EndIf
EndFunc
Func RemoteRCON($tCMD, $tPWD, $vConnectedSocket, $sServIP, $sName)
Global $zCMD[2]
Local $tCMD1 = _ArrayToString(_StringBetween($tCMD, "GET /", " HTTP/"))
$zCMD = StringSplit($tCMD1, "@")
If $zCMD[0] = 2 Then
If $zCMD[1] = $tPWD Then
$zCMD[2] = ReplaceSpace($zCMD[2])
LogWrite(" [Remote RCON] Correct password received. Sending RCON command to all servers:" & $zCMD[2])
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $zCMD[2], "yes", $aRCONResponseWaitms)
EndIf
Return False
Next
Sleep(5000)
Else
Return True
EndIf
Else
Return True
EndIf
EndFunc
Func LogWrite($Msg, $msgdebug = "blank")
$aLogFile = $aFolderLog & $aUtilName & "_Log_" & @YEAR & "-" & @MON & "-" & @MDAY & ".txt"
$aLogDebugFile = $aFolderLog & $aUtilName & "_LogFull_" & @YEAR & "-" & @MON & "-" & @MDAY & ".txt"
If $Msg <> "" Then
FileWriteLine($aLogFile, _NowCalc() & $Msg)
$aGUILogWindowText = _NowTime(5) & $Msg & @CRLF & StringLeft($aGUILogWindowText, 10000)
If $aGUIReady Then GUICtrlSetData($LogTicker, $aGUILogWindowText)
EndIf
If $msgdebug <> "no" Then
If $msgdebug = "blank" Then
FileWriteLine($aLogDebugFile, _NowCalc() & $Msg)
Else
FileWriteLine($aLogDebugFile, _NowCalc() & $msgdebug)
EndIf
EndIf
EndFunc
Func PurgeLogFile($TF = True)
If $TF Then
$aPurgeLogFileName = $aFolderTemp & $aUtilName & "_PurgeLogFile.bat"
Local $sFileExists = FileExists($aPurgeLogFileName)
If $sFileExists = 1 Then
FileDelete($aPurgeLogFileName)
EndIf
FileWriteLine($aPurgeLogFileName, "for /f ""tokens=* skip=" & $aLogQuantity & """ %%F in " & Chr(40) & "'dir """ & $aFolderLog & $aUtilName & "_Log_*.txt"" /o-d /tc /b'" & Chr(41) & " do del """ & $aFolderLog & "%%F""")
FileWriteLine($aPurgeLogFileName, "for /f ""tokens=* skip=" & $aLogQuantity & """ %%F in " & Chr(40) & "'dir """ & $aFolderLog & $aUtilName & "_LogFull_*.txt"" /o-d /tc /b'" & Chr(41) & " do del """ & $aFolderLog & "%%F""")
FileWriteLine($aPurgeLogFileName, "for /f ""tokens=* skip=" & $aLogQuantity & """ %%F in " & Chr(40) & "'dir """ & $aFolderLog & $aUtilName & "_OnlineUserLog_*.txt"" /o-d /tc /b'" & Chr(41) & " do del """ & $aFolderLog & "%%F""")
LogWrite("", " Deleting log files >" & $aLogQuantity & " in folder " & $aFolderTemp)
Run($aPurgeLogFileName, "", @SW_HIDE)
EndIf
EndFunc
Func _ExtractZipAll($sZipFile, $sDestinationFolder, $sFolderStructure = "")
Local $i
Do
$i += 1
$sTempZipFolder = @TempDir & "\Temporary Directory " & $i & " for " & StringRegExpReplace($sZipFile, ".*\\", "")
Until Not FileExists($sTempZipFolder)
Local $oShell = ObjCreate("Shell.Application")
If Not IsObj($oShell) Then
Return SetError(1, 0, 0)
EndIf
Local $oDestinationFolder = $oShell.NameSpace($sDestinationFolder)
If Not IsObj($oDestinationFolder) Then
DirCreate($sDestinationFolder)
EndIf
Local $oOriginFolder = $oShell.NameSpace($sZipFile & "\" & $sFolderStructure)
If Not IsObj($oOriginFolder) Then
Return SetError(3, 0, 0)
EndIf
Local $oOriginFile = $oOriginFolder.Items()
If Not IsObj($oOriginFile) Then
Return SetError(4, 0, 0)
EndIf
$oDestinationFolder.CopyHere($oOriginFile, 20)
DirRemove($sTempZipFolder, 1)
Return 1
EndFunc
#Region
Func _ExtractZip($sZipFile, $sFolderStructure, $sFile, $sDestinationFolder)
Local $i
Do
$i += 1
$sTempZipFolder = @TempDir & "\Temporary Directory " & $i & " for " & StringRegExpReplace($sZipFile, ".*\\", "")
Until Not FileExists($sTempZipFolder)
Local $oShell = ObjCreate("Shell.Application")
If Not IsObj($oShell) Then
Return SetError(1, 0, 0)
EndIf
Local $oDestinationFolder = $oShell.NameSpace($sDestinationFolder)
If Not IsObj($oDestinationFolder) Then
Return SetError(2, 0, 0)
EndIf
Local $oOriginFolder = $oShell.NameSpace($sZipFile & "\" & $sFolderStructure)
If Not IsObj($oOriginFolder) Then
Return SetError(3, 0, 0)
EndIf
Local $oOriginFile = $oOriginFolder.ParseName($sFile)
If Not IsObj($oOriginFile) Then
Return SetError(4, 0, 0)
EndIf
$oDestinationFolder.CopyHere($oOriginFile, 4)
DirRemove($sTempZipFolder, 1)
Return 1
EndFunc
#EndRegion
Func SteamcmdDelete($sCmdDir)
LogWrite(" [Update] Deleting SteamCMD package and steampps temp folders.")
DirRemove($sCmdDir & "\package", 1)
DirRemove($sCmdDir & "\steamapps", 1)
EndFunc
#Region
Func FileExistsFunc($tSplash = 0)
_DownloadAndExtractFile("steamcmd", "https://steamcdn-a.akamaihd.net/client/installer/steamcmd.zip", "http://www.phoenix125.com/share/atlas/steamcmd.zip", $tSplash, $aSteamCMDDir)
_DownloadAndExtractFile("mcrcon", "http://www.phoenix125.com/share/atlas/mcrcon.zip", "https://github.com/phoenix125/AtlasServerUpdateUtility/releases/download/Latest/mcrcon.zip", $tSplash)
If $aServerModYN = "yes" Then _DownloadAndExtractFile("AtlasModDownloader", "http://www.phoenix125.com/share/atlas/AtlasModDownloader.zip", "https://github.com/phoenix125/Atlas-Mod-Downloader/releases/download/AtlasModDownloader/AtlasModDownloader.zip", $tSplash)
_DownloadAndExtractFile("DiscordSendWebhook", "http://www.phoenix125.com/share/atlas/DiscordSendWebhook.zip", "https://github.com/phoenix125/DiscordSendWebhook/releases/download/DiscordSendWebhook/DiscordSendWebhook.zip", $tSplash)
_DownloadAndExtractFile("NetworkConnectionsViewer", "http://www.phoenix125.com/share/atlas/NetworkConnectionsViewer.zip", "https://github.com/phoenix125/NetworkConnectionsViewer/releases/download/LatestVersion/NetworkConnectionsViewer.zip", $tSplash)
If $aUseKeepAliveYN = "yes" Then _DownloadAndExtractFile($aKeepAliveFileName, "http://www.phoenix125.com/share/atlas/" & $aKeepAliveFileZip, "https://github.com/phoenix125/AtlasServerUpdateUtilityKeepAlive/releases/download/LatestVersion/" & $aKeepAliveFileZip, $tSplash)
_DownloadAndExtractFile("wget", "http://www.phoenix125.com/share/atlas/wget.zip", "https://github.com/phoenix125/AtlasServerUpdateUtility/releases/download/Latest/wget.zip", $tSplash, $aFolderTemp)
_DownloadAndExtractFile("7z", "http://www.phoenix125.com/share/atlas/7z.zip", "https://github.com/phoenix125/AtlasServerUpdateUtility/releases/download/Latest/7z.zip", $tSplash, $aFolderTemp, "7z.dll")
EndFunc
#EndRegion
Func _DownloadAndExtractFile($tFileName, $tURL1, $tURL2 = "", $tSplash = 0, $tFolder = @ScriptDir, $tFile2 = 0, $tFile3 = 0, $tFile4 = 0, $tFile5 = 0)
$tFolder = RemoveTrailingSlash($tFolder)
If FileExists($tFolder & "\" & $tFileName & ".exe") = 0 Then
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $aStartText & "Downloading " & $tFileName & ".exe.")
Else
_Splash($aStartText & "Downloading " & $tFileName & ".exe.", 0, 475)
EndIf
DirCreate($tFolder)
InetGet($tURL1, $tFolder & "\" & $tFileName & ".zip", 1)
If Not FileExists($tFolder & "\" & $tFileName & ".zip") Then
SetError(1, 1)
LogWrite(" [Util] Error downloading " & $tFileName & " from Source1: " & $tURL1)
InetGet($tURL2, $tFolder & "\" & $tFileName & ".zip", 1)
If Not FileExists($tFolder & "\" & $tFileName & ".zip") Then
SetError(1, 2)
LogWrite(" [Util] Error downloading " & $tFileName & " from Source2: " & $tURL2)
SplashOff()
MsgBox($MB_OK, $aUtilName, "ERROR!!!  " & $tFileName & ".zip download failed.")
$aSplashStartUp = _Splash($aStartText, 0, 475)
Return
EndIf
EndIf
DirCreate($tFolder)
_ExtractZip($tFolder & "\" & $tFileName & ".zip", "", $tFileName & ".exe", $tFolder)
If $tFile2 <> 0 Then _ExtractZip($tFolder & "\" & $tFileName & ".zip", "", $tFile2, $tFolder)
If $tFile3 <> 0 Then _ExtractZip($tFolder & "\" & $tFileName & ".zip", "", $tFile3, $tFolder)
If $tFile4 <> 0 Then _ExtractZip($tFolder & "\" & $tFileName & ".zip", "", $tFile4, $tFolder)
If $tFile5 <> 0 Then _ExtractZip($tFolder & "\" & $tFileName & ".zip", "", $tFile5, $tFolder)
If FileExists($tFolder & "\" & $tFileName & ".exe") Then
LogWrite(" [Util] Downloaded and installed " & $tFileName & ".")
Else
LogWrite(" [Util] Error extracting " & $tFileName & ".exe from " & $tFileName & ".zip")
SetError(1, 3)
SplashOff()
MsgBox($MB_OK, $aUtilName, "ERROR!!! Extracting " & $tFileName & ".exe from " & $tFileName & ".zip failed.")
$aSplashStartUp = _Splash($aStartText, 0, 475)
Return
EndIf
FileDelete($tFolder & "\" & $tFileName & ".zip")
EndIf
EndFunc
#Region
Func CheckMod($sMods, $sSteamCmdDir, $sServerDir, $tSplash = 0, $tShow = False)
Local $xError = False
Local $tTxt = $aStartText & "Checking for mod updates"
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Global $aSplashMod = $tSplash
Else
If $tShow Then
Global $aSplashMod = _Splash($tTxt)
EndIf
EndIf
If ($aServerModYN = "yes") Then
Local $sFileExists = FileExists(@ScriptDir & "\AtlasModDownloader.exe")
If $sFileExists = 0 Then
_Splash($aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Downloading AtlasModDownloader.exe.")
LogWrite(" Downloaded and installed AtlasModDownloader.exe")
InetGet("http://www.phoenix125.com/share/atlas/AtlasModDownloader.exe", @ScriptDir & "\AtlasModDownloader.exe", 1)
If Not FileExists(@ScriptDir & "\AtlasModDownloader.exe") Then
SplashOff()
MsgBox(0x0, "AtlasModDownloader Not Found", "Could not find AtlasModDownloader.exe at " & @ScriptDir)
_ExitUtil()
EndIf
EndIf
EndIf
Local $aMods = StringSplit($sMods, ",")
Local $tError = 0
Local $tModsUpdated = ""
For $i = 1 To $aMods[0]
$aMods[$i] = StringStripWS($aMods[$i], 8)
Local $aLatestTime = GetLatestModUpdateTime($aMods[$i], $tShow)
$aModName[$i] = $aLatestTime[3]
Local $aInstalledTime = GetInstalledModUpdateTime($sServerDir, $aMods[$i], $aModName[$i], $tShow)
If FileExists($aServerDirLocal & "\ShooterGame\Content\Mods\" & $aMods[$i] & ".mod") Or FileExists($aServerDirLocal & "\ShooterGame\Content\Mods\" & $aMods[$i] & "\" & $aMods[$i] & ".mod") Then
If Not $aLatestTime[0] Or Not $aLatestTime[1] Then
Local $aErrorMsg = "Something went wrong downloading update information for mod [" & $aMods[$i] & "] If running Windows Server, Disable ""IE Enhanced Security Configuration"" for Administrators (via Server Manager > Local Server > IE Enhanced Security Configuration)."
LogWrite(" [Mod] " & $aErrorMsg)
$xError = True
$tError = 1
SplashOff()
If $tShow Then
MsgBox($MB_OK, $aUtilityVer, $aErrorMsg, 5)
EndIf
If $tSplash > 0 Then $aSplashStartUp = _Splash($aStartText, 0, 475)
ElseIf Not $aInstalledTime[0] Then
$xError = True
$tError = 2
$bStopUpdate = UpdateMod($aMods[$i], $aModName[$i], $sSteamCmdDir, $sServerDir, $tError, $i)
$tModsUpdated &= $aMods[$i] & " " & $aModName[$i] & ", "
ElseIf Not $aInstalledTime[1] Then
$xError = True
$tError = 3
$bStopUpdate = UpdateMod($aMods[$i], $aModName[$i], $sSteamCmdDir, $sServerDir, $tError, $i)
$tModsUpdated &= $aMods[$i] & " " & $aModName[$i] & ", "
ElseIf $aInstalledTime[1] And (StringCompare($aLatestTime[2], $aInstalledTime[2]) <> 0) Then
$tError = 4
$xError = True
$bStopUpdate = UpdateMod($aMods[$i], $aModName[$i], $sSteamCmdDir, $sServerDir, $tError, $i)
$tModsUpdated &= $aMods[$i] & " " & $aModName[$i] & ", "
EndIf
Else
$xError = True
$tError = 2
$bStopUpdate = UpdateMod($aMods[$i], $aModName[$i], $sSteamCmdDir, $sServerDir, $tError, $i)
$tModsUpdated &= $aMods[$i] & " " & $aModName[$i] & ", "
EndIf
Next
If $tError > 0 Then
$tModsUpdated = StringTrimRight($tModsUpdated, 2)
$aModMsgInGame = AnnounceReplaceModID($sModMsgInGame, $sAnnounceNotifyModUpdate, $tModsUpdated)
$aModMsgDiscord = AnnounceReplaceModID($sModMsgDiscord, $sAnnounceNotifyModUpdate, $tModsUpdated)
$aModMsgTwitch = AnnounceReplaceModID($sModMsgTwitch, $sAnnounceNotifyModUpdate, $tModsUpdated)
EndIf
If ($aBeginDelayedShutdown <> 1) And ($xError = False) Then
LogWrite(" [Mod] Mods are Up to Date.")
ElseIf $tError = 1 Then
LogWrite(" [Mod] " & $aErrorMsg)
Else
$aRebootReason = "mod"
$aBeginDelayedShutdown = 1
RunExternalScriptMod()
EndIf
If $tShow And $xError Then
Local $tTxt = $aStartText & "Checking for mod updates complete."
Global $aSplashStartUp = _Splash($tTxt)
EndIf
EndFunc
Func GetLatestModUpdateTime($sMod, $sShow)
Local $aReturn[4] = [True, False, "", ""]
Local $zModName = ""
Local $sFilePath = $aFolderTemp & "mod_" & $sMod & "_latest_ver.tmp"
Local $aFDError = 1
If FileExists($sFilePath) Then
$aFDError = FileDelete($sFilePath)
If $aFDError = 0 Then
LogWrite("", " [Mod] Error!  Failed to delete mod_" & $sMod & "_latest_ver.tmp. Ignoring Internal Browser check and using Internet Explorer instead.")
Else
EndIf
Else
EndIf
LogWrite("", " [Mod] Checking for mod update via Internal Browser: http://steamcommunity.com/sharedfiles/filedetails/changelog/" & $sMod)
Local $tInet = InetGet("http://steamcommunity.com/sharedfiles/filedetails/changelog/" & $sMod, $sFilePath, 1)
$tErr = _InetGetErrorText(@error, 3)
Sleep(100)
Local $hFileOpen = FileOpen($sFilePath, 0)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
Local $aAppInfo1 = _StringBetween($sFileRead, "Update: ", "<div class=")
If _ArrayToString($aAppInfo1) = -1 Or $aFDError = 0 Then
LogWrite("", " [Mod] Checking for mod update via Internet Explorer: http://steamcommunity.com/sharedfiles/filedetails/changelog/" & $sMod)
Local $sFileRead = _INetGetSource("http://steamcommunity.com/sharedfiles/filedetails/changelog/" & $sMod)
Sleep(100)
Local $aAppInfo1 = _StringBetween($sFileRead, "Update: ", "<div class=")
If _ArrayToString($aAppInfo1) = -1 Then
LogWrite("", " [Mod] Checking for mod update via wget.exe http://steamcommunity.com/sharedfiles/filedetails/changelog/" & $sMod)
Local $tFolder = RemoveTrailingSlash($aFolderTemp)
FileDelete($tFolder & "\" & $sMod)
_DownloadAndExtractFile("wget", "http://www.phoenix125.com/share/atlas/wget.zip", "https://github.com/phoenix125/AtlasServerUpdateUtility/releases/download/Latest/wget.zip", 0, $tFolder)
Local $mOut = Run($tFolder & "\wget.exe http://steamcommunity.com/sharedfiles/filedetails/changelog/" & $sMod, $tFolder, @SW_MINIMIZE)
Local $tErr = ProcessWaitClose($mOut, 2)
If $tErr = 0 Then
LogWrite("", " [Mod] ERROR! Checking for mod update via GNU Wget.exe TIMEOUT.")
EndIf
$sFileRead = FileRead($tFolder & "\" & $sMod)
Local $aAppInfo1 = _StringBetween($sFileRead, "Update: ", "<div class=")
If _ArrayToString($aAppInfo1) = -1 Then
$aReturn[1] = False
LogWrite("", " [Mod] Failed to get latest mod version [" & $sMod & "]. Skipping this update check. " & $sMod)
Else
Local $aAppInfo2 = $aAppInfo1[0]
Local $aAppInfo3 = _ArrayToString(_StringBetween($aAppInfo2, "<p id=""", """"))
$aReturn[1] = True
$aReturn[2] = $aAppInfo3
EndIf
Else
Local $aAppInfo2 = $aAppInfo1[0]
Local $aAppInfo3 = _ArrayToString(_StringBetween($aAppInfo2, "<p id=""", """"))
$aReturn[1] = True
$aReturn[2] = $aAppInfo3
EndIf
Else
Local $aAppInfo2 = $aAppInfo1[0]
Local $aAppInfo3 = _ArrayToString(_StringBetween($aAppInfo2, "<p id=""", """"))
$aReturn[1] = True
$aReturn[2] = $aAppInfo3
EndIf
Local $zModName = _ArrayToString(_StringBetween($sFileRead, "<title>Steam Community :: ", " :: Change Notes</title>"))
$aReturn[3] = $zModName
If $sShow Then
ControlSetText($aSplashMod, "", "Static1", $aStartText & "Checking for mod " & $sMod & @CRLF & $zModName & " update or new mod.")
EndIf
Return $aReturn
EndFunc
Func _InetGetErrorText($iErrorCode, $iInfoLevel = 1)
Local $sErrMsg, $sErrDesc
Switch $iErrorCode
Case 0
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_SUCCESS"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Action completed successfully."
Case 12001
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_OUT_OF_HANDLES"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "No more handles could be generated at this time."
Case 12002
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_TIMEOUT"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request has timed out."
Case 12003
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_EXTENDED_ERROR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "An extended error was returned from the server [may be 'file not found']. This is typically a string or buffer containing a verbose error message. Call InternetGetLastResponseInfo to retrieve the error text."
Case 12004
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INTERNAL_ERROR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "An internal error has occurred."
Case 12005
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INVALID_URL"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The URL is invalid."
Case 12006
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_UNRECOGNIZED_SCHEME"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The URL scheme could not be recognized or is not supported."
Case 12007
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_NAME_NOT_RESOLVED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The server name could not be resolved."
Case 12008
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_PROTOCOL_NOT_FOUND"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested protocol could not be located."
Case 12009
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INVALID_OPTION"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "A request to InternetQueryOption or InternetSetOption specified an invalid option value."
Case 12010
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_BAD_OPTION_LENGTH"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The length of an option supplied to InternetQueryOption or InternetSetOption is incorrect for the type of option specified."
Case 12011
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_OPTION_NOT_SETTABLE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request option cannot be set, only queried."
Case 12012
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_SHUTDOWN"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The Win32 Internet function support is being shut down or unloaded."
Case 12013
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INCORRECT_USER_NAME"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request to connect and log on to an FTP server could not be completed because the supplied user name is incorrect."
Case 12014
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INCORRECT_PASSWORD"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request to connect and log on to an FTP server could not be completed because the supplied password is incorrect."
Case 12015
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_LOGIN_FAILURE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request to connect to and log on to an FTP server failed."
Case 12016
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INVALID_OPERATION"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested operation is invalid."
Case 12017
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_OPERATION_CANCELLED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The operation was canceled, usually because the handle on which the request was operating was closed before the operation completed."
Case 12018
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INCORRECT_HANDLE_TYPE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The type of handle supplied is incorrect for this operation."
Case 12019
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INCORRECT_HANDLE_STATE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested operation cannot be carried out because the handle supplied is not in the correct state."
Case 12020
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_NOT_PROXY_REQUEST"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request cannot be made via a proxy."
Case 12021
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_REGISTRY_VALUE_NOT_FOUND"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "A required registry value could not be located."
Case 12022
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_BAD_REGISTRY_PARAMETER"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "A required registry value was located but is an incorrect type or has an invalid value."
Case 12023
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_NO_DIRECT_ACCESS"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Direct network access cannot be made at this time."
Case 12024
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_NO_CONTEXT"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "An asynchronous request could not be made because a zero context value was supplied."
Case 12025
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_NO_CALLBACK"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "An asynchronous request could not be made because a callback function has not been set."
Case 12026
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_REQUEST_PENDING"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The required operation could not be completed because one or more requests are pending."
Case 12027
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INCORRECT_FORMAT"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The format of the request is invalid."
Case 12028
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_ITEM_NOT_FOUND"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested item could not be located."
Case 12029
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_CANNOT_CONNECT"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The attempt to connect to the server failed."
Case 12030
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_CONNECTION_ABORTED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The connection with the server has been terminated."
Case 12031
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_CONNECTION_RESET"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The connection with the server has been reset."
Case 12032
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_FORCE_RETRY"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Calls for the Win32 Internet function to redo the request."
Case 12033
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_INVALID_PROXY_REQUEST"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request to the proxy was invalid."
Case 12034
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_NEED_UI"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "A user interface or other blocking operation has been requested."
Case 12036
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_HANDLE_EXISTS"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request failed because the handle already exists."
Case 12037
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_SEC_CERT_DATE_INVALID"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "SSL certificate date that was received from the server is bad. The certificate is expired."
Case 12038
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_SEC_CERT_CN_INVALID"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "SSL certificate common name (host name field) is incorrect. For example, if you entered www.server.com and the common name on the certificate says www.different.com."
Case 12039
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_HTTP_TO_HTTPS_ON_REDIR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The application is moving from a non-SSL to an SSL connection because of a redirect."
Case 12040
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_HTTPS_TO_HTTP_ON_REDIR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The application is moving from an SSL to an non-SSL connection because of a redirect."
Case 12041
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_MIXED_SECURITY"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Indicates that the content is not entirely secure. Some of the content being viewed may have come from unsecured servers."
Case 12042
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_CHG_POST_IS_NON_SECURE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The application is posting and attempting to change multiple lines of text on a server that is not secure."
Case 12043
If BitAND($iInfoLevel, 1) Then $sErrMsg = "INTERNET_POST_IS_NON_SECURE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The application is posting data to a server that is not secure."
Case 12044
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The server is requesting client authentication."
Case 12045
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_INVALID_CA"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The function is unfamiliar with the Certificate Authority that generated the server's certificate."
Case 12046
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Client authorization is not set up on this computer."
Case 12047
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_ASYNC_THREAD_FAILED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The application could not start an asynchronous thread."
Case 12048
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_REDIRECT_SCHEME_CHANGE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The function could not handle the redirection, because the scheme changed (for example, HTTP to FTP)."
Case 12049
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_DIALOG_PENDING"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Another thread has a password dialog box in progress."
Case 12050
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_RETRY_DIALOG"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The dialog box should be retried."
Case 12052
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The data being submitted to an SSL connection is being redirected to a non-SSL connection."
Case 12053
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_INSERT_CDROM"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request requires a CD-ROM to be inserted in the CD-ROM drive to locate the resource requested."
Case 12054
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested resource requires Fortezza authentication."
Case 12055
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_SEC_CERT_ERRORS"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The SSL certificate contains errors."
Case 12056
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_SEC_CERT_NO_REV"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The SSL certificate was not revoked."
Case 12057
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_SEC_CERT_REV_FAILED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Revocation of the SSL certificate failed."
Case 12110
If BitAND($iInfoLevel, 1) Then $sErrMsg = "FTP_TRANSFER_IN_PROGRESS"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested operation cannot be made on the FTP session handle because an operation is already in progress."
Case 12111
If BitAND($iInfoLevel, 1) Then $sErrMsg = "FTP_DROPPED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The FTP operation was not completed because the session was aborted."
Case 12130
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_PROTOCOL_ERROR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "An error was detected while parsing data returned from the gopher server."
Case 12131
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_NOT_FILE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request must be made for a file locator."
Case 12132
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_DATA_ERROR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "An error was detected while receiving data from the gopher server."
Case 12133
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_END_OF_DATA"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The end of the data has been reached."
Case 12134
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_INVALID_LOCATOR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The supplied locator is not valid."
Case 12135
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_INCORRECT_LOCATOR_TYPE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The type of the locator is not correct for this operation."
Case 12136
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_NOT_GOPHER_PLUS"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested operation can only be made against a Gopher+ server or with a locator that specifies a Gopher+ operation."
Case 12137
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_ATTRIBUTE_NOT_FOUND"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested attribute could not be located."
Case 12138
If BitAND($iInfoLevel, 1) Then $sErrMsg = "GOPHER_UNKNOWN_LOCATOR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The locator type is unknown."
Case 12150
If BitAND($iInfoLevel, 1) Then $sErrMsg = "HTTP_HEADER_NOT_FOUND"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The requested header could not be located."
Case 12151
If BitAND($iInfoLevel, 1) Then $sErrMsg = "HTTP_DOWNLEVEL_SERVER"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The server did not return any headers."
Case 12152
If BitAND($iInfoLevel, 1) Then $sErrMsg = "HTTP_INVALID_SERVER_RESPONSE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The server response could not be parsed."
Case 12153
If BitAND($iInfoLevel, 1) Then $sErrMsg = "HTTP_INVALID_HEADER"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The supplied header is invalid."
Case 12154
If BitAND($iInfoLevel, 1) Then $sErrMsg = "HTTP_INVALID_QUERY_REQUEST"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The request made to HttpQueryInfo is invalid."
Case 12155
If BitAND($iInfoLevel, 1) Then $sErrMsg = "HTTP_HEADER_ALREADY_EXISTS"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The header could not be added because it already exists."
Case 12156
If BitAND($iInfoLevel, 1) Then $sErrMsg = "HTTP_REDIRECT_FAILED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The redirection failed because either the scheme changed (for example, HTTP to FTP) or all attempts made to redirect failed (default is five attempts)."
Case 12157
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_SECURITY_CHANNEL_ERROR"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The application experienced an internal error loading the SSL libraries."
Case 12158
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_UNABLE_TO_CACHE_FILE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The function was unable to cache the file."
Case 12159
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_TCPIP_NOT_INSTALLED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The required protocol stack is not loaded and the application cannot start WinSock."
Case 12160
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_HTTP_NOT_REDIRECTED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The HTTP request was not redirected."
Case 12161
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The HTTP cookie requires confirmation."
Case 12162
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_HTTP_COOKIE_DECLINED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The HTTP cookie was declined by the server."
Case 12163
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_DISCONNECTED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The Internet connection has been lost."
Case 12164
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_SERVER_UNREACHABLE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The Web site or server indicated is unreachable."
Case 12165
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_PROXY_SERVER_UNREACHABLE"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The designated proxy server cannot be reached."
Case 12166
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "There was an error in the automatic proxy configuration script."
Case 12167
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The automatic proxy configuration script could not be downloaded. The INTERNET_FLAG_MUST_CACHE_REQUEST flag was set."
Case 12168
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The redirection requires user confirmation."
Case 12169
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_SEC_INVALID_CERT"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "SSL certificate is invalid."
Case 12170
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_SEC_CERT_REVOKED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "SSL certificate was revoked."
Case 12171
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_FAILED_DUETOSECURITYCHECK"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The function failed due to a security check."
Case 12172
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_NOT_INITIALIZED"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Initialization of the WinINet API has not occurred. Indicates that a higher-level function, such as InternetOpen, has not been called yet."
Case 12174
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "The MS-Logoff digest header has been returned from the Web site. This header specifically instructs the digest package to purge credentials for the associated realm. This error will only be returned if INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY has been set."
Case Else
If BitAND($iInfoLevel, 1) Then $sErrMsg = "ERROR_UNKNOWN"
If BitAND($iInfoLevel, 2) Then $sErrDesc = "Unidentified error - no description available."
EndSwitch
If $sErrMsg And $sErrDesc Then $sErrMsg &= ": "
Return $sErrMsg & $sErrDesc
EndFunc
Func GetInstalledModUpdateTime($sServerDir, $sMod, $sModName, $sShow)
Local $aReturn[3] = [False, False, ""]
If $sShow Then
ControlSetText($aSplashMod, "", "Static1", $aStartText & "Checking for mod updates" & @CRLF & $sMod & " " & $sModName)
EndIf
Local Const $sFilePath = $aFolderTemp & "mod_" & $sMod & "_appworkshop.tmp"
Local $hFileOpen = FileOpen($sFilePath, 0)
If $hFileOpen = -1 Then
$aReturn[0] = False
Else
$aReturn[0] = True
Local $sFileRead = FileRead($hFileOpen)
Local $aAppInfo = StringSplit($sFileRead, '"WorkshopItemDetails"', 1)
If UBound($aAppInfo) >= 3 Then
$aAppInfo = StringSplit($aAppInfo[2], '"' & $sMod & '"', 1)
EndIf
If UBound($aAppInfo) >= 3 Then
$aAppInfo = StringSplit($aAppInfo[2], '"timetouched', 1)
EndIf
If UBound($aAppInfo) >= 2 Then
$aAppInfo = StringSplit($aAppInfo[1], '"', 1)
EndIf
If UBound($aAppInfo) >= 9 And StringRegExp($aAppInfo[8], '^\d+$') Then
$aReturn[1] = True
$aReturn[2] = $aAppInfo[8]
EndIf
If FileExists($sFilePath) Then
FileClose($hFileOpen)
EndIf
EndIf
Return $aReturn
EndFunc
Func UpdateMod($sMod, $sModName, $sSteamCmdDir, $sServerDir, $iReason, $sModNo)
Local $bReturn = False
Local $tSplash = _Splash(" Mod " & $sMod & " " & $sModName & @CRLF & " update released or new mod." & @CRLF & "Downloading and installing mod update.", 0, 500, 140)
Local $aModScript = @ScriptDir & "\AtlasModDownloader.exe  --modids " & $sMod & " --steamcmd """ & $sSteamCmdDir & """ --workingdir """ & $sServerDir & """"
LogWrite(" [Mod] Mod " & $sMod & " " & $sModName & " update released or new mod found. Downloading and installing mod.", " [Mod] Mod " & $sMod & " " & $sModName & " update released or new mod found. Downloading and installing mod:" & $aModScript)
$Timer = TimerInit()
Local $tPID = Run($aModScript)
If $aServerModTimeoutMin > 0 Then
Do
If Not ProcessExists($tPID) Then ExitLoop
ControlSetText($tSplash, "", "Static1", " Mod " & $sMod & " " & $sModName & @CRLF & " update released or new mod." & @CRLF & @CRLF & "Downloading and installing mod update." & @CRLF & "Timeout Countdown:" & Int($aServerModTimeoutMin * 60 - (TimerDiff($Timer) / 1000)))
Sleep(950)
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
Until TimerDiff($Timer) > (60000 * $aServerModTimeoutMin)
If ProcessExists($tPID) Then
ProcessClose($tPID)
EndIf
EndIf
If FileExists($sSteamCmdDir & "\steamapps\workshop\" & $aModAppWorkshop) Then
FileMove($sSteamCmdDir & "\steamapps\workshop\" & $aModAppWorkshop, $aFolderTemp & "mod_" & $sMod & "_appworkshop.tmp", 1)
EndIf
SplashOff()
Return $bReturn
EndFunc
#EndRegion
Func _InetGetMulti($tCnt, $tFile, $tLink1, $tLink2 = "0")
FileDelete($tFile)
Local $i = 0
Local $tTmp1 = InetGet($tLink1, $tFile, $INET_FORCERELOAD, $INET_DOWNLOADBACKGROUND)
Do
Sleep(100)
$i += 1
Until InetGetInfo($tTmp1, $INET_DOWNLOADCOMPLETE) Or $i = $tCnt
InetClose($tTmp1)
If $i = $tCnt And $tLink2 <> "0" Then
$tTmp2 = InetGet($tLink2, $tFile, $INET_FORCERELOAD, $INET_DOWNLOADBACKGROUND)
Do
Sleep(100)
$i += 1
Until InetGetInfo($tTmp2, $INET_DOWNLOADCOMPLETE) Or $i = $tCnt
InetClose($tTmp2)
EndIf
Local $hFileOpen = FileOpen($tFile, 0)
Local $hFileRead = FileRead($hFileOpen)
If $hFileOpen = -1 Then
InetClose($tTmp1)
Sleep(200)
FileClose($hFileOpen)
Local $hFileRead = _INetGetSource($tLink1)
If @error Then
If $tLink2 <> "0" Then
$hFileRead = _INetGetSource($tLink2)
If @error Then
Return "Error"
Else
FileClose($hFileOpen)
FileDelete($tFile)
FileWrite($tFile, $hFileRead)
EndIf
Else
Return True
EndIf
Else
FileClose($hFileOpen)
FileDelete($tFile)
FileWrite($tFile, $hFileRead)
EndIf
Else
FileClose($hFileOpen)
EndIf
Return $hFileRead
EndFunc
#Region
Func UtilUpdate($tLink, $tDL, $tUtil, $tUtilName, $tSplash = 0, $tUpdate = "show")
SetStatusBusy("Starting Util Update.")
$tUtilUpdateAvailableTF = False
If $tUpdate = "show" Then
Local $tTxt = $aStartText & "Checking for " & $tUtilName & " updates."
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
EndIf
Local $tVer[2]
Local $sFilePath = $aFolderTemp & $aUtilName & "_latest_ver.tmp"
$iGet = _InetGetMulti(20, $sFilePath, $tLink)
If $iGet = "Error" Then
LogWrite(" [Util] " & $tUtilName & " update check failed to download latest version: " & $tLink)
If $tUpdate = "show" Then
If $aShowUpdate Then
Local $tTxt = $aStartText & $aUtilName & " update check failed." & @CRLF & "Please try again later."
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
Sleep(2000)
$aShowUpdate = False
EndIf
EndIf
Else
$tVer = StringSplit($iGet, "^", 2)
If UBound($tVer) < 2 Then Return False
Local $tTxt1 = ReplaceCRLF(ReplaceCRwithCRLF($tVer[1]))
If $tVer[0] = $tUtil Then
$tUtilUpdateAvailableTF = False
LogWrite(" [Util] " & $tUtilName & " up to date. Version: " & $tVer[0], " [Util] " & $tUtilName & " up to date. Version : " & $tVer[0] & ", Notes : " & $tTxt1)
If FileExists($aUtilUpdateFile) Then
FileDelete($aUtilUpdateFile)
EndIf
If $tUpdate = "show" Then
If $aShowUpdate Then
Local $tTxt = $aStartText & $aUtilName & " up to date . . ."
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
Sleep(2000)
$aShowUpdate = False
EndIf
EndIf
Else
$tUtilUpdateAvailableTF = True
LogWrite(" [Util] !!! New " & $aUtilName & " update available. Installed version: " & $tUtil & ", Latest version: " & $tVer[0], " [Util] New " & $aUtilName & " update available. Installed version: " & $tUtil & ", Latest version: " & $tVer[0] & ", Notes: " & $tTxt1)
FileWrite($aUtilUpdateFile, _NowCalc() & " [Util] New " & $aUtilName & " update available. Installed version: " & $tUtil & ", Latest version: " & $tVer[0] & ", Notes: " & $tTxt1)
If ($tUpdate = "show") Or ($tUpdate = "auto") Then
SplashOff()
If ($tUpdate = "Auto") And ($aUpdateAutoUtil = "yes") Then
Local $tMB = 6
Else
SetStatusBusy("Util Update. Waiting for User Input.", "Waiting for User Input")
Local $tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "New " & $aUtilName & " update available. " & @CRLF & "Installed version: " & $tUtil & @CRLF & "Latest version: " & $tVer[0] & @CRLF & @CRLF & "Notes: " & @CRLF & $tVer[1] & @CRLF & @CRLF & "Click (YES) to download update to " & @CRLF & @ScriptDir & @CRLF & "Click (NO) to stop checking for updates." & @CRLF & "Click (CANCEL) to skip this update check.", 15)
EndIf
If $tMB = 6 Then
_Splash(" Downloading latest version of " & @CRLF & $tUtilName)
Local $tZIP = @ScriptDir & "\" & $tUtilName & "_" & $tVer[0] & ".zip"
If FileExists($tZIP) Then
FileDelete($tZIP)
EndIf
If FileExists($tUtilName & "_" & $tVer[0] & ".exe") Then
FileDelete($tUtilName & "_" & $tVer[0] & ".exe")
EndIf
InetGet($tDL, $tZIP, 1)
_ExtractZip($tZIP, "", $tUtilName & "_" & $tVer[0] & ".exe", @ScriptDir)
If FileExists(@ScriptDir & "\readme.txt") Then
FileDelete(@ScriptDir & "\readme.txt")
EndIf
_ExtractZip($tZIP, "", "readme.txt", @ScriptDir)
If Not FileExists(@ScriptDir & "\" & $tUtilName & "_" & $tVer[0] & ".exe") Then
LogWrite(" [Util] ERROR! " & $tUtilName & ".exe download failed.")
SplashOff()
$tMB = MsgBox($MB_OKCANCEL, $aUtilityVer, "Utility update download failed . . . " & @CRLF & "Go to """ & $tLink & """ to download latest version." & @CRLF & @CRLF & "Click (OK), (CANCEL), or wait 60 seconds, to resume current version.", 60)
Else
SplashOff()
If ($tUpdate = "Auto") And ($aUpdateAutoUtil = "yes") Then
$tMB = MsgBox($MB_OKCANCEL, $aUtilityVer, "Auto utility update download complete. . . " & @CRLF & @CRLF & "Click (OK) to run new version or wait 60 seconds (servers will remain running) OR" & @CRLF & "Click (CANCEL) to resume current version.", 60)
If $tMB = 1 Then
ElseIf $tMB = -1 Then
$tMB = 1
ElseIf $tMB = 2 Then
EndIf
Else
$tMB = MsgBox($MB_OKCANCEL, $aUtilityVer, "Utility update download complete. . . " & @CRLF & @CRLF & "Click (OK) to run new version (servers will remain running) OR" & @CRLF & "Click (CANCEL), or wait 15 seconds, to resume current version.", 15)
EndIf
If $tMB = 1 Then
LogWrite(" [Util] Update download complete. Shutting down current version and starting new version. Initiated by User or Auto Update.")
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
PIDSaveServer($aServerPID, $aPIDServerFile)
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
IniWrite($aUtilCFGFile, "CFG", "aCFGPreviousVersionToArchive", $aUtilName & "_" & $aUtilVersion)
Run(@ScriptDir & "\" & $tUtilName & "_" & $tVer[0] & ".exe")
_ExitUtil()
Else
LogWrite(" [Util] Update download complete. Per user request, continuing to run current version. Resuming utility . . .")
_Splash("Utility update check canceled by user." & @CRLF & "Resuming utility . . .", 2000)
EndIf
EndIf
ElseIf $tMB = 7 Then
$aUpdateUtil = "0"
IniWrite($aIniFile, " --------------- " & StringUpper($aUtilName) & " MISC OPTIONS --------------- ", "Check for " & $aUtilName & " updates every __ hours (0 to disable) (0-24) ###", $aUpdateUtil)
LogWrite(" [Util] " & "Utility update check disabled. To enable update check, " & @CRLF & "change [Check for Updates ###=yes] in the .ini.")
_Splash("Utility update check disabled." & @CRLF & "To enable update check, change [Check for Updates ###=yes] in the .ini.", 5000, 500)
ElseIf $tMB = 2 Then
LogWrite(" [Util] Utility update check canceled by user. Resuming utility . . .")
_Splash("Utility update check canceled by user." & @CRLF & "Resuming utility . . .", 2000)
EndIf
EndIf
EndIf
EndIf
SetStatusIdle()
Return $tUtilUpdateAvailableTF
EndFunc
#EndRegion
Func ReplaceReturn($tMsg0)
Return StringReplace($tMsg0, "|", @CRLF)
EndFunc
Func ReplaceCRLF($tMsg0)
Return StringReplace($tMsg0, @CRLF, "|")
EndFunc
Func ReplaceSpace($tMsg0)
Return StringReplace($tMsg0, "%", Chr(32))
EndFunc
Func ReplaceCRwithCRLF($sString)
Return StringRegExpReplace($sString, '(*BSR_ANYCRLF)\R', @CRLF)
EndFunc
Func ReplaceVerticalBarCRwithSlash($sString)
Return StringReplace($sString, "|", "/")
EndFunc
Func MakeServerSummaryFile($tServerSummaryFile)
FileDelete($tServerSummaryFile)
Sleep(250)
FileWriteLine($tServerSummaryFile, _NowCalc() & @CRLF & " ------------------------- SERVER SUMMARY -------------------------" & @CRLF & @CRLF)
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "no" Then
$xStartGrid[$i] = "no "
EndIf
FileWriteLine($tServerSummaryFile, " [Server " & _ServerNamingScheme($i, $aNamingScheme) & "] Use:" & $xStartGrid[$i] & " QueryPort:" & $xServerport[$i] & ", Port:" & $xServergameport[$i] & ", SeamlessIP:" & $xServerIP[$i] & ", SeamlessDataPort:" & $xServerseamlessDataPort[$i] & ", RCON:" & $xServerRCONPort[$i + 1] & ", DIR:" & $xServerAltSaveDir[$i] & ", PID:" & $aServerPID[$i] & ", Name: " & $xServerNames[$i])
Next
Local $aWAN = _GetIP()
FileWriteLine($tServerSummaryFile, @CRLF & "            AdminPassword: " & $aServerAdminPass & @CRLF & "               MaxPlayers: " & $aServerMaxPlayers & @CRLF & "      ReservedPlayerSlots: " & $aServerReservedSlots & @CRLF & "                Multihome: " & $aServerMultiHomeIP & @CRLF & "    Server Extra Commands: " & $aServerExtraCMD & @CRLF & "  SteamCMD Extra Commands: " & $aSteamExtraCMD & @CRLF)
If $aServerModYN = "yes" Then
FileWriteLine($tServerSummaryFile, "          Mod Number List: " & $aServerModList & @CRLF & "                Mod Names: " & _ArrayToString($aModName) & @CRLF)
Else
FileWriteLine($tServerSummaryFile, "          Mod Number List: " & @CRLF & "                Mod Names: " & @CRLF)
EndIf
FileWriteLine($tServerSummaryFile, "          Local Server IP: " & @IPAddress1 & @CRLF & "                   WAN IP: " & $aWAN & @CRLF & @CRLF)
If $aRemoteRestartUse = "yes" Then
FileWriteLine($tServerSummaryFile, "Remote Restart Local Link: http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/?" & $aRemoteRestartKey & "=" & $aRemoteRestartCode & @CRLF & "  Remote Restart WAN Link: http://" & $aWAN & ":" & $aRemoteRestartPort & "/?" & $aRemoteRestartKey & "=" & $aRemoteRestartCode & @CRLF & @CRLF & "RCON Broadcast Local Link: http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@broadcast%Admin%Says%Hi" & @CRLF & "  RCON Broadcast WAN Link: http://" & $aWAN & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@broadcast%Admin%Says%Hi" & @CRLF & @CRLF & "  RCON Command Local Link: http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@[command] (no brackets)" & @CRLF & "    RCON Command WAN Link: http://" & $aWAN & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@[command] (no brackets)")
Else
FileWriteLine($tServerSummaryFile, "Remote Restart Local Link: http://" & @CRLF & "  Remote Restart WAN Link: http://" & @CRLF & @CRLF & "RCON Broadcast Local Link: http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@broadcast%Admin%Says%Hi" & @CRLF & "  RCON Broadcast WAN Link: http://" & $aWAN & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@broadcast%Admin%Says%Hi" & @CRLF & @CRLF & "  RCON Command Local Link: http://" & $aRemoteRestartIP & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@[command] (no brackets)" & @CRLF & "    RCON Command WAN Link: http://" & $aWAN & ":" & $aRemoteRestartPort & "/" & $aServerAdminPass & "@[command] (no brackets)")
EndIf
FileWriteLine($tServerSummaryFile, @CRLF & "Settings listed in the order as listed in ServerGrid.json: (if having server problems, paste the following in the appropriate section in the " & $aUtilName & ".ini file)")
Local $tRCON = "              RCON ports: "
For $i = 1 To ($aServerGridTotal - 1)
$tRCON = $tRCON & $xServerRCONPort[$i] & ","
Next
$tRCON = $tRCON & $xServerRCONPort[$aServerGridTotal]
FileWriteLine($tServerSummaryFile, $tRCON)
Local $tDIR = "              AltSaveDIR: "
For $i = 0 To ($aServerGridTotal - 2)
$tDIR = $tDIR & $xServerAltSaveDir[$i] & ","
Next
$tDIR = $tDIR & $xServerAltSaveDir[$aServerGridTotal - 1]
FileWriteLine($tServerSummaryFile, $tDIR)
LogWrite(" Created server summary file: " & $tServerSummaryFile)
EndFunc
Func _HTTP_ResponseText($Url)
$oHTTP = ObjCreate("winhttp.winhttprequest.5.1")
$oHTTP.Open("GET", $Url)
$oHTTP.SetRequestHeader("User-Agent", "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.0.10) Gecko/2009042316 Firefox/3.0.10 (.NET CLR 4.0.20506)")
$oHTTP.Send()
Return $oHTTP.ResponseText
EndFunc
Func F_ExitCloseN($tRestart = False)
LogWrite(" [" & $aServerName & "] Utility exit without server shutdown initiated by user (Exit: Do NOT Shut Down Servers).")
SplashOff()
If ($aServerUseRedis = "yes") And ($aPIDRedisreadYetTF = False) Or ($aPIDServerReadYetTF = False) Then
If $aServerUseRedis = "yes" Then
Local $aMsg = "Closing Utility. If Redis and/or Servers were running, they will remain running."
Else
Local $aMsg = "Closing Utility. If Servers were running, they will remain running."
EndIf
LogWrite(" [" & $aServerName & "] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
If $tRestart = False Then
MsgBox(0, $aUtilityVer, $aMsg, 20)
LogWrite(" [Util] " & $aUtilityVer & " Stopped by User")
Else
LogWrite(" [Util] " & $aUtilityVer & " Restarting Util")
_RestartUtil()
EndIf
_ExitUtil()
Else
If $tRestart = False Then
MsgBox(4096, $aUtilityVer, "Thank you for using " & $aUtilName & "." & @CRLF & @CRLF & "SERVERS AND REDIS ARE STILL RUNNING ! ! !" & @CRLF & @CRLF & "Please report any problems or comments to: " & @CRLF & "Discord: http://discord.gg/EU7pzPs or " & @CRLF & "Forum: http://phoenix125.createaforum.com/index.php. " & @CRLF & @CRLF & "Visit http://www.Phoenix125.com", 20)
LogWrite(" [Util] " & $aUtilityVer & " Stopped by User")
Else
LogWrite(" [Util] " & $aUtilityVer & " Restarting Util")
EndIf
PIDSaveServer($aServerPID, $aPIDServerFile)
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
CFGLastClose()
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
If $tRestart Then
_RestartUtil()
EndIf
_ExitUtil()
EndIf
EndFunc
Func F_ExitCloseY($tRestart = False)
SetStatusBusy("Util Shutdown Initiated")
If $tRestart = False Then
LogWrite(" [" & $aServerName & "] Utility exit with server shutdown initiated by user (Exit: Shut Down Servers).")
EndIf
If ($aServerUseRedis = "yes") And ($aPIDRedisreadYetTF = False) Or ($aPIDServerReadYetTF = False) Then
If $aServerUseRedis = "yes" Then
Local $aMsg = "Closing Utility. If Redis and/or Servers were running, they will remain running."
Else
Local $aMsg = "Closing Utility. If Servers were running, they will remain running."
EndIf
LogWrite(" [Util] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
If $tRestart = False Then
MsgBox(0, $aUtilityVer, $aMsg, 20)
LogWrite(" [Util] " & $aUtilityVer & " Stopped by User")
Else
LogWrite(" [Util] " & $aUtilityVer & " Restarting Util")
_RestartUtil()
EndIf
_ExitUtil()
Else
SetStatusBusy("Util Shutdown. Waiting for User Input.", "Waiting for User Input")
If $aServerUseRedis = "yes" Then
$bMsg = "Utility exited unexpectedly or before it was fully initialized." & @CRLF & @CRLF & "Close utility?" & @CRLF & @CRLF & "Click (YES) to shutdown all servers and redis and exit utility." & @CRLF & "Click (NO) to shutdown all servers BUT LEAVE REDIS RUNNING." & @CRLF & "Click (CANCEL) to exit utility but leave servers and redis still running."
Else
$bMsg = "Utility exited unexpectedly or before it was fully initialized." & @CRLF & @CRLF & "Close utility?" & @CRLF & @CRLF & "Click (YES) to shutdown all servers and exit utility." & @CRLF & "Click (NO) or (CANCEL) to exit utility but leave servers running."
EndIf
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $bMsg, 60)
SetStatusBusy("Util Shutdown Initiated.")
If $tMB = 6 Then
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, True, False)
SplashOff()
If ProcessExists($aServerPIDRedis) And $aServerUseRedis = "yes" Then
LogWrite(" [Redis (PID: " & $aServerPIDRedis & ")] Killing Process")
ProcessClose($aServerPIDRedis)
If FileExists($aPIDRedisFile) Then
FileDelete($aPIDRedisFile)
EndIf
EndIf
SplashOff()
If $tRestart = False Then
MsgBox(4096, $aUtilityVer, "Thank you for using " & $aUtilName & "." & @CRLF & "Please report any problems or comments to: " & @CRLF & "Discord: http://discord.gg/EU7pzPs or " & @CRLF & "Forum: http://phoenix125.createaforum.com/index.php. " & @CRLF & @CRLF & "Visit http://www.Phoenix125.com", 20)
LogWrite(" [Util] " & $aUtilityVer & " Stopped by User")
Else
LogWrite(" [Util] " & $aUtilityVer & " Restarting Util")
EndIf
CFGLastClose()
If $tRestart Then
_RestartUtil()
EndIf
_ExitUtil()
ElseIf $tMB = 7 Then
Local $aMsg = "Thank you for using " & $aUtilName & "." & @CRLF & "Please report any problems or comments to: " & @CRLF & "Discord: http://discord.gg/EU7pzPs or " & @CRLF & "Forum: http://phoenix125.createaforum.com/index.php. " & @CRLF & @CRLF & "Visit http://www.Phoenix125.com"
LogWrite(" [" & $aServerName & "] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
SplashOff()
If $tRestart = False Then
MsgBox(4096, $aUtilityVer, $aMsg, 20)
LogWrite(" [Util] " & $aUtilityVer & " Stopped by User")
Else
LogWrite(" [Util] " & $aUtilityVer & " Restarting Util")
_RestartUtil()
EndIf
_ExitUtil()
Else
Local $aMsg = "Thank you for using " & $aUtilName & "." & @CRLF & "Please report any problems or comments to: " & @CRLF & "Discord: http://discord.gg/EU7pzPs or " & @CRLF & "Forum: http://phoenix125.createaforum.com/index.php. " & @CRLF & @CRLF & "Visit http://www.Phoenix125.com"
LogWrite(" [" & $aServerName & "] Server Shutdown - Initiated by User when closing " & $aUtilityVer & " Script")
SplashOff()
If $tRestart = False Then
MsgBox(4096, $aUtilityVer, $aMsg, 20)
LogWrite(" [Util] " & $aUtilityVer & " Stopped by User")
Else
LogWrite(" [Util] " & $aUtilityVer & " Restarting Util")
_RestartUtil()
EndIf
PIDSaveServer($aServerPID, $aPIDServerFile)
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
CFGLastClose()
CloseTCP($aRemoteRestartIP, $aRemoteRestartPort, 0)
_ExitUtil()
EndIf
EndIf
SetStatusIdle()
EndFunc
Func F_RestartNow($tAsk = True)
SetStatusBusy("Restart Now. Waiting for User Input.", "Waiting for User Input")
LogWrite(" [Server] Restart Server Now requested by user (Restart Server Now) Redis will remain running.")
If $tAsk Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, "Do you wish to Restart Server Now?" & @CRLF & @CRLF & "Click (YES) to Restart Servers Now with Discord Announcement (will ask message)" & @CRLF & "Click (NO) to Restart Servers Now" & @CRLF & "Click (CANCEL) to cancel.", 15)
Else
$tMB = 6
EndIf
If $tMB = 6 Then
$tMsg = InputBox("Send Discord Message", "Enter message to send to Discord:", "", "", 400, 125, Default, Default, 120)
If $tMsg = "" Then
_Splash("Send Discord message cancelled. Restarting servers.", 2000)
Else
SendDiscordMsg($sDiscordWebHookURLs, $tMsg, $sDiscordBotName, $bDiscordBotUseTTS, $sDiscordBotAvatar)
EndIf
LogWrite(" [Server] Restart Server Now request initiated by user.")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
SetStatusBusy("Server process check in progress...", "Updating Main Window")
GUIUpdateQuick()
ElseIf $tMB = 7 Then
LogWrite(" [Server] Restart Server Now request initiated by user.")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
SetStatusBusy("Server process check in progress...", "Updating Main Window")
GUIUpdateQuick()
Else
LogWrite(" [Server] Restart Server Now request canceled by user.")
_Splash("Restart Server Now canceled. Resuming utility . . .")
Sleep(2000)
EndIf
SplashOff()
SetStatusIdle()
EndFunc
Func F_RemoteRestart()
SetStatusBusy("Remote Restart. Waiting for User Input.", "Waiting for User Input")
LogWrite(" [Remote Restart] Remote Restart requested by user (Initiate Remote Restart).")
If $aRemoteRestartUse <> "yes" Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, "You must enable Remote Restart in the " & $aUtilName & ".ini." & @CRLF & @CRLF & "Would you like to enable it? (Port:" & $aRemoteRestartPort & ")" & @CRLF & "Click (YES) to enable Remote Restart. A utility restart will be required." & @CRLF & "Click (NO) or (CANCEL) to skip.", 15)
If $tMB = 6 Then
LogWrite(" [Remote Restart] Remote Restart enabled in " & $aUtilName & ".ini per user request")
IniWrite($aIniFile, " --------------- REMOTE RESTART OPTIONS --------------- ", "Use Remote Restart? (yes/no) ###", "yes")
$aRemoteRestartUse = "yes"
_Splash("Remote Restart enabled in " & $aUtilName & ".ini. " & @CRLF & "Restarting utility in 5 seconds.", 5000)
PIDSaveServer($aServerPID, $aPIDServerFile)
PIDSaveRedis($aServerPIDRedis, $aPIDRedisFile)
LogWrite(" [Util] " & $aUtilityVer & " Restarting Util")
_RestartUtil()
_ExitUtil()
Else
LogWrite(" [Remote Restart] No changes made to Remote Restart setting in " & $aUtilName & ".ini per user request.")
_Splash("No changes were made. Resuming utility . . .", 2000)
EndIf
Else
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, "Do you wish to initiate Remote Restart (reboot all servers in " & $aRemoteTime[$aRemoteCnt] & "min)?" & @CRLF & @CRLF & "Click (YES) to Initiate Remote Restart." & @CRLF & "Click (NO) or (CANCEL) to cancel.", 15)
If $tMB = 6 Then
If $aBeginDelayedShutdown = 0 Then
LogWrite(" [Remote Restart] Remote Restart request initiated by user.")
If ($sUseDiscordBotRemoteRestart = "yes") Or ($sUseTwitchBotRemoteRestart = "yes") Or ($sInGameAnnounce = "yes") Then
$aRebootReason = "remoterestart"
$aBeginDelayedShutdown = 1
$aTimeCheck0 = _NowCalc()
Else
RunExternalRemoteRestart()
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
EndIf
EndIf
Else
LogWrite(" [Remote Restart] Remote Restart request canceled by user.")
_Splash("Remote Restart canceled. Resuming utility . . .", 2000)
EndIf
EndIf
SetStatusIdle()
EndFunc
#Region _RestartUtil Function
Func _RestartUtil($fQuickRebootTF = True)
$fExit = 1
If $aUseKeepAliveYN = "yes" Then IniWrite($aKeepAliveConfigFileFull, " --------------- ATLASSERVERUPDATEUTILITYKEEPALIVE --------------- ", "System use: Close AtlasServerUpdateUtilityKeepAlive? (Checked prior to restarting above Program... used when purposely shutting down above Program)(yes/no) ###", "yes")
_Splash("Restarting utility. . .", 2500)
If $fQuickRebootTF Then IniWrite($aUtilCFGFile, "CFG", "aUtilReboot", "yes")
Local $Pid
If Not $__Restart Then
If @Compiled Then
$Pid = Run(@ScriptFullPath & ' ' & $CmdLineRaw, @ScriptDir, Default, 1)
Else
$Pid = Run(@AutoItExe & ' "' & @ScriptFullPath & '" ' & $CmdLineRaw, @ScriptDir, Default, 1)
EndIf
If @error Then
Return SetError(@error, 0, 0)
EndIf
StdinWrite($Pid, @AutoItPID)
EndIf
$__Restart = 1
If $fExit Then
Sleep(50)
_ExitUtil(False)
EndIf
Return 1
EndFunc
Func OnAutoItStart()
Sleep(50)
Local $Pid = ConsoleRead(1)
If @extended Then
While ProcessExists($Pid)
Sleep(100)
WEnd
EndIf
EndFunc
#EndRegion _RestartUtil Function
Func SetStatusBusy($tMsg0, $tMsg1 = "no")
If $tMsg1 = "no" Then $tMsg1 = $tMsg0
TraySetToolTip($tMsg0)
TraySetIcon($aIconFile, 201)
GUICtrlSetImage($IconReady, $aIconFile, 203)
GUICtrlSetData($LabelUtilReadyStatus, $tMsg1)
EndFunc
Func SetStatusIdle()
GUICtrlSetImage($IconReady, $aIconFile, 204)
GUICtrlSetData($LabelUtilReadyStatus, "Idle")
TraySetToolTip($aIconFile)
TraySetIcon($aIconFile, 99)
EndFunc
Func F_StopServer()
SetStatusBusy("Stop server(s). Waiting for User Input.", "Waiting for User Input")
LogWrite(" [" & $aServerName & "] Send shutdown (DoExit) command to servers requested by user (Stop Server(s)).")
Local $aMsg = "Do you wish to shut down servers?" & @CRLF & @CRLF & "Click (YES) to shut down in " & $aStopServerTime[$aStopServerCnt] & " min with announcements?" & @CRLF & "Click (NO) to shut down servers now without announcements." & @CRLF & "Click (CANCEL) to cancel."
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 15)
If $tMB = 6 Then
If $aBeginDelayedShutdown = 0 Then
SetStatusBusy("Stop Server Started")
LogWrite(" [" & $aServerName & "] Stop Server request initiated by user.")
If ($sUseDiscordBotStopServer = "no") And (IniRead($aUtilCFGFile, "CFG", "aAskStopServerDiscord", "yes") = "yes") Then
IniWrite($aUtilCFGFile, "CFG", "aAskStopServerDiscord", "no")
$tMB1 = MsgBox($MB_YESNOCANCEL, $aUtilName, "Notice! Discord announcement for STOP SERVER is disabled in " & @CRLF & $aUtilName & ".ini." & @CRLF & @CRLF & "Would you like to enable it?" & @CRLF & "Click (YES) to enable STOP SERVER Discord announcement" & @CRLF & "Click (NO) or (CANCEL) to keep STOP SERVER Discord announcement disabled.", 20)
If $tMB1 = 6 Then
LogWrite(" [" & $aServerName & "] STOP SERVER Discord announcement enabled in " & $aUtilName & ".ini.")
$sUseDiscordBotStopServer = "yes"
IniWrite($aIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for STOP SERVER? (yes/no) ###", "yes")
_Splash("Stop Server Discord and In-Game Announcements were disabled." & @CRLF & @CRLF & "The following setting was changed in the " & $aUtilName & ".ini." & @CRLF & """Send Discord message for STOP SERVER? (yes/no) ###=yes""", 7000, 500, 150)
Else
LogWrite(" [" & $aServerName & "] No changes made to STOP SERVER Discord announcement setting in " & $aUtilName & ".ini.")
_Splash("No changes were made. Resuming utility . . .", 2000)
EndIf
EndIf
If ($sUseDiscordBotStopServer = "yes") Or ($sUseTwitchBotStopServer = "yes") Or ($sInGameAnnounce = "yes") Then
$aRebootReason = "stopservers"
$aBeginDelayedShutdown = 1
$aTimeCheck0 = _NowCalc()
_Splash("Stop Server with announcements initiated.", 2000)
Else
LogWrite(" [" & $aServerName & "] Stop Server Discord, Twitch, and In-Game announcements are disabled in " & @CRLF & $aUtilName & ".ini.")
_Splash("Stop Server Discord, Twitch, and In-Game announcements are disabled." & @CRLF & @CRLF & "Stopping servers WITHOUT announcements", 0, 500, 150)
SetStatusBusy("Stopping Servers")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, True)
SetStatusIdle()
SplashOff()
EndIf
EndIf
ElseIf $tMB = 7 Then
SetStatusBusy("Stopping Servers")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, True)
SetStatusIdle()
ElseIf $tMB = 2 Then
SetStatusBusy("Canceled")
LogWrite(" [" & $aServerName & "] Stop Server request canceled by user.")
_Splash("Stop Server canceled. Resuming utility . . .", 2000)
EndIf
SetStatusIdle()
EndFunc
Func F_StartServer()
LogWrite(" [Server] Start all servers requested by user (Start Server(s)).")
$tMsg1 = "Starting all servers." & @CRLF & @CRLF
$aSplash = _Splash($tMsg1, 0, 500)
SetStatusBusy("Starting all server(s).", "Start Servers")
Local $tFirstGrid = True
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) = 0 And $xLocalGrid[$i] = "yes" Then
If ($xLocalGrid[$i] = "yes") Then
_GUICtrlListView_SetItemChecked($wMainListViewWindow, $i, True)
If $tFirstGrid = False Then
Local $tDelay = Int($aServerStartDelay) + ($xGridStartDelay[$i])
For $x = 0 To ($tDelay - 1)
ControlSetText($aSplash, "", "Static1", "Starting server " & _ServerNamingScheme($i, $aNamingScheme) & " in " & ($tDelay - $x) & " seconds.")
SetStatusBusy("Starting Server " & _ServerNamingScheme($i, $aNamingScheme) & " in " & ($tDelay - $x))
Sleep(1000)
Next
Else
$tFirstGrid = False
ControlSetText($aSplash, "", "Static1", "Starting server " & _ServerNamingScheme($i, $aNamingScheme) & " in 1 seconds.")
SetStatusBusy("Starting Server " & _ServerNamingScheme($i, $aNamingScheme) & " in 1")
Sleep(1000)
EndIf
If $aServerMinimizedYN = "no" Then
$aServerPID[$i] = Run($xServerStart[$i])
Else
$aServerPID[$i] = Run($xServerStart[$i], "", @SW_MINIMIZE)
EndIf
$xServerCPU[$i] = _ProcessUsageTracker_Create("", $aServerPID[$i])
LogWrite(" [Server] Server " & _ServerNamingScheme($i, $aNamingScheme) & " started (PID: " & $aServerPID[$i] & ")]", " [Server " & _ServerNamingScheme($i, $aNamingScheme) & " started (PID: " & $aServerPID[$i] & ")] " & $xServerStart[$i])
$xStartGrid[$i] = "yes"
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", "yes")
EndIf
EndIf
Next
SplashOff()
SetStatusIdle()
EndFunc
Func F_UpdateUtilCheck()
LogWrite(" [Util] " & $aUtilName & " update check requested by user (Check for Updates).")
$aShowUpdate = True
UtilUpdate($aServerUpdateLinkVerUse, $aServerUpdateLinkDLUse, $aUtilVersion, $aUtilName, 0, "show")
EndFunc
Func F_UpdateServCheck()
Local $aMsg = "Check for " & $aGameName & " server updates." & @CRLF & @CRLF & "Click (YES) to check for update and install if update available." & @CRLF & "Click (NO) to FORCE an update with -validate. WARNING! Will shutdown all servers!" & @CRLF & "Click (CANCEL) to cancel update check."
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Then
SplashOff()
_Splash("Checking for server updates.")
SetStatusBusy("Check: Server Update")
UpdateCheck(True)
SetStatusIdle()
SplashOff()
ElseIf $tMB = 7 Then
Local $aMsg = "Check for " & $aGameName & " server updates." & @CRLF & @CRLF & "WARNING! Continuing will shut down all servers and perform a steamcmd update with -validate." & @CRLF & @CRLF & "Click (YES) to shut down servers and perform update." & @CRLF & "Click (NO) or (CANCEL) to cancel and resume utility."
SplashOff()
$tMB1 = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB1 = 6 Then
$bUpdateRequired = True
$aSteamUpdateNow = True
$aUpdateVerify = "yes"
RunExternalScriptUpdate()
$TimeStamp = StringRegExpReplace(_NowCalc(), "[\\\/\: ]", "_")
SteamcmdDelete($aSteamCMDDir)
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, False)
Else
_Splash("Update check canceled. Resuming utility . . .", 2000)
EndIf
ElseIf $tMB = 2 Then
_Splash("Update check canceled. Resuming utility . . .", 2000)
EndIf
EndFunc
Func F_SendMessage($tAllorSel = "ask", $tMsgCmd = "", $tAskTF = True)
SetStatusBusy("Send Message. Waiting for User Input.", "Waiting for User Input")
Local $aCancelTF = False
If $tAskTF = False Then
If $tAllorSel = "all" Then
For $i = 0 To ($aServerGridTotal - 1)
ControlSetText($tSplash, "", "Static1", "Sending message to ALL grids: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
SetStatusBusy("Sending message.", "Send message to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
Next
ElseIf $tAllorSel = "local" Then
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" And $xLocalGrid[$i] = "yes" Then
ControlSetText($tSplash, "", "Static1", "Sending message to ALL grids: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
SetStatusBusy("Sending message.", "Send message to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
EndIf
Next
EndIf
Else
LogWrite(" [Remote RCON] Broadcast message requested by user (Send message).")
SplashOff()
Local $tResponse = ""
If $tAllorSel = "ask" Or $tAllorSel = "all" Then
If $aGridSomeRemoteTF Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, "Send in-game message to ALL grids?" & @CRLF & @CRLF & "Click (YES) to send to ALL grids (Local and Remote)." & @CRLF & "Click (NO) to send to LOCAL hosted grids." & @CRLF & "Click (CANCEL) to cancel.", 15)
Else
$tMB = 7
EndIf
If $tMB = 2 Or $tMB = -1 Then
LogWrite(" [Remote RCON] Send RCON command canceled by user.")
_Splash("Send RCON command canceled. Resuming utility . . .", 2000)
Else
If $tMB = 6 Then
Local $tTxt = "Enter message to broadcast to ALL grids (Local and Remote):"
Else
If $aGridSomeRemoteTF Then
Local $tTxt = "Enter message to broadcast to all LOCAL grids:"
Else
Local $tTxt = "Enter message to broadcast to ALL grids:"
EndIf
EndIf
$tMsg = InputBox($aUtilName, $tTxt, "", "", 400, 125, Default, Default, 360)
If $tMsg = "" Or @error Then
LogWrite(" [Remote RCON] Broadcast message canceled by user.")
_Splash("Broadcast Message canceled. Resuming utility . . .", 2000)
Else
$tMsg = "broadcast " & $tMsg
If $tMB = 6 Then
LogWrite(" [Remote RCON] Sending message to ALL grids (Local and Remote):" & $tMsg)
Local $tSplash = _Splash("Sending message to ALL grids: " & @CRLF & $tMsg)
For $i = 0 To ($aServerGridTotal - 1)
ControlSetText($tSplash, "", "Static1", "Sending message to ALL grids: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
SetStatusBusy("Sending message.", "Send message to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
Next
_RCONMsgBox($tMsg, $tResponse, "Message")
SplashOff()
ElseIf $tMB = 7 Then
LogWrite(" [Remote RCON] Sending message to local grids:" & $tMsg)
Local $tSplash = _Splash("Sending message to all LOCAL grids: " & @CRLF & $tMsg)
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then
ControlSetText($tSplash, "", "Static1", "Sending message to ALL grids: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
SetStatusBusy("Sending message.", "Send message to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
EndIf
Next
_RCONMsgBox($tMsg, $tResponse, "Message")
SplashOff()
EndIf
EndIf
EndIf
ElseIf $tAllorSel = "sel" Then
If $tMsgCmd = "" Then
$tMsg = InputBox($aUtilName, "Enter message to broadcast to selected servers", "", "", 400, 125, Default, Default, 180)
If $tMsg = "" Or @error Then
LogWrite(" [Remote RCON] Broadcast message canceled by user.")
_Splash("Broadcast Message canceled. Resuming utility . . .", 2000)
$aCancelTF = True
EndIf
Else
$tMsg = $tMsgCmd
EndIf
LogWrite(" [Remote RCON] Sending message to selected servers:" & $tMsg)
If $tMsgCmd = "" Then
Local $tSplash = _Splash("Sending message to selected servers: " & @CRLF & $tMsg)
EndIf
If $aCancelTF = False Then
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
ControlSetText($tSplash, "", "Static1", "Sending message to selected servers: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
SetStatusBusy("Sending message.", "Send message to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
EndIf
Next
If $tMsgCmd = "" Then
_RCONMsgBox($tMsg, $tResponse, "Message")
EndIf
EndIf
SplashOff()
EndIf
EndIf
SetStatusIdle()
EndFunc
Func F_SendRCON($tAllorSel = "ask", $tMsgCmd = "", $tAskTF = True)
SetStatusBusy("Send RCON. Waiting for User Input.", "Waiting for User Input")
If $tAskTF = False Then
If $tAllorSel = "all" Then
$tMsg = $tMsgCmd
For $i = 0 To ($aServerGridTotal - 1)
ControlSetText($tSplash, "", "Static1", "Sending RCON command to ALL grids: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
SetStatusBusy("Send RCON. Sending RCON command.", "Sending RCON to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
Next
ElseIf $tAllorSel = "local" Then
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" And $xLocalGrid[$i] = "yes" Then
SetStatusBusy("Send RCON. Sending RCON command.", "Sending RCON to " & _ServerNamingScheme($i, $aNamingScheme))
ControlSetText($tSplash, "", "Static1", "Sending RCON command to all LOCAL grids: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
EndIf
Next
EndIf
Else
LogWrite(" [Remote RCON] Send RCON command requested by user (Send command).")
SplashOff()
Local $tResponse = ""
If $tAllorSel = "ask" Or $tAllorSel = "all" Then
If $aGridSomeRemoteTF Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, "Send RCON command to ALL grids?" & @CRLF & @CRLF & "Click (YES) to send to ALL grids (Local and Remote)." & @CRLF & "Click (NO) to send to LOCAL hosted grids." & @CRLF & "Click (CANCEL) to cancel.", 15)
Else
$tMB = 7
EndIf
If $tMB = 2 Or $tMB = -1 Then
LogWrite(" [Remote RCON] Send RCON command canceled by user.")
_Splash("Send RCON command canceled. Resuming utility . . .", 2000)
Else
If $tMB = 6 Then
Local $tTxt = "Enter RCON command to send to ALL grids (Local and Remote):"
Else
If $aGridSomeRemoteTF Then
Local $tTxt = "Enter RCON command to send to all LOCAL grids:"
Else
Local $tTxt = "Enter RCON command to send to ALL grids:"
EndIf
EndIf
$tMsg = InputBox($aUtilName, $tTxt, "", "", 400, 125, Default, Default, 180)
$tMsg = $tMsgCmd
If $tMsg = "" Then
LogWrite(" [Remote RCON] Send RCON command canceled by user.")
_Splash("Send RCON command canceled. Resuming utility . . .", 2000)
Else
If $tMB = 6 Then
LogWrite(" [Remote RCON] Sending RCON command to ALL grids (Local and Remote):" & $tMsg)
Local $tSplash = _Splash("Sending RCON command to ALL grids: " & @CRLF & $tMsg)
For $i = 0 To ($aServerGridTotal - 1)
ControlSetText($tSplash, "", "Static1", "Sending RCON command to ALL grids: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
SetStatusBusy("Send RCON. Sending RCON command.", "Sending RCON to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
Next
_RCONMsgBox($tMsg, $tResponse, "RCON")
SplashOff()
ElseIf $tMB = 7 Then
LogWrite(" [Remote RCON] Sending RCON command to local grids:" & $tMsg)
Local $tSplash = _Splash("Sending RCON command to all LOCAL grids: " & @CRLF & $tMsg)
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then
SetStatusBusy("Send RCON. Sending RCON command.", "Sending RCON to " & _ServerNamingScheme($i, $aNamingScheme))
ControlSetText($tSplash, "", "Static1", "Sending RCON command to all LOCAL grids: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
EndIf
Next
_RCONMsgBox($tMsg, $tResponse, "RCON")
SplashOff()
EndIf
EndIf
EndIf
ElseIf $tAllorSel = "sel" Then
If $tMsgCmd = "" Then
$tMsg = InputBox($aUtilName, "Enter RCON command to send to selected servers", "", "", 400, 125, Default, Default, 180)
Else
$tMsg = $tMsgCmd
EndIf
LogWrite(" [Remote RCON] Sending RCON command to selected servers:" & $tMsg)
If $tMsgCmd = "" Then
Local $tSplash = _Splash("Sending RCON command to selected servers: " & @CRLF & $tMsg)
EndIf
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
ControlSetText($tSplash, "", "Static1", "Sending RCON command to selected servers: " & _ServerNamingScheme($i, $aNamingScheme) & @CRLF & $tMsg)
SetStatusBusy("Send RCON. Sending RCON command.", "Sending RCON to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
EndIf
Next
If $tMsgCmd = "" Then
_RCONMsgBox($tMsg, $tResponse, "RCON")
EndIf
SplashOff()
ElseIf $tAllorSel = "local" Then
If $tMsgCmd = "" Then
$tMsg = InputBox($aUtilName, "Enter RCON command to send to selected servers", "", "", 400, 125, Default, Default, 180)
Else
$tMsg = $tMsgCmd
EndIf
LogWrite(" [Remote RCON] Sending RCON command to selected servers:" & $tMsg)
If $tMsgCmd = "" Then
_Splash("Sending RCON command to selected servers: " & @CRLF & $tMsg)
EndIf
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then
SetStatusBusy("Send RCON. Sending RCON command.", "Sending RCON to " & _ServerNamingScheme($i, $aNamingScheme))
Local $tRCON = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $tMsg, "no", $aRCONResponseWaitms)
If $aRCONError Then $tRCON = "[Time out error: No Response]"
$tResponse &= "Server " & _ServerNamingScheme($i, $aNamingScheme) & ":" & ReplaceCRLF($tRCON) & @CRLF
EndIf
Next
If $tMsgCmd = "" Then
_RCONMsgBox($tMsg, $tResponse, "RCON")
EndIf
EndIf
EndIf
SetStatusIdle()
EndFunc
Func _RCONMsgBox($tMsg, $tResponse, $tRCONorMsg = "RCON")
SplashOff()
If $tRCONorMsg = "RCON" Then
Local $tTxt1 = "RCON command sent"
Else
Local $tTxt1 = "Broadcast Message sent"
EndIf
Local $tTxt = $tTxt1 & ":" & @CRLF & $tMsg & @CRLF & @CRLF & "Response:" & @CRLF & $tResponse
ClipPut($tTxt)
LogWrite("", " [Remote RCON] " & ReplaceCRLF($tTxt))
MsgBox($MB_OK, $aUtilName, $tTxt & @CRLF & @CRLF & "Response copied to clipboard.", 30)
EndFunc
Func SendMessageAddDuration($tTxt)
If $sInGameMessageDuration = 6 Then
Return $tTxt
Else
Local $tTxt1 = ""
For $i = 1 To $sInGameMessageDuration
$tTxt1 &= "   "
Next
$tTxt2 = "-" & $tTxt1 & "\n" & $tTxt & "\n-" & $tTxt1
Return $tTxt2
EndIf
EndFunc
Func _ServerNamingScheme($ti, $tScheme)
If $tScheme = 1 Then Return $xServergridx[$ti] & $xServergridy[$ti]
If $tScheme = 2 Then Return Chr(Int($xServergridx[$ti]) + 65) & (Int($xServergridy[$ti]) + 1)
If $tScheme = 3 Then Return $xServergridx[$ti] & "," & $xServergridy[$ti]
EndFunc
Func SelectServersStop($tServNo = -1)
SetStatusBusy("Stop select server(s). Waiting for User Input.", "Waiting for User Input")
LogWrite(" [Remote RCON] Send shutdown (DoExit) command to select servers requested by user (Stop Server(s)).")
If $tServNo = -1 Then
$bMsg = "Shut down selected server(s)." & @CRLF & @CRLF & "Click (YES) to shutdown select servers WITH an announcement." & @CRLF & "Click (NO)  to shutdown select servers with NO announcement." & @CRLF & "Click (CANCEL) to cancel."
Else
$bMsg = "Shut down server " & _ServerNamingScheme($tServNo, $aNamingScheme) & "." & @CRLF & @CRLF & "Click (YES) to shutdown WITH an announcement." & @CRLF & "Click (NO)  to shutdown with NO announcement." & @CRLF & "Click (CANCEL) to cancel."
EndIf
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $bMsg, 60)
If $tMB = 6 Then
If $aBeginDelayedShutdown = 0 Then
Local $tSelectServersTxt1 = "("
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Or $i = $tServNo Then
$tSelectServersTxt1 &= _ServerNamingScheme($i, $sAnnounceNamingScheme) & " "
EndIf
Next
$tSelectServersTxt &= StringTrimRight($tSelectServersTxt1, 1) & ") "
$aStopServerMsgInGame = AnnounceReplaceTime($sAnnounceNotifyStopServer, $tSelectServersTxt & $sInGameStopServerMessage)
$aStopServerMsgDiscord = AnnounceReplaceTime($sAnnounceNotifyStopServer, $tSelectServersTxt & $sDiscordStopServerMessage)
$aStopServerMsgTwitch = AnnounceReplaceTime($sAnnounceNotifyStopServer, $tSelectServersTxt & $sTwitchStopServerMessage)
SetStatusBusy("Stop Server Started")
LogWrite(" [" & $aServerName & "] Stop Server request initiated by user. Servers: " & $tSelectServersTxt)
If ($sUseDiscordBotStopServer = "no") And (IniRead($aUtilCFGFile, "CFG", "aAskStopServerDiscord", "yes") = "yes") Then
IniWrite($aUtilCFGFile, "CFG", "aAskStopServerDiscord", "no")
$tMB1 = MsgBox($MB_YESNOCANCEL, $aUtilName, "Notice! Discord announcement for STOP SERVER is disabled in " & @CRLF & $aUtilName & ".ini." & @CRLF & @CRLF & "Would you like to enable it?" & @CRLF & "Click (YES) to enable STOP SERVER Discord announcement" & @CRLF & "Click (NO) or (CANCEL) to keep STOP SERVER Discord announcement disabled.", 20)
If $tMB1 = 6 Then
LogWrite(" [" & $aServerName & "] STOP SERVER Discord announcement enabled in " & $aUtilName & ".ini.")
$sUseDiscordBotStopServer = "yes"
IniWrite($aIniFile, " --------------- DISCORD INTEGRATION --------------- ", "Send Discord message for STOP SERVER? (yes/no) ###", "yes")
_Splash("Stop Server Discord and In-Game Announcements were disabled." & @CRLF & @CRLF & "The following setting was changed in the " & $aUtilName & ".ini." & @CRLF & """Send Discord message for STOP SERVER? (yes/no) ###=yes""", 7000, 500, 150)
Else
LogWrite(" [" & $aServerName & "] No changes made to STOP SERVER Discord announcement setting in " & $aUtilName & ".ini.")
_Splash("No changes were made. Resuming utility . . .", 2000)
EndIf
EndIf
If ($sUseDiscordBotStopServer = "yes") Or ($sUseTwitchBotStopServer = "yes") Or ($sInGameAnnounce = "yes") Then
$aRebootReason = "stopservers"
$aSelectServers = True
$aBeginDelayedShutdown = 1
$aTimeCheck0 = _NowCalc()
_Splash("Stop Server with announcements initiated.", 2000)
Else
LogWrite(" [" & $aServerName & "] Stop Server Discord, Twitch, and In-Game announcements are disabled in " & @CRLF & $aUtilName & ".ini.")
_Splash("Stop Server Discord, Twitch, and In-Game announcements are disabled" & @CRLF & @CRLF & "Stopping servers WITHOUT announcements", 0, 500, 150)
SetStatusBusy("Stopping Servers")
CloseServer($aServerIP, $aTelnetPort, $aTelnetPass, False, True)
SetStatusIdle()
SplashOff()
EndIf
EndIf
ElseIf $tMB = 7 Then
$tMsg1 = "Sending shutdown (DoExit) command to select servers."
$aSplash = _Splash($tMsg1, 0, 500)
SetStatusBusy("Stopping select server(s).", "Stop Server ")
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Or $i = $tServNo Then
ControlSetText($aSplash, "", "Static1", $tMsg1 & @CRLF & @CRLF & "Server:" & _ServerNamingScheme($i, $aNamingScheme))
GUICtrlSetData($LabelUtilReadyStatus, "Stop Server " & _ServerNamingScheme($i, $aNamingScheme))
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, "DoExit", "no", $aRCONResponseWaitms)
LogWrite(" [Server] " & $tMsg1 & " Server:" & _ServerNamingScheme($i, $aNamingScheme))
$xStartGrid[$i] = "no"
$aGridSomeDisable = True
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", "no")
Sleep(1000 * $aServerShutdownDelay)
EndIf
Next
LogWrite(" Waiting up to " & $aShutDnWait & " seconds for server(s) to finish saving world . . .")
For $k = 1 To $aShutDnWait
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Or $i = $tServNo Then
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
Local $tTime = TimerInit()
$aErrorShutdown = 1
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, "DoExit", "no", 0)
SendCTRLC($aServerPID[$i])
EndIf
EndIf
Next
If $aErrorShutdown = 1 Then
Local $tDelay = 1000 - (TimerDiff($tTime))
If $tDelay < 0 Then $tDelay = 0
Sleep($tDelay)
ControlSetText($aSplash, "", "Static1", "Waiting up to " & $aShutDnWait & " seconds for server(s) to finish saving world . . ." & @CRLF & @CRLF & "Countdown: " & ($aShutDnWait - $k))
GUICtrlSetData($LabelUtilReadyStatus, "Stop Svr Cntdn " & ($aShutDnWait - $k))
$aErrorShutdown = 0
Else
ExitLoop
EndIf
Next
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Or $i = $tServNo Then
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
$aErrorShutdown = 1
LogWrite(" [Server (PID: " & $aServerPID[$i] & ")] Warning: Shutdown failed. Killing Process")
ProcessClose($aServerPID[$i])
Else
$aServerPID[$i] = ""
EndIf
EndIf
Next
GUICtrlSetData($LabelUtilReadyStatus, "Stop Server Complete")
ControlSetText($aSplash, "", "Static1", "Select server(s) shutdown complete.")
Sleep(2000)
SplashOff()
ElseIf $tMB = 2 Then
LogWrite(" [Remote RCON] Select server(s) shutdown CANCELED.")
GUICtrlSetData($LabelUtilReadyStatus, "Stop Server CANCELED")
_Splash("Select server(s) shutdown CANCELED.", 2000)
EndIf
SetStatusIdle()
EndFunc
Func SelectServersStart($tServNo = -1)
LogWrite(" [Server] Start select servers requested by user (Start Server(s)).")
$tMsg1 = "Starting select servers." & @CRLF & @CRLF
$aSplash = _Splash($tMsg1, 0, 500)
SetStatusBusy("Starting select server(s).", "Start Servers")
Local $tFirstGrid = True
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) = 0 And (_GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Or $i = $tServNo) Then
If ($xLocalGrid[$i] = "yes") Then
If $tFirstGrid = False Then
Local $tDelay = Int($aServerStartDelay) + ($xGridStartDelay[$i])
For $x = 0 To ($tDelay - 1)
ControlSetText($aSplash, "", "Static1", "Starting server " & _ServerNamingScheme($i, $aNamingScheme) & " in " & ($tDelay - $x) & " seconds.")
SetStatusBusy("Starting Server " & _ServerNamingScheme($i, $aNamingScheme) & " in " & ($tDelay - $x))
Sleep(1000)
Next
Else
$tFirstGrid = False
ControlSetText($aSplash, "", "Static1", "Starting server " & _ServerNamingScheme($i, $aNamingScheme) & " in 1 seconds.")
SetStatusBusy("Starting Server " & _ServerNamingScheme($i, $aNamingScheme) & " in 1")
Sleep(1000)
EndIf
If $aServerMinimizedYN = "no" Then
$aServerPID[$i] = Run($xServerStart[$i])
Else
$aServerPID[$i] = Run($xServerStart[$i], "", @SW_MINIMIZE)
EndIf
$xServerCPU[$i] = _ProcessUsageTracker_Create("", $aServerPID[$i])
LogWrite(" [Server] Server " & _ServerNamingScheme($i, $aNamingScheme) & " started (PID: " & $aServerPID[$i] & ")]", " [Server " & _ServerNamingScheme($i, $aNamingScheme) & " started (PID: " & $aServerPID[$i] & ")] " & $xServerStart[$i])
$xStartGrid[$i] = "yes"
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$i] & "," & $xServergridy[$i] & ") (yes/no)", "yes")
Else
ControlSetText($aSplash, "", "Static1", "Server NOT started because it is not local: " & _ServerNamingScheme($i, $aNamingScheme))
Sleep(4000)
EndIf
EndIf
Next
SplashOff()
SetStatusIdle()
EndFunc
Func PIDSaveRedis($tPID, $tFile)
If $aPIDRedisreadYetTF Then
If FileExists($tFile) Then
FileDelete($tFile & ".bak")
FileMove($tFile, $tFile & ".bak", 1)
EndIf
FileWrite($tFile, $tPID)
EndIf
EndFunc
Func PIDSaveServer($tPID, $tFile)
If $aPIDServerReadYetTF Then
If FileExists($tFile) Then
FileDelete($tFile & ".bak")
FileMove($tFile, $tFile & ".bak", 1)
EndIf
Local $tTmp = _ArrayToString($tPID)
FileWrite($tFile, $tTmp)
EndIf
EndFunc
Func PIDReadRedis($tFile, $tSplash = 0)
$aPIDRedisreadYetTF = True
Local $tTmp = FileOpen($tFile)
$tReturn = FileRead($tTmp)
FileClose($tTmp)
If $tTmp = -1 Then
$tReturn = "0"
LogWrite("", " Lastpidredis.tmp file not found. Existing Redis Server NOT running")
ElseIf $tReturn = "" Then
$tReturn = "0"
FileDelete($tFile)
LogWrite("", " Lastpidredis.tmp file corrupt.")
EndIf
If $tReturn = "0" Then
Local $tTmp = FileOpen($tFile & ".bak")
$tReturn = FileRead($tTmp)
FileClose($tTmp)
If $tTmp = -1 Then
$tReturn = "0"
LogWrite("", " Lastpidredis.tmp.bak file not found. Existing Redis Server NOT running")
ElseIf $tReturn = "" Then
$tReturn = "0"
FileDelete($tFile)
LogWrite("", " Lastpidredis.tmp.bak file corrupt.")
EndIf
EndIf
If $tReturn <> "0" Then
If ProcessExists($tReturn) Then
LogWrite(" Redis Server PID(" & $tReturn & ") found.")
If $aUtilReboot = "no" And ((_DateDiff('n', $aCFGLastUpdate, _NowCalc())) >= $aUpdateCheckInterval) Then
Local $tTxt = $aStartText & "Redis Server found." & @CRLF & "PID:(" & $tReturn & ")"
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
Sleep(1500)
EndIf
Else
$tReturn = "0"
EndIf
EndIf
Return $tReturn
EndFunc
Func PIDReadServer($tFile, $tSplash = 0)
$aPIDServerReadYetTF = True
Local $tReturn[$aServersMax]
Local $tTmp1 = FileOpen($tFile)
Local $tReturn1 = FileRead($tTmp1)
FileClose($tTmp1)
Local $tTmp2 = FileOpen($tFile & ".bak")
Local $tReturn2 = FileRead($tTmp2)
FileClose($tTmp2)
If $tTmp1 = -1 Then
LogWrite("", " [Util PID Check] Lastpidserver.tmp file not found.")
$tReturn1 = $tReturn2
$aNoExistingPID = True
If $tTmp2 = -1 Then
$tReturn[0] = "0"
LogWrite("", " [Util PID Check] Lastpidserver.tmp.bak file not found.")
$aNoExistingPID = True
Else
If $tReturn2 = "" Then
$tReturn[0] = "0"
LogWrite("", " [Util PID Check] Lastpidserver.tmp.bak contained no server PID data.")
$aNoExistingPID = True
FileDelete($tFile & ".bak")
EndIf
EndIf
Else
$aNoExistingPID = False
If $tReturn1 = "" Then
LogWrite("", " [Util PID Check] Lastpidserver.tmp file contained no server PID data.")
$tReturn1 = $tReturn2
If $tTmp2 = -1 Then
$tReturn[0] = "0"
LogWrite("", " [Util PID Check] Lastpidserver.tmp.bak file not found.")
$aNoExistingPID = True
Else
If $tReturn2 = "" Then
$tReturn[0] = "0"
LogWrite("", " [Util PID Check] Lastpidserver.tmp.bak contained no server PID data.")
$aNoExistingPID = True
FileDelete($tFile & ".bak")
EndIf
EndIf
EndIf
EndIf
If $tReturn[0] <> "0" Then
$dReturn = StringSplit($tReturn1, "|", 2)
$tReturn = ResizeArray($dReturn, $aServersMax)
Local $tPID = ""
Local $tFound = 0
For $i = 0 To $aServerGridTotal
If ProcessExists($tReturn[$i]) Then
Local $tProcessNameFromPID = _ProcessGetName($tReturn[$i])
If (StringInStr($tProcessNameFromPID, "Shooter") <> 0) Or (StringInStr($tProcessNameFromPID, "Atlas") <> 0) Then
$xServerCPU[$i] = _ProcessUsageTracker_Create("", $tReturn[$i])
LogWrite(" Server PID(" & $tReturn[$i] & ") found.")
$tPID = $tPID & $tReturn[$i] & ","
$tFound += 1
Else
LogWrite(" -ERROR- Server PID(" & $tReturn[$i] & ") was found but was not an Atlas server.  Server will be restarted.")
$tReturn[$i] = ""
$aNoExistingPID = True
EndIf
Else
If $tReturn[$i] <> "" Then
LogWrite(" -ERROR- Server PID(" & $tReturn[$i] & ") NOT found. Server will be restarted.")
$tReturn[$i] = ""
$aNoExistingPID = True
EndIf
EndIf
Next
If $tPID <> "" Then
If $aUtilReboot = "no" And ((_DateDiff('n', $aCFGLastUpdate, _NowCalc())) >= $aUpdateCheckInterval) Then
$aTmp = ResizeArray($tReturn)
Local $tTxt = $aStartText & $tFound & " Running servers found." & @CRLF & "PID:(" & StringTrimRight($tPID, 1) & ")"
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
Else
_Splash($tTxt)
EndIf
Sleep(2500)
EndIf
EndIf
EndIf
Return $tReturn
EndFunc
Func SendCTRLC($tPID)
Local $hWnd = _WinGetByPID($tPID, 1)
ControlSend($hWnd, "", "", "^C" & @CR)
EndFunc
Func _WinGetByPID($iPID, $iArray = 1)
Local $aError[1] = [0], $aWinList, $sReturn
If IsString($iPID) Then
$iPID = ProcessExists($iPID)
EndIf
$aWinList = WinList()
For $A = 1 To $aWinList[0][0]
If WinGetProcess($aWinList[$A][1]) = $iPID And BitAND(WinGetState($aWinList[$A][1]), 2) Then
If $iArray Then
Return $aWinList[$A][1]
EndIf
$sReturn &= $aWinList[$A][1] & Chr(1)
EndIf
Next
If $sReturn Then
Return StringSplit(StringTrimRight($sReturn, 1), Chr(1))
EndIf
Return SetError(1, 0, $aError)
EndFunc
Func RespawnDinosCheck($sWDays, $sHours, $sMin)
Local $iDay = -1
Local $iHour = -1
Local $aDays = StringSplit($sWDays, ",")
Local $aHours = StringSplit($sHours, ",")
For $d = 1 To $aDays[0]
$iDay = StringStripWS($aDays[$d], 8)
If Int($iDay) = Int(@WDAY) Or Int($iDay) = 0 Then
For $h = 1 To $aHours[0]
$iHour = StringStripWS($aHours[$h], 8)
If Int($iHour) = Int(@HOUR) And Int($sMin) = Int(@MIN) Then
Return True
EndIf
Next
EndIf
Next
Return False
EndFunc
Func DestroyWildDinos()
$aCMD = "destroywilddinos"
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aServerAdminPass, $aCMD, "yes", $aRCONResponseWaitms)
EndIf
Next
EndFunc
Func BatchFilesCreate($tSplash = 0, $tFolder = "0")
If $tFolder = "0" Then $tFolder = $aBatFolder
If $tSplash <> 0 Then ControlSetText($tSplash, "", "Static1", $aStartText & "Creating backup batch files.")
DirRemove($tFolder, 1)
DirCreate($tFolder)
Local $tTxtValY = "start """ & $aUtilName & """ /wait /high """ & $aSteamCMDDir & "\steamcmd.exe"" ^" & @CRLF & "+login anonymous ^" & @CRLF & "+force_install_dir """ & $aServerDirLocal & """ ^" & @CRLF & "+app_update " & $aSteamAppID & " validate ^" & @CRLF & "+quit"
Local $tTxtValN = "start """ & $aUtilName & """ /wait /high """ & $aSteamCMDDir & "\steamcmd.exe"" ^" & @CRLF & "+login anonymous ^" & @CRLF & "+force_install_dir """ & $aServerDirLocal & """ ^" & @CRLF & "+app_update " & $aSteamAppID & " ^" & @CRLF & "+quit"
FileDelete($tFolder & "\Install_Atlas.bat")
FileWrite($tFolder & "\Install_Atlas.bat", $tTxtValY)
FileDelete($tFolder & "\Update_Atlas.bat")
FileWrite($tFolder & "\Update_Atlas_Validate_Yes.bat", $tTxtValY)
FileDelete($tFolder & "\Update_Atlas.bat")
FileWrite($tFolder & "\Update_Atlas_Validate_No.bat", $tTxtValN)
If FileExists($tFolder & "\Launch_Atlas All.bat") Then FileDelete($aBatFolder & "\Launch_Atlas All.bat")
FileWriteLine($tFolder & "\Launch_Atlas All.bat", "start """ & $aUtilName & """ cmd /k Call " & $xServerRedis & @CRLF & "timeout /t 5" & @CRLF)
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then
If FileExists($tFolder & "\Launch_Atlas_" & $xServergridx[$i] & $xServergridy[$i] & ".bat") Then FileDelete($aBatFolder & "\" & "Launch_Atlas_" & $xServergridx[$i] & $xServergridy[$i] & ".bat")
FileWrite($tFolder & "\Launch_Atlas_" & $xServergridx[$i] & $xServergridy[$i] & ".bat", "Start """ & $aUtilName & """ " & $xServerStart[$i] & @CRLF & "Exit")
FileWriteLine($tFolder & "\Launch_Atlas All.bat", "start """ & $aUtilName & """ cmd /k Call " & "Launch_Atlas_" & $xServergridx[$i] & $xServergridy[$i] & ".bat" & @CRLF & "timeout /t 1" & @CRLF)
EndIf
Next
FileWriteLine($aBatFolder & "\Launch_Atlas All.bat", "exit")
EndFunc
Func SteamInstallGame($tSplash)
Local $tTxt = "start """ & $aUtilName & """ /wait /high """ & $aSteamCMDDir & "\steamcmd.exe"" ^" & @CRLF & "+login anonymous ^" & @CRLF & "+force_install_dir """ & $aServerDirLocal & """ ^" & @CRLF & "+app_update " & $aSteamAppID & " validate ^" & @CRLF & "+quit"
DirCreate($aBatFolder)
FileDelete($aBatFolder & "\" & $aBatUpdateGame)
FileWrite($aBatFolder & "\" & $aBatUpdateGame, $tTxt)
If FileExists($aSteamCMDDir & "\logs\content_log.txt") Then
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aSteamCMDDir & "\logs\content_log.txt" & "_" & $tTime & ".bak"
FileMove($aSteamCMDDir & "\logs\content_log.txt", $tFile)
EndIf
RunWait($aBatFolder & "\" & $aBatUpdateGame)
Local $tError = ""
Local $tFile = FileOpen($aSteamCMDDir & "\logs\content_log.txt")
Local $tRead = FileRead($tFile)
Local $tString = StringInStr($tRead, "update canceled : ")
If $tString <> 0 Then
$tError1 = _ArrayToString(_StringBetween($tRead, "canceled : ", @CRLF))
SplashOff()
MsgBox(0, $aUtilName, "Error!!! SteamCMD install failed with error:" & @CRLF & @CRLF & $tError1)
Else
ControlSetText($tSplash, "", "Static1", $aUtilName & " file installation complete.")
Sleep(3000)
SplashOff()
EndIf
EndFunc
Func SteamUpdate($aSteamExtraCMD, $aSteamCMDDir, $tValidateINI, $tSplash = 0)
If $tSplash = 0 Then SplashOff()
$aSteamUpdateNow = False
$aSteamEXE = $aSteamCMDDir & "\steamcmd.exe +@ShutdownOnFailedCommand 1 +@NoPromptForPassword 1 " & $aSteamExtraCMD & "+login anonymous +force_install_dir """ & $aServerDirLocal & """ +app_update " & $aSteamAppID
If ($tValidateINI = "yes") Or ($aUpdateVerify = "yes") Then
$aSteamEXE = $aSteamEXE & " validate"
EndIf
$aSteamEXE = $aSteamEXE & " +quit"
LogWrite(" [Running SteamCMD update]", " [Running SteamCMD update] " & $aSteamEXE)
RunWait($aSteamEXE)
If $tSplash = 0 Then SplashOff()
EndFunc
Func _ArraySum(ByRef $a_array, $i_lbound1 = 0, $i_lbound2 = 0)
Local $i_ubound1 = UBound($a_array, 1) - 1
Local $i_ubound2 = UBound($a_array, 2) - 1
Local $i_add = 0
If $i_ubound2 > 0 Then
For $i = $i_lbound1 To $i_ubound1
For $n = $i_lbound2 To $i_ubound2
$i_add += Number($a_array[$i][$n])
Next
Next
Else
For $i = $i_lbound1 To $i_ubound1
$i_add += Number($a_array[$i])
Next
EndIf
Return $i_add
EndFunc
Func GetPlayerCount($tSplash = 0, $tStartup = True, $aWriteLog = False)
If ((_DateDiff('s', $aTimeCheck6, _NowCalc())) < 300) Then
Local $tServerStartDelayDoneTF = False
Else
Local $tServerStartDelayDoneTF = True
EndIf
Local $aCMD = "listplayers"
$tOnlinePlayerReady = True
Global $tOnlinePlayers[4]
Local $aErr = False
Local $tUserLog[$aServerGridTotal]
Local $tUserMsg[$aServerGridTotal]
Local $tUserNoSteam[$aServerGridTotal]
$aServerReadyTF = False
$tOnlinePlayers[0] = False
$tOnlinePlayers[1] = ""
$tOnlinePlayers[2] = ""
$tOnlinePlayers[3] = ""
SetStatusBusy("Scanning servers for online players.", "Check: Players")
For $i = 0 To ($aServerGridTotal - 1)
If ($xStartGrid[$i] = "yes" And $xLocalGrid[$i] = "yes") Or ($aPollRemoteServersYN = "yes" And $xLocalGrid[$i] = "no") Then
GUICtrlSetData($LabelUtilReadyStatus, "Check: Players " & _ServerNamingScheme($i, $aNamingScheme))
If $tStartup Then
Local $tTxt = $aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Preparing GUI. Getting server information." & @CRLF & "Checking online players on server " & _ServerNamingScheme($i, $aNamingScheme)
Else
Local $tTxt = "Checking online players on server " & _ServerNamingScheme($i, $aNamingScheme)
EndIf
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
GUICtrlSetData($LabelUtilReadyStatus, "Check: Players " & _ServerNamingScheme($i, $aNamingScheme))
EndIf
If $aServerRCONIP = "" Then
$mMsg = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aTelnetPass, $aCMD, "players", $aOnlinePlayerWaitms)
Else
$mMsg = SendRCON($aServerRCONIP, $xServerRCONPort[$i + 1], $aTelnetPass, $aCMD, "players", $aOnlinePlayerWaitms)
EndIf
If StringInStr($mMsg, "No Players Connected") <> 0 Then
$aServerPlayers[$i] = 0
Else
If $aRCONError Then
$aErr = True
$aServerPlayers[$i] = -2
Else
$mMsg = StringReplace($mMsg, " ", "")
$tUserLog[$i] = ""
$tUserMsg[$i] = ""
$tUserNoSteam[$i] = ""
Local $tUserAll = _StringBetween($mMsg, ".", ",")
Local $tUserCnt = UBound($tUserAll)
Local $tSteamAll[$tUserCnt + 1]
Local $tUsers = _ArrayToString($tUserAll)
Local $tSteamAll = _StringBetween($mMsg, ",", @CRLF)
For $x = 0 To ($tUserCnt - 1)
$tUserLog[$i] &= $tUserAll[$x] & "." & $tSteamAll[$x] & "|"
$tUserMsg[$i] &= $tUserAll[$x] & " [" & $tSteamAll[$x] & "] "
$tUserNoSteam[$i] &= $tUserAll[$x] & " "
Next
If $tUsers < 0 Then
$aErr = True
$aServerPlayers[$i] = -2
Else
$aServerPlayers[$i] = $tUserCnt
EndIf
EndIf
EndIf
Else
$aServerPlayers[$i] = -2
EndIf
Next
If $aErr Then
For $x1 = 1 To $aOnlinePlayersRetryAttempts
If $aUseKeepAliveYN = "yes" Then KeepUtilAliveCounter()
GUICtrlSetData($LabelUtilReadyStatus, "Recheck " & $x1 & ": Waiting 1sec")
Sleep(1000)
For $i = 0 To ($aServerGridTotal - 1)
If ($xStartGrid[$i] = "yes") Or ($aPollRemoteServersYN = "yes" And $xLocalGrid[$i] = "no") And $aServerPlayers[$i] < 0 Then
GUICtrlSetData($LabelUtilReadyStatus, "Recheck " & $x1 & ": Players " & _ServerNamingScheme($i, $aNamingScheme))
If $tStartup Then
Local $tTxt = $aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Preparing GUI. Getting server information." & @CRLF & "Checking online players Recheck " & $x1 & ": Server " & _ServerNamingScheme($i, $aNamingScheme)
Else
Local $tTxt = "Checking online players Recheck " & $x1 & ": Server " & _ServerNamingScheme($i, $aNamingScheme)
EndIf
If $tSplash > 0 Then
ControlSetText($tSplash, "", "Static1", $tTxt)
GUICtrlSetData($LabelUtilReadyStatus, "Recheck " & $x1 & ": Players " & _ServerNamingScheme($i, $aNamingScheme))
EndIf
If $aServerRCONIP = "" Then
$mMsg = SendRCON($xServerIP[$i], $xServerRCONPort[$i + 1], $aTelnetPass, $aCMD, "players", $aOnlinePlayerWaitms)
Else
$mMsg = SendRCON($aServerRCONIP, $xServerRCONPort[$i + 1], $aTelnetPass, $aCMD, "players", $aOnlinePlayerWaitms)
EndIf
If StringInStr($mMsg, "No Players Connected") <> 0 Then
$aServerPlayers[$i] = 0
Else
If $aRCONError Then
$aServerPlayers[$i] = -2
Else
$mMsg = StringReplace($mMsg, " ", "")
Local $tUserAll = _StringBetween($mMsg, ".", ",")
Local $tUserCnt = UBound($tUserAll)
Local $tSteamAll[$tUserCnt + 1]
Local $tUsers = _ArrayToString($tUserAll)
Local $tSteamAll = _StringBetween($mMsg, ",", @CRLF)
$tUserLog[$i] = ""
$tUserMsg[$i] = ""
$tUserNoSteam[$i] = ""
For $x = 0 To ($tUserCnt - 1)
$tUserLog[$i] &= $tUserAll[$x] & "." & $tSteamAll[$x] & "|"
$tUserMsg[$i] &= $tUserAll[$x] & " [" & $tSteamAll[$x] & "] "
$tUserNoSteam[$i] &= $tUserAll[$x] & " "
Next
If $tUsers < 0 Then
$aServerPlayers[$i] = -2
Else
$aServerPlayers[$i] = $tUserCnt
EndIf
EndIf
EndIf
EndIf
Next
Next
EndIf
For $i = 0 To ($aServerGridTotal - 1)
If ($xStartGrid[$i] = "yes") Or ($aPollRemoteServersYN = "yes" And $xLocalGrid[$i] = "no") Then
If $aServerPlayers[$i] = 0 Then
$tOnlinePlayers[1] = $tOnlinePlayers[1] & _ServerNamingScheme($i, $aNamingScheme) & "(0) "
$tOnlinePlayers[2] = $tOnlinePlayers[2] & "Server " & _ServerNamingScheme($i, $aNamingScheme) & ": 0" & @CRLF
$tOnlinePlayers[3] = $tOnlinePlayers[3] & "Server " & _ServerNamingScheme($i, $aNamingScheme) & ": 0" & @CRLF
ElseIf $aServerPlayers[$i] >= 0 Then
$tOnlinePlayers[1] = $tOnlinePlayers[1] & _ServerNamingScheme($i, $aNamingScheme) & "(" & $aServerPlayers[$i] & " " & $tUserLog[$i] & ") "
$tOnlinePlayers[2] = $tOnlinePlayers[2] & "Server " & _ServerNamingScheme($i, $aNamingScheme) & ": " & $aServerPlayers[$i] & " " & $tUserMsg[$i] & @CRLF
$tOnlinePlayers[3] = $tOnlinePlayers[3] & "Server " & _ServerNamingScheme($i, $aNamingScheme) & ": " & $aServerPlayers[$i] & " " & $tUserNoSteam[$i] & @CRLF
ElseIf $aServerPlayers[$i] < 0 Then
$tOnlinePlayers[1] = $tOnlinePlayers[1] & _ServerNamingScheme($i, $aNamingScheme) & "(-) "
$tOnlinePlayers[2] = $tOnlinePlayers[2] & "Server " & _ServerNamingScheme($i, $aNamingScheme) & ": -" & @CRLF
$tOnlinePlayers[3] = $tOnlinePlayers[3] & "Server " & _ServerNamingScheme($i, $aNamingScheme) & ": -" & @CRLF
EndIf
EndIf
Next
$tOnlinePlayers[1] &= " "
If $aErr = 0 Then
$aServerReadyTF = True
$tServerStartDelayDoneTF = True
$aTimeCheck6 = _DateAdd('n', -5, _NowCalc())
Else
If $tServerStartDelayDoneTF = False Then _Splash("Online Player Check." & @CRLF & @CRLF & "Waiting up to 5 minutes for servers to come online.", 3000)
EndIf
Local $tFile = $aFolderLog & $aUtilName & "_OnlineUserLog_" & @YEAR & "-" & @MON & "-" & @MDAY & ".txt"
Local $tNumberOfLines = _FileCountLines($tFile)
If $tNumberOfLines <> 0 Then
Local $tReadLastLine = FileReadLine($tFile, $tNumberOfLines)
Local $tLastOnlineArray = _StringBetween($tReadLastLine, "[Online] ", "  ")
If @error Then
Local $tLastOnlineString = "No entry"
Else
Local $tLastOnlineString = $tLastOnlineArray[0] & "  "
EndIf
Else
Local $tLastOnlineString = ""
EndIf
If ($tLastOnlineString <> $tOnlinePlayers[1]) Or $aWriteLog Then
$tOnlinePlayers[0] = True
If $tServerStartDelayDoneTF Then
If $aWriteLog Then
LogWrite(" [Online Players] " & $tOnlinePlayers[1] & " [Manual Request]")
Else
LogWrite(" [Online Players] " & $tOnlinePlayers[1])
EndIf
If $tServerStartDelayDoneTF And $aWriteLog = False Then WriteOnlineLog("[Online] " & $tOnlinePlayers[1])
EndIf
EndIf
If $tSplash < 1 Then
SplashOff()
EndIf
If FileExists($aOnlinePlayerWebFile) Then
FileDelete($aOnlinePlayerWebFile)
EndIf
FileWrite($aOnlinePlayerWebFile, $tOnlinePlayers[3])
SetStatusIdle()
Return $tOnlinePlayers
EndFunc
Func F_ShowPlayerCount()
$aPlayerCountShowTF = True
If $aServerOnlinePlayerYN = "no" Then
_Splash("To show online players, " & @CRLF & "you must Enable Online Players Check/Log. . .", 3000)
Else
ShowPlayerCount()
EndIf
EndFunc
Func WriteOnlineLog($aMsg)
FileWriteLine($aFolderLog & $aUtilName & "_OnlineUserLog_" & @YEAR & "-" & @MON & "-" & @MDAY & ".txt", _NowCalc() & " " & $aMsg)
EndFunc
Func F_UpdateUtilPause()
SplashOff()
MsgBox($MB_OK, $aUtilityVer, $aUtilityVer & " Paused.  Press OK to resume.")
EndFunc
Func TrayUpdateServPause()
TrayItemSetState($iTrayUpdateServPause, $TRAY_DISABLE)
TrayItemSetState($iTrayUpdateServUnPause, $TRAY_ENABLE)
IniWrite($aIniFile, " --------------- CHECK FOR UPDATE --------------- ", "Check for server updates? (yes/no) ###", "no")
EndFunc
Func TrayUpdateServUnPause()
TrayItemSetState($iTrayUpdateServPause, $TRAY_ENABLE)
TrayItemSetState($iTrayUpdateServUnPause, $TRAY_DISABLE)
IniWrite($aIniFile, " --------------- CHECK FOR UPDATE --------------- ", "Check for server updates? (yes/no) ###", "yes")
EndFunc
Func ShowPlayerCount()
$aServerOnlinePlayerYN = "yes"
ShowOnlinePlayersGUI()
EndFunc
Func _WM_SIZE($hWndGUI, $Msg, $wParam, $lParam)
Local $iHeight, $iWidth
$iWidth = BitAND($lParam, 0xFFFF)
$iHeight = BitShift($lParam, 16)
If ($hWndGUI = $wOnlinePlayers) Then
_WinAPI_MoveWindow($wOnlinePlayers, 10, 10, $iWidth - 20, $iHeight - 20)
ElseIf ($hWndGUI = $wGUIMainWindow) Then
_WinAPI_MoveWindow($wMainListViewWindow, 112, 90, $iWidth - 128, $iHeight - 230)
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func ShowOnlinePlayersGUI()
If $aServerOnlinePlayerYN = "yes" Then
If $aPlayerCountShowTF Then
If $aPlayerCountWindowTF = False Then
$gOnlinePlayerWindow = GUICreate($aUtilName & " Online Players", $aGUIW, $aGUIH, -1, -1, BitOR($WS_SIZEBOX, $WS_MINIMIZEBOX))
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_OnlinePlayers_Close", $gOnlinePlayerWindow)
$wOnlinePlayers = GUICtrlCreateEdit("", 0, 0, _WinAPI_GetClientWidth($gOnlinePlayerWindow), _WinAPI_GetClientHeight($gOnlinePlayerWindow), BitOR($ES_AUTOHSCROLL, $ES_NOHIDESEL, $ES_WANTRETURN, $WS_HSCROLL, $WS_VSCROLL, $ES_READONLY))
GUICtrlSetState($wOnlinePlayers, $GUI_FOCUS)
GUIRegisterMsg($WM_SIZE, "_WM_SIZE")
$aPlayerCountWindowTF = True
GUISetState(@SW_SHOWNORMAL, $gOnlinePlayerWindow)
EndIf
If $tOnlinePlayerReady Then
GUICtrlSetData($wOnlinePlayers, _DateTimeFormat(_NowCalc(), 0) & @CRLF & $tOnlinePlayers[2])
Else
GUICtrlSetData($wOnlinePlayers, _DateTimeFormat(_NowCalc(), 0) & @CRLF & "Waiting for first Online Player check.")
EndIf
EndIf
EndIf
EndFunc
Func TrayShowPlayerCheckPause()
GUIDelete()
$aPlayerCountWindowTF = False
TrayItemSetState($iTrayPlayerCheckPause, $TRAY_DISABLE)
TrayItemSetState($iTrayPlayerCheckUnPause, $TRAY_ENABLE)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for, and log, online players? (yes/no) ###", "no")
$aServerOnlinePlayerYN = "no"
EndFunc
Func TrayShowPlayerCheckUnPause()
TrayItemSetState($iTrayPlayerCheckPause, $TRAY_ENABLE)
TrayItemSetState($iTrayPlayerCheckUnPause, $TRAY_DISABLE)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Check for, and log, online players? (yes/no) ###", "yes")
$aServerOnlinePlayerYN = "yes"
EndFunc
Func _ImageToGUIImageListResized($tGUICreate, $tFile, $tWidth = 16, $tHeight = 16)
_GDIPlus_Startup()
Local $GDIpBmpLarge, $GDIpBmpResized, $GDIbmp, $tReturn
$GDIpBmpLarge = _GDIPlus_ImageLoadFromFile($tFile)
$GDIpBmpResized = _GDIPlus_ImageResize($GDIpBmpLarge, $tWidth, $tHeight)
$GDIbmp = _GDIPlus_BitmapCreateHBITMAPFromBitmap($GDIpBmpResized)
$tReturn = _GUIImageList_Add($tGUICreate, $GDIbmp)
_GDIPlus_BitmapDispose($GDIpBmpLarge)
_GDIPlus_BitmapDispose($GDIpBmpResized)
_WinAPI_DeleteObject($GDIbmp)
_GDIPlus_Shutdown()
Return $tReturn
EndFunc
Func ShowMainGUI($tSplash = 0)
Global $aServerPI_Stripped = ResizeArray($aServerPID, $aServerGridTotal)
Global $aServerMem = _GetMemArrayRawAvg($aServerPI_Stripped)
$aGUIMainActive = True
If $tSplash > 0 Then ControlSetText($tSplash, "", "Static1", $aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF & "Building Main Window.")
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
Local $tAtlasProcessName = WinGetTitle(_WinGetByPID($aServerPID[$i]))
ExitLoop
Else
Local $tAtlasProcessName = "ShooterGameServer.exe v0.0 ("
EndIf
Next
Global $tAtlasVer = _ArrayToString(_StringBetween($tAtlasProcessName, "ShooterGameServer.exe ", " ("))
Local $tTitle = $aUtilityVer & " | Atlas Version:" & $tAtlasVer & " | " & $aServerWorldFriendlyName
#Region ### START Koda GUI section ### Form=G:\Game Server Files\AutoIT\AtlasServerUpdateUtility\Temp Work Files\atladkoda(b10-listview).kxf
Global $wGUIMainWindow = GUICreate($tTitle, 1001, 701, -1, -1, BitOR($GUI_SS_DEFAULT_GUI, $WS_SIZEBOX, $WS_MAXIMIZEBOX))
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_Main_Close", $wGUIMainWindow)
GUISetIcon($aIconFile, 99)
GUISetBkColor($cMWBackground)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
Global $RestartAllGrids = GUICtrlCreateGroup("Log", 112, 592, 873, 97)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKHEIGHT)
Global $LogTicker = GUICtrlCreateEdit("", 120, 608, 857, 73, BitOR($ES_AUTOVSCROLL, $ES_READONLY, $WS_VSCROLL))
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKHEIGHT)
GUICtrlSetState($LogTicker, $GUI_FOCUS)
DllCall('user32.dll', 'int', 'HideCaret', 'hwnd', '')
GUICtrlSetData(-1, $aGUILogWindowText)
GUICtrlSetBkColor(-1, $cLWBackground)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKHEIGHT)
Global $Header = GUICtrlCreateGroup("", 8, 0, 985, 49)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKHEIGHT)
$LabelMEM = GUICtrlCreateLabel("Mem: ", 292, 10, 33, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetColor(-1, $cMWMemCPU)
$LabelCPU = GUICtrlCreateLabel("CPU:", 293, 27, 29, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetColor(-1, $cMWMemCPU)
Local $MemStats = MemGetStats()
Global $MemPercent = GUICtrlCreateLabel($MemStats[$MEM_LOAD] & "-- %", 323, 11, 20, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetColor(-1, $cMWMemCPU)
Global $CPUPercent = GUICtrlCreateLabel("-- %", 322, 27, 24, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetColor(-1, $cMWMemCPU)
Global $ServerHeading = GUICtrlCreateLabel($aUtilName, 45, 15, 225, 28)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetFont(-1, 14, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, $cMWMemCPU)
Global $ExitShutDownServers = GUICtrlCreateButton("Exit: SHUT DOWN servers", 664, 16, 155, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_ExitShutDownY")
GUICtrlSetTip(-1, "Exit util and shut down all servers")
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
Global $ExitDoNotShutDownServers = GUICtrlCreateButton("Exit: Do NOT shut down servers", 824, 16, 163, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_ExitShutDownN")
GUICtrlSetTip(-1, "Exit util but leave all servers running")
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $IconDiscord = GUICtrlCreateIcon($aIconFile, 209, 600, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_DiscordServer")
GUICtrlSetTip(-1, "Discord Server")
Global $IconForum = GUICtrlCreateIcon($aIconFile, 208, 536, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_DiscussionForum")
GUICtrlSetTip(-1, "Discussion Forum")
Global $IconHelp = GUICtrlCreateIcon($aIconFile, 213, 504, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_Help")
GUICtrlSetTip(-1, "Help")
Global $IconPhoenix = GUICtrlCreateIcon($aIconFile, 99, 568, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_MainWebpage")
GUICtrlSetTip(-1, "Main Webpage")
Global $IconPhoenixMain = GUICtrlCreateIcon($aIconFile, 99, 16, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_MainWebpage")
GUICtrlSetTip(-1, "Main Webpage")
Global $IconInfo = GUICtrlCreateIcon($aIconFile, 207, 632, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_About")
GUICtrlSetTip(-1, "About")
Global $IconPause = GUICtrlCreateIcon($aIconFile, 206, 376, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_Pause")
GUICtrlSetTip(-1, "Pause All " & $aUtilName & " functions (Servers will remain running)")
Global $IconUpdate = GUICtrlCreateIcon($aIconFile, 205, 408, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_CheckForUtilUpdates")
GUICtrlSetTip(-1, "Check for Updates for " & $aUtilName)
Global $IconConfig = GUICtrlCreateIcon($aIconFile, 211, 440, 16, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_UtilConfig")
GUICtrlSetTip(-1, $aUtilName & " Config")
Local $tX = 8, $tY = 54
Local $tGroupW = 89, $tButtonW = $tGroupW - 14, $tButtonH = 25, $tButtonGapY = 3
Local $tButtons = 4, $tGroupH = (($tButtonH + $tButtonGapY) * $tButtons + 17)
Global $ShowWindows = GUICtrlCreateGroup("Show Window", $tX, $tY, $tGroupW, $tGroupH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
$tY += 16
Global $ServerInfo = GUICtrlCreateButton("Tools", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_Tools")
GUICtrlSetTip(-1, "Open TOOLS window")
$tY += $tButtonH + $tButtonGapY
Global $Players = GUICtrlCreateButton("Players", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_Players")
GUICtrlSetTip(-1, "Show Online Players Window")
$tY += $tButtonH + $tButtonGapY
Global $Config = GUICtrlCreateButton("CONFIG", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_Config")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
GUICtrlSetTip(-1, "Display Util Config Window")
$tY += $tButtonH + $tButtonGapY
Global $LogFile = GUICtrlCreateButton("Log/Ini Files", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_LogFile")
GUICtrlSetTip(-1, "Open Log, Server Summary, Online Players, and Default " & $aServerName & " Config Files")
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
$tY += $tButtonH + $tButtonGapY + 8
Local $tButtons = 7, $tGroupH = (($tButtonH + $tButtonGapY) * $tButtons + 17)
Global $RestartAllGrid = GUICtrlCreateGroup("All Grids", $tX, $tY, $tGroupW, $tGroupH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
$tY += 16
Global $SendRCONAll = GUICtrlCreateButton("Send RCON", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_AllSendRCON")
GUICtrlSetTip(-1, "Send RCON Command to All Grids (Will ask Local and/or Remote grids)")
$tY += $tButtonH + $tButtonGapY
Global $SendMsgAll = GUICtrlCreateButton("Send Msg", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_AllSendMsg")
GUICtrlSetTip(-1, "Broadcast In Game Message to All Grids (Will ask Local and/or Remote grids)")
$tY += $tButtonH + $tButtonGapY
Global $SendMsgPresetAll = GUICtrlCreateButton("Preset Msg", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_AllSendPresetMsg")
GUICtrlSetTip(-1, "Broadcast In Game User-Definable Preset Message to All Grids (Will ask Local and/or Remote grids)")
$tY += $tButtonH + $tButtonGapY
Global $RemoteRestartAll = GUICtrlCreateButton("Rmt Restart", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_AllRmtRestart")
GUICtrlSetTip(-1, "Initiate Remote Restart: Restart All LOCAL Grid Servers with Message and Delay")
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$tY += $tButtonH + $tButtonGapY
Global $RestartNowAll = GUICtrlCreateButton("Restart NOW", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_AllRestartNow")
GUICtrlSetTip(-1, "Restart All LOCAL Grid Servers")
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$tY += $tButtonH + $tButtonGapY
Global $StopServerAll = GUICtrlCreateButton("Stop Servers", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_StopServerAll")
GUICtrlSetTip(-1, "Stop All LOCAL Grids With or Without Announcement")
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$tY += $tButtonH + $tButtonGapY
Global $StartServerAll = GUICtrlCreateButton("Start Servers", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_StartServerAll")
GUICtrlSetTip(-1, "Start All LOCAL Grids With or Without Announcement")
GUICtrlSetBkColor(-1, $cSWButtonStartServer)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
$tY += $tButtonH + $tButtonGapY + 8
Local $tButtons = 5, $tGroupH = (($tButtonH + $tButtonGapY) * $tButtons + 17)
Global $SelectedGrids = GUICtrlCreateGroup("Selected Grids", $tX, $tY, $tGroupW, $tGroupH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
$tY += 16
Global $SendRCONSel = GUICtrlCreateButton("Send RCON", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_SelectSendRCON")
GUICtrlSetTip(-1, "Send RCON Command to Selected Grids")
$tY += $tButtonH + $tButtonGapY
Global $SendMsgSel = GUICtrlCreateButton("Send Msg", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_SelectSendMsg")
GUICtrlSetTip(-1, "Send In Game Message to Selected Grids")
$tY += $tButtonH + $tButtonGapY
Global $SendMsgPresetSelect = GUICtrlCreateButton("Preset Msg", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_SelectSendPresetMsg")
GUICtrlSetTip(-1, "Broadcast In Game User-Definable Preset Message to Selected Grids")
$tY += $tButtonH + $tButtonGapY
Global $StopServers = GUICtrlCreateButton("Stop Server(s)", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_SelectStopServers")
GUICtrlSetTip(-1, "Stop Selected Grids With or Without Announcement")
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$tY += $tButtonH + $tButtonGapY
Global $StartServers = GUICtrlCreateButton("Start Server(s)", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_SelectStartServers")
GUICtrlSetTip(-1, "Start Selected Grids")
GUICtrlSetBkColor(-1, $cSWButtonStartServer)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
$tY += $tButtonH + $tButtonGapY + 8
Local $tButtons = 3, $tGroupH = (($tButtonH + $tButtonGapY) * $tButtons + 17)
Global $Update = GUICtrlCreateGroup("Update", $tX, $tY, $tGroupW, $tGroupH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
$tY += 16
Global $UpdateMods = GUICtrlCreateButton("Update Mods", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_ModUpdates")
GUICtrlSetTip(-1, "Check for Mod Updates")
If $aServerModYN = "no" Then GUICtrlSetState(-1, $GUI_DISABLE)
$tY += $tButtonH + $tButtonGapY
Global $UpdateAtlas = GUICtrlCreateButton("Update " & $aServerName, $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_UpdateGame")
GUICtrlSetTip(-1, "Check for " & $aServerName & " Updates")
$tY += $tButtonH + $tButtonGapY
Global $UpdateUtil = GUICtrlCreateButton("Update Util", $tX + 8, $tY, $tButtonW, $tButtonH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_UpdateUtil")
GUICtrlSetTip(-1, "Check for " & $aUtilName & " Updates")
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
Local $tY = 56, $tX = 111, $tBW = 45, $tBGap = 3
Global $GUI_Main_B_SelectAll = GUICtrlCreateButton("All", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_SelectAll")
$tX += $tBW + $tBGap
Global $GUI_Main_B_SelectNone = GUICtrlCreateButton("None", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_SelectNone")
$tX += $tBW + $tBGap
Global $GUI_Main_B_Invert = GUICtrlCreateButton("Invert", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_Invert")
$tX += $tBW + $tBGap
Global $GUI_Main_B_Local = GUICtrlCreateButton("Local", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_Local")
$tX += $tBW + $tBGap
Global $GUI_Main_B_Remote = GUICtrlCreateButton("Remote", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_Remote")
$tX += $tBW + $tBGap
Global $GUI_Main_B_PVP = GUICtrlCreateButton("PVP", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_PVP")
$tX += $tBW + $tBGap
Global $GUI_Main_B_PVE = GUICtrlCreateButton("PVE", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_PVE")
Local $tY = 56, $tX = 987, $tBW = 100, $tBGap = 3
$tX = $tX - $tBW - $tBGap
Global $GUI_Main_B_EventScheduler = GUICtrlCreateButton("Event Scheduler", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_EventScheduler")
GUICtrlSetTip(-1, "Open Event Scheduler Window")
$tX = $tX - $tBW - $tBGap
Global $GUI_Main_B_BackupMenu = GUICtrlCreateButton("Backup Menu", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_BackupMenu")
GUICtrlSetTip(-1, "Open Backup Window")
$tX = $tX - $tBW - $tBGap
Global $GUI_Main_B_GridConfigurator = GUICtrlCreateButton("Grid Configurator", $tX, $tY, $tBW, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_B_GridConfigurator")
GUICtrlSetTip(-1, "Open Grid Configurator Window. TIP: Click Server Name in main window.")
Global $wMainListViewWindow = _GUICtrlListView_Create($wGUIMainWindow, "", 112, 90, 873, 460, BitOR($LVS_NOLABELWRAP, $LVS_REPORT, $LVS_SHOWSELALWAYS, $LBS_EXTENDEDSEL, $LVS_NOSORTHEADER))
_GUICtrlListView_SetExtendedListViewStyle($wMainListViewWindow, BitOR($LVS_EX_GRIDLINES, $LVS_EX_SUBITEMIMAGES, $LVS_EX_CHECKBOXES, $LVS_EX_FULLROWSELECT, $LVS_EX_ONECLICKACTIVATE))
_GUICtrlListView_SetBkColor($wMainListViewWindow, $cSWBackground)
_GUICtrlListView_SetTextBkColor($wMainListViewWindow, $cSWBackground)
GUICtrlSetFont(-1, 9, 400, 0, "MS Sans Serif")
Global $aGUI_Main_Columns[12] = ["", "Run", "Local", "Rmt", "Server Name", "Grid", "Players", "CPU %", "Mem MB", "Folder", "PID", "Status"]
Global $aGUI_Main_Widths[12] = [21, 32, 38, 38, 320, 35, 60, 50, 60, 60, 60, 70]
For $i = 0 To (UBound($aGUI_Main_Columns) - 1)
_GUICtrlListView_InsertColumn($wMainListViewWindow, $i, $aGUI_Main_Columns[$i], $aGUI_Main_Widths[$i])
_GUICtrlListView_JustifyColumn($wMainListViewWindow, $i, 2)
Next
Local $tW1 = 24, $tH1 = 16
Global $hImage = _GUIImageList_Create($tW1, $tH1, 5)
_ImageToGUIImageListResized($hImage, $aFolderTemp & "i_toggle_on_left0.png", $tW1, $tH1)
_ImageToGUIImageListResized($hImage, $aFolderTemp & "i_toggle_off_left0.png", $tW1, $tH1)
_ImageToGUIImageListResized($hImage, $aFolderTemp & "i_button_green_left1.png", $tW1, $tH1)
_ImageToGUIImageListResized($hImage, $aFolderTemp & "i_button_red_left1.png", $tW1, $tH1)
_ImageToGUIImageListResized($hImage, $aFolderTemp & "i_check_green_left1.png", $tW1, $tH1)
_ImageToGUIImageListResized($hImage, $aFolderTemp & "i_check_gray_left1.png", $tW1, $tH1)
_GUICtrlListView_SetImageList($wMainListViewWindow, $hImage, 1)
Global $aMainLVW[$aServerGridTotal][12]
For $i = 0 To ($aServerGridTotal - 1)
$aMainLVW[$i][0] = ""
If $xStartGrid[$i] <> "yes" Then
$aMainLVW[$i][1] = "--"
Else
$aMainLVW[$i][1] = $xStartGrid[$i]
EndIf
If $xLocalGrid[$i] <> "yes" Then
$aMainLVW[$i][2] = "yes"
$aMainLVW[$i][3] = "--"
Else
$aMainLVW[$i][2] = "--"
$aMainLVW[$i][3] = "yes"
EndIf
$aMainLVW[$i][4] = $xServerNames[$i]
$aMainLVW[$i][5] = _ServerNamingScheme($i, $aNamingScheme)
If (UBound($aServerPlayers) = $aServerGridTotal) And ($aServerPlayers[$i] > -1) Then
$aMainLVW[$i][6] = $aServerPlayers[$i] & " / " & $aServerMaxPlayers
Else
$aMainLVW[$i][6] = "-- / " & $aServerMaxPlayers
EndIf
If $xStartGrid[$i] = "yes" Then
$aMainLVW[$i][7] = "--"
Local $aMemTmp = ($aServerMem[$i] / (1024 ^ 2))
$aMainLVW[$i][8] = _AddCommasDecimalNo($aMemTmp) & " MB"
Else
$aMainLVW[$i][7] = ""
$aMainLVW[$i][8] = ""
EndIf
$aMainLVW[$i][9] = $xServerAltSaveDir[$i]
$aMainLVW[$i][10] = $aServerPID[$i]
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
$aMainLVW[$i][11] = "Running"
Else
If $xStartGrid[$i] = "yes" Then
$aMainLVW[$i][11] = "CRASHED"
Else
If $xLocalGrid[$i] = "yes" Then
$aMainLVW[$i][11] = "Disabled"
Else
$aMainLVW[$i][11] = "Offline"
If $aServerOnlinePlayerYN = "yes" Then $aMainLVW[$i][11] = "Poll Off"
If (UBound($aServerPlayers) = $aServerGridTotal) And ($aServerPlayers[$i] > -1) And ($aServerOnlinePlayerYN = "yes") Then
$aMainLVW[$i][11] = "Running"
EndIf
EndIf
EndIf
EndIf
Local $aString = ""
For $x = 0 To 10
$aString &= $aMainLVW[$i][$x] & "|"
Next
$aString &= $aMainLVW[$i][11]
_GUICtrlListView_AddItem($wMainListViewWindow, "", 0)
For $x = 4 To 11
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, $aMainLVW[$i][$x], $x)
Next
Next
For $i = 0 To ($aServerGridTotal - 1)
If $xStartGrid[$i] = "yes" Then
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, "", 1, 0)
Else
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, "", 1, 1)
EndIf
Next
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, "", 2, 4)
Else
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, "", 3, 5)
EndIf
Next
Global $aGUIListViewEX = _GUIListViewEx_Init($wMainListViewWindow, $aMainLVW, 0, 0, True, 32 + 1024)
_GUIListViewEx_SetEditStatus($aGUIListViewEX, "*", 0)
Local $aSelCol[4] = [Default, $cSWBackground, Default, Default]
_GUIListViewEx_SetDefColours($aGUIListViewEX, $aSelCol)
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWRunning & ";", $i, 11)
Else
If $xStartGrid[$i] = "yes" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWCrashed & ";", $i, 11)
Else
If $xLocalGrid[$i] = "yes" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWDisabled & ";", $i, 11)
Else
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWOffline & ";", $i, 11)
If (UBound($aServerPlayers) = $aServerGridTotal) And ($aServerPlayers[$i] > -1) And ($aServerOnlinePlayerYN = "yes") Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWRunning & ";", $i, 11)
EndIf
EndIf
EndIf
EndIf
Next
_GUIListViewEx_MsgRegister()
Global $UpdateIntervalLabel = GUICtrlCreateLabel("Player Update Interval (sec)", 710, 568)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
Global $UpdateIntervalSlider = GUICtrlCreateSlider(848, 565, 102, 21, BitOR($GUI_SS_DEFAULT_SLIDER, $TBS_NOTICKS))
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_S_UpdateIntervalSlider")
GUICtrlSetLimit(-1, 600, 30)
GUICtrlSetData(-1, $aServerOnlinePlayerSec)
GUICtrlSetTip(-1, "Seconds: 30-600")
GUICtrlSetBkColor(-1, $cMWBackground)
Global $UpdateIntervalEdit = GUICtrlCreateEdit("", 952, 568, 33, 17, BitOR($ES_CENTER, $ES_WANTRETURN))
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_E_UpdateIntervalEdit")
GUICtrlSetData(-1, $aServerOnlinePlayerSec)
GUICtrlSetBkColor(-1, $cSWBackground)
GUICtrlSetTip(-1, "Seconds: 30-600")
Global $IconRefreshPlayers = GUICtrlCreateIcon($aIconFile, 205, 558, 567, 16, 16)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_I_IconRefreshPlayers")
GUICtrlSetTip(-1, "Check for Online Players")
Global $gPollOnlinePlayers = GUICtrlCreateCheckbox("Poll Online Players", 580, 564)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "GUI_Main_CB_PollOnlinePLayers")
If $aServerOnlinePlayerYN = "yes" Then
GUICtrlSetState(-1, $GUI_CHECKED)
Else
GUICtrlSetState(-1, $GUI_UNCHECKED)
EndIf
$IconReady = GUICtrlCreateIcon($aIconFile, 204, 113, 563, 24, 24)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
Global $LabelUtilReadyStatus = GUICtrlCreateLabel("Idle", 144, 568, 130, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
Global $gPollRemoteServersCB = GUICtrlCreateCheckbox("Poll Remote Servers", 305, 564)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
GUICtrlSetOnEvent($aPollRemoteServersYN, "GUI_Main_CB_PollRemoteServers")
If $aPollRemoteServersYN = "yes" Then
GUICtrlSetState($gPollRemoteServersCB, $GUI_CHECKED)
Else
GUICtrlSetState($gPollRemoteServersCB, $GUI_UNCHECKED)
EndIf
Global $gPollRemoteServersLabel = GUICtrlCreateLabel("Poll Remote Servers", 320, 568, -1, -1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
Global $LabelTotalPlayers = GUICtrlCreateLabel("Total Players: ", 432, 568, 71, 17)
GUICtrlSetResizing(-1, $GUI_DOCKHCENTER + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
Global $TotalPlayersEdit = GUICtrlCreateEdit("", 504, 566, 35, 17, BitOR($ES_CENTER, $ES_READONLY))
GUICtrlSetResizing(-1, $GUI_DOCKHCENTER + $GUI_DOCKBOTTOM + $GUI_DOCKSIZE)
GUICtrlSetState($TotalPlayersEdit, $GUI_FOCUS)
DllCall('user32.dll', 'int', 'HideCaret', 'hwnd', '')
GUICtrlSetData(-1, $aTotalPlayersOnline)
GUICtrlSetBkColor(-1, $cLWBackground)
GUICtrlSetTip(-1, "Total Players Online")
#EndRegion ### END Koda GUI section ###
If $aServerOnlinePlayerYN = "yes" Then
$aOnlinePlayers = GetPlayerCount($tSplash)
GUICtrlSetData($LabelUtilReadyStatus, "Idle")
EndIf
$aStartText = $aUtilName & " " & $aUtilVersion & " started." & @CRLF & @CRLF
If $tSplash > 0 Then ControlSetText($tSplash, "", "Static1", $aStartText & "Preparing Main Window Data.")
GUIUpdateQuick()
If $aShowGUI Then
GUISetState(@SW_SHOWNORMAL, $wGUIMainWindow)
Else
GUISetState(@SW_HIDE, $wGUIMainWindow)
EndIf
If $aServerOnlinePlayerYN = "yes" Then
ShowPlayerCount()
EndIf
SetStatusIdle()
EndFunc
Func GUI_Main_L_Column()
EndFunc
Func GUIUpdateQuick()
SetStatusBusy("Server process check in progress...", "Updating Main Window")
SetStatusBusy("Server process check in progress...", "Updating: Mem & CPU")
Local $aUpdateBatchFiles = False
Local $MemStats = MemGetStats()
GUICtrlSetData($MemPercent, $MemStats[$MEM_LOAD] & "%")
Local $tCPU = _CPUOverallUsageTracker_GetUsage($aCPUOverallTracker)
GUICtrlSetData($CPUPercent, Int($tCPU) & "%")
Local $tMainLVW[$aServerGridTotal][12]
$aServerPI_Stripped = ResizeArray($aServerPID, $aServerGridTotal)
$aServerMem = _GetMemArrayRawAvg($aServerPI_Stripped)
SetStatusBusy("Server process check in progress...", "Updating: Info Window")
Local $tTotalPlayers = 0
$tTotalLocalPlayers = 0
Local $tTotalPlayerError = False
Local $aHasRemoteServersTF = False
$aGridSomeRemoteTF = False
For $i = 0 To ($aServerGridTotal - 1)
SetStatusBusy("Server process check in progress...", "Updating: Data Grid " & _ServerNamingScheme($i, $aNamingScheme))
If $xStartGrid[$i] <> "yes" Then
$tMainLVW[$i][1] = "--"
Else
$tMainLVW[$i][1] = $xStartGrid[$i]
EndIf
If $xLocalGrid[$i] <> "yes" Then
$tMainLVW[$i][2] = "--"
$tMainLVW[$i][3] = "yes"
$aGridSomeRemoteTF = True
Else
$tMainLVW[$i][2] = "yes"
$tMainLVW[$i][3] = "--"
EndIf
$tMainLVW[$i][4] = $xServerNames[$i]
$tMainLVW[$i][5] = _ServerNamingScheme($i, $aNamingScheme)
If (UBound($aServerPlayers) = $aServerGridTotal) And ($aServerPlayers[$i] > -1) And $aServerOnlinePlayerYN = "yes" Then
$tMainLVW[$i][6] = $aServerPlayers[$i] & " / " & $aServerMaxPlayers
Else
$tMainLVW[$i][6] = "-- / " & $aServerMaxPlayers
EndIf
If $xStartGrid[$i] = "yes" Then
Local $tCPU = _ProcessUsageTracker_GetUsage($xServerCPU[$i])
$tMainLVW[$i][7] = Round($tCPU, 1) & "%"
Local $aMemTmp = ($aServerMem[$i] / (1024 ^ 2))
$tMainLVW[$i][8] = _AddCommasDecimalNo($aMemTmp)
Else
$tMainLVW[$i][7] = ""
$tMainLVW[$i][8] = ""
EndIf
$tMainLVW[$i][9] = $xServerAltSaveDir[$i]
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
$tMainLVW[$i][11] = "Running"
$aCloseServerTF = False
Else
$aServerPID[$i] = ""
If $xStartGrid[$i] = "yes" And $xLocalGrid[$i] = "yes" Then
If $aCloseServerTF Then
$tMainLVW[$i][11] = "Starting"
LogWrite(" Server [" & _ServerNamingScheme($i, $aNamingScheme) & "] PID [" & $aMainLVW[$i][10] & "] """ & $xServerNames[$i] & """ restarting.")
Else
$tMainLVW[$i][11] = "CRASHED"
LogWrite(" WARNING!!! Server [" & _ServerNamingScheme($i, $aNamingScheme) & "] PID [" & $aMainLVW[$i][10] & "] """ & $xServerNames[$i] & """ CRASHED, Restarting server")
EndIf
Else
If $xLocalGrid[$i] = "yes" Then
$tMainLVW[$i][11] = "Disabled"
Else
$aHasRemoteServersTF = True
If (UBound($aServerPlayers) = $aServerGridTotal) And ($aServerPlayers[$i] > -1) And ($aServerOnlinePlayerYN = "yes") Then
$tMainLVW[$i][11] = "Running"
Else
If $aPollRemoteServersYN = "yes" Then
$tMainLVW[$i][11] = "Offline"
Else
$tMainLVW[$i][11] = "Poll Off"
EndIf
EndIf
EndIf
EndIf
EndIf
If $tMainLVW[$i][11] <> $aMainLVW[$i][11] Then
If $tMainLVW[$i][11] = "Offline" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWOffline & ";", $i, 11)
ElseIf $tMainLVW[$i][11] = "Running" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWRunning & ";", $i, 11)
ElseIf $tMainLVW[$i][11] = "Starting" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWStarting & ";", $i, 11)
ElseIf $tMainLVW[$i][11] = "CRASHED" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWCrashed & ";", $i, 11)
ElseIf $tMainLVW[$i][11] = "Offline" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWOffline & ";", $i, 11)
ElseIf $tMainLVW[$i][11] = "Poll Off" Then
_GUIListViewEx_SetColour($aGUIListViewEX, $cSWDisabled & ";", $i, 11)
EndIf
EndIf
$tMainLVW[$i][10] = $aServerPID[$i]
For $x = 1 To 2
If $tMainLVW[$i][$x] <> $aMainLVW[$i][$x] Then
$aMainLVW[$i][$x] = $tMainLVW[$i][$x]
$aUpdateBatchFiles = True
EndIf
Next
For $x = 4 To 11
If $tMainLVW[$i][$x] <> $aMainLVW[$i][$x] Then
$aMainLVW[$i][$x] = $tMainLVW[$i][$x]
_GUICtrlListView_SetItemText($wMainListViewWindow, $i, $aMainLVW[$i][$x], $x)
EndIf
Next
If $aServerPlayers[$i] > -1 Then
$tTotalPlayers += $aServerPlayers[$i]
If $xLocalGrid[$i] And $xStartGrid[$i] Then $tTotalLocalPlayers += $aServerPlayers[$i]
Else
If $tMainLVW[$i][11] = "Offline" Then
$tTotalPlayerError = True
EndIf
EndIf
If $tMainLVW[$i][1] <> $aMainLVW[$i][1] Then
$aMainLVW[$i][1] = $tMainLVW[$i][1]
If $xStartGrid[$i] = "yes" Then
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, "", 1, 0)
Else
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, "", 1, 1)
EndIf
EndIf
If $tMainLVW[$i][2] <> $aMainLVW[$i][2] Then
$aMainLVW[$i][2] = $tMainLVW[$i][2]
If $xLocalGrid[$i] = "yes" Then
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, "", 2, 4)
Else
_GUICtrlListView_AddSubItem($wMainListViewWindow, $i, "", 3, 5)
EndIf
EndIf
Next
If $aUpdateBatchFiles Then
SetStatusBusy("Server process check in progress...", "Updating: Batch Files")
BatchFilesCreate()
EndIf
$aTotalPlayersOnline = $tTotalPlayers
SetStatusBusy("Server process check in progress...", "Updating: Online Players")
If $tTotalPlayerError Then $aTotalPlayersOnline = "--"
GUICtrlSetData($TotalPlayersEdit, $aTotalPlayersOnline)
If $tUtilUpdateAvailableTF Then
GUICtrlSetImage($IconUpdate, $aIconFile, 216)
GUICtrlSetTip($IconUpdate, $aUtilName & " update available")
Else
GUICtrlSetImage($IconUpdate, $aIconFile, 205)
GUICtrlSetTip($IconUpdate, "Check for Updates for " & $aUtilName)
EndIf
SetStatusBusy("Server process check in progress...", "Updating: " & $aGameName & " Version")
For $i = 0 To ($aServerGridTotal - 1)
If ProcessExists($aServerPID[$i]) And $xLocalGrid[$i] = "yes" Then
Local $tAtlasProcessName = WinGetTitle(_WinGetByPID($aServerPID[$i]))
ExitLoop
Else
Local $tAtlasProcessName = "ShooterGameServer.exe v0.0 ("
EndIf
Next
$tAtlasVer = _ArrayToString(_StringBetween($tAtlasProcessName, "ShooterGameServer.exe ", " ("))
Local $tTitle = $aUtilityVer & " | Atlas Version:" & $tAtlasVer & " | " & $aServerWorldFriendlyName
WinSetTitle($wGUIMainWindow, "", $tTitle)
If $tAtlasVer = "v0.0" Then
$tAtlasVer = _ArrayToString(_StringBetween($tAtlasProcessName, "ShooterGameServer.exe ", " ("))
Local $tTitle = $aUtilityVer & " | Atlas Version:" & $tAtlasVer & " | " & $aServerWorldFriendlyName
WinSetTitle($wGUIMainWindow, "", $tTitle)
EndIf
If FileExists($aExportMainGUIGridFile) Then
FileDelete($aExportMainGUIGridFile)
EndIf
SetStatusBusy("Server process check in progress...", "Updating: Export Data")
_FileWriteFromArray($aExportMainGUIGridFile, $tMainLVW)
EndFunc
Func _GUICtrlTab_SetBkColor($hWnd, $hSysTab32, $sBkColor)
Local $aTabPos = ControlGetPos($hWnd, "", $hSysTab32)
Local $aTab_Rect = _GUICtrlTab_GetItemRect($hSysTab32, -1)
GUICtrlCreateLabel("", $aTabPos[0] + 2, $aTabPos[1] + $aTab_Rect[3] + 4, $aTabPos[2] - 6, $aTabPos[3] - $aTab_Rect[3] - 7)
GUICtrlSetBkColor(-1, $sBkColor)
GUICtrlSetState(-1, $GUI_DISABLE)
EndFunc
Func LogWindow($lDefaultTabNo = 1)
If WinExists($LogWindow) Then
Else
#Region ### START Koda GUI section ### Form=g:\game server files\autoit\atlasserverupdateutility\temp work files\atladkoda(log-b1).kxf
Local $lWidth = 1000, $lHeight = 600
Global $LogWindow = GUICreate($aUtilityVer & " Logs & Full Config Files", $lWidth, $lHeight, -1, -1, BitOR($GUI_SS_DEFAULT_GUI, $WS_MAXIMIZEBOX, $WS_SIZEBOX, $WS_THICKFRAME, $WS_TABSTOP))
GUISetIcon($aIconFile, 99)
GUISetBkColor($cMWBackground)
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_Log_Close", $LogWindow)
$lLogTabWindow = GUICtrlCreateTab(8, 8, ($lWidth - 17), ($lHeight - 18))
GUICtrlSetResizing(-1, $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
$lBasicTab = GUICtrlCreateTabItem("Basic Log")
If $lDefaultTabNo = 1 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lBasicEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $ES_READONLY + $WS_HSCROLL + $WS_VSCROLL + $ES_MULTILINE)
GUICtrlSetResizing($lBasicEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor($lBasicEdit, $cFWBackground)
_GUICtrlEdit_SetLimitText($lBasicEdit, 500000)
Local $tFileOpen = FileOpen($aLogFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lBasicEdit, $tTxt)
Global $lBasicBDay[7], $lBasicDDate[7]
Local $lX = 12
$lBasicDDate[0] = _NowCalcDate()
$lBasicBDay[0] = GUICtrlCreateButton("Today", $lX, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_Basic_B_Button")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetFont(-1, -1, $FW_EXTRABOLD)
For $i = 1 To 6
$lBasicDDate[$i] = _DateAdd('d', (0 - $i), _NowCalcDate())
$lBasicBDay[$i] = GUICtrlCreateButton(StringTrimLeft($lBasicDDate[$i], 5), ($lX + (80 * $i)), 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_Basic_B_Button")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Next
$lDetailedTab = GUICtrlCreateTabItem("Detailed Log")
If $lDefaultTabNo = 2 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lDetailedEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $ES_READONLY + $WS_HSCROLL + $WS_VSCROLL + $ES_MULTILINE)
GUICtrlSetResizing($lDetailedEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor($lDetailedEdit, $cFWBackground)
_GUICtrlEdit_SetLimitText($lDetailedEdit, 500000)
Local $tFileOpen = FileOpen($aLogDebugFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lDetailedEdit, $tTxt)
Global $lDetailedBDay[7], $lDetailedDDate[7]
Local $lX = 12
$lDetailedDDate[0] = _NowCalcDate()
$lDetailedBDay[0] = GUICtrlCreateButton("Today", $lX, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_Detailed_B_Button")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetFont(-1, -1, $FW_EXTRABOLD)
For $i = 1 To 6
$lDetailedDDate[$i] = _DateAdd('d', (0 - $i), _NowCalcDate())
$lDetailedBDay[$i] = GUICtrlCreateButton(StringTrimLeft($lDetailedDDate[$i], 5), ($lX + (80 * $i)), 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_Detailed_B_Button")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Next
$lOnlinePlayersTab = GUICtrlCreateTabItem("OnlinePlayers Log")
If $lDefaultTabNo = 3 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lOnlinePlayersEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $ES_READONLY + $WS_HSCROLL + $WS_VSCROLL + $ES_MULTILINE)
GUICtrlSetResizing($lOnlinePlayersEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor($lOnlinePlayersEdit, $cFWBackground)
_GUICtrlEdit_SetLimitText($lOnlinePlayersEdit, 500000)
Local $tFileOpen = FileOpen($aOnlinePlayerFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($lOnlinePlayersEdit, $tTxt)
Global $lOnlinePlayersBDay[7], $lOnlinePlayersDDate[7]
Local $lX = 12
$lOnlinePlayersDDate[0] = _NowCalcDate()
$lOnlinePlayersBDay[0] = GUICtrlCreateButton("Today", $lX, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_OnlinePlayers_B_Button")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetFont(-1, -1, $FW_EXTRABOLD)
For $i = 1 To 6
$lOnlinePlayersDDate[$i] = _DateAdd('d', (0 - $i), _NowCalcDate())
$lOnlinePlayersBDay[$i] = GUICtrlCreateButton(StringTrimLeft($lOnlinePlayersDDate[$i], 5), ($lX + (80 * $i)), 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_OnlinePlayers_B_Button")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Next
Global $lServerSummaryTab = GUICtrlCreateTabItem("Server Summary")
If $lDefaultTabNo = 4 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lServerSummaryEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $ES_READONLY + $WS_HSCROLL + $WS_VSCROLL + $ES_MULTILINE)
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor($lServerSummaryEdit, $cFWBackground)
_GUICtrlEdit_SetLimitText($lServerSummaryEdit, 500000)
Local $tFileOpen = FileOpen($aServerSummaryFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetFont($lServerSummaryEdit, 9, 400, 0, $fFWFixedFont)
GUICtrlSetData($lServerSummaryEdit, $tTxt)
Global $lServerSummaryBRefresh = GUICtrlCreateButton("Refresh", 12, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_ServerSummary_B_Button")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$lConfigTab = GUICtrlCreateTabItem("AtlasServerUpdateUtility.ini")
If $lDefaultTabNo = 5 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lConfigEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $WS_HSCROLL + $WS_VSCROLL + $ES_WANTRETURN + $ES_MULTILINE)
GUICtrlSetResizing($lConfigEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
_GUICtrlEdit_SetLimitText($lConfigEdit, 500000)
GUICtrlSetBkColor($lConfigEdit, $cFWBackground)
Local $tFileOpen = FileOpen($aIniFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetFont($lConfigEdit, 9, 400, 0, $fFWFixedFont)
GUICtrlSetData($lConfigEdit, $tTxt)
Global $lConfigIniBSave = GUICtrlCreateButton("Save", 12, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_Config_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $lConfigINIBReset = GUICtrlCreateButton("Reset", 92, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_Config_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $lWidth - 25 - $tButtonW - $tButtonGapY, $gY = 41
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T1_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T1_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
$lGridSelectTab = GUICtrlCreateTabItem("GridStartSelect.ini")
If $lDefaultTabNo = 6 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lGridSelectEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $WS_HSCROLL + $WS_VSCROLL + $ES_WANTRETURN + $ES_MULTILINE)
GUICtrlSetResizing($lGridSelectEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
_GUICtrlEdit_SetLimitText($lGridSelectEdit, 500000)
GUICtrlSetBkColor($lGridSelectEdit, $cFWBackground)
Local $tFileOpen = FileOpen($aGridSelectFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetFont($lGridSelectEdit, 9, 400, 0, $fFWFixedFont)
GUICtrlSetData($lGridSelectEdit, $tTxt)
Global $lGridStartSelectBSave = GUICtrlCreateButton("Save", 12, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_GridSelect_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $lGridStartSelectBReset = GUICtrlCreateButton("Reset", 92, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_GridSelect_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $lWidth - 25 - $tButtonW - $tButtonGapY, $gY = 41
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T1_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T1_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
$lServerGridTab = GUICtrlCreateTabItem("ServerGrid.json")
If $lDefaultTabNo = 7 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lServerGridEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $WS_HSCROLL + $WS_VSCROLL + $ES_WANTRETURN + $ES_MULTILINE)
GUICtrlSetResizing($lServerGridEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
_GUICtrlEdit_SetLimitText($lServerGridEdit, 9999999)
GUICtrlSetBkColor($lServerGridEdit, $cFWBackground)
Local $tFileOpen = FileOpen($aConfigFull)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetFont($lServerGridEdit, 9, 400, 0, $fFWFixedFont)
GUICtrlSetData($lServerGridEdit, $tTxt)
Global $lServerGridBSave = GUICtrlCreateButton("Save", 12, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_ServerGrid_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $lServerGridBReset = GUICtrlCreateButton("Reset", 92, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_ServerGrid_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $lWidth - 25 - $tButtonW - $tButtonGapY, $gY = 41
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T1_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T1_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
$lDefaultGameTab = GUICtrlCreateTabItem("DefaultGame.ini")
If $lDefaultTabNo = 8 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lDefaultGameEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $WS_HSCROLL + $WS_VSCROLL + $ES_WANTRETURN + $ES_MULTILINE)
GUICtrlSetResizing($lDefaultGameEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
_GUICtrlEdit_SetLimitText($lDefaultGameEdit, 500000)
GUICtrlSetBkColor($lDefaultGameEdit, $cFWBackground)
Local $tFileOpen = FileOpen($aDefaultGame)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetFont($lDefaultGameEdit, 9, 400, 0, $fFWFixedFont)
GUICtrlSetData($lDefaultGameEdit, $tTxt)
Global $lDefaultGameBSave = GUICtrlCreateButton("Save", 12, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_DefaultGame_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $lDefaultGameBReset = GUICtrlCreateButton("Reset", 92, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_DefaultGame_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $lWidth - 25 - $tButtonW - $tButtonGapY, $gY = 41
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T1_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T1_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
$lDefaultGUSTab = GUICtrlCreateTabItem("DefaultGUS.ini")
If $lDefaultTabNo = 9 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lDefaultGUSEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $WS_HSCROLL + $WS_VSCROLL + $ES_WANTRETURN + $ES_MULTILINE)
GUICtrlSetResizing($lDefaultGUSEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
_GUICtrlEdit_SetLimitText($lDefaultGUSEdit, 500000)
GUICtrlSetBkColor($lDefaultGUSEdit, $cFWBackground)
Local $tFileOpen = FileOpen($aDefaultGUS)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetFont($lDefaultGUSEdit, 9, 400, 0, $fFWFixedFont)
GUICtrlSetData($lDefaultGUSEdit, $tTxt)
Global $lDefaultGUSBSave = GUICtrlCreateButton("Save", 12, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_DefaultGUS_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $lDefaultGUSBReset = GUICtrlCreateButton("Reset", 92, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_DefaultGUS_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $lWidth - 25 - $tButtonW - $tButtonGapY, $gY = 41
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T1_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T1_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
$lDefaultEngineTab = GUICtrlCreateTabItem("DefaultEngine.ini")
If $lDefaultTabNo = 10 Then GUICtrlSetState(-1, $GUI_SHOW)
Global $lDefaultEngineEdit = GUICtrlCreateEdit("", 12, 73, ($lWidth - 25), ($lHeight - 90), $WS_HSCROLL + $WS_VSCROLL + $ES_WANTRETURN + $ES_MULTILINE)
GUICtrlSetResizing($lDefaultEngineEdit, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
_GUICtrlEdit_SetLimitText($lDefaultEngineEdit, 500000)
GUICtrlSetBkColor($lDefaultEngineEdit, $cFWBackground)
Local $tFileOpen = FileOpen($aDefaultEngine)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetFont($lDefaultEngineEdit, 9, 400, 0, $fFWFixedFont)
GUICtrlSetData($lDefaultEngineEdit, $tTxt)
Global $lDefaultEngineBSave = GUICtrlCreateButton("Save", 12, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_DefaultEngine_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $lDefaultEngineBReset = GUICtrlCreateButton("Reset", 92, 41, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_Log_DefaultEngine_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKTOP + $GUI_DOCKLEFT + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $lWidth - 25 - $tButtonW - $tButtonGapY, $gY = 41
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T1_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T1_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
GUICtrlCreateTabItem("")
GUISetState(@SW_SHOW)
EndIf
#EndRegion ### END Koda GUI section ###
EndFunc
Func WM_NOTIFY_Main_UpdateIntervalSlider($hWnd, $iMsg, $iWParam, $iLParam)
Local $iWLoWord = BitAND($iWParam, 0xFFFF)
If $iWLoWord = $UpdateIntervalSlider Then
GUICtrlSetData($UpdateIntervalEdit, GUICtrlRead($UpdateIntervalSlider))
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func WizardSelect()
If WinExists($WizardWindowSelect) Then
Else
If WinExists($WizardWindowExist) Then GUIDelete($WizardWindowExist)
If WinExists($WizardWindowNew) Then GUIDelete($WizardWindowExist)
$WizardWindowSelect = GUICreate("AtlasServerUpdateUtility Setup Wizard", 906, 555, -1, -1, BitOR($GUI_SS_DEFAULT_GUI, $WS_SIZEBOX, $WS_THICKFRAME, $WS_TABSTOP))
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_WizardSelect_Close", $WizardWindowSelect)
GUISetIcon($aIconFile, 99)
GUISetBkColor($cW1Background)
$Group1 = GUICtrlCreateGroup("Group1", 192, -32, 1, 33)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$Group2 = GUICtrlCreateGroup("AtlasServerUpdateUtility", 48, 40, 809, 337)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
$Label1 = GUICtrlCreateLabel("Welcome to the AtlasServerupdateUtility setup wizard!", 172, 123, 526, 29)
GUICtrlSetFont(-1, 16, 800, 4, "MS Sans Serif")
$Label2 = GUICtrlCreateLabel("Please select from the following:", 308, 223, 272, 28)
GUICtrlSetFont(-1, 14, 400, 0, "MS Sans Serif")
Global $W1_B_New = GUICtrlCreateButton("New Install", 299, 267, 115, 33)
GUICtrlSetOnEvent(-1, "GUI_W1_B_NewInstall")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
Global $W1_B_Exist = GUICtrlCreateButton("Existing Server", 475, 267, 115, 33)
GUICtrlSetOnEvent(-1, "GUI_W1_B_Existing")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUISetState(@SW_SHOW)
#EndRegion ### END Koda GUI section ###
If WinExists($wGUIMainWindow) Then
Else
While $aExitGUIW1 = False
Sleep(100)
WEnd
GUIDelete($WizardWindowSelect)
$aExitGUIW1 = False
If $aWizardSelect = 2 Then WizardExisting(1)
If $aWizardSelect = 3 Then WizardNew()
EndIf
EndIf
EndFunc
Func GUI_WizardSelect_Close()
$aExitGUIW1 = True
$aWizardSelect = 1
If WinExists($wGUIMainWindow) Then
GUIDelete($WizardWindowSelect)
$aExitGUIW1 = False
Else
_ExitUtil()
EndIf
EndFunc
Func GUI_W1_B_Existing()
GUIDelete($WizardWindowSelect)
$aExitGUIW1 = True
If WinExists($wGUIMainWindow) Then
WizardExisting(1)
Else
$aWizardSelect = 2
EndIf
EndFunc
Func GUI_W1_B_NewInstall()
GUIDelete($WizardWindowSelect)
$aExitGUIW1 = True
If WinExists($wGUIMainWindow) Then
WizardNew()
Else
$aWizardSelect = 3
EndIf
EndFunc
Func WizardExisting($wDefaultTabNo = 1)
If WinExists($WizardWindowExist) Then
Else
Global $aGUI_W2_LastTab = $wDefaultTabNo - 1
Global $aGUI_W2_T4_GridStartClicked = False
Global $aGUI_W2_T6_ConfigClicked = False
If WinExists($wGUIMainWindow) Then $aConfigSettingsImported = True
If $wDefaultTabNo > 1 Then $aConfigSettingsImported = True
$WizardWindowExist = GUICreate("AtlasServerUpdateUtility Setup Wizard", 906, 555, -1, -1)
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_WizardExist_Close", $WizardWindowExist)
GUISetIcon($aIconFile, 99)
GUISetBkColor($cW2Background)
Global $WizardTabWindow = GUICtrlCreateTab(8, 8, 889, 537)
GUICtrlSetOnEvent(-1, "GUI_W2_On_Tab")
GUICtrlSetResizing(-1, $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $Tab1 = GUICtrlCreateTabItem("1 Atlas Folder")
If $wDefaultTabNo = 1 Then GUICtrlSetState(-1, $GUI_SHOW)
$Label1 = GUICtrlCreateLabel("Welcome to the AtlasServerUpdateUtility install Wizard.", 72, 64, 537, 29)
GUICtrlSetFont(-1, 16, 800, 0, "MS Sans Serif")
$Label2 = GUICtrlCreateLabel("Please select the Atlas Dedicated Server installation folder: ", 104, 192, 358, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W2_T1_B_ImportSettings = GUICtrlCreateButton("Import Settings", 105, 370, 179, 25)
GUICtrlSetOnEvent(-1, "GUI_W2_T1_B_ImportSettings")
Global $W2_T1_B_SelectFolder = GUICtrlCreateButton("Select Folder", 684, 225, 107, 25)
GUICtrlSetOnEvent(-1, "GUI_W2_T1_B_SelectFolder")
$Label3 = GUICtrlCreateLabel("Click below to import existing settings from the " & $aConfigFile & " file.", 104, 336, 392, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
$Label4 = GUICtrlCreateLabel("Step 1", 72, 160, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$Label5 = GUICtrlCreateLabel("Step 2", 72, 294, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
Global $W2_T1_I_AtlasDIR = GUICtrlCreateInput($aServerDirLocal, 108, 225, 569, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T1_I_AtlasDIR")
$Label32 = GUICtrlCreateLabel("For existing servers.", 504, 104, 173, 28)
GUICtrlSetFont(-1, 14, 400, 0, "MS Sans Serif")
Global $Tab2 = GUICtrlCreateTabItem("2 AltSaveDIR")
If $wDefaultTabNo = 2 Then GUICtrlSetState(-1, $GUI_SHOW)
$Group1 = GUICtrlCreateGroup("AltSaveDIR", 76, 89, 753, 369)
Global $W2_T2_R_Default00 = GUICtrlCreateRadio("Default Scheme: 00,01,02,10,11,12", 100, 169, 209, 17)
GUICtrlSetOnEvent(-1, "GUI_W2_T2_R_Default00")
Global $W2_T2_R_DefaultA1 = GUICtrlCreateRadio("Default Scheme: A1,A2,A3,B1,B2,B3", 100, 201, 281, 17)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "GUI_W2_T2_R_DefaultA10")
Global $W2_T2_R_Custom1 = GUICtrlCreateRadio("Custom Method 1: Direct listing of Folders", 100, 233, 217, 17)
GUICtrlSetOnEvent(-1, "GUI_W2_T2_R_Custom1")
GUICtrlSetState(-1, $GUI_CHECKED)
Global $W2_T2_R_Custom2 = GUICtrlCreateRadio("Custom Method 2: Enter folders one-at-a-time using a new popup window for each server.  (Coming soon!)", 100, 337, 600, 17)
GUICtrlSetOnEvent(-1, "GUI_W2_T2_R_Custom2")
$Label6 = GUICtrlCreateLabel("Server AltSaveDirectoryName(s) (comma separated. Use same order as servers are listed in ServerGrid.json) ex.A1,A2,A3,B1,B2,B3,C1,C2,C3", 116, 257, 700, 17)
AutoSetAltSaveDIR()
Global $W2_T2_B_Folders = GUICtrlCreateButton("Enter Folders", 116, 361, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_W2_T2_B_Folders")
Global $W2_T2_I_AltSaveDIR2 = GUICtrlCreateInput($aServerAltSaveDir, 200, 363, 541, 21)
GUICtrlSetState(-1, $GUI_DISABLE)
$Label8 = GUICtrlCreateLabel("Please select the naming scheme for the grid server folders:", 100, 129, 358, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W2_T2_I_AltSaveDIR = GUICtrlCreateInput($aServerAltSaveDir, 116, 281, 625, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T2_I_AltSaveDIR")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$Label22 = GUICtrlCreateLabel("Step 3", 36, 49, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
Global $Tab3 = GUICtrlCreateTabItem("3 RCON Ports")
If $wDefaultTabNo = 3 Then GUICtrlSetState(-1, $GUI_SHOW)
$Group2 = GUICtrlCreateGroup("RCON Ports", 76, 193, 753, 329)
Global $W2_T3_R_Import = GUICtrlCreateRadio("Import RCON ports from each grid server's GameUserSettings.ini file.", 100, 281, 361, 17)
GUICtrlSetOnEvent(-1, "GUI_W2_T3_R_Import")
Global $W2_T3_R_Method1 = GUICtrlCreateRadio("Entry Method 1: Direct listing of RCON ports", 100, 313, 233, 17)
GUICtrlSetOnEvent(-1, "GUI_W2_T3_R_Method1")
Global $W2_T3_R_Method2 = GUICtrlCreateRadio("Custom Method 2: Enter RCON ports one-at-a-time using a new popup window for each server.", 100, 417, 600, 17)
GUICtrlSetOnEvent(-1, "GUI_W2_T3_R_Method2")
GUICtrlSetState(-1, $GUI_CHECKED)
$Label9 = GUICtrlCreateLabel("Server RCON ports (comma separated. Use same order as servers are listed in ServerGrid.json", 116, 337, 447, 17)
Global $W2_T3_B_Ports = GUICtrlCreateButton("Enter Ports", 116, 441, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_W2_T3_B_Ports")
AutoSetRCON()
Global $W2_T3_I_RCONPorts2 = GUICtrlCreateInput($aServerRCONPort, 200, 443, 573, 21)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$Label10 = GUICtrlCreateLabel("Please select the entry method for the RCON ports for each grid server.", 100, 233, 422, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W2_T3_I_RCONPorts = GUICtrlCreateInput($aServerRCONPort, 116, 361, 657, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T3_I_RCONPorts")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$Group4 = GUICtrlCreateGroup("RCON IP Address", 76, 89, 753, 97)
Global $W2_T3_R_UseServerIP = GUICtrlCreateRadio("Use Server IP (Requires port forwarding with router loopback)", 100, 121, 393, 17)
GUICtrlSetOnEvent(-1, "GUI_W2_T3_R_UseServerIP")
GUICtrlSetState($W2_T3_R_UseServerIP, $GUI_CHECKED)
Global $W2_T3_R_CustomIP = GUICtrlCreateRadio("Custom IP", 100, 153, 65, 17)
GUICtrlSetOnEvent(-1, "GUI_W2_T3_R_CustomIP")
If $iIniRead Then
If $aServerIP = "" Then
$tTmp = "127.0.0.1"
Else
$tTmp = $aServerRCONIP
EndIf
Else
$tTmp = "127.0.0.1"
EndIf
Global $W2_T3_I_RCONIP = GUICtrlCreateInput($tTmp, 172, 153, 145, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T3_I_RCONIP")
$Label31 = GUICtrlCreateLabel("(Ex: 127.0.0.1)", 324, 153, 73, 17)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$Label23 = GUICtrlCreateLabel("Step 4", 36, 49, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$Tab4 = GUICtrlCreateTabItem("4 Grid Start")
If $wDefaultTabNo = 4 Then GUICtrlSetState(-1, $GUI_SHOW)
$Label12 = GUICtrlCreateLabel("* If all grid servers are on one machine and you plan to start them all, skip this section.", 96, 40, 595, 20)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
$Label13 = GUICtrlCreateLabel("Otherwise, please make any changes to the AtlasServerUpdateUtilityGridStartSelect.ini file below:", 104, 64, 581, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W2_T4_E_GridStart = GUICtrlCreateEdit("", 16, 120, 873, 409)
GUICtrlSetOnEvent(-1, "GUI_W2_T4_E_GridStart")
Local $tFileOpen = FileOpen($aGridSelectFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($W2_T4_E_GridStart, $tTxt)
Global $W2_T4_B_Save = GUICtrlCreateButton("Save", 16, 88, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_W2_T4_B_Save")
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $W2_T4_B_Reset = GUICtrlCreateButton("Reset", 96, 88, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_W2_T4_B_Reset")
$Label24 = GUICtrlCreateLabel("Step 5", 36, 49, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$Tab5 = GUICtrlCreateTabItem("5 Priority Settings")
If $wDefaultTabNo = 5 Then GUICtrlSetState(-1, $GUI_SHOW)
$Group3 = GUICtrlCreateGroup("Atlas Server", 72, 112, 753, 177)
$Label14 = GUICtrlCreateLabel("Admin Password", 88, 136, 82, 17, $SS_RIGHT)
$Label15 = GUICtrlCreateLabel("Max Players", 352, 136, 61, 17, $SS_RIGHT)
$Label16 = GUICtrlCreateLabel("Reserved Slots", 488, 136, 76, 17, $SS_RIGHT)
Global $W2_T5_I_AdminPass = GUICtrlCreateInput($aServerAdminPass, 176, 136, 121, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T5_I_AdminPass")
Global $W2_T5_I_MaxPlayers = GUICtrlCreateInput($aServerMaxPlayers, 416, 136, 25, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T5_I_MaxPlayers")
Global $W2_T5_I_ReservedSlots = GUICtrlCreateInput($aServerReservedSlots, 568, 136, 25, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T5_I_ReservedSlots")
$Label17 = GUICtrlCreateLabel("Atlas extra commandline parameters", 136, 184, 173, 17, $SS_RIGHT)
$Label18 = GUICtrlCreateLabel("SteamCMD extra commandline parameters", 104, 216, 204, 17, $SS_RIGHT)
Global $W2_T5_I_AtlasExtraCMD = GUICtrlCreateInput($aServerExtraCMD, 320, 184, 369, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T5_I_AtlasExtraCMD")
Global $W2_T5_I_SteamCMDExtraCMD = GUICtrlCreateInput($aSteamExtraCMD, 320, 216, 369, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T5_I_SteamCMDExtraCMD")
$Label19 = GUICtrlCreateLabel("Atlas server and mod update check interval", 96, 248, 209, 17, $SS_RIGHT)
Global $W2_T5_I_UpdateInterval = GUICtrlCreateInput($aUpdateCheckInterval, 320, 248, 25, 21)
GUICtrlSetOnEvent(-1, "GUI_W2_T5_I_UpdateInterval")
$Label20 = GUICtrlCreateLabel("minutes (05-59)", 352, 248, 76, 17)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$Label25 = GUICtrlCreateLabel("Step 6", 36, 49, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$Tab6 = GUICtrlCreateTabItem("6 Review All Settings")
If $wDefaultTabNo = 6 Then GUICtrlSetState(-1, $GUI_SHOW)
$Label21 = GUICtrlCreateLabel("Make any desired changes to the AtlasServerUpdateUtility.ini file below.", 104, 48, 502, 20)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
$Label26 = GUICtrlCreateLabel("Step 7", 36, 49, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
Global $W2_T6_B_Save = GUICtrlCreateButton("Save", 12, 89, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_W2_T6_B_Save")
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $W2_T6_B_Reset = GUICtrlCreateButton("Reset", 92, 89, 75, 25)
GUICtrlSetOnEvent(-1, "GUI_W2_T6_B_Reset")
Global $W2_T6_E_Config = GUICtrlCreateEdit("", 12, 129, 873, 409)
GUICtrlSetOnEvent(-1, "GUI_W2_T6_E_Config")
Local $tFileOpen = FileOpen($aIniFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData(-1, $tTxt)
$Label29 = GUICtrlCreateLabel("NOTICE!!! The utility must be restarted for most changes to take effect.", 176, 72, 547, 17)
$Tab7 = GUICtrlCreateTabItem("7 Finish")
If $wDefaultTabNo = 7 Then GUICtrlSetState(-1, $GUI_SHOW)
$Label27 = GUICtrlCreateLabel("Step 8", 36, 49, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$Label28 = GUICtrlCreateLabel("Congratulations!  You have completed the setup wizard.", 186, 120, 540, 29)
GUICtrlSetFont(-1, 16, 800, 0, "MS Sans Serif")
$Label30 = GUICtrlCreateLabel("Click to restart the utility with your new settings.", 282, 232, 334, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
Global $W2_T7_B_ExitRestartY = GUICtrlCreateButton("RESTART", 402, 272, 75, 25)
GUICtrlSetOnEvent(-1, "W2_T7_B_ExitRestartY")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
Global $W2_T7_B_ExitRestartN = GUICtrlCreateButton("Exit without Restarting Util", 368, 336, 147, 25)
GUICtrlSetOnEvent(-1, "W2_T7_B_ExitRestartN")
$Label33 = GUICtrlCreateLabel("(Warning! Some settings will not take effect until utility is restarted)", 288, 368, 313, 17, $SS_CENTER)
GUICtrlCreateTabItem("")
GUISetState(@SW_SHOW)
If WinExists($wGUIMainWindow) Then
Else
While $aExitGUIW2 = False
Sleep(100)
WEnd
GUIDelete($WizardWindowExist)
$aExitGUIW2 = False
EndIf
EndIf
EndFunc
Func GUI_WizardExist_Close($tSplashTF = True)
If WinExists($wGUIMainWindow) Then
GUIDelete($WizardWindowExist)
Else
$aExitGUIW2 = True
EndIf
If $aSplashStartUp <> 0 Then
If $tSplashTF Then $aSplashStartUp = _Splash($aStartText & @CRLF & "Setup Wizard Completed.", 1500, 475)
EndIf
EndFunc
Func GUI_W2_On_Tab()
Switch GUICtrlRead($WizardTabWindow)
Case 0
GUI_W2_Last_Tab(0)
Case 1
GUI_W2_Last_Tab(1)
If $iIniRead Then
If $aServerAltSaveSelect = 1 Then GUICtrlSetState($W2_T2_R_Default00, $GUI_CHECKED)
If $aServerAltSaveSelect = 2 Then GUICtrlSetState($W2_T2_R_DefaultA1, $GUI_CHECKED)
If $aServerAltSaveSelect = 3 Then
AutoSetAltSaveDIR()
GUICtrlSetState($W2_T2_R_Custom1, $GUI_CHECKED)
EndIf
GUICtrlSetData($W2_T2_I_AltSaveDIR, $aServerAltSaveDir)
GUICtrlSetData($W2_T2_I_AltSaveDIR2, $aServerAltSaveDir)
EndIf
Case 2
GUI_W2_Last_Tab(2)
If $aConfigSettingsImported Then
AutoSetRCON()
GUICtrlSetData($W2_T3_I_RCONPorts, $aServerRCONPort)
GUICtrlSetData($W2_T3_I_RCONPorts2, $aServerRCONPort)
EndIf
If $iIniRead And ($aServerRCONImport = "yes") Then GUICtrlSetState($W2_T3_R_Import, $GUI_CHECKED)
Case 3
GUI_W2_Last_Tab(3)
If $aConfigSettingsImported Then
If FileExists($aGridSelectFile) Then
Else
GridStartSelect($aGridSelectFile, $aLogFile, True)
EndIf
Local $tFileOpen = FileOpen($aGridSelectFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($W2_T4_E_GridStart, $tTxt)
Else
MsgBox($MB_OK, $aUtilName, "Cannot create GridStartSelect.ini file until the " & $aConfigFile & " file has been imported.")
GUICtrlSetState($Tab1, $GUI_SHOW)
EndIf
Case 4
GUI_W2_Last_Tab(4)
If $iIniRead Then
GUICtrlSetData($W2_T5_I_AdminPass, $aServerAdminPass)
GUICtrlSetData($W2_T5_I_MaxPlayers, $aServerMaxPlayers)
GUICtrlSetData($W2_T5_I_ReservedSlots, $aServerReservedSlots)
GUICtrlSetData($W2_T5_I_AtlasExtraCMD, $aServerExtraCMD)
GUICtrlSetData($W2_T5_I_SteamCMDExtraCMD, $aSteamExtraCMD)
GUICtrlSetData($W2_T5_I_UpdateInterval, $aUpdateCheckInterval)
EndIf
Case 5
GUI_W2_Last_Tab(5)
Local $tFileOpen = FileOpen($aIniFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($W2_T6_E_Config, $tTxt)
Case 6
GUI_W2_Last_Tab(6)
EndSwitch
EndFunc
Func GUI_W2_Last_Tab($tTab)
If ($aGUI_W2_LastTab = 0) And ($aConfigSettingsImported = False) Then
MsgBox($MB_OK, $aUtilName, "You must Import " & $aConfigFile & " file to continue.")
GUICtrlSetState($Tab1, $GUI_SHOW)
Return
EndIf
If $aGUI_W2_LastTab = 1 Then
If GUICtrlRead($W2_T2_R_Custom2) = 4 Or GUICtrlRead($W2_T2_R_Custom1) = 4 Then GUI_W2_T2_R_Custom1()
Sleep(250)
EndIf
If $aGUI_W2_LastTab = 2 Then
If GUICtrlRead($W2_T3_R_Import) = 4 Then
$aServerRCONImport = "no"
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Import RCON ports from GameUserSettings.ini files? (yes/no) ###", $aServerRCONImport)
$aServerRCONPort = GUICtrlRead($W2_T3_I_RCONPorts)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server RCON Port(s) (comma separated, grid order as in ServerGrid.json, ignore if importing RCON ports) ###", $aServerRCONPort)
EndIf
Sleep(250)
EndIf
If ($aGUI_W2_LastTab = 3) And ($aGUI_W2_T4_GridStartClicked = True) Then
Local $tTxt = GUICtrlRead($W2_T4_E_GridStart)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aGridSelectFile & "_" & $tTime & ".bak"
FileMove($aGridSelectFile, $tFile, 1)
FileWrite($aGridSelectFile, $tTxt)
EndIf
If ($aGUI_W2_LastTab = 5) And ($aGUI_W2_T6_ConfigClicked = True) Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "Do you wish to save changes to AtlasServerUpdateUtility.ini?" & @CRLF & @CRLF & "Click (YES) to Save" & @CRLF & "Click (NO) to Skip" & @CRLF & "Click (CANCEL) to Reset.", 10)
If $tMB = 6 Then
GUI_W2_T6_B_Save()
ElseIf $tMB = 2 Then
GUI_W2_T6_B_Reset()
EndIf
EndIf
$aGUI_W2_LastTab = $tTab
EndFunc
Func GUI_W2_T1_B_SelectFolder()
Local $tCtrlID = $W2_T1_I_AtlasDIR
Local $tInput = FileSelectFolder("Please select " & $aUtilName & " installation folder", $aServerDirLocal)
If @error Then
Local $tRead = GUICtrlRead($tCtrlID)
GUICtrlSetData($tCtrlID, $tRead)
Else
GUICtrlSetData($tCtrlID, $tInput)
EndIf
$aServerDirLocal = GUICtrlRead($tCtrlID)
$aServerDirLocal = RemoveInvalidCharacters($aServerDirLocal)
$aServerDirLocal = RemoveTrailingSlash($aServerDirLocal)
$aServerDirLocal = RemoveShooterGame($aServerDirLocal)
GUICtrlSetData($tCtrlID, $aServerDirLocal)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " DIR ###", $aServerDirLocal)
EndFunc
Func GUI_W2_T1_I_AtlasDIR()
Local $tCtrlID = $W2_T1_I_AtlasDIR
$aServerDirLocal = GUICtrlRead($tCtrlID)
$aServerDirLocal = RemoveInvalidCharacters($aServerDirLocal)
$aServerDirLocal = RemoveTrailingSlash($aServerDirLocal)
$aServerDirLocal = RemoveShooterGame($aServerDirLocal)
GUICtrlSetData($tCtrlID, $aServerDirLocal)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " DIR ###", $aServerDirLocal)
EndFunc
Func GUI_W2_T1_B_ImportSettings()
$aConfigSettingsImported = True
_Splash("Importing settings from " & $aConfigFile & ".", 0, 475)
Global $aConfigFull = $aServerDirLocal & "\ShooterGame\" & $aConfigFile
Global $aDefaultGame = $aServerDirLocal & "\ShooterGame\Config\DefaultGame.ini"
Global $aDefaultGUS = $aServerDirLocal & "\ShooterGame\Config\DefaultGameUserSettings.ini"
Global $aDefaultEngine = $aServerDirLocal & "\ShooterGame\Config\DefaultEngine.ini"
ImportConfig($aServerDirLocal, $aConfigFile, True)
Sleep(2000)
SplashOff()
EndFunc
Func GUI_W2_T2_R_Default00()
$aServerAltSaveSelect = 1
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", $aServerAltSaveSelect)
EndFunc
Func GUI_W2_T2_R_DefaultA10()
$aServerAltSaveSelect = 2
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", $aServerAltSaveSelect)
EndFunc
Func GUI_W2_T2_R_Custom1()
$aServerAltSaveSelect = 3
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", $aServerAltSaveSelect)
$aServerAltSaveDir = GUICtrlRead($W2_T2_I_AltSaveDIR)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames (Use same order as listed in ServerGrid.json. Comma separated) ###", $aServerAltSaveDir)
EndFunc
Func GUI_W2_T2_R_Custom2()
EndFunc
Func GUI_W2_T2_B_Folders()
SplashOff()
GUICtrlSetState($W2_T2_R_Custom2, $GUI_CHECKED)
Local $tTxt = ""
AutoSetAltSaveDIR()
For $i = 0 To ($aServerGridTotal - 1)
$tInput = InputBox("AltSaveDIR " & $i + 1 & " of " & $aServerGridTotal, "AltSaveDIR for Server " & _ServerNamingScheme($i, $aNamingScheme) & ":", $xServerAltSaveDir[$i], "", 100, 130, Default, Default, 60)
$tInput = RemoveInvalidCharacters($tInput)
$tInput = RemoveCommas($tInput)
If @error Then $tInput = $xServerAltSaveDir[$i]
If $tInput = "" Then $tInput = "0"
$xServerAltSaveDir[$i] = $tInput
$tTxt &= $tInput & ","
Next
$aServerAltSaveDir = RemoveTrailingComma($tTxt)
GUICtrlSetData($W2_T2_I_AltSaveDIR2, $aServerAltSaveDir)
$aServerAltSaveSelect = 3
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", $aServerAltSaveSelect)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames (Use same order as listed in ServerGrid.json. Comma separated) ###", $aServerAltSaveDir)
EndFunc
Func GUI_W2_T2_I_AltSaveDIR()
$aServerAltSaveSelect = 3
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames Pattern: (1) for 00,01,10,11 (2) for A1,A2,B1,B2 (3) Custom (Enter below) ###", $aServerAltSaveSelect)
$aServerAltSaveDir = GUICtrlRead($W2_T2_I_AltSaveDIR)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames (Use same order as listed in ServerGrid.json. Comma separated) ###", $aServerAltSaveDir)
GUICtrlSetState($W2_T2_R_Custom1, $GUI_CHECKED)
$xServerAltSaveDir = StringSplit($aServerAltSaveDir, ",", 2)
If $aServerGridTotal <> UBound($xServerAltSaveDir) And ($aServerWorldFriendlyName <> "TempXY") Then
SplashOff()
Local $aErrorMsg = " [CRITICAL ERROR!] The number of AltSaveDIRs does not match the number of grids listed in ServerGrid.json file." & @CRLF & "Number of Server AltSaveDIRs:" & (UBound($xServerAltSaveDir)) & ". Grid Total:" & $aServerGridTotal & @CRLF
LogWrite($aErrorMsg)
MsgBox($MB_OK, $aUtilityVer, $aErrorMsg)
EndIf
EndFunc
Func GUI_W2_T3_R_UseServerIP()
$aServerRCONIP = ""
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "RCON IP (ex. 127.0.0.1 - Leave BLANK for server IP) ###", $aServerRCONIP)
EndFunc
Func GUI_W2_T3_I_RCONIP()
$aServerRCONIP = GUICtrlRead($W2_T3_I_RCONIP)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "RCON IP (ex. 127.0.0.1 - Leave BLANK for server IP) ###", $aServerRCONIP)
GUICtrlSetState($W2_T3_R_CustomIP, $GUI_CHECKED)
EndFunc
Func GUI_W2_T3_R_CustomIP()
$aServerRCONIP = GUICtrlRead($W2_T3_I_RCONIP)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "RCON IP (ex. 127.0.0.1 - Leave BLANK for server IP) ###", $aServerRCONIP)
GUICtrlSetState($W2_T3_R_CustomIP, $GUI_CHECKED)
EndFunc
Func GUI_W2_T3_R_Import()
$aServerRCONImport = "yes"
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Import RCON ports from GameUserSettings.ini files? (yes/no) ###", $aServerRCONImport)
EndFunc
Func GUI_W2_T3_R_Method1()
$aServerRCONImport = "no"
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Import RCON ports from GameUserSettings.ini files? (yes/no) ###", $aServerRCONImport)
$aServerRCONPort = GUICtrlRead($W2_T3_I_RCONPorts)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server RCON Port(s) (comma separated, grid order as in ServerGrid.json, ignore if importing RCON ports) ###", $aServerRCONPort)
GUICtrlSetState($W2_T3_R_Method1, $GUI_CHECKED)
EndFunc
Func GUI_W2_T3_I_RCONPorts()
$aServerRCONImport = "no"
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Import RCON ports from GameUserSettings.ini files? (yes/no) ###", $aServerRCONImport)
$aServerRCONPort = GUICtrlRead($W2_T3_I_RCONPorts)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server RCON Port(s) (comma separated, grid order as in ServerGrid.json, ignore if importing RCON ports) ###", $aServerRCONPort)
GUICtrlSetState($W2_T3_R_Method1, $GUI_CHECKED)
EndFunc
Func GUI_W2_T3_R_Method2()
EndFunc
Func GUI_W2_T3_B_Ports()
SplashOff()
GUICtrlSetState($W2_T3_R_Method2, $GUI_CHECKED)
Local $tTxt = ""
If (UBound($xServerRCONPort) - 1) < $aServerGridTotal Then
Global $xServerRCONPort[$aServerGridTotal + 1]
$xServerRCONPort[0] = $aServerGridTotal
For $i = 1 To ($aServerGridTotal)
$xServerRCONPort[$i] = 25718 + 2 * $i
Next
EndIf
For $i = 0 To ($aServerGridTotal - 1)
$tInput = InputBox("RCON Port " & $i + 1 & " of " & $aServerGridTotal, "RCON Port for Server " & _ServerNamingScheme($i, $aNamingScheme) & ":", $xServerRCONPort[$i + 1], "", 100, 130, Default, Default, 120)
If @error Then $tInput = $xServerRCONPort[$i + 1]
If $tInput = "" Then $tInput = "0"
$xServerRCONPort[$i + 1] = $tInput
$tTxt &= $tInput & ","
Next
$aServerRCONPort = RemoveTrailingComma($tTxt)
$aServerRCONImport = "no"
GUICtrlSetData($W2_T3_I_RCONPorts2, $aServerRCONPort)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server RCON Port(s) (comma separated, grid order as in ServerGrid.json, ignore if importing RCON ports) ###", $aServerRCONPort)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Import RCON ports from GameUserSettings.ini files? (yes/no) ###", $aServerRCONImport)
EndFunc
Func GUI_W2_T4_B_Save()
Local $tTxt = GUICtrlRead($W2_T4_E_GridStart)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aGridSelectFile & "_" & $tTime & ".bak"
FileMove($aGridSelectFile, $tFile, 1)
FileWrite($aGridSelectFile, $tTxt)
_Splash("GridStartSelect.ini updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $aUtilName & "GridStartSelect.ini_" & $tTime & ".bak", 3000, 525)
$aGUI_W2_T4_GridStartClicked = False
EndFunc
Func GUI_W2_T4_B_Reset()
Local $tFileOpen = FileOpen($aGridSelectFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($W2_T4_E_GridStart, $tTxt)
EndFunc
Func GUI_W2_T4_E_GridStart()
$aGUI_W2_T4_GridStartClicked = True
EndFunc
Func GUI_W2_T5_I_AdminPass()
$aServerAdminPass = GUICtrlRead($W2_T5_I_AdminPass)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Admin password ###", $aServerAdminPass)
EndFunc
Func GUI_W2_T5_I_MaxPlayers()
$aServerMaxPlayers = GUICtrlRead($W2_T5_I_MaxPlayers)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Max players ###", $aServerMaxPlayers)
EndFunc
Func GUI_W2_T5_I_ReservedSlots()
$aServerReservedSlots = GUICtrlRead($W2_T5_I_ReservedSlots)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Reserved slots ###", $aServerReservedSlots)
EndFunc
Func GUI_W2_T5_I_AtlasExtraCMD()
$aServerExtraCMD = GUICtrlRead($W2_T5_I_AtlasExtraCMD)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " extra commandline parameters (ex.?serverpve-pve -NoCrashDialog) ###", $aServerExtraCMD)
EndFunc
Func GUI_W2_T5_I_SteamCMDExtraCMD()
$aSteamExtraCMD = GUICtrlRead($W2_T5_I_SteamCMDExtraCMD)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "SteamCMD extra commandline parameters (ex. -latest_experimental) ###", $aSteamExtraCMD)
EndFunc
Func GUI_W2_T5_I_UpdateInterval()
$aUpdateCheckInterval = GUICtrlRead($W2_T5_I_UpdateInterval)
If $aUpdateCheckInterval < 5 Then $aUpdateCheckInterval = 5
If $aUpdateCheckInterval > 59 Then $aUpdateCheckInterval = 59
IniWrite($aIniFile, " --------------- CHECK FOR UPDATE --------------- ", "Update check interval in minutes (05-59) ###", $aUpdateCheckInterval)
EndFunc
Func GUI_W2_T6_B_Save()
Local $tTxt = GUICtrlRead($W2_T6_E_Config)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aIniFile & "_" & $tTime & ".bak"
FileMove($aIniFile, $tFile, 1)
FileWrite($aIniFile, $tTxt)
_Splash($aUtilName & ".ini updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $aUtilName & ".ini_" & $tTime & ".bak", 3000, 525)
$aGUI_W2_T6_ConfigClicked = False
EndFunc
Func GUI_W2_T6_B_Reset()
Local $tFileOpen = FileOpen($aIniFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($W2_T6_E_Config, $tTxt)
EndFunc
Func GUI_W2_T6_E_Config()
$aGUI_W2_T6_ConfigClicked = True
EndFunc
Func W2_T7_B_ExitRestartY()
$aWizExistFinished = True
If WinExists($wGUIMainWindow) Then
GUIDelete($WizardWindowExist)
Else
$aExitGUIW2 = True
EndIf
If $aSplashStartUp <> 0 Then
$aSplashStartUp = _Splash($aStartText & @CRLF & "Setup Wizard Completed.", 1500, 475)
EndIf
F_ExitCloseN(True)
EndFunc
Func W2_T7_B_ExitRestartN()
$aWizExistFinished = True
If WinExists($wGUIMainWindow) Then
GUIDelete($WizardWindowExist)
Else
$aExitGUIW2 = True
EndIf
If $aSplashStartUp <> 0 Then
$aSplashStartUp = _Splash($aStartText & @CRLF & "Setup Wizard Completed.", 1500, 475)
EndIf
EndFunc
Func AutoSetRCON()
Local $tTest = StringSplit($aServerRCONPort, ",")
If $tTest[0] <> $aServerGridTotal Then
Local $tRCONCnt = 25710
Local $tRCONStr = ""
For $i = 1 To ($aServerGridTotal)
$tRCONStr &= $tRCONCnt & ","
$tRCONCnt += 2
Next
$aServerRCONPort = RemoveTrailingComma($tRCONStr)
EndIf
EndFunc
Func AutoSetAltSaveDIR()
Local $tTest = StringSplit($aServerAltSaveDir, ",")
If $tTest[0] <> $aServerGridTotal Then
$aServerAltSaveDir = ""
Global $xServerAltSaveDir[$aServerGridTotal]
If $aNamingScheme > 2 Then $aNamingScheme = 2
For $i = 0 To ($aServerGridTotal - 1)
$xServerAltSaveDir[$i] = _ServerNamingScheme($i, $aNamingScheme)
Next
EndIf
For $i = 0 To ($aServerGridTotal - 1)
$aServerAltSaveDir &= $xServerAltSaveDir[$i] & ","
Next
$aServerAltSaveDir = RemoveTrailingComma($aServerAltSaveDir)
If $aServerAltSaveDir = "" Then
For $i = 0 To ($aServerGridTotal - 1)
$aServerAltSaveDir &= _ServerNamingScheme($i, $aNamingScheme) & ","
Next
$aServerAltSaveDir = RemoveTrailingComma($aServerAltSaveDir)
EndIf
EndFunc
Func WizardNew()
SplashOff()
If WinExists($WizardWindowNew) Then
Else
#Region ### START Koda GUI section ### Form=G:\Game Server Files\AutoIT\AtlasServerUpdateUtility\Temp Work Files\atladkoda(lwiz-2 new)b1.kxf
$WizardWindowNew = GUICreate("AtlasServerUpdateUtility Setup Wizard", 906, 555, -1, -1, BitOR($GUI_SS_DEFAULT_GUI, $WS_SIZEBOX, $WS_THICKFRAME, $WS_TABSTOP))
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_WizardNew_Close", $WizardWindowNew)
GUISetIcon($aIconFile, 99)
GUISetBkColor($cW3Background)
$Group1 = GUICtrlCreateGroup("Install New Atlas Server Wizard", 24, 24, 857, 497)
$W3_Label1 = GUICtrlCreateLabel("Welcome to the AtlasServerUpdateUtility install Wizard.", 90, 49, 537, 29)
GUICtrlSetFont(-1, 16, 800, 0, "MS Sans Serif")
$W3_Label4 = GUICtrlCreateLabel("Step 1", 78, 82, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$W3_Label2 = GUICtrlCreateLabel("Please select the Atlas Dedicated Server installation folder: ", 126, 106, 358, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W3_I_AtlasDIR = GUICtrlCreateInput("D:\Game Servers\" & $aGameName & " Dedicated Server", 126, 130, 569, 21)
GUICtrlSetOnEvent(-1, "W3_I_AtlasDIR")
$W3_Label32 = GUICtrlCreateLabel("Install new Atlas server.", 522, 97, 198, 28)
GUICtrlSetFont(-1, 14, 400, 0, "MS Sans Serif")
Global $W3_B_SelectFolder = GUICtrlCreateButton("Select Folder", 702, 130, 107, 25)
GUICtrlSetOnEvent(-1, "W3_B_SelectFolder")
$W3_Label5 = GUICtrlCreateLabel("Step 2", 78, 162, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$W3_Label8 = GUICtrlCreateLabel("SteamCMD extra commandline parameters", 126, 186, 261, 20, $SS_RIGHT)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W3_I_SteamCMDExtraCMD = GUICtrlCreateInput("", 126, 210, 369, 21)
GUICtrlSetOnEvent(-1, "W3_I_SteamCMDExtraCMD")
$W3_Label7 = GUICtrlCreateLabel("Step 3", 78, 242, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$W3_Label3 = GUICtrlCreateLabel("Click below to install Atlas Server (using SteamCMD)", 122, 265, 314, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W3_B_InstallServer = GUICtrlCreateButton("Install Atlas Server", 123, 291, 115, 25)
GUICtrlSetOnEvent(-1, "W3_B_InstallServer")
$W3_Label9 = GUICtrlCreateLabel("Step 4", 78, 330, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
Global $W3_B_Continue = GUICtrlCreateButton("Import Config and Continue", 128, 456, 179, 25)
GUICtrlSetOnEvent(-1, "W3_B_Continue")
Global $W3_B_Cancel = GUICtrlCreateButton("Cancel", 784, 472, 75, 25)
GUICtrlSetOnEvent(-1, "W3_B_Cancel")
$W3_Label12 = GUICtrlCreateLabel("Copy your Grid files (ServerGrid.json, ServerGrid.ServerOnly.json, and map image files) to", 128, 360, 534, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W3_Label2 = GUICtrlCreateLabel("D:\Game Servers\" & $aGameName & " Dedicated Server\ShooterGame", 128, 384, 569, 17)
GUICtrlSetBkColor(-1, 0xC0C0C0)
$W3_Label11 = GUICtrlCreateLabel("Step 5", 78, 424, 51, 24)
GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
$W3_Label1 = GUICtrlCreateLabel("For help creating your map files, visit:", 408, 416, 222, 20)
GUICtrlSetFont(-1, 10, 400, 0, "MS Sans Serif")
Global $W3_B_GridHelpWebPage = GUICtrlCreateButton("AtlasDSSGuide (Webpage Link)", 632, 408, 187, 25)
GUICtrlSetOnEvent(-1, "W3_B_GridHelpWebPage")
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUISetState(@SW_SHOW)
#EndRegion ### END Koda GUI section ###
If WinExists($wGUIMainWindow) Then
Else
While $aExitGUIW3 = False
Sleep(100)
WEnd
GUIDelete($WizardWindowNew)
$aExitGUIW3 = False
If $aWizardSelect = 1 Then WizardExisting(2)
EndIf
EndIf
EndFunc
Func GUI_WizardNew_Close()
If WinExists($wGUIMainWindow) Then
GUIDelete($WizardWindowNew)
Else
$aExitGUIW3 = True
EndIf
EndFunc
Func W3_I_AtlasDIR()
$aServerDirLocal = GUICtrlRead($W3_I_AtlasDIR)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " DIR ###", $aServerDirLocal)
GUICtrlSetData($W3_Label2, $aServerDirLocal & "\ShooterGame")
EndFunc
Func W3_B_SelectFolder()
Local $tCtrlID = $W3_I_AtlasDIR
Local $tInput = FileSelectFolder("Please select " & $aUtilName & " installation folder", $aServerDirLocal)
If @error Then
Local $tRead = GUICtrlRead($tCtrlID)
GUICtrlSetData($tCtrlID, $tRead)
Else
GUICtrlSetData($tCtrlID, $tInput)
EndIf
$aServerDirLocal = GUICtrlRead($tCtrlID)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " DIR ###", $aServerDirLocal)
GUICtrlSetData($W3_Label2, $aServerDirLocal & "\ShooterGame")
EndFunc
Func W3_I_SteamCMDExtraCMD()
$aSteamExtraCMD = GUICtrlRead($W3_I_SteamCMDExtraCMD)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "SteamCMD extra commandline parameters (ex. -latest_experimental) ###", $aSteamExtraCMD)
EndFunc
Func W3_B_InstallServer()
$tSplash = _Splash("Downloading and installing " & @CRLF & "SteamCMD and mcrcon.exe (if needed).", 0, 475)
FileExistsFunc($tSplash)
ControlSetText($tSplash, "", "Static1", "Downloading and installing " & @CRLF & $aUtilName & " dedicated server.")
SteamcmdDelete($aSteamCMDDir)
SteamInstallGame($tSplash)
EndFunc
Func W3_B_GridHelpWebPage()
Run(@ComSpec & " /c " & "start https://krookedskull.com/index.php?title=AtlasDSSGuide#Building_the_Map", "")
EndFunc
Func W3_B_Continue()
GUI_WizardNew_Close()
GUI_W2_T1_B_ImportSettings()
_Splash("Creating default GridStartSelect.ini file.", 0, 475)
GridStartSelect($aGridSelectFile, $aLogFile, True)
SplashOff()
$aWizardSelect = 1
EndFunc
Func W3_B_Cancel()
GUI_WizardNew_Close()
EndFunc
Func ConfigEdit($tSplash = 0, $tWarn = False)
SplashOff()
If WinExists($ConfigEditWindow) Then
Else
#Region ### START Koda GUI section ### Form=g:\game server files\autoit\atlasserverupdateutility\temp work files\atladkoda(configedit)b1.kxf
Global $ConfigEditWindow = GUICreate($aUtilName & " Config Editor", 1001, 701, -1, -1, BitOR($GUI_SS_DEFAULT_GUI, $WS_SIZEBOX, $WS_THICKFRAME, $WS_MAXIMIZEBOX))
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_ConfigEdit_Close", $ConfigEditWindow)
GUISetIcon($aIconFile, 99)
GUISetBkColor($cMWBackground)
Global $C_IniFailWindow = GUICtrlCreateEdit("", 8, 616, 985, 73, BitOR($ES_AUTOVSCROLL, $ES_READONLY, $ES_WANTRETURN, $WS_VSCROLL))
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKBOTTOM + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cLWBackground)
Local $tFile = FileOpen($aIniFailFileBasic)
Local $tFailFile = FileRead($tFile)
FileClose($tFile)
GUICtrlSetData(-1, $tFailFile)
$Label1 = GUICtrlCreateLabel("Changes from last util start:", 8, 592, 250, 20)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
Global $C_B_Save = GUICtrlCreateButton("Save", 8, 8, 75, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "C_B_Save")
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $C_B_Reset = GUICtrlCreateButton("Reset", 88, 8, 75, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "C_B_Reset")
Global $C_B_SaveResetShutDownN = GUICtrlCreateButton("Save and Restart Util (Leave Servers Running)", 208, 8, 299, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
GUICtrlSetOnEvent(-1, "C_B_SaveResetShutDownN")
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $ConifgINIEdit = GUICtrlCreateEdit("", 8, 40, 985, 545)
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cFWBackground)
Local $tFileOpen = FileOpen($aIniFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData(-1, $tTxt)
Global $C_B_SaveResetShutDownY = GUICtrlCreateButton("Save and Restart Util (SHUT DOWN Servers)", 512, 8, 243, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "C_B_SaveResetShutDownY")
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
If WinExists($wGUIMainWindow) Then
GUICtrlSetState($C_B_SaveResetShutDownY, $GUI_ENABLE)
Else
GUICtrlSetState($C_B_SaveResetShutDownY, $GUI_DISABLE)
EndIf
Global $C_B_ContinueNoRestartUtil = GUICtrlCreateButton("Continue WITHOUT Restarting Util", 800, 8, 195, 25)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKSIZE)
GUICtrlSetOnEvent(-1, "C_B_ContinueNoRestartUtil")
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
$Label2 = GUICtrlCreateLabel(" NOTICE! Util must be restarted for changes to take effect.", 576, 592, 417, 20, BitOR($SS_CENTER, $WS_BORDER), $WS_EX_STATICEDGE)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
GUICtrlSetBkColor(-1, 0xFFFF00)
GUISetState(@SW_SHOW)
#EndRegion ### END Koda GUI section ###
If $tWarn Then MsgBox($MB_OK, "New or changed INI Parameters", "INI FILE WAS UPDATED." & @CRLF & "Found " & $iIniFail & " missing or changes variable(s) in " & $aUtilName & ".ini:" & @CRLF & @CRLF & $iIniError & @CRLF & @CRLF & "Please make any required changes.", 5)
If WinExists($wGUIMainWindow) Then
Else
While $aConfigEditWindow = False
Sleep(100)
WEnd
GUIDelete($ConfigEditWindow)
$aConfigEditWindow = False
If $tSplash > 0 Then Global $aSplashStartUp = _Splash($aStartText, 0, 475)
EndIf
EndIf
EndFunc
Func GUI_ConfigEdit_Close()
If WinExists($wGUIMainWindow) Then
GUIDelete($ConfigEditWindow)
Else
$aConfigEditWindow = True
EndIf
EndFunc
Func C_B_Save()
Local $tTxt = GUICtrlRead($ConifgINIEdit)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFile = $aIniFile & "_" & $tTime & ".bak"
FileMove($aIniFile, $tFile, 1)
FileWrite($aIniFile, $tTxt)
_Splash($aUtilName & ".ini updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $aUtilName & ".ini_" & $tTime & ".bak", 3000, 525)
EndFunc
Func C_B_Reset()
Local $tFileOpen = FileOpen($aIniFile)
Local $tTxt = FileRead($tFileOpen)
FileClose($tFileOpen)
GUICtrlSetData($ConifgINIEdit, $tTxt)
EndFunc
Func C_B_SaveResetShutDownN()
C_B_Save()
GUI_ConfigEdit_Close()
F_ExitCloseN(True)
EndFunc
Func C_B_SaveResetShutDownY()
C_B_Save()
GUI_ConfigEdit_Close()
F_ExitCloseY(True)
EndFunc
Func C_B_ContinueNoRestartUtil()
GUI_ConfigEdit_Close()
EndFunc
Func ShowGUITools()
If WinExists($wToolsWindow) Then
Else
$wToolsWindow = GUICreate("AtlasServerUpdateUtility Tools", 906, 555, -1, -1, BitOR($GUI_SS_DEFAULT_GUI, $WS_SIZEBOX, $WS_THICKFRAME))
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_Tools_Close", $wToolsWindow)
GUISetIcon($aIconFile, 99)
GUISetBkColor($cT1Background)
$Group1 = GUICtrlCreateGroup("Group1", 192, -32, 1, 33)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$Group2 = GUICtrlCreateGroup("AtlasServerUpdateUtility Tools", 24, 24, 857, 505)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
Local $tButtonW = 155, $tButtonH = 33, $tLabelH = 20
Local $tButtonX = 43, $tButtonY = 67, $tLabelX = $tButtonX + 165, $tLabelY = $tButtonY + 7
Global $T1_B_SetupWizard = GUICtrlCreateButton("Setup Wizard", $tButtonX, $tButtonY, $tButtonW, $tButtonH)
GUICtrlSetOnEvent(-1, "GUI_Tools_B_SetupWizard")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
$T1_L_SetupWizard = GUICtrlCreateLabel("A tool to prepare the essential config paramaters.", $tLabelX, $tLabelY, 345, $tLabelH)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
$tButtonY += 48
$tLabelY += 48
Global $T1_B_AllPortsScanner = GUICtrlCreateButton("Network Conn. Viewer", $tButtonX, $tButtonY, $tButtonW, $tButtonH)
GUICtrlSetOnEvent(-1, "GUI_Tools_B_NetworkConnectionsViewer")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
$T1_L_AllPortsScanner = GUICtrlCreateLabel("Displays all ports/programs used by local computer.", $tLabelX, $tLabelY, 650, $tLabelH)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$tButtonY += 48
$tLabelY += 48
Global $T1_B_DuplicatePortChecker = GUICtrlCreateButton("Duplicate Port Checker", $tButtonX, $tButtonY, $tButtonW, $tButtonH)
GUICtrlSetOnEvent(-1, "GUI_Tools_B_DuplicatePortChecker")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
$T1_L_DuplicatePortChecker = GUICtrlCreateLabel("Check for duplicate ports assigned in the ServerGrid.json file and RCON ports.", $tLabelX, $tLabelY, 542, $tLabelH)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$tButtonY += 48
$tLabelY += 48
Global $T1_B_CreateBatchFiles = GUICtrlCreateButton("Create Batch Files", $tButtonX, $tButtonY, $tButtonW, $tButtonH)
GUICtrlSetOnEvent(-1, "GUI_Tools_B_CreateBatchFiles")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
$T1_L_DuplicatePortChecker = GUICtrlCreateLabel("Create batch files for starting and updating " & $aGameName & ".", $tLabelX, $tLabelY, 542, $tLabelH)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$tButtonY += 48
$tLabelY += 48
Global $T1_B_CreateServerSummary = GUICtrlCreateButton("Create Server Summary", $tButtonX, $tButtonY, $tButtonW, $tButtonH)
GUICtrlSetOnEvent(-1, "GUI_Tools_B_CreateServerSummary")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
$T1_L_DuplicatePortChecker = GUICtrlCreateLabel("Create text file containing IP addresses, ports, and other server settings.", $tLabelX, $tLabelY, 542, $tLabelH)
GUICtrlSetFont(-1, 10, 800, 0, "MS Sans Serif")
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUISetState(@SW_SHOWNORMAL, $wToolsWindow)
If WinExists($wGUIMainWindow) Then
Else
While $aExitGUIT1 = False
Sleep(100)
WEnd
GUIDelete($wToolsWindow)
$aExitGUIT1 = False
If $aGUITools = 2 Then WizardExisting(1)
If $aGUITools = 3 Then WizardNew()
EndIf
EndIf
EndFunc
Func GUI_Tools_Close()
$aExitGUIT1 = True
$aGUITools = 1
If WinExists($wGUIMainWindow) Then
GUIDelete($wToolsWindow)
$aExitGUIT1 = False
EndIf
EndFunc
Func GUI_Tools_B_SetupWizard()
WizardSelect()
EndFunc
Func GUI_Tools_B_DuplicatePortChecker()
_CheckForDuplicatePorts()
EndFunc
Func GUI_Tools_B_NetworkConnectionsViewer()
_NetworkConnectionsViewer()
EndFunc
Func GUI_Tools_B_CreateBatchFiles()
$tSourceFolder = FileSelectFolder("Select folder", $aBatFolder, 1)
If @error Then
_Splash("Create batch files cancelled . . .", 2000)
Else
$tSplash = _Splash("Creating batch files . . .")
BatchFilesCreate($tSplash, $tSourceFolder)
_Splash("Batch files created.", 2000)
ShellExecute($tSourceFolder)
EndIf
EndFunc
Func GUI_Tools_B_CreateServerSummary()
$tServerSummaryFile = FileSaveDialog("Select Filename and Folder for Server Summary", @ScriptDir, "Text files (*.txt)", BitOR($FD_PATHMUSTEXIST, $FD_PROMPTOVERWRITE), "Server_Summary.txt")
If @error Then
_Splash("Create server summary file cancelled . . .", 2000)
Else
$tSplash = _Splash("Creating server summary file . . .")
MakeServerSummaryFile($tServerSummaryFile)
_Splash("Server summary file created.", 2000)
ShellExecute($tServerSummaryFile)
EndIf
EndFunc
Func SelectFolder($tTxt, $tDefaultDIR = @ScriptDir)
Opt("GUIOnEventMode", 0)
Global $tSourceFolder = $tDefaultDIR
Global $tSFTxt = $tTxt
Global $aSFDone = False
If WinExists($wSelectFolder) Then
SplashOff()
MsgBox($aUtilName, "Only one folder select window can be open at a time." & @CRLF & @CRLF & "Please close other window before opening this one.")
Return True
Else
Global $wSelectFolder = GUICreate($aUtilName, 720, 120, -1, -1)
Global $GUI_SF_I_SelectFolder = GUICtrlCreateInput($tDefaultDIR, 8, 40, 617, 21)
Local $tLabelSelectFolder = GUICtrlCreateLabel($tSFTxt, 8, 16, 200, 17)
Global $GUI_SF_B_SelectFolder = GUICtrlCreateButton("Select Folder", 632, 40, 75, 25)
Global $GUI_SF_B_Done = GUICtrlCreateButton("Done", 8, 72, 75, 25)
GUISetState(@SW_SHOW)
Do
$nMsg = GUIGetMsg()
Switch $nMsg
Case $GUI_EVENT_CLOSE
$aSFDone = True
Case $GUI_SF_B_SelectFolder
$tSourceFolder = FileSelectFolder($tTxt, $tDefaultDIR, 7, GUICtrlRead($GUI_SF_I_SelectFolder))
If @error Then
GUICtrlSetData($GUI_SF_I_SelectFolder, $tDefaultDIR)
Else
GUICtrlSetData($GUI_SF_I_SelectFolder, $tSourceFolder)
EndIf
Case $GUI_SF_B_Done
$aSFDone = True
EndSwitch
Sleep(100)
Until $aSFDone = True
$aSFDone = False
Opt("GUIOnEventMode", 1)
If WinExists($wGUIMainWindow) Then
GUIDelete($wSelectFolder)
$aExitGUISF1 = False
EndIf
Return $tSourceFolder
EndIf
EndFunc
Func GUI_SelectFolder_Close()
Opt("GUIOnEventMode", 1)
$tSourceFolder = GUICtrlRead($GUI_SF_I_SelectFolder)
$aExitGUISF1 = True
$aSelectFolder = 1
If WinExists($wGUIMainWindow) Then
GUIDelete($wSelectFolder)
$aExitGUISF1 = False
EndIf
EndFunc
Func GUI_SF_I_SelectFolder()
EndFunc
Func GUI_SF_B_SelectFolder()
$tSourceFolder = FileSelectFolder($tSFTxt, GUICtrlRead($GUI_SF_I_SelectFolder), 7, GUICtrlRead($GUI_SF_I_SelectFolder))
If @error Then
GUICtrlSetData($GUI_SF_I_SelectFolder, @ScriptDir)
Else
GUICtrlSetData($GUI_SF_I_SelectFolder, $tSourceFolder)
EndIf
EndFunc
Func GUI_SF_B_Done()
GUI_SelectFolder_Close()
EndFunc
Func GridConfiguratorGUI($tGridClicked)
If WinExists($wGridConfig) Then
Else
Global $tGridActive = $tGridClicked
Global $tG_T1_EditClicked = False, $tG_T2_EditClicked = False, $tG_T3_EditClicked = False, $tG_T4_EditClicked = False, $tG_T5_EditClicked = False
Global $tG_T6_EditClicked = False, $tG_T7_EditClicked = False, $tG_T8_EditClicked = False
Global $G_LastTab = 0, $aLastGridActive = 0, $aCancelTF = False
Local $gX = 0, $gY = 40
Local $gBW = 27, $gBH = 25, $gBGapX = 1, $gBGapY = 1, $gBinaRow = 35
For $i = 0 To ($aServerGridTotal - 1)
If Mod($i + 1, $gBinaRow) = 0 Then $gY += $gBH + $gBGapY
Next
Global $G_W_GridWinX = 1001
Global $G_W_GridWinY = 585 + $gY
Global $wGridConfig = GUICreate("Grid Configurator", $G_W_GridWinX, $G_W_GridWinY, -1, -1, BitOR($GUI_SS_DEFAULT_GUI, $WS_MAXIMIZEBOX, $WS_SIZEBOX, $WS_THICKFRAME, $WS_TABSTOP))
GUISetOnEvent($GUI_EVENT_CLOSE, "GUI_GridConfig_Close", $wGridConfig)
GUISetIcon($aIconFile, 99)
GUISetBkColor($cT1Background)
GUICtrlCreateTabItem("")
Global $G_W_GridButtons[$aServerGridTotal]
Local $tNamingScheme = $aNamingScheme
If $tNamingScheme = 3 Then $tNamingScheme = 1
Local $gBXstart = 8, $gBYstart = 8
Local $gBXnow = $gBXstart, $gBYnow = $gBYstart
For $i = 0 To ($aServerGridTotal - 1)
$G_W_GridButtons[$i] = GUICtrlCreateButton(_ServerNamingScheme($i, $tNamingScheme), $gBXnow, $gBYnow, $gBW, $gBH)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_W_GridTabClicked")
If Mod($i + 1, $gBinaRow) = 0 Then
$gBYnow += $gBH + $gBGapY
$gBXnow = $gBXstart
Else
$gBXnow += $gBW + $gBGapX
EndIf
Next
Global $G_GridConfig_Tab = GUICtrlCreateTab(8, $gY, $G_W_GridWinX - 16, 577)
GUICtrlSetOnEvent(-1, "G_On_Tab")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKLEFT + $GUI_DOCKTOP)
Global $G_T1_T_Main = GUICtrlCreateTabItem("1 Main")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $G_T1_L_GridName = GUICtrlCreateLabel("", 76, $gY + 33, 602, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_L_GridNumber = GUICtrlCreateLabel("", 20, $gY + 33, 49, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 126 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T1_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T1_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $G_T1_B_StartStopServer = GUICtrlCreateButton("", 20, $gY + 65, 107, 33)
GUICtrlSetOnEvent(-1, "G_T1_B_StartStopServer")
GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_G_LocalRemote = GUICtrlCreateGroup("", 372, $gY + 57, 129, 41)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_R1_Local = GUICtrlCreateRadio("Local", 380, $gY + 73, 49, 17)
GUICtrlSetOnEvent(-1, "G_T1_R1_Local")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_R1_Remote = GUICtrlCreateRadio("Remote", 436, $gY + 73, 57, 17)
GUICtrlSetOnEvent(-1, "G_T1_R1_Remote")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $G_T1_G_StartGrid = GUICtrlCreateGroup("", 140, $gY + 57, 225, 41, -1, $WS_EX_TRANSPARENT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_l2 = GUICtrlCreateLabel("Start Grid at Util Startup?", 148, $gY + 74, 121, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_R2_StartGridYes = GUICtrlCreateRadio("Yes", 276, $gY + 73, 41, 17)
GUICtrlSetOnEvent(-1, "G_T1_R2_StartGridYes")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_R2_StartGridNo = GUICtrlCreateRadio("No", 324, $gY + 73, 33, 17)
GUICtrlSetOnEvent(-1, "G_T1_R2_StartGridNo")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
Local $G_T1_G_GridNameIP = GUICtrlCreateGroup("", 20, $gY + 105, 851, 129)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_5 = GUICtrlCreateLabel("Server Name", 36, $gY + 122, 66, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_ServerName = GUICtrlCreateInput("", 108, $gY + 121, 305, 21)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_I_ServerName")
Local $G_T1_L_2 = GUICtrlCreateLabel("IP Address", 49, $gY + 147, 55, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_IPAddress = GUICtrlCreateInput("", 108, $gY + 145, 305, 21)
GUICtrlSetOnEvent(-1, "G_T1_I_IPAddress")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_34 = GUICtrlCreateLabel("AltSaveDIR", 731, $gY + 124, 60, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
If $aServerAltSaveSelect <> 3 Then GUICtrlSetState(-1, $GUI_DISABLE)
Global $G_T1_I_AltSaveDIR = GUICtrlCreateInput("", 796, $gY + 121, 65, 21, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "G_T1_I_AltSaveDIR")
If $aServerAltSaveSelect <> 3 Then GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_37 = GUICtrlCreateLabel("Query Port", 441, $gY + 124, 54, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_QueryPort = GUICtrlCreateInput("", 500, $gY + 121, 49, 21, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "G_T1_I_QueryPort")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_38 = GUICtrlCreateLabel("Game Port", 441, $gY + 148, 54, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_GamePort = GUICtrlCreateInput("", 500, $gY + 145, 49, 21, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "G_T1_I_GamePort")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_39 = GUICtrlCreateLabel("Seamless Port", 578, $gY + 124, 71, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_SeamlessPort = GUICtrlCreateInput("", 652, $gY + 121, 49, 21, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "G_T1_I_SeamlessPort")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_40 = GUICtrlCreateLabel("RCON Port", 591, $gY + 148, 57, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_RCONPort = GUICtrlCreateInput("", 652, $gY + 145, 49, 21, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "G_T1_I_RCONPort")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_41 = GUICtrlCreateLabel("Commandline (All Grids)", 29, $gY + 179, 114, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_CommandlineAllGrids = GUICtrlCreateInput("", 148, $gY + 177, 265, 21)
GUICtrlSetOnEvent(-1, "G_T1_I_CommandlineAllGrids")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_42 = GUICtrlCreateLabel("Added Commandline (This Grid)", 29, $gY + 203, 152, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_CommandlineThisGrid = GUICtrlCreateInput("", 185, $gY + 201, 228, 21)
GUICtrlSetOnEvent(-1, "G_T1_I_CommandlineThisGrid")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $tX = 508, $tY = $gY + 57
Local $G_T1_G_LocalRemote = GUICtrlCreateGroup("", $tX, $tY, 115, 41)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_R4_PVE = GUICtrlCreateRadio("PVE", $tX + 8, $tY + 16, 40, 17)
GUICtrlSetOnEvent(-1, "G_T1_R4_PVE")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_R4_PVP = GUICtrlCreateRadio("PVP", $tX + 62, $tY + 16, 40, 17)
GUICtrlSetOnEvent(-1, "G_T1_R4_PVP")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $tX = 438, $tY = $gY + 170
Local $G_T1_G_GridDelay = GUICtrlCreateGroup("", $tX, $tY, 363, 41)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_1 = GUICtrlCreateLabel("All Grids Startup Delay", $tX + 8, $tY + 16, 109, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_BaseDelay = GUICtrlCreateInput("", $tX + 120, $tY + 13, 25, 21, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "G_T1_I_BaseDelay")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_3 = GUICtrlCreateLabel("Additional delay this grid:", $tX + 208, $tY + 16, 120, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $G_T1_L_4 = GUICtrlCreateLabel("seconds", $tX + 152, $tY + 16, 44, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_I_AddedDelayGrid = GUICtrlCreateInput("", $tX + 328, $tY + 13, 25, 21, BitOR($ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "G_T1_I_AddedDelayGrid")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
Local $tX = 630, $tY = $gY + 57, $tW = 80
Local $G_T1_G_HomeServer = GUICtrlCreateGroup("", $tX, $tY, 180, 41)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += 8
Local $G_T1_L_HomeServer = GUICtrlCreateLabel("Is Home Server?", $tX, $tY + 17, $tW, 17, $SS_RIGHT)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += 10 + $tW
$tW = 35
Global $G_T1_R3_HomeServerYes = GUICtrlCreateRadio("Yes", $tX, $tY + 16, $tW, 17)
GUICtrlSetOnEvent(-1, "G_T1_R3_HomeServerYes")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 8
Global $G_T1_R3_HomeServerNo = GUICtrlCreateRadio("No", $tX, $tY + 16, $tW, 17)
GUICtrlSetOnEvent(-1, "G_T1_R3_HomeServerNo")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
Local $G_T1_G_OpenFolder = GUICtrlCreateGroup("Open Folder ", 880, $gY + 24, 101, 160)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_B_SaveFolder = GUICtrlCreateButton("Save Folder", 888, $gY + 48, 83, 25)
GUICtrlSetOnEvent(-1, "G_T1_B_SaveFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetTip(-1, "(This Grid) Open Save Folder in Explorer")
Global $G_T1_B_ConfigFolder = GUICtrlCreateButton("Config Folder", 888, $gY + 80, 83, 25)
GUICtrlSetOnEvent(-1, "G_T1_B_ConfigFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetTip(-1, "(This Grid) Open Config Folder in Explorer")
Global $G_T1_B_AtlasLogFolder = GUICtrlCreateButton($aGameName & " Log Folder", 888, $gY + 112, 83, 25)
GUICtrlSetTip(-1, "(All Grids) Open " & $aGameName & " Log Folder in Explorer")
GUICtrlSetOnEvent(-1, "G_T1_B_AtlasLogFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T1_B_ServerGrid = GUICtrlCreateButton("ServerGrid.json", 888, $gY + 144, 83, 25)
GUICtrlSetTip(-1, "(All Grids) Open Folder Containing ServerGrid.json File in Explorer")
GUICtrlSetOnEvent(-1, "G_T1_B_ServerGrid")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Global $G_T1_B_PurgeBackups = GUICtrlCreateButton("Purge Backups", 888, $gY + 204, 83, 25)
GUICtrlSetTip(-1, "Delete backups: GUS.bak, Game.bak, Engine.bak, ServerGrid, DefaultGUS/Game/Engine. Will ask how many backups to keep.")
GUICtrlSetOnEvent(-1, "G_T1_B_PurgeBackups")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cTextHighlight)
Local $tButtonW = 35, $tButtonGapY = 5
Local $gX = 20, $gW = $tButtonW, $gGap = $tButtonGapY, $tY = $gY + 245
GUICtrlCreateGraphic(10, $tY, $G_W_GridWinX - 20, 2, $SS_SUNKEN)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tY += 6
Global $G_T1_B_HighlightAll = GUICtrlCreateButton("All", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "Highlight / Select ALL parameters")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_HighlightAll")
GUICtrlSetBkColor(-1, $cTextHighlight)
$gX = $gX + $tButtonW + $tButtonGapY
Global $G_T1_B_HighlightNone = GUICtrlCreateButton("None", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "Highlight / Select NO parameters (unselect all)")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_HighlightNone")
GUICtrlSetBkColor(-1, $cTextHighlight)
$gX = $gX + $tButtonW + $tButtonGapY
Local $tButtonW = 50, $tButtonGapY = 5
Global $G_T1_B_HighlightDefault = GUICtrlCreateButton("Default", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "Highlight / Select DEFAULT parameters")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_HighlightDefault")
GUICtrlSetBkColor(-1, $cTextHighlight)
$gX = $gX + $tButtonW + $tButtonGapY
Local $tButtonW = 65, $tButtonGapY = 5
Global $G_T1_B_HighlightSetDefault = GUICtrlCreateButton("Set Default", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "Set Highlighted / Selected parameters as default")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_HighlightSetDefault")
GUICtrlSetBkColor(-1, $cTextHighlight)
$gX = $gX + $tButtonW + $tButtonGapY
Local $tButtonW = 60, $tButtonGapY = 5
GUICtrlCreateLabel("<- Highlight", $gX, $tY + 5, $tButtonW, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cTextHighlight)
$gX = $gX + $tButtonW + $tButtonGapY + 15
Local $tButtonW = 70, $tButtonGapY = 5
GUICtrlCreateLabel("Parameters ->", $gX, $tY + 5, $tButtonW, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cTextUnHighlight)
$gX = $gX + $tButtonW + $tButtonGapY
Local $tButtonW = 60, $tButtonGapY = 5
Global $G_T1_B_DefaultParams = GUICtrlCreateButton("Default", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "Change HIGHLIGHTED parameters to default values")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_DefaultParams")
GUICtrlSetBkColor(-1, $cTextUnHighlight)
$gX = $gX + $tButtonW + $tButtonGapY
Local $tButtonW = 60, $tButtonGapY = 5
Global $G_T1_B_SetDefaultParams = GUICtrlCreateButton("Set Default", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "SAVE all HIGHLIGHTED parameter values as default. Stackable: You can pick and choose from different grids which params to hightlight and save as default values.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_SetDefaultParams")
GUICtrlSetBkColor(-1, $cTextUnHighlight)
$gX = $gX + $tButtonW + $tButtonGapY + 25
Local $tButtonW = 65, $tButtonGapY = 5
Global $G_T1_B_NewParam = GUICtrlCreateButton("New Param", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "Add new parameter to the list.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_NewParam")
GUICtrlSetBkColor(-1, $cButtonFadedBlue)
GUICtrlSetState(-1, $GUI_DISABLE)
$pW = $G_W_GridWinX
Local $tButtonW = 165, $tButtonGapY = 5
$gX = $pW - 20 - $tButtonW
Global $G_T1_B_CopyAllGrids = GUICtrlCreateButton("Copy Highlighted to ALL Grids", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "Copy to ALL grids. Files will be backed up.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_CopyAllGrids")
GUICtrlSetBkColor(-1, $cGGridButtonSave)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T1_B_CopySelectGrids = GUICtrlCreateButton("Copy Highlighted to Select Grids", $gX, $tY, $tButtonW, 25)
GUICtrlSetTip(-1, "Copy to grids selected on MAIN WINDOW. Files will be backed up.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_T1_B_CopySelectGrids")
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $G_T2_T_GUS = GUICtrlCreateTabItem("2 GameUserSettings.ini")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $G_T2_L_GridName = GUICtrlCreateLabel("", 76, $gY + 33, 602, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T2_L_GridNumber = GUICtrlCreateLabel("", 20, $gY + 33, 49, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T2_E_Edit = GUICtrlCreateEdit("", 20, $gY + 97, 961, $G_W_GridWinY - 152)
GUICtrlSetOnEvent(-1, "G_T2_E_EditGUS")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cFWBackground)
_GUICtrlEdit_SetLimitText(-1, 999999)
Local $tButtonW = 110, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T2_B_CopyAllGrids = GUICtrlCreateButton("Copy to ALL Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T2_B_CopyAllGrids")
GUICtrlSetTip(-1, "Copy to ALL grids. Files will be backed up.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T2_B_CopySelectGrids = GUICtrlCreateButton("Copy to Select Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T2_B_CopySelectGrids")
GUICtrlSetTip(-1, "Copy to grids selected on MAIN WINDOW.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tX = 20, $tW = 50, $tGap = 20
Global $G_T2_B_Save = GUICtrlCreateButton("Save", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Click to save file: A backup will be made.")
GUICtrlSetOnEvent(-1, "G_T2_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
$tX += $tW + 5
Global $G_T2_B_Reset = GUICtrlCreateButton("Reset", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Reset Edit Window: Reload contents from file.")
GUICtrlSetOnEvent(-1, "G_T2_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
Global $G_T2_B_Find = GUICtrlCreateButton("Find", $tX, $gY + 65, $tW, 25)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "G_T2_B_Find")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T2_B_Replace = GUICtrlCreateButton("Replace", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Text: New Window Asks for Text to be Replaced With New Text.")
GUICtrlSetOnEvent(-1, "G_T2_B_Replace")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 110
Global $G_T2_B_ClipboardCopy = GUICtrlCreateButton("Copy to Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Copy Edit Window To Clipboard")
GUICtrlSetOnEvent(-1, "G_T2_B_ClipboardCopy")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T2_B_ClipboardPaste = GUICtrlCreateButton("Paste from Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Edit Window Content With Clipboard")
GUICtrlSetOnEvent(-1, "G_T2_B_ClipboardPaste")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 75
Global $G_T2_B_OpenFile = GUICtrlCreateButton("Open File", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open This File With Your Default Windows Text Editor")
GUICtrlSetOnEvent(-1, "G_T2_B_OpenFile")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T2_B_OpenFolder = GUICtrlCreateButton("Open Folder", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open The Folder Containing This File in Windows Explorer")
GUICtrlSetOnEvent(-1, "G_T2_B_OpenFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T2_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T2_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $G_T3_T_Game = GUICtrlCreateTabItem("3 Game.ini")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $G_T3_L_GridName = GUICtrlCreateLabel("", 76, $gY + 33, 602, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T3_L_GridNumber = GUICtrlCreateLabel("", 20, $gY + 33, 49, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T3_E_Edit = GUICtrlCreateEdit("", 20, $gY + 97, 961, $G_W_GridWinY - 152)
GUICtrlSetOnEvent(-1, "G_T3_E_Edit")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cFWBackground)
_GUICtrlEdit_SetLimitText(-1, 999999)
Local $tButtonW = 110, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T3_B_CopyAllGrids = GUICtrlCreateButton("Copy to ALL Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T3_B_CopyAllGrids")
GUICtrlSetTip(-1, "Copy to ALL grids. Files will be backed up.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T3_B_CopySelectGrids = GUICtrlCreateButton("Copy to Select Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetTip(-1, "Copy to grids selected on MAIN WINDOW.")
GUICtrlSetOnEvent(-1, "G_T3_B_CopySelectGrids")
GUICtrlSetTip(-1, "Copy to grids selected on MAIN WINDOW.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tX = 20, $tW = 50, $tGap = 20
Global $G_T3_B_Save = GUICtrlCreateButton("Save", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Click to save file: A backup will be made.")
GUICtrlSetOnEvent(-1, "G_T3_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
$tX += $tW + 5
Global $G_T3_B_Reset = GUICtrlCreateButton("Reset", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Reset Edit Window: Reload contents from file.")
GUICtrlSetOnEvent(-1, "G_T3_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
Global $G_T3_B_Find = GUICtrlCreateButton("Find", $tX, $gY + 65, $tW, 25)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "G_T3_B_Find")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T3_B_Replace = GUICtrlCreateButton("Replace", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Text: New Window Asks for Text to be Replaced With New Text.")
GUICtrlSetOnEvent(-1, "G_T3_B_Replace")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 110
Global $G_T3_B_ClipboardCopy = GUICtrlCreateButton("Copy to Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Copy Edit Window To Clipboard")
GUICtrlSetOnEvent(-1, "G_T3_B_ClipboardCopy")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T3_B_ClipboardPaste = GUICtrlCreateButton("Paste from Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Edit Window Content With Clipboard")
GUICtrlSetOnEvent(-1, "G_T3_B_ClipboardPaste")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 75
Global $G_T3_B_OpenFile = GUICtrlCreateButton("Open File", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open This File With Your Default Windows Text Editor")
GUICtrlSetOnEvent(-1, "G_T3_B_OpenFile")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T3_B_OpenFolder = GUICtrlCreateButton("Open Folder", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open The Folder Containing This File in Windows Explorer")
GUICtrlSetOnEvent(-1, "G_T3_B_OpenFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T3_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T3_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $G_T4_T_Engine = GUICtrlCreateTabItem("4 Engine.ini")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $G_T4_L_GridName = GUICtrlCreateLabel("", 76, $gY + 33, 602, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T4_L_GridNumber = GUICtrlCreateLabel("", 20, $gY + 33, 49, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T4_E_Edit = GUICtrlCreateEdit("", 20, $gY + 97, 961, $G_W_GridWinY - 152)
GUICtrlSetOnEvent(-1, "G_T4_E_Edit")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cFWBackground)
_GUICtrlEdit_SetLimitText(-1, 999999)
Local $tButtonW = 110, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T4_B_CopyAllGrids = GUICtrlCreateButton("Copy to ALL Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T4_B_CopyAllGrids")
GUICtrlSetTip(-1, "Copy to ALL grids. Files will be backed up.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T4_B_CopySelectGrids = GUICtrlCreateButton("Copy to Select Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetTip(-1, "Copy to grids selected on MAIN WINDOW.")
GUICtrlSetOnEvent(-1, "G_T4_B_CopySelectGrids")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tX = 20, $tW = 50, $tGap = 20
Global $G_T4_B_Save = GUICtrlCreateButton("Save", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Click to save file: A backup will be made.")
GUICtrlSetOnEvent(-1, "G_T4_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
$tX += $tW + 5
Global $G_T4_B_Reset = GUICtrlCreateButton("Reset", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Reset Edit Window: Reload contents from file.")
GUICtrlSetOnEvent(-1, "G_T4_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
Global $G_T4_B_Find = GUICtrlCreateButton("Find", $tX, $gY + 65, $tW, 25)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "G_T4_B_Find")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T4_B_Replace = GUICtrlCreateButton("Replace", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Text: New Window Asks for Text to be Replaced With New Text.")
GUICtrlSetOnEvent(-1, "G_T4_B_Replace")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 110
Global $G_T4_B_ClipboardCopy = GUICtrlCreateButton("Copy to Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Copy Edit Window To Clipboard")
GUICtrlSetOnEvent(-1, "G_T4_B_ClipboardCopy")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T4_B_ClipboardPaste = GUICtrlCreateButton("Paste from Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Edit Window Content With Clipboard")
GUICtrlSetOnEvent(-1, "G_T4_B_ClipboardPaste")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 75
Global $G_T4_B_OpenFile = GUICtrlCreateButton("Open File", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open This File With Your Default Windows Text Editor")
GUICtrlSetOnEvent(-1, "G_T4_B_OpenFile")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T4_B_OpenFolder = GUICtrlCreateButton("Open Folder", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open The Folder Containing This File in Windows Explorer")
GUICtrlSetOnEvent(-1, "G_T4_B_OpenFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T4_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T4_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $G_T5_T_ServerGrid = GUICtrlCreateTabItem("5 ServerGrid.json")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $G_T5_L_GridName = GUICtrlCreateLabel("", 76, $gY + 33, 602, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T5_L_GridNumber = GUICtrlCreateLabel("", 20, $gY + 33, 49, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T5_E_Edit = GUICtrlCreateEdit("", 20, $gY + 97, 961, $G_W_GridWinY - 152)
GUICtrlSetOnEvent(-1, "G_T5_E_Edit")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cFWBackground)
_GUICtrlEdit_SetLimitText(-1, 9999999)
Local $tX = 20, $tW = 50, $tGap = 20
Global $G_T5_B_Save = GUICtrlCreateButton("Save", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Click to save file: A backup will be made.")
GUICtrlSetOnEvent(-1, "G_T5_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
$tX += $tW + 5
Global $G_T5_B_Reset = GUICtrlCreateButton("Reset", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Reset Edit Window: Reload contents from file.")
GUICtrlSetOnEvent(-1, "G_T5_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
Global $G_T5_B_Find = GUICtrlCreateButton("Find", $tX, $gY + 65, $tW, 25)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "G_T5_B_Find")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T5_B_Replace = GUICtrlCreateButton("Replace", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Text: New Window Asks for Text to be Replaced With New Text.")
GUICtrlSetOnEvent(-1, "G_T5_B_Replace")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 110
Global $G_T5_B_ClipboardCopy = GUICtrlCreateButton("Copy to Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Copy Edit Window To Clipboard")
GUICtrlSetOnEvent(-1, "G_T5_B_ClipboardCopy")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T5_B_ClipboardPaste = GUICtrlCreateButton("Paste from Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Edit Window Content With Clipboard")
GUICtrlSetOnEvent(-1, "G_T5_B_ClipboardPaste")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 75
Global $G_T5_B_OpenFile = GUICtrlCreateButton("Open File", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open This File With Your Default Windows Text Editor")
GUICtrlSetOnEvent(-1, "G_T5_B_OpenFile")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T5_B_OpenFolder = GUICtrlCreateButton("Open Folder", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open The Folder Containing This File in Windows Explorer")
GUICtrlSetOnEvent(-1, "G_T5_B_OpenFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T5_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T5_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $G_T6_T_Tab = GUICtrlCreateTabItem("6 DefaultGUS.ini")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $G_T6_L_GridName = GUICtrlCreateLabel("", 76, $gY + 33, 602, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T6_L_GridNumber = GUICtrlCreateLabel("", 20, $gY + 33, 49, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T6_E_Edit = GUICtrlCreateEdit("", 20, $gY + 97, 961, $G_W_GridWinY - 152)
GUICtrlSetOnEvent(-1, "G_T6_E_Edit")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cFWBackground)
_GUICtrlEdit_SetLimitText(-1, 999999)
Local $tButtonW = 110, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T6_B_CopyAllGrids = GUICtrlCreateButton("Copy to ALL Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T6_B_CopyAllGrids")
GUICtrlSetTip(-1, "Copy to ALL grids. Files will be backed up.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T6_B_CopySelectGrids = GUICtrlCreateButton("Copy to Select Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T6_B_CopySelectGrids")
GUICtrlSetTip(-1, "Copy to grids selected on MAIN WINDOW.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tX = 20, $tW = 50, $tGap = 20
Global $G_T6_B_Save = GUICtrlCreateButton("Save", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Click to save file: A backup will be made.")
GUICtrlSetOnEvent(-1, "G_T6_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
$tX += $tW + 5
Global $G_T6_B_Reset = GUICtrlCreateButton("Reset", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Reset Edit Window: Reload contents from file.")
GUICtrlSetOnEvent(-1, "G_T6_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
Global $G_T6_B_Find = GUICtrlCreateButton("Find", $tX, $gY + 65, $tW, 25)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "G_T6_B_Find")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T6_B_Replace = GUICtrlCreateButton("Replace", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Text: New Window Asks for Text to be Replaced With New Text.")
GUICtrlSetOnEvent(-1, "G_T6_B_Replace")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 110
Global $G_T6_B_ClipboardCopy = GUICtrlCreateButton("Copy to Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Copy Edit Window To Clipboard")
GUICtrlSetOnEvent(-1, "G_T6_B_ClipboardCopy")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T6_B_ClipboardPaste = GUICtrlCreateButton("Paste from Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Edit Window Content With Clipboard")
GUICtrlSetOnEvent(-1, "G_T6_B_ClipboardPaste")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 75
Global $G_T6_B_OpenFile = GUICtrlCreateButton("Open File", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open This File With Your Default Windows Text Editor")
GUICtrlSetOnEvent(-1, "G_T6_B_OpenFile")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T6_B_OpenFolder = GUICtrlCreateButton("Open Folder", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open The Folder Containing This File in Windows Explorer")
GUICtrlSetOnEvent(-1, "G_T6_B_OpenFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T6_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T6_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $G_T7_T_Tab = GUICtrlCreateTabItem("7 DefaultGame.ini")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $G_T7_L_GridName = GUICtrlCreateLabel("", 76, $gY + 33, 602, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T7_L_GridNumber = GUICtrlCreateLabel("", 20, $gY + 33, 49, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T7_E_Edit = GUICtrlCreateEdit("", 20, $gY + 97, 961, $G_W_GridWinY - 152)
GUICtrlSetOnEvent(-1, "G_T7_E_Edit")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cFWBackground)
_GUICtrlEdit_SetLimitText(-1, 999999)
Local $tButtonW = 110, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T7_B_CopyAllGrids = GUICtrlCreateButton("Copy to ALL Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T7_B_CopyAllGrids")
GUICtrlSetTip(-1, "Copy to ALL grids. Files will be backed up.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T7_B_CopySelectGrids = GUICtrlCreateButton("Copy to Select Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T7_B_CopySelectGrids")
GUICtrlSetTip(-1, "Copy to grids selected on MAIN WINDOW.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tX = 20, $tW = 50, $tGap = 20
Global $G_T7_B_Save = GUICtrlCreateButton("Save", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Click to save file: A backup will be made.")
GUICtrlSetOnEvent(-1, "G_T7_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
GUICtrlSetBkColor(-1, $cGGridButtonSave)
Global $G_T7_B_Reset = GUICtrlCreateButton("Reset", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Reset Edit Window: Reload contents from file.")
GUICtrlSetOnEvent(-1, "G_T7_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
Global $G_T7_B_Find = GUICtrlCreateButton("Find", $tX, $gY + 65, $tW, 25)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "G_T7_B_Find")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T7_B_Replace = GUICtrlCreateButton("Replace", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Text: New Window Asks for Text to be Replaced With New Text.")
GUICtrlSetOnEvent(-1, "G_T7_B_Replace")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 110
Global $G_T7_B_ClipboardCopy = GUICtrlCreateButton("Copy to Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Copy Edit Window To Clipboard")
GUICtrlSetOnEvent(-1, "G_T7_B_ClipboardCopy")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T7_B_ClipboardPaste = GUICtrlCreateButton("Paste from Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Edit Window Content With Clipboard")
GUICtrlSetOnEvent(-1, "G_T7_B_ClipboardPaste")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 75
Global $G_T7_B_OpenFile = GUICtrlCreateButton("Open File", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open This File With Your Default Windows Text Editor")
GUICtrlSetOnEvent(-1, "G_T7_B_OpenFile")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T7_B_OpenFolder = GUICtrlCreateButton("Open Folder", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open The Folder Containing This File in Windows Explorer")
GUICtrlSetOnEvent(-1, "G_T7_B_OpenFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T7_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T7_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
Global $G_T8_T_Tab = GUICtrlCreateTabItem("8 DefaultEngine.ini")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
Global $G_T8_L_GridName = GUICtrlCreateLabel("", 76, $gY + 33, 602, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T8_L_GridNumber = GUICtrlCreateLabel("", 20, $gY + 33, 49, 24)
GUICtrlSetFont(-1, 12, 800, 0, "MS Sans Serif")
GUICtrlSetColor(-1, 0x800000)
GUICtrlSetBkColor(-1, 0xFFFFFF)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Global $G_T8_E_Edit = GUICtrlCreateEdit("", 20, $gY + 97, 961, $G_W_GridWinY - 152)
GUICtrlSetOnEvent(-1, "G_T8_E_Edit")
GUICtrlSetResizing(-1, $GUI_DOCKAUTO + $GUI_DOCKTOP + $GUI_DOCKHCENTER + $GUI_DOCKVCENTER)
GUICtrlSetBkColor(-1, $cFWBackground)
_GUICtrlEdit_SetLimitText(-1, 999999)
Local $tButtonW = 110, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T8_B_CopyAllGrids = GUICtrlCreateButton("Copy to ALL Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T8_B_CopyAllGrids")
GUICtrlSetTip(-1, "Copy to ALL grids. Files will be backed up.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T8_B_CopySelectGrids = GUICtrlCreateButton("Copy to Select Grids", $gX, $gY + 65, $tButtonW, 25)
GUICtrlSetOnEvent(-1, "G_T8_B_CopySelectGrids")
GUICtrlSetTip(-1, "Copy to grids selected on MAIN WINDOW.")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tX = 20, $tW = 50, $tGap = 20
Global $G_T8_B_Save = GUICtrlCreateButton("Save", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Click to save file: A backup will be made.")
GUICtrlSetOnEvent(-1, "G_T8_B_Save")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cGGridButtonSave)
$tX += $tW + 5
Global $G_T8_B_Reset = GUICtrlCreateButton("Reset", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Reset Edit Window: Reload contents from file.")
GUICtrlSetOnEvent(-1, "G_T8_B_Reset")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
Global $G_T8_B_Find = GUICtrlCreateButton("Find", $tX, $gY + 65, $tW, 25)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "G_T8_B_Find")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T8_B_Replace = GUICtrlCreateButton("Replace", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Text: New Window Asks for Text to be Replaced With New Text.")
GUICtrlSetOnEvent(-1, "G_T8_B_Replace")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 110
Global $G_T8_B_ClipboardCopy = GUICtrlCreateButton("Copy to Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Copy Edit Window To Clipboard")
GUICtrlSetOnEvent(-1, "G_T8_B_ClipboardCopy")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T8_B_ClipboardPaste = GUICtrlCreateButton("Paste from Clipboard", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Replace Edit Window Content With Clipboard")
GUICtrlSetOnEvent(-1, "G_T8_B_ClipboardPaste")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5 + $tGap
$tW = 75
Global $G_T8_B_OpenFile = GUICtrlCreateButton("Open File", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open This File With Your Default Windows Text Editor")
GUICtrlSetOnEvent(-1, "G_T8_B_OpenFile")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$tX += $tW + 5
Global $G_T8_B_OpenFolder = GUICtrlCreateButton("Open Folder", $tX, $gY + 65, $tW, 25)
GUICtrlSetTip(-1, "Open The Folder Containing This File in Windows Explorer")
GUICtrlSetOnEvent(-1, "G_T8_B_OpenFolder")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
Local $tButtonW = 85, $tButtonGapY = 5, $tButtonX = $G_W_GridWinX - 15 - $tButtonW - $tButtonGapY
Local $gX = $tButtonX, $gW = $tButtonW, $gGap = $tButtonGapY
Global $G_T8_B_RestartServers = GUICtrlCreateButton("Restart Servers", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart Servers: You will be asked whether to restart servers now OR use Remote Restart with announcements.")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartServers")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonStopServer)
$gX = $gX - $tButtonW - $tButtonGapY
Global $G_T8_B_RestartUtil = GUICtrlCreateButton("Restart Util", $gX, $gY + 33, $tButtonW, 25)
GUICtrlSetTip(-1, "Restart This Utility Program: Servers Will Remain Running")
GUICtrlSetOnEvent(-1, "G_TA_B_RestartUtil")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetBkColor(-1, $cSWButtonRestartUtil)
_ParamFileImport()
Global $G_T1_L_ParametersTF[$gParamTFMax]
Global $G_T1_I_ParametersTF[$gParamTFMax]
Global $G_T1_I_ParamTFX[$gParamTFMax]
Global $G_T1_I_ParamTFY[$gParamTFMax]
Local $pW = $G_W_GridWinX - 41, $pH = 10 + (24 * $tParamTypeMax), $gScrollStartX = 10, $gScrollStartY = 10, $gParamInputBoxW = 60, $tButtonW = 110
Local $iScroll_Width = $pW - 20, $iScroll_Ht = $pH, $iH_Tight = 0, $iV_Tight = 0, $fBefore = True, $iRepeat = 0, $bRegisterMsg = True
$tY = $tY + 25
If (24 * $gParamTFMax) > 321 Then
$gScrollWindowH = $G_W_GridWinY - 20 - ($tY)
Else
$gScrollWindowH = 10 + (24 * $gParamTFMax)
EndIf
Global $G_T1_G_Parameters = GUICreate("", $pW, $gScrollWindowH, 15, $tY, BitOR($WS_POPUP, $WS_BORDER), $WS_EX_MDICHILD, $wGridConfig)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH)
$G_T1_G_ParamScrollBars = _GUIScrollbars_Generate($G_T1_G_Parameters, $iScroll_Width, $iScroll_Ht, $iH_Tight, $iV_Tight, $fBefore, $iRepeat, $bRegisterMsg)
Local $gParamBaseY = $gScrollStartY
Local $gParamColumn1x = $gScrollStartX
Local $gParamColumn2x = Int(($pW - 20 - $gScrollStartX) / 2)
Local $gParamY = $gParamBaseY
Local $gParamX = $gParamColumn1x
For $i = 0 To ($gParamTFMax - 1)
$G_T1_L_ParametersTF[$i] = GUICtrlCreateLabel($gParamTFName[$i], $gParamX + 32, $gParamY, 300, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_W_ParamTFLabelClicked")
GUICtrlSetTip(-1, $gParamTFToolTip[$i])
$G_T1_I_ParamTFX[$i] = $gParamX
$G_T1_I_ParamTFY[$i] = $gParamY - 5
If $gParamTFValue[$i] Then
$G_T1_I_ParametersTF[$i] = GUICtrlCreateIcon($aIconFile, 214, $G_T1_I_ParamTFX[$i], $G_T1_I_ParamTFY[$i], 24, 24)
Else
$G_T1_I_ParametersTF[$i] = GUICtrlCreateIcon($aIconFile, 215, $G_T1_I_ParamTFX[$i], $G_T1_I_ParamTFY[$i], 24, 24)
EndIf
GUICtrlSetOnEvent(-1, "G_W_ParamTFIconClicked")
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$gParamY += 24
Next
Global $gParamNumMax = UBound($gParamNumName)
Global $G_T1_L_ParametersEdit[$gParamNumMax]
Global $G_T1_I_ParametersEdit[$gParamNumMax]
Local $gParamEditColumn1x = $gParamColumn2x
Local $gParamEditColumn2x = 60 + $gParamEditColumn1x
Local $gParamY = $gParamBaseY
Local $gParamX1 = $gParamEditColumn1x
Local $gParamX2 = $gParamEditColumn2x
For $i = 0 To ($gParamNumMax - 1)
If $gParamNumName[$i] = "Message" Then
$G_T1_I_ParametersEdit[$i] = GUICtrlCreateButton("MOTD", $gParamX1, $gParamY, 50, 17, $ES_LEFT)
Else
$G_T1_I_ParametersEdit[$i] = GUICtrlCreateInput($gParamNumValue[$i], $gParamX1, $gParamY, 50, 17, $ES_RIGHT)
EndIf
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
GUICtrlSetOnEvent(-1, "G_W_ParamNumEditClicked")
$G_T1_L_ParametersEdit[$i] = GUICtrlCreateLabel($gParamNumName[$i], $gParamX2, $gParamY, 300, 17)
GUICtrlSetOnEvent(-1, "G_W_ParamNumLabelClicked")
GUICtrlSetTip(-1, $gParamNumToolTip[$i])
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKTOP + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$gParamY += 24
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlSetState(-1, $GUI_DISABLE)
G_T1_UpdateTab()
GUISetState(@SW_SHOW, $wGridConfig)
GUISetState(@SW_SHOW, $G_T1_G_Parameters)
If WinExists($wGUIMainWindow) Then
Else
While $aExitGUIG = False
Sleep(100)
WEnd
GUIDelete($wGridConfig)
$aExitGUIG = False
EndIf
EndIf
EndFunc
Func GUI_GridConfig_Close()
$aExitGUIG = True
If WinExists($wGUIMainWindow) Then
GUIDelete($wGridConfig)
$aExitGUIG = False
EndIf
EndFunc
Func G_On_Tab()
Switch GUICtrlRead($G_GridConfig_Tab)
Case 0
G_T1_UpdateTab()
G_LastTab(0)
GUISetState(@SW_SHOW, $G_T1_G_Parameters)
Case 1
G_T2_UpdateTab()
G_LastTab(1)
GUISetState(@SW_HIDE, $G_T1_G_Parameters)
Case 2
G_T3_UpdateTab()
G_LastTab(2)
GUISetState(@SW_HIDE, $G_T1_G_Parameters)
Case 3
G_T4_UpdateTab()
G_LastTab(3)
GUISetState(@SW_HIDE, $G_T1_G_Parameters)
Case 4
G_T5_UpdateTab()
G_LastTab(4)
GUISetState(@SW_HIDE, $G_T1_G_Parameters)
Case 5
G_T6_UpdateTab()
G_LastTab(5)
GUISetState(@SW_HIDE, $G_T1_G_Parameters)
Case 6
G_T7_UpdateTab()
G_LastTab(6)
GUISetState(@SW_HIDE, $G_T1_G_Parameters)
Case 7
G_T8_UpdateTab()
G_LastTab(7)
GUISetState(@SW_HIDE, $G_T1_G_Parameters)
EndSwitch
EndFunc
Func G_W_GridTabClicked()
Local $tGID = @GUI_CtrlId
Local $tCancelTF = G_LastTab($G_LastTab)
For $i = 0 To ($aServerGridTotal - 1)
If $tGID = $G_W_GridButtons[$i] Then
$tGridActive = $i
ExitLoop
EndIf
Next
If $tCancelTF Or $aCancelTF Then
$tGridActive = $aLastGridActive
Else
If $G_LastTab = 0 Then G_T1_UpdateTab()
If $G_LastTab = 1 Then G_T2_UpdateTab()
If $G_LastTab = 2 Then G_T3_UpdateTab()
If $G_LastTab = 3 Then G_T4_UpdateTab()
If $G_LastTab = 4 Then G_T5_UpdateTab()
If $G_LastTab = 5 Then G_T6_UpdateTab()
If $G_LastTab = 6 Then G_T7_UpdateTab()
If $G_LastTab = 7 Then G_T8_UpdateTab()
$aLastGridActive = $tGridActive
EndIf
G_UpdateGridTabs()
$aLastGridActive = $tGridActive
EndFunc
Func G_LastTab($tTab)
If $G_LastTab = 0 Then
EndIf
$aCancelTF = False
If $G_LastTab = 1 Then
If $tG_T2_EditClicked Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "Do you wish to save changes to GameUserSettings.ini?" & @CRLF & @CRLF & "Click (YES) to save" & @CRLF & "Click (NO) to discarge changes" & @CRLF & "Click (CANCEL) to continue editing.", 10)
If $tMB = 6 Then
G_T2_B_Save()
$tG_T2_EditClicked = False
ElseIf $tMB = 7 Then
G_T2_B_Reset()
$tG_T2_EditClicked = False
ElseIf $tMB = 2 Or $tMB = -1 Then
Local $tTxt = GUICtrlRead($G_T2_E_Edit)
GUICtrlSetState($G_T2_T_GUS, $GUI_SHOW)
GUICtrlSetData($G_T2_E_Edit, $tTxt)
$tG_T2_EditClicked = True
$aCancelTF = True
EndIf
EndIf
EndIf
If $G_LastTab = 2 Then
If $tG_T3_EditClicked Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "Do you wish to save changes to Game.ini?" & @CRLF & @CRLF & "Click (YES) to save" & @CRLF & "Click (NO) to discarge changes" & @CRLF & "Click (CANCEL) to continue editing.", 10)
If $tMB = 6 Then
G_T3_B_Save()
$tG_T3_EditClicked = False
ElseIf $tMB = 7 Then
G_T3_B_Reset()
$tG_T3_EditClicked = False
ElseIf $tMB = 2 Or $tMB = -1 Then
Local $tTxt = GUICtrlRead($G_T3_E_Edit)
GUICtrlSetState($G_T3_T_Game, $GUI_SHOW)
GUICtrlSetData($G_T3_E_Edit, $tTxt)
$tG_T3_EditClicked = True
$aCancelTF = True
EndIf
EndIf
EndIf
If $G_LastTab = 3 Then
If $tG_T4_EditClicked Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "Do you wish to save changes to Engine.ini?" & @CRLF & @CRLF & "Click (YES) to save" & @CRLF & "Click (NO) to discarge changes" & @CRLF & "Click (CANCEL) to continue editing.", 10)
If $tMB = 6 Then
G_T4_B_Save()
$tG_T4_EditClicked = False
ElseIf $tMB = 7 Then
G_T4_B_Reset()
$tG_T4_EditClicked = False
ElseIf $tMB = 2 Or $tMB = -1 Then
Local $tTxt = GUICtrlRead($G_T4_E_Edit)
GUICtrlSetState($G_T4_T_Engine, $GUI_SHOW)
GUICtrlSetData($G_T4_E_Edit, $tTxt)
$tG_T4_EditClicked = True
$aCancelTF = True
EndIf
EndIf
EndIf
If $G_LastTab = 4 Then
If $tG_T5_EditClicked Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "Do you wish to save changes to ServerGrid.json?" & @CRLF & @CRLF & "Click (YES) to save" & @CRLF & "Click (NO) to discarge changes" & @CRLF & "Click (CANCEL) to continue editing.", 10)
If $tMB = 6 Then
G_T5_B_Save()
$tG_T5_EditClicked = False
ElseIf $tMB = 7 Then
G_T5_B_Reset()
$tG_T5_EditClicked = False
ElseIf $tMB = 2 Or $tMB = -1 Then
Local $tTxt = GUICtrlRead($G_T5_E_Edit)
GUICtrlSetState($G_T5_T_ServerGrid, $GUI_SHOW)
GUICtrlSetData($G_T5_E_Edit, $tTxt)
$tG_T5_EditClicked = True
$aCancelTF = True
EndIf
EndIf
EndIf
If $G_LastTab = 5 Then
If $tG_T6_EditClicked Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "Do you wish to save changes to DefaultGameUserSettings.ini?" & @CRLF & @CRLF & "Click (YES) to save" & @CRLF & "Click (NO) to discarge changes" & @CRLF & "Click (CANCEL) to continue editing.", 10)
If $tMB = 6 Then
G_T6_B_Save()
$tG_T6_EditClicked = False
ElseIf $tMB = 7 Then
G_T6_B_Reset()
$tG_T6_EditClicked = False
ElseIf $tMB = 2 Or $tMB = -1 Then
Local $tTxt = GUICtrlRead($G_T6_E_Edit)
GUICtrlSetState($G_T6_T_Tab, $GUI_SHOW)
GUICtrlSetData($G_T6_E_Edit, $tTxt)
$tG_T6_EditClicked = True
$aCancelTF = True
EndIf
EndIf
EndIf
If $G_LastTab = 6 Then
If $tG_T7_EditClicked Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "Do you wish to save changes to DefaultGame.ini?" & @CRLF & @CRLF & "Click (YES) to save" & @CRLF & "Click (NO) to discarge changes" & @CRLF & "Click (CANCEL) to continue editing.", 10)
If $tMB = 6 Then
G_T7_B_Save()
$tG_T7_EditClicked = False
ElseIf $tMB = 7 Then
G_T7_B_Reset()
$tG_T7_EditClicked = False
ElseIf $tMB = 2 Or $tMB = -1 Then
Local $tTxt = GUICtrlRead($G_T7_E_Edit)
GUICtrlSetState($G_T7_T_Tab, $GUI_SHOW)
GUICtrlSetData($G_T7_E_Edit, $tTxt)
$tG_T7_EditClicked = True
$aCancelTF = True
EndIf
EndIf
EndIf
If $G_LastTab = 7 Then
If $tG_T8_EditClicked Then
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilityVer, "Do you wish to save changes to DefaultEngine.ini?" & @CRLF & @CRLF & "Click (YES) to save" & @CRLF & "Click (NO) to discarge changes" & @CRLF & "Click (CANCEL) to continue editing.", 10)
If $tMB = 6 Then
G_T8_B_Save()
$tG_T8_EditClicked = False
ElseIf $tMB = 7 Then
G_T8_B_Reset()
$tG_T8_EditClicked = False
ElseIf $tMB = 2 Or $tMB = -1 Then
Local $tTxt = GUICtrlRead($G_T8_E_Edit)
GUICtrlSetState($G_T8_T_Tab, $GUI_SHOW)
GUICtrlSetData($G_T8_E_Edit, $tTxt)
$tG_T8_EditClicked = True
$aCancelTF = True
EndIf
EndIf
EndIf
$G_LastTab = $tTab
Return $aCancelTF
EndFunc
Func G_T1_UpdateTab()
GUICtrlSetData($G_T1_L_GridNumber, "(" & _ServerNamingScheme($tGridActive, $aNamingScheme) & ")")
GUICtrlSetData($G_T1_L_GridName, $xServerNames[$tGridActive])
GUICtrlSetData($G_T1_I_AddedDelayGrid, $xGridStartDelay[$tGridActive])
GUICtrlSetData($G_T1_I_BaseDelay, $aServerStartDelay)
GUICtrlSetData($G_T1_I_ServerName, $xServerNames[$tGridActive])
GUICtrlSetData($G_T1_I_IPAddress, $xServerIP[$tGridActive])
GUICtrlSetData($G_T1_I_AltSaveDIR, $xServerAltSaveDir[$tGridActive])
GUICtrlSetData($G_T1_I_QueryPort, $xServerport[$tGridActive])
GUICtrlSetData($G_T1_I_GamePort, $xServergameport[$tGridActive])
GUICtrlSetData($G_T1_I_SeamlessPort, $xServerseamlessDataPort[$tGridActive])
GUICtrlSetData($G_T1_I_RCONPort, $xServerRCONPort[$tGridActive + 1])
GUICtrlSetData($G_T1_I_CommandlineAllGrids, $aServerExtraCMD)
GUICtrlSetData($G_T1_I_CommandlineThisGrid, $xServerGridExtraCMD[$tGridActive])
_ParamsRead()
G_UpdateStartGrid()
G_UpdateRadioLocal()
G_T1_B_StartStopServUpdate()
G_UpdateRadioIsHomeServer()
G_UpdateRadioServerPVE()
G_UpdateGridTabs()
G_UpdateHighlight()
G_UpdateValue()
EndFunc
Func G_UpdateGridTabs()
For $i = 0 To ($aServerGridTotal - 1)
If $i = $tGridActive Then
GUICtrlSetBkColor($G_W_GridButtons[$i], $cGGridButtonActive)
Else
GUICtrlSetBkColor($G_W_GridButtons[$i], $cGGridButtonInactive)
EndIf
Next
EndFunc
Func G_UpdateRadioLocal()
If $xLocalGrid[$tGridActive] = "yes" Then
GUICtrlSetState($G_T1_R1_Local, $GUI_CHECKED)
GUICtrlSetState($G_T1_R1_Remote, $GUI_UNCHECKED)
Else
GUICtrlSetState($G_T1_R1_Local, $GUI_UNCHECKED)
GUICtrlSetState($G_T1_R1_Remote, $GUI_CHECKED)
EndIf
EndFunc
Func G_UpdateStartGrid()
If $xStartGrid[$tGridActive] = "yes" Then
GUICtrlSetState($G_T1_R2_StartGridYes, $GUI_CHECKED)
GUICtrlSetState($G_T1_R2_StartGridNo, $GUI_UNCHECKED)
Else
GUICtrlSetState($G_T1_R2_StartGridYes, $GUI_UNCHECKED)
GUICtrlSetState($G_T1_R2_StartGridNo, $GUI_CHECKED)
EndIf
EndFunc
Func G_UpdateRadioIsHomeServer()
If $xServerIsHomeServer[$tGridActive] Then
GUICtrlSetState($G_T1_R3_HomeServerYes, $GUI_CHECKED)
GUICtrlSetState($G_T1_R3_HomeServerNo, $GUI_UNCHECKED)
Else
GUICtrlSetState($G_T1_R3_HomeServerYes, $GUI_UNCHECKED)
GUICtrlSetState($G_T1_R3_HomeServerNo, $GUI_CHECKED)
EndIf
EndFunc
Func G_UpdateRadioServerPVE()
If $xServerPVE[$tGridActive] Then
GUICtrlSetState($G_T1_R4_PVE, $GUI_CHECKED)
GUICtrlSetState($G_T1_R4_PVP, $GUI_UNCHECKED)
Else
GUICtrlSetState($G_T1_R4_PVE, $GUI_UNCHECKED)
GUICtrlSetState($G_T1_R4_PVP, $GUI_CHECKED)
EndIf
EndFunc
Func G_UpdateHighlight()
For $i = 0 To ($gParamTFMax - 1)
If $gParamTFActiveTF[$i] = True Then
GUICtrlSetBkColor($G_T1_L_ParametersTF[$i], $cTextHighlight)
Else
GUICtrlSetBkColor($G_T1_L_ParametersTF[$i], $cTextUnHighlight)
EndIf
Next
For $i = 0 To ($gParamNumMax - 1)
If $gParamNumActiveTF[$i] Then
GUICtrlSetBkColor($G_T1_L_ParametersEdit[$i], $cTextHighlight)
Else
GUICtrlSetBkColor($G_T1_L_ParametersEdit[$i], $cTextUnHighlight)
EndIf
Next
EndFunc
Func G_UpdateValue()
For $i = 0 To ($gParamTFMax - 1)
If $gParamTFValue[$i] Then
GUICtrlSetImage($G_T1_I_ParametersTF[$i], $aIconFile, 214)
Else
GUICtrlSetImage($G_T1_I_ParametersTF[$i], $aIconFile, 215)
EndIf
If $gParamTFValExistTF[$i] Then
GUICtrlSetColor($G_T1_L_ParametersTF[$i], $cTextActive)
Else
GUICtrlSetColor($G_T1_L_ParametersTF[$i], $cTextInactive)
EndIf
Next
For $i = 0 To ($gParamNumMax - 1)
If $gParamNumName[$i] = "Message" Then
GUICtrlSetData($G_T1_I_ParametersEdit[$i], "MOTD")
Else
GUICtrlSetData($G_T1_I_ParametersEdit[$i], $gParamNumValue[$i])
EndIf
If $gParamNumValExistTF[$i] Then
GUICtrlSetColor($G_T1_L_ParametersEdit[$i], $cTextActive)
Else
GUICtrlSetColor($G_T1_L_ParametersEdit[$i], $cTextInactive)
EndIf
Next
EndFunc
Func G_TA_B_RestartUtil()
_RestartUtil()
EndFunc
Func G_TA_B_RestartServers()
LogWrite("", " [Server] Restart Server requested by user in Grid Configurator.")
$bMsg = "Restart Servers Requested." & @CRLF & @CRLF & "Click (YES) to restart servers WITH announcement" & @CRLF & "(Initiate Remote Restart)" & @CRLF & "Click (NO) to restart servers NOW" & @CRLF & "Click (CANCEL) to cancel."
SplashOff()
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $bMsg, 30)
If $tMB = 6 Then
F_RemoteRestart()
ElseIf $tMB = 7 Then
F_RestartNow(False)
ElseIf $tMB = 2 Then
LogWrite("", " [Server] Restart Server canceled by user.")
_Splash("Restart cancelled.", 2000)
ElseIf $tMB = -1 Then
LogWrite("", " [Server] Restart Server canceled by user.")
_Splash("Restart cancelled.", 2000)
EndIf
EndFunc
Func G_T1_B_SaveFolder()
ShellExecute($aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\")
EndFunc
Func G_T1_B_ConfigFolder()
ShellExecute($aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\")
EndFunc
Func G_T1_B_AtlasLogFolder()
ShellExecute($aServerDirLocal & "\ShooterGame\Saved\Logs\")
EndFunc
Func G_T1_B_ServerGrid()
ShellExecute($aServerDirLocal & "\ShooterGame\")
EndFunc
Func G_T1_B_PurgeBackups()
Local $tBackupsToKeep = Number(Int(InputBox($aUtilName, "Number of recent backups to keep? (0-100)", 10, "", -1, 125, Default, Default, 60)))
If $tBackupsToKeep < 1 Or $tBackupsToKeep > 100 Then
_Splash("You must enter a valid number")
Else
PurgeParamBackups($tBackupsToKeep)
EndIf
EndFunc
Func G_W_ParamTFIconClicked()
Local $tTxt = ""
For $i = 0 To ($gParamTFMax - 1)
$tTxt &= $G_T1_I_ParametersTF[$i] & @CRLF
If @GUI_CtrlId = $G_T1_I_ParametersTF[$i] Then
If $gParamTFValue[$i] Then
GUICtrlSetImage($G_T1_I_ParametersTF[$i], $aIconFile, 215)
$gParamTFValue[$i] = False
Else
GUICtrlSetImage($G_T1_I_ParametersTF[$i], $aIconFile, 214)
$gParamTFValue[$i] = True
EndIf
_ParamClicked($i, "TF")
ExitLoop
EndIf
Next
EndFunc
Func G_W_ParamTFLabelClicked()
For $i = 0 To ($gParamTFMax - 1)
If @GUI_CtrlId = $G_T1_L_ParametersTF[$i] Then
If $gParamTFActiveTF[$i] Then
$gParamTFActiveTF[$i] = False
GUICtrlSetBkColor($G_T1_L_ParametersTF[$i], $cTextUnHighlight)
Else
$gParamTFActiveTF[$i] = True
GUICtrlSetBkColor($G_T1_L_ParametersTF[$i], $cTextHighlight)
EndIf
ExitLoop
EndIf
Next
EndFunc
Func G_W_ParamNumEditClicked()
For $i = 0 To ($gParamNumMax - 1)
If @GUI_CtrlId = $G_T1_I_ParametersEdit[$i] Then
Local $tOld = $gParamNumValue[$i]
If $gParamNumName[$i] = "Message" Then
$gParamNumValue[$i] = InputBox($aUtilName, "Enter Message of the Day (MOTD):", $tOld, "", 550, 125, Default, Default, 360)
If @error Then $gParamNumValue[$i] = $tOld
Else
$gParamNumValue[$i] = GUICtrlRead($G_T1_I_ParametersEdit[$i])
EndIf
_ParamClicked($i, "Num", $tOld)
ExitLoop
EndIf
Next
EndFunc
Func G_W_ParamNumLabelClicked()
For $i = 0 To ($gParamNumMax - 1)
If @GUI_CtrlId = $G_T1_L_ParametersEdit[$i] Then
If $gParamNumActiveTF[$i] Then
$gParamNumActiveTF[$i] = False
GUICtrlSetBkColor($G_T1_L_ParametersEdit[$i], $cTextUnHighlight)
Else
$gParamNumActiveTF[$i] = True
GUICtrlSetBkColor($G_T1_L_ParametersEdit[$i], $cTextHighlight)
EndIf
ExitLoop
EndIf
Next
EndFunc
Func G_T1_B_StartStopServUpdate()
If ProcessExists($aServerPID[$tGridActive]) And $xLocalGrid[$tGridActive] = "yes" Then
GUICtrlSetBkColor($G_T1_B_StartStopServer, 0xFF5858)
GUICtrlSetData($G_T1_B_StartStopServer, "Stop Server")
Else
If $xLocalGrid[$tGridActive] = "yes" Then
GUICtrlSetBkColor($G_T1_B_StartStopServer, 0x00FF00)
GUICtrlSetData($G_T1_B_StartStopServer, "Start Server")
Else
GUICtrlSetBkColor($G_T1_B_StartStopServer, 0xD7DBDD)
GUICtrlSetData($G_T1_B_StartStopServer, "Remote Server")
EndIf
EndIf
EndFunc
Func G_T1_B_StartStopServer()
GUI_Main_B_SelectNone()
G_T1_B_StartStopServUpdate()
If GUICtrlRead($G_T1_B_StartStopServer) = "Start Server" Then
If $xLocalGrid[$tGridActive] = "no" Then
_Splash("ERROR! Cannot start server " & _ServerNamingScheme($tGridActive, $aNamingScheme) & "." & @CRLF & "It is set as a Remote server." & @CRLF & "To start, set it to LOCAL and try again.", 5000)
Else
SelectServersStart($tGridActive)
EndIf
ElseIf GUICtrlRead($G_T1_B_StartStopServer) = "Remote Server" Then
_Splash("ERROR! Cannot start server " & _ServerNamingScheme($tGridActive, $aNamingScheme) & "." & @CRLF & "It is set as a Remote server. To start, set it to a local server then try again.", 5000)
ElseIf GUICtrlRead($G_T1_B_StartStopServer) = "Stop Server" Then
SelectServersStop($tGridActive)
Else
EndIf
G_UpdateStartGrid()
G_T1_B_StartStopServUpdate()
EndFunc
Func G_T1_R1_Local()
$xLocalGrid[$tGridActive] = "yes"
IniWrite($aGridSelectFile, $aGridIniTitle[1], "Is Server (" & $xServergridx[$tGridActive] & "," & $xServergridy[$tGridActive] & ") Local (yes/no)", $xLocalGrid[$tGridActive])
G_UpdateRadioLocal()
G_T1_B_StartStopServUpdate()
EndFunc
Func G_T1_R1_Remote()
$xLocalGrid[$tGridActive] = "no"
IniWrite($aGridSelectFile, $aGridIniTitle[1], "Is Server (" & $xServergridx[$tGridActive] & "," & $xServergridy[$tGridActive] & ") Local (yes/no)", $xLocalGrid[$tGridActive])
G_UpdateRadioLocal()
G_T1_B_StartStopServUpdate()
G_T1_R2_StartGridNo()
EndFunc
Func G_T1_R2_StartGridYes()
$xStartGrid[$tGridActive] = "yes"
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$tGridActive] & "," & $xServergridy[$tGridActive] & ") (yes/no)", $xStartGrid[$tGridActive])
G_UpdateStartGrid()
EndFunc
Func G_T1_R2_StartGridNo()
$xStartGrid[$tGridActive] = "no"
IniWrite($aGridSelectFile, $aGridIniTitle[0], "Start Server (" & $xServergridx[$tGridActive] & "," & $xServergridy[$tGridActive] & ") (yes/no)", $xStartGrid[$tGridActive])
G_UpdateStartGrid()
EndFunc
Func G_T1_I_AddedDelayGrid()
$xGridStartDelay[$tGridActive] = GUICtrlRead($G_T1_I_AddedDelayGrid)
If $xGridStartDelay[$tGridActive] < 0 Then
$xGridStartDelay[$tGridActive] = 0
GUICtrlSetData($G_T1_I_AddedDelayGrid, $xGridStartDelay[$tGridActive])
EndIf
If $xGridStartDelay[$tGridActive] > 600 Then
$xGridStartDelay[$tGridActive] = 600
GUICtrlSetData($G_T1_I_AddedDelayGrid, $xGridStartDelay[$tGridActive])
EndIf
_BackupFile($aGridSelectFile)
IniWrite($aGridSelectFile, $aGridIniTitle[3], "Additional startup delay Server (" & $xServergridx[$tGridActive] & "," & $xServergridy[$tGridActive] & ") (0-600)", $xGridStartDelay[$tGridActive])
EndFunc
Func G_T1_I_BaseDelay()
$aServerStartDelay = GUICtrlRead($G_T1_I_BaseDelay)
If $aServerStartDelay < 0 Then
$aServerStartDelay = 0
GUICtrlSetData($G_T1_I_BaseDelay, $aServerStartDelay)
ElseIf $aServerStartDelay > 600 Then
$aServerStartDelay = 600
GUICtrlSetData($G_T1_I_BaseDelay, $aServerStartDelay)
EndIf
_BackupFile($aIniFile)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Delay in seconds between grid server starts (0-600) ###", $aServerStartDelay)
EndFunc
Func G_T1_I_ServerName()
Local $aTxtOld = $xServerNames[$tGridActive]
$xServerNames[$tGridActive] = GUICtrlRead($G_T1_I_ServerName)
Local $aTxtNew = $xServerNames[$tGridActive]
Local $tParam = "name"
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, True, False)
If $tLine = -1 Then
$xServerNames[$tGridActive] = $aTxtOld
_Splash("ERROR! Server Name not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
GUICtrlSetData($G_T1_I_ServerName, $xServerNames[$tGridActive])
EndFunc
Func G_T1_I_IPAddress()
Local $aTxtOld = $xServerIP[$tGridActive]
$xServerIP[$tGridActive] = GUICtrlRead($G_T1_I_IPAddress)
Local $aTxtNew = $xServerIP[$tGridActive]
Local $tParam = "ip"
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, True, False)
If $tLine = -1 Then
$xServerIP[$tGridActive] = $aTxtOld
_Splash("ERROR! Server IP not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
GUICtrlSetData($G_T1_I_IPAddress, $xServerIP[$tGridActive])
EndFunc
Func G_T1_I_AltSaveDIR()
Local $aTxtOld = $xServerAltSaveDir[$tGridActive]
$xServerAltSaveDir[$tGridActive] = GUICtrlRead($G_T1_I_AltSaveDIR)
Local $aTxtNew = $xServerAltSaveDir[$tGridActive]
_BackupFile($aIniFile)
$aServerAltSaveDir = StringReplace($aServerAltSaveDir, $aTxtOld, $aTxtNew)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server AltSaveDirectoryNames (Use same order as listed in ServerGrid.json. Comma separated) ###", $aServerAltSaveDir)
GUICtrlSetData($G_T1_I_AltSaveDIR, $xServerAltSaveDir[$tGridActive])
EndFunc
Func G_T1_I_QueryPort()
Local $aTxtOld = $xServerport[$tGridActive]
$xServerport[$tGridActive] = GUICtrlRead($G_T1_I_QueryPort)
Local $aTxtNew = $xServerport[$tGridActive]
Local $tParam = "port"
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, False, False)
If $tLine = -1 Then
$xServerport[$tGridActive] = $aTxtOld
_Splash("ERROR! Query Port not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
GUICtrlSetData($G_T1_I_QueryPort, $xServerport[$tGridActive])
EndFunc
Func G_T1_I_GamePort()
Local $aTxtOld = $xServergameport[$tGridActive]
$xServergameport[$tGridActive] = GUICtrlRead($G_T1_I_GamePort)
Local $aTxtNew = $xServergameport[$tGridActive]
Local $tParam = "gamePort"
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, False, False)
If $tLine = -1 Then
$xServergameport[$tGridActive] = $aTxtOld
_Splash("ERROR! Game Port not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
GUICtrlSetData($G_T1_I_GamePort, $xServergameport[$tGridActive])
EndFunc
Func G_T1_I_SeamlessPort()
Local $aTxtOld = $xServerseamlessDataPort[$tGridActive]
$xServerseamlessDataPort[$tGridActive] = GUICtrlRead($G_T1_I_SeamlessPort)
Local $aTxtNew = $xServerseamlessDataPort[$tGridActive]
Local $tParam = "seamlessDataPort"
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, False, False)
If $tLine = -1 Then
$xServerseamlessDataPort[$tGridActive] = $aTxtOld
_Splash("ERROR! SeamlessDataPort not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
GUICtrlSetData($G_T1_I_SeamlessPort, $xServerseamlessDataPort[$tGridActive])
EndFunc
Func G_T1_I_RCONPort()
Local $aTxtOld = $xServerRCONPort[$tGridActive + 1]
$xServerRCONPort[$tGridActive + 1] = GUICtrlRead($G_T1_I_RCONPort)
Local $aTxtNew = $xServerRCONPort[$tGridActive + 1]
If ($aServerRCONImport = "yes") Then
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\GameUserSettings.ini"
Local $tBefore = "RCONPort=" & $aTxtOld
_ReplaceStringFile($aFile, $tBefore, $aTxtNew, -1, "RCON", False)
Else
_BackupFile($aIniFile)
$aServerRCONPort = StringReplace($aServerRCONPort, $aTxtOld, $aTxtNew)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", "Server RCON Port(s) (comma separated, grid order as in ServerGrid.json, ignore if importing RCON ports) ###", $aServerRCONPort)
EndIf
GUICtrlSetData($G_T1_I_RCONPort, $xServerRCONPort[$tGridActive + 1])
EndFunc
Func G_T1_I_CommandlineAllGrids()
$aServerExtraCMD = GUICtrlRead($G_T1_I_CommandlineAllGrids)
_BackupFile($aIniFile)
IniWrite($aIniFile, " --------------- GAME SERVER CONFIGURATION --------------- ", $aGameName & " extra commandline parameters (ex.?serverpve-pve -NoCrashDialog) ###", $aServerExtraCMD)
EndFunc
Func G_T1_I_CommandlineThisGrid()
$xServerGridExtraCMD[$tGridActive] = GUICtrlRead($G_T1_I_CommandlineThisGrid)
_BackupFile($aGridSelectFile, "", False)
IniWrite($aGridSelectFile, $aGridIniTitle[2], "Add to Commandline for Server (" & $xServergridx[$tGridActive] & "," & $xServergridy[$tGridActive] & ")", $xServerGridExtraCMD[$tGridActive])
EndFunc
Func G_T1_B_HighlightAll()
For $i = 0 To ($gParamTFMax - 1)
$gParamTFActiveTF[$i] = True
GUICtrlSetBkColor($G_T1_L_ParametersTF[$i], $cTextHighlight)
Next
For $i = 0 To ($gParamNumMax - 1)
$gParamNumActiveTF[$i] = True
GUICtrlSetBkColor($G_T1_L_ParametersEdit[$i], $cTextHighlight)
Next
EndFunc
Func G_T1_B_HighlightNone()
For $i = 0 To ($gParamTFMax - 1)
$gParamTFActiveTF[$i] = False
GUICtrlSetBkColor($G_T1_L_ParametersTF[$i], $cTextUnHighlight)
Next
For $i = 0 To ($gParamNumMax - 1)
$gParamNumActiveTF[$i] = False
GUICtrlSetBkColor($G_T1_L_ParametersEdit[$i], $cTextUnHighlight)
Next
EndFunc
Func G_T1_B_HighlightDefault()
_ParamFileImport("Highlight")
G_UpdateHighlight()
EndFunc
Func G_T1_B_HighlightSetDefault()
For $i = 0 To ($gParamTFMax - 1)
$gParamTFActiveDefaultTF[$i] = $gParamTFActiveTF[$i]
Next
For $i = 0 To ($gParamNumMax - 1)
$gParamNumActiveDefaultTF[$i] = $gParamNumActiveTF[$i]
Next
Local $tCount = _ParamFileWrite("Highlight")
EndFunc
Func G_T1_B_DefaultParams()
_ParamFileImport("Value")
G_UpdateValue()
_ParamsSave("sel", "all")
EndFunc
Func G_T1_B_SetDefaultParams()
If _AnySelParam() Then
For $i = 0 To ($gParamTFMax - 1)
$gParamTFDefaultValue[$i] = $gParamTFValue[$i]
Next
For $i = 0 To ($gParamNumMax - 1)
$gParamNumDefaultValue[$i] = $gParamNumValue[$i]
Next
Local $tCount = _ParamFileWrite("Param")
_Splash("Default Parameter values saved." & @CRLF & $tCount & " highlighted parameters saved as default values." & @CRLF & @CRLF & "Click [Default] button to paste the saved default values to current grid.", 2000)
Else
_Splash("No Parameters selected.", 2000)
EndIf
EndFunc
Func G_T1_B_NewParam()
Local $tTxt = "Add new parameter to list."
Local $pParName = InputBox($tTxt, "Parameter name", "bDisableFogOfWar", "", 400, 125)
Local $pParValue = InputBox($tTxt, "Default value", "True", "", 400, 125)
Local $pParFile = InputBox($tTxt, "(0)CommandLine (1)ServerGrid (2)GUS (3)Game (4)Engine", "2", "", 400, 125)
Local $pParDescription = InputBox($tTxt, "Description", "", "", 400, 125)
MsgBox(0, "Kim", $pParName & @CRLF & $pParValue & @CRLF & $pParFile & @CRLF & $pParDescription)
EndFunc
Func G_T1_B_CopySelectGrids()
$tSplash = _Splash("Applying changes to files")
If _AnySelParam() And _AnySelGrid() Then
Local $tTot = 0, $tFnd = 0
For $i = 0 To ($aServerGridTotal - 1)
If _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
ControlSetText($tSplash, "", "Static1", "Applying changes to Server " & _ServerNamingScheme($i, $aNamingScheme) & " files.")
Local $tFound = _ParamsSave("sel", "all", $i)
$tTot += $tFound[0]
$tFnd += $tFound[1]
EndIf
Next
LogWrite(" [Param] " & $tTot & " Parameters compared. " & $tFnd & " changes made.")
ControlSetText($tSplash, "", "Static1", "Done. Parameters compared: " & $tTot & " , Changes Made: " & $tFnd)
Sleep(2000)
SplashOff()
Else
If _AnySelParam() = False Then _Splash("No Parameters selected.", 2000)
If _AnySelGrid() = False Then _Splash("No Grids selected in main window.", 2000)
EndIf
EndFunc
Func G_T1_B_CopyAllGrids()
If _AnySelParam() Then
$tSplash = _Splash("Applying changes to files")
Local $tTot = 0, $tFnd = 0
For $i = 0 To ($aServerGridTotal - 1)
ControlSetText($tSplash, "", "Static1", "Applying changes to Server " & _ServerNamingScheme($i, $aNamingScheme) & " files.")
Local $tFound = _ParamsSave("sel", "all", $i)
$tTot += $tFound[0]
$tFnd += $tFound[1]
Next
LogWrite(" [Param] " & $tTot & " Parameters compared. " & $tFnd & " changes made.")
ControlSetText($tSplash, "", "Static1", "Done. Parameters compared: " & $tTot & " , Changes Made: " & $tFnd)
Sleep(2000)
SplashOff()
Else
_Splash("No Parameters selected.", 2000)
EndIf
EndFunc
Func G_T1_R4_PVP()
If $xServerPVE[$tGridActive] = True Then
$xServerPVE[$tGridActive] = False
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\GameUserSettings.ini"
Local $tBefore = "ServerPVE=True"
Local $aTxtNew = $xServerPVE[$tGridActive]
_ReplaceStringFile($aFile, $tBefore, $aTxtNew, -1, "TF", False)
G_UpdateRadioServerPVE()
EndIf
EndFunc
Func G_T1_R4_PVE()
If $xServerPVE[$tGridActive] = False Then
$xServerPVE[$tGridActive] = True
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\GameUserSettings.ini"
Local $tBefore = "ServerPVE=False"
Local $aTxtNew = $xServerPVE[$tGridActive]
_ReplaceStringFile($aFile, $tBefore, $aTxtNew, -1, "TF", False)
G_UpdateRadioServerPVE()
EndIf
EndFunc
Func G_T1_R3_HomeServerNo()
Local $aTxtOld = $xServerIsHomeServer[$tGridActive]
$xServerIsHomeServer[$tGridActive] = False
Local $aTxtNew = $xServerIsHomeServer[$tGridActive]
Local $tParam = "isHomeServer"
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, False, False)
If $tLine = -1 Then
$xServerIsHomeServer[$tGridActive] = $aTxtOld
_Splash("ERROR!" & $tParam & " not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
G_UpdateRadioIsHomeServer()
EndFunc
Func G_T1_R3_HomeServerYes()
Local $aTxtOld = $xServerIsHomeServer[$tGridActive]
$xServerIsHomeServer[$tGridActive] = True
Local $aTxtNew = $xServerIsHomeServer[$tGridActive]
Local $tParam = "isHomeServer"
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, False, False)
If $tLine = -1 Then
$xServerIsHomeServer[$tGridActive] = $aTxtOld
_Splash("ERROR!" & $tParam & " not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
G_UpdateRadioIsHomeServer()
EndFunc
Func G_T2_UpdateTab()
GUICtrlSetData($G_T2_L_GridNumber, "(" & _ServerNamingScheme($tGridActive, $aNamingScheme) & ")")
GUICtrlSetData($G_T2_L_GridName, $xServerNames[$tGridActive])
Local $tFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\GameUserSettings.ini"
Local $tFileRead = FileRead($tFile)
GUICtrlSetData($G_T2_E_Edit, $tFileRead)
EndFunc
Func G_T2_E_EditGUS()
$tG_T2_EditClicked = True
EndFunc
Func G_T2_B_Save()
Local $tFileName = "GameUserSettings.ini"
Local $tTxt = GUICtrlRead($G_T2_E_Edit)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
Local $tFileBackup = $tFileSource & "_" & $tTime & ".bak"
FileMove($tFileSource, $tFileBackup, 1)
FileWrite($tFileSource, $tTxt)
$tG_T2_EditClicked = False
_Splash($tFileName & " updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $tFileName & "_" & $tTime & ".bak", 2000, 525)
EndFunc
Func G_T2_B_Reset()
Local $tFileName = "GameUserSettings.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
Local $tTxt = FileRead($tFileSource)
$tG_T2_EditClicked = False
GUICtrlSetData($G_T2_E_Edit, $tTxt)
EndFunc
Func G_T2_B_Replace()
Local $tTxtBefore = InputBox($aUtilName, "Enter text to replace (before)", "", "", -1, 125, Default, Default, 120)
If $tTxtBefore = "" Then Return
Local $tTxtAfter = InputBox($aUtilName, "Enter text to replace with (after)", "", "", -1, 125, Default, Default, 120)
$tMB = MsgBox($MB_OKCANCEL, "REPLACE TEXT", "Replace:" & $tTxtBefore & @CRLF & "With:" & $tTxtAfter)
If $tMB = 1 Then
Local $tTxt = GUICtrlRead($G_T2_E_Edit)
Local $tTxt1 = StringReplace($tTxt, $tTxtBefore, $tTxtAfter)
$tReplacements = @extended
GUICtrlSetData($G_T2_E_Edit, $tTxt1)
$tG_T2_EditClicked = True
_Splash($tReplacements & " occurrences were replaced", 2000)
Else
_Splash("Replace canceled.", 1500)
EndIf
EndFunc
Func G_T2_B_ClipboardCopy()
ClipPut(GUICtrlRead($G_T2_E_Edit))
_Splash("Contents copied to clipboard", 750)
EndFunc
Func G_T2_B_ClipboardPaste()
GUICtrlSetData($G_T2_E_Edit, ClipGet())
EndFunc
Func G_T2_B_OpenFile()
Local $tFileName = "GameUserSettings.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
ShellExecute($tFileSource)
EndFunc
Func G_T2_B_OpenFolder()
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer"
ShellExecute($tFileSource)
EndFunc
Func G_T2_B_CopyAllGrids()
Local $tFileName = "GameUserSettings.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
SplashOff()
Local $aMsg = "Copy to ALL LOCAL grids?" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy (RCON Ports will be updated)." & @CRLF & "Click (NO) to copy AS IS. (Notice! RCON ports will NOT be updated)." & @CRLF & "Click (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied from " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " to ALL LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T2_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
If $i <> $tGridActive Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\" & $tFileName
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
If $tMB = 6 Then _Update_GUS_File($tFileTemp, $i)
EndIf
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T2_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
EndFunc
Func G_T2_B_CopySelectGrids()
If _AnySelGrid() Then
Local $tFileName = "GameUserSettings.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
SplashOff()
Local $tGrids = ""
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then $tGrids &= _ServerNamingScheme($i, $aNamingScheme) & " "
Next
If $tGrids = "" Then $tGrids = " [ None Selected ]"
Local $aMsg = "Copy to the following SELECT LOCAL grids?" & @CRLF & $tGrids & @CRLF & @CRLF & " (Uses local grids selected in MAIN WINDOW)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy (RCON Ports will be updated)." & @CRLF & "Click (NO) to copy AS IS. (Notice! RCON ports will NOT be updated)." & @CRLF & "Click (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied from " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " to SELECT LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T2_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
If $i <> $tGridActive Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\" & $tFileName
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
If $tMB = 6 Then _Update_GUS_File($tFileTemp, $i)
EndIf
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T2_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
Else
_Splash("No Grids selected in main window.", 2000)
EndIf
EndFunc
Func G_T3_UpdateTab()
GUICtrlSetData($G_T3_L_GridNumber, "(" & _ServerNamingScheme($tGridActive, $aNamingScheme) & ")")
GUICtrlSetData($G_T3_L_GridName, $xServerNames[$tGridActive])
Local $tFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\Game.ini"
Local $tFileRead = FileRead($tFile)
GUICtrlSetData($G_T3_E_Edit, $tFileRead)
EndFunc
Func G_T3_E_Edit()
$tG_T3_EditClicked = True
EndFunc
Func G_T3_B_Save()
Local $tFileName = "Game.ini"
Local $tTxt = GUICtrlRead($G_T3_E_Edit)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
Local $tFileBackup = $tFileSource & "_" & $tTime & ".bak"
FileMove($tFileSource, $tFileBackup, 1)
FileWrite($tFileSource, $tTxt)
$tG_T3_EditClicked = False
_Splash($tFileName & " updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $tFileName & "_" & $tTime & ".bak", 2000, 525)
EndFunc
Func G_T3_B_Reset()
Local $tFileName = "Game.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
Local $tTxt = FileRead($tFileSource)
GUICtrlSetData($G_T3_E_Edit, $tTxt)
$tG_T3_EditClicked = False
EndFunc
Func G_T3_B_Replace()
Local $tTxtBefore = InputBox($aUtilName, "Enter text to replace (before)", "", "", -1, 125, Default, Default, 120)
If $tTxtBefore = "" Then Return
Local $tTxtAfter = InputBox($aUtilName, "Enter text to replace with (after)", "", "", -1, 125, Default, Default, 120)
$tMB = MsgBox($MB_OKCANCEL, "REPLACE TEXT", "Replace:" & $tTxtBefore & @CRLF & "With:" & $tTxtAfter)
If $tMB = 1 Then
Local $tTxt = GUICtrlRead($G_T3_E_Edit)
Local $tTxt1 = StringReplace($tTxt, $tTxtBefore, $tTxtAfter)
$tReplacements = @extended
GUICtrlSetData($G_T3_E_Edit, $tTxt1)
$tG_T3_EditClicked = True
_Splash($tReplacements & " occurrences were replaced", 2000)
Else
_Splash("Replace canceled.", 1500)
EndIf
EndFunc
Func G_T3_B_ClipboardCopy()
ClipPut(GUICtrlRead($G_T3_E_Edit))
_Splash("Contents copied to clipboard", 750)
EndFunc
Func G_T3_B_ClipboardPaste()
GUICtrlSetData($G_T3_E_Edit, ClipGet())
EndFunc
Func G_T3_B_OpenFile()
Local $tFileName = "Game.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
ShellExecute($tFileSource)
EndFunc
Func G_T3_B_OpenFolder()
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer"
ShellExecute($tFileSource)
EndFunc
Func G_T3_B_CopyAllGrids()
Local $tFileName = "Game.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
SplashOff()
Local $aMsg = "Copy " & $tFileName & " content" & @CRLF & "From " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " to ALL LOCAL grids?" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied from " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " to ALL LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T3_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
If $i <> $tGridActive Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\" & $tFileName
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T3_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
EndFunc
Func G_T3_B_CopySelectGrids()
If _AnySelGrid() Then
Local $tFileName = "Game.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
SplashOff()
Local $tGrids = ""
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then $tGrids &= _ServerNamingScheme($i, $aNamingScheme) & " "
Next
If $tGrids = "" Then $tGrids = " [ None Selected ]"
Local $aMsg = "Copy to the following SELECT LOCAL grids?" & @CRLF & $tGrids & @CRLF & @CRLF & " (Uses local grids selected in MAIN WINDOW)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied from " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " to SELECT LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T3_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
If $i <> $tGridActive Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\" & $tFileName
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T3_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
Else
_Splash("No Grids selected in main window.", 2000)
EndIf
EndFunc
Func G_T4_UpdateTab()
GUICtrlSetData($G_T4_L_GridNumber, "(" & _ServerNamingScheme($tGridActive, $aNamingScheme) & ")")
GUICtrlSetData($G_T4_L_GridName, $xServerNames[$tGridActive])
Local $tFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\Engine.ini"
Local $tFileRead = FileRead($tFile)
GUICtrlSetData($G_T4_E_Edit, $tFileRead)
EndFunc
Func G_T4_E_Edit()
$tG_T4_EditClicked = True
EndFunc
Func G_T4_B_Save()
Local $tFileName = "Engine.ini"
Local $tTxt = GUICtrlRead($G_T4_E_Edit)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
Local $tFileBackup = $tFileSource & "_" & $tTime & ".bak"
FileMove($tFileSource, $tFileBackup, 1)
FileWrite($tFileSource, $tTxt)
$tG_T4_EditClicked = False
_Splash($tFileName & " updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $tFileName & "_" & $tTime & ".bak", 2000, 525)
EndFunc
Func G_T4_B_Reset()
Local $tFileName = "Engine.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
Local $tTxt = FileRead($tFileSource)
$tG_T4_EditClicked = False
GUICtrlSetData($G_T4_E_Edit, $tTxt)
EndFunc
Func G_T4_B_Replace()
Local $tTxtBefore = InputBox($aUtilName, "Enter text to replace (before)", "", "", -1, 125, Default, Default, 120)
If $tTxtBefore = "" Then Return
Local $tTxtAfter = InputBox($aUtilName, "Enter text to replace with (after)", "", "", -1, 125, Default, Default, 120)
$tMB = MsgBox($MB_OKCANCEL, "REPLACE TEXT", "Replace:" & $tTxtBefore & @CRLF & "With:" & $tTxtAfter)
If $tMB = 1 Then
Local $tTxt = GUICtrlRead($G_T4_E_Edit)
Local $tTxt1 = StringReplace($tTxt, $tTxtBefore, $tTxtAfter)
$tReplacements = @extended
GUICtrlSetData($G_T4_E_Edit, $tTxt1)
$tG_T4_EditClicked = True
_Splash($tReplacements & " occurrences were replaced", 2000)
Else
_Splash("Replace canceled.", 1500)
EndIf
EndFunc
Func G_T4_B_ClipboardCopy()
ClipPut(GUICtrlRead($G_T4_E_Edit))
_Splash("Contents copied to clipboard", 750)
EndFunc
Func G_T4_B_ClipboardPaste()
GUICtrlSetData($G_T4_E_Edit, ClipGet())
EndFunc
Func G_T4_B_OpenFile()
Local $tFileName = "Engine.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
ShellExecute($tFileSource)
EndFunc
Func G_T4_B_OpenFolder()
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer"
ShellExecute($tFileSource)
EndFunc
Func G_T4_B_CopyAllGrids()
Local $tFileName = "Engine.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
SplashOff()
Local $aMsg = "Copy " & $tFileName & " content" & @CRLF & "From " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " to ALL LOCAL grids?" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied from " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " to ALL LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T4_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
If $i <> $tGridActive Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\" & $tFileName
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T4_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
EndFunc
Func G_T4_B_CopySelectGrids()
If _AnySelGrid() Then
Local $tFileName = "Engine.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\" & $tFileName
SplashOff()
Local $tGrids = ""
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then $tGrids &= _ServerNamingScheme($i, $aNamingScheme) & " "
Next
If $tGrids = "" Then $tGrids = " [ None Selected ]"
Local $aMsg = "Copy to the following SELECT LOCAL grids?" & @CRLF & $tGrids & @CRLF & @CRLF & " (Uses local grids selected in MAIN WINDOW)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied from " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " to SELECT LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T4_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
If $i <> $tGridActive Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\" & $tFileName
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T4_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
Else
_Splash("No Grids selected in main window.", 2000)
EndIf
EndFunc
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Func G_T5_UpdateTab()
GUICtrlSetData($G_T5_L_GridNumber, "(" & _ServerNamingScheme($tGridActive, $aNamingScheme) & ")")
GUICtrlSetData($G_T5_L_GridName, $xServerNames[$tGridActive])
Local $tFile = $aServerDirLocal & "\ShooterGame\ServerGrid.json"
Local $tFileRead = FileRead($tFile)
GUICtrlSetData($G_T5_E_Edit, $tFileRead)
EndFunc
Func G_T5_E_Edit()
$tG_T5_EditClicked = True
EndFunc
Func G_T5_B_Save()
Local $tFileName = "ServerGrid.json"
Local $tTxt = GUICtrlRead($G_T5_E_Edit)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileSource = $aServerDirLocal & "\ShooterGame\" & $tFileName
Local $tFileBackup = $tFileSource & "_" & $tTime & ".bak"
FileMove($tFileSource, $tFileBackup, 1)
FileWrite($tFileSource, $tTxt)
$tG_T5_EditClicked = False
_Splash($tFileName & " updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $tFileName & "_" & $tTime & ".bak", 2000, 525)
EndFunc
Func G_T5_B_Reset()
Local $tFileName = "ServerGrid.json"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\" & $tFileName
Local $tTxt = FileRead($tFileSource)
$tG_T5_EditClicked = False
GUICtrlSetData($G_T5_E_Edit, $tTxt)
EndFunc
Func G_T5_B_Replace()
Local $tTxtBefore = InputBox($aUtilName, "Enter text to replace (before)", "", "", -1, 125, Default, Default, 120)
If $tTxtBefore = "" Then Return
Local $tTxtAfter = InputBox($aUtilName, "Enter text to replace with (after)", "", "", -1, 125, Default, Default, 120)
$tMB = MsgBox($MB_OKCANCEL, "REPLACE TEXT", "Replace:" & $tTxtBefore & @CRLF & "With:" & $tTxtAfter)
If $tMB = 1 Then
Local $tTxt = GUICtrlRead($G_T5_E_Edit)
Local $tTxt1 = StringReplace($tTxt, $tTxtBefore, $tTxtAfter)
$tReplacements = @extended
GUICtrlSetData($G_T5_E_Edit, $tTxt1)
$tG_T5_EditClicked = True
_Splash($tReplacements & " occurrences were replaced", 2000)
Else
_Splash("Replace canceled.", 1500)
EndIf
EndFunc
Func G_T5_B_Find()
$tTxt = InputBox($aUtilName, "Enter text to find", "", "", -1, 125, Default, Default, 60)
If $tTxt = "" Then
Else
Local $tTxt1 = GUICtrlRead($G_T5_E_Edit)
$tTxtPos = StringInStr($tTxt1, $tTxt)
If $tTxtPos = 0 Then
_Splash("Text not found", 1000)
Else
_GUICtrlEdit_SetSel($G_T5_E_Edit, $tTxtPos, $tTxtPos + StringLen($tTxt))
_GUICtrlEdit_Scroll($G_T5_E_Edit, $SB_SCROLLCARET)
_GUICtrlEdit_SetSel($G_T5_E_Edit, $tTxtPos, $tTxtPos + StringLen($tTxt))
_GUICtrlEdit_Scroll($G_T5_E_Edit, $SB_SCROLLCARET)
EndIf
EndIf
EndFunc
Func G_T5_B_ClipboardCopy()
ClipPut(GUICtrlRead($G_T5_E_Edit))
_Splash("Contents copied to clipboard", 750)
EndFunc
Func G_T5_B_ClipboardPaste()
GUICtrlSetData($G_T5_E_Edit, ClipGet())
EndFunc
Func G_T5_B_OpenFile()
Local $tFileName = "ServerGrid.json"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\" & $tFileName
ShellExecute($tFileSource)
EndFunc
Func G_T5_B_OpenFolder()
Local $tFileSource = $aServerDirLocal & "\ShooterGame"
ShellExecute($tFileSource)
EndFunc
Func G_T6_UpdateTab()
GUICtrlSetData($G_T6_L_GridNumber, "(" & _ServerNamingScheme($tGridActive, $aNamingScheme) & ")")
GUICtrlSetData($G_T6_L_GridName, $xServerNames[$tGridActive])
Local $tFile = $aServerDirLocal & "\ShooterGame\Config\DefaultGameUserSettings.ini"
Local $tFileRead = FileRead($tFile)
GUICtrlSetData($G_T6_E_Edit, $tFileRead)
EndFunc
Func G_T6_E_Edit()
$tG_T6_EditClicked = True
EndFunc
Func G_T6_B_Save()
Local $tFileName = "DefaultGameUserSettings.ini"
Local $tTxt = GUICtrlRead($G_T6_E_Edit)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
Local $tFileBackup = $tFileSource & "_" & $tTime & ".bak"
FileMove($tFileSource, $tFileBackup, 1)
FileWrite($tFileSource, $tTxt)
$tG_T6_EditClicked = False
_Splash($tFileName & " updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $tFileName & "_" & $tTime & ".bak", 2000, 525)
EndFunc
Func G_T6_B_Reset()
Local $tFileName = "DefaultGameUserSettings.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
Local $tTxt = FileRead($tFileSource)
$tG_T6_EditClicked = False
GUICtrlSetData($G_T6_E_Edit, $tTxt)
EndFunc
Func G_T6_B_Replace()
Local $tTxtBefore = InputBox($aUtilName, "Enter text to replace (before)", "", "", -1, 125, Default, Default, 120)
If $tTxtBefore = "" Then Return
Local $tTxtAfter = InputBox($aUtilName, "Enter text to replace with (after)", "", "", -1, 125, Default, Default, 120)
$tMB = MsgBox($MB_OKCANCEL, "REPLACE TEXT", "Replace:" & $tTxtBefore & @CRLF & "With:" & $tTxtAfter)
If $tMB = 1 Then
Local $tTxt = GUICtrlRead($G_T6_E_Edit)
Local $tTxt1 = StringReplace($tTxt, $tTxtBefore, $tTxtAfter)
$tReplacements = @extended
GUICtrlSetData($G_T6_E_Edit, $tTxt1)
$tG_T6_EditClicked = True
_Splash($tReplacements & " occurrences were replaced", 2000)
Else
_Splash("Replace canceled.", 1500)
EndIf
EndFunc
Func G_T6_B_ClipboardCopy()
ClipPut(GUICtrlRead($G_T6_E_Edit))
_Splash("Contents copied to clipboard", 750)
EndFunc
Func G_T6_B_ClipboardPaste()
GUICtrlSetData($G_T6_E_Edit, ClipGet())
EndFunc
Func G_T6_B_OpenFile()
Local $tFileName = "DefaultGameUserSettings.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
ShellExecute($tFileSource)
EndFunc
Func G_T6_B_OpenFolder()
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config"
ShellExecute($tFileSource)
EndFunc
Func G_T6_B_CopyAllGrids()
Local $tFileName = "DefaultGameUserSettings.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
SplashOff()
Local $aMsg = "Copy to ALL LOCAL grids? (Warning! Does NOT combine files)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied to ALL LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T6_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\GameUserSettings.ini"
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T6_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
EndFunc
Func G_T6_B_CopySelectGrids()
If _AnySelGrid Then
Local $tFileName = "DefaultGameUserSettings.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
SplashOff()
Local $tGrids = ""
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then $tGrids &= _ServerNamingScheme($i, $aNamingScheme) & " "
Next
If $tGrids = "" Then $tGrids = " [ None Selected ]"
Local $aMsg = "Copy to SELECT LOCAL grids? (Warning! Does NOT combine files)" & @CRLF & $tGrids & @CRLF & @CRLF & " (Uses local grids selected in MAIN WINDOW)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied to SELECT LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T6_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\GameUserSettings.ini"
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T6_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
Else
_Splash("No Grids selected in main window.", 2000)
EndIf
EndFunc
Func G_T7_UpdateTab()
GUICtrlSetData($G_T7_L_GridNumber, "(" & _ServerNamingScheme($tGridActive, $aNamingScheme) & ")")
GUICtrlSetData($G_T7_L_GridName, $xServerNames[$tGridActive])
Local $tFile = $aServerDirLocal & "\ShooterGame\Config\DefaultGame.ini"
Local $tFileRead = FileRead($tFile)
GUICtrlSetData($G_T7_E_Edit, $tFileRead)
EndFunc
Func G_T7_E_Edit()
$tG_T7_EditClicked = True
EndFunc
Func G_T7_B_Save()
Local $tFileName = "DefaultGame.ini"
Local $tTxt = GUICtrlRead($G_T7_E_Edit)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
Local $tFileBackup = $tFileSource & "_" & $tTime & ".bak"
FileMove($tFileSource, $tFileBackup, 1)
FileWrite($tFileSource, $tTxt)
$tG_T7_EditClicked = False
_Splash($tFileName & " updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $tFileName & "_" & $tTime & ".bak", 2000, 525)
EndFunc
Func G_T7_B_Reset()
Local $tFileName = "DefaultGame.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
Local $tTxt = FileRead($tFileSource)
$tG_T7_EditClicked = False
GUICtrlSetData($G_T7_E_Edit, $tTxt)
EndFunc
Func G_T7_B_Replace()
Local $tTxtBefore = InputBox($aUtilName, "Enter text to replace (before)", "", "", -1, 125, Default, Default, 120)
If $tTxtBefore = "" Then Return
Local $tTxtAfter = InputBox($aUtilName, "Enter text to replace with (after)", "", "", -1, 125, Default, Default, 120)
$tMB = MsgBox($MB_OKCANCEL, "REPLACE TEXT", "Replace:" & $tTxtBefore & @CRLF & "With:" & $tTxtAfter)
If $tMB = 1 Then
Local $tTxt = GUICtrlRead($G_T7_E_Edit)
Local $tTxt1 = StringReplace($tTxt, $tTxtBefore, $tTxtAfter)
$tReplacements = @extended
GUICtrlSetData($G_T7_E_Edit, $tTxt1)
$tG_T7_EditClicked = True
_Splash($tReplacements & " occurrences were replaced", 2000)
Else
_Splash("Replace canceled.", 1500)
EndIf
EndFunc
Func G_T7_B_ClipboardCopy()
ClipPut(GUICtrlRead($G_T7_E_Edit))
_Splash("Contents copied to clipboard", 750)
EndFunc
Func G_T7_B_ClipboardPaste()
GUICtrlSetData($G_T7_E_Edit, ClipGet())
EndFunc
Func G_T7_B_OpenFile()
Local $tFileName = "DefaultGame.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
ShellExecute($tFileSource)
EndFunc
Func G_T7_B_OpenFolder()
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config"
ShellExecute($tFileSource)
EndFunc
Func G_T7_B_CopyAllGrids()
Local $tFileName = "DefaultGame.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
SplashOff()
Local $aMsg = "Copy to ALL LOCAL grids? (Warning! Does NOT combine files)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied to ALL LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T7_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\Game.ini"
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T7_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
EndFunc
Func G_T7_B_CopySelectGrids()
If _AnySelGrid() Then
Local $tFileName = "DefaultGame.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
SplashOff()
Local $tGrids = ""
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then $tGrids &= _ServerNamingScheme($i, $aNamingScheme) & " "
Next
If $tGrids = "" Then $tGrids = " [ None Selected ]"
Local $aMsg = "Copy to SELECT LOCAL grids? (Warning! Does NOT combine files)" & @CRLF & $tGrids & @CRLF & @CRLF & " (Uses local grids selected in MAIN WINDOW)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied to SELECT LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T7_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\Game.ini"
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T7_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
Else
_Splash("No Grids selected in main window.", 2000)
EndIf
EndFunc
Func G_T8_UpdateTab()
GUICtrlSetData($G_T8_L_GridNumber, "(" & _ServerNamingScheme($tGridActive, $aNamingScheme) & ")")
GUICtrlSetData($G_T8_L_GridName, $xServerNames[$tGridActive])
Local $tFile = $aServerDirLocal & "\ShooterGame\Config\DefaultEngine.ini"
Local $tFileRead = FileRead($tFile)
GUICtrlSetData($G_T8_E_Edit, $tFileRead)
EndFunc
Func G_T8_E_Edit()
$tG_T8_EditClicked = True
EndFunc
Func G_T8_B_Save()
Local $tFileName = "DefaultEngine.ini"
Local $tTxt = GUICtrlRead($G_T8_E_Edit)
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
Local $tFileBackup = $tFileSource & "_" & $tTime & ".bak"
FileMove($tFileSource, $tFileBackup, 1)
FileWrite($tFileSource, $tTxt)
$tG_T8_EditClicked = False
_Splash($tFileName & " updated." & @CRLF & @CRLF & "Backup created: " & @CRLF & $tFileName & "_" & $tTime & ".bak", 2000, 525)
EndFunc
Func G_T8_B_Reset()
Local $tFileName = "DefaultEngine.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
Local $tTxt = FileRead($tFileSource)
$tG_T8_EditClicked = False
GUICtrlSetData($G_T8_E_Edit, $tTxt)
EndFunc
Func G_T8_B_Replace()
Local $tTxtBefore = InputBox($aUtilName, "Enter text to replace (before)", "", "", -1, 125, Default, Default, 120)
If $tTxtBefore = "" Then Return
Local $tTxtAfter = InputBox($aUtilName, "Enter text to replace with (after)", "", "", -1, 125, Default, Default, 120)
$tMB = MsgBox($MB_OKCANCEL, "REPLACE TEXT", "Replace:" & $tTxtBefore & @CRLF & "With:" & $tTxtAfter)
If $tMB = 1 Then
Local $tTxt = GUICtrlRead($G_T8_E_Edit)
Local $tTxt1 = StringReplace($tTxt, $tTxtBefore, $tTxtAfter)
$tReplacements = @extended
GUICtrlSetData($G_T8_E_Edit, $tTxt1)
$tG_T8_EditClicked = True
_Splash($tReplacements & " occurrences were replaced", 2000)
Else
_Splash("Replace canceled.", 1500)
EndIf
EndFunc
Func G_T8_B_ClipboardCopy()
ClipPut(GUICtrlRead($G_T8_E_Edit))
_Splash("Contents copied to clipboard", 750)
EndFunc
Func G_T8_B_ClipboardPaste()
GUICtrlSetData($G_T8_E_Edit, ClipGet())
EndFunc
Func G_T8_B_OpenFile()
Local $tFileName = "DefaultEngine.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
ShellExecute($tFileSource)
EndFunc
Func G_T8_B_OpenFolder()
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config"
ShellExecute($tFileSource)
EndFunc
Func G_T8_B_CopyAllGrids()
Local $tFileName = "DefaultEngine.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
SplashOff()
Local $aMsg = "Copy to ALL LOCAL grids? (Warning! Does NOT combine files)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied to ALL LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T8_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\Engine.ini"
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T8_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
EndFunc
Func G_T8_B_CopySelectGrids()
If _AnySelGrid() Then
Local $tFileName = "DefaultEngine.ini"
Local $tFileSource = $aServerDirLocal & "\ShooterGame\Config\" & $tFileName
SplashOff()
Local $tGrids = ""
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then $tGrids &= _ServerNamingScheme($i, $aNamingScheme) & " "
Next
If $tGrids = "" Then $tGrids = " [ None Selected ]"
Local $aMsg = "Copy to SELECT LOCAL grids? (Warning! Does NOT combine files)" & @CRLF & $tGrids & @CRLF & @CRLF & " (Uses local grids selected in MAIN WINDOW)" & @CRLF & " (Backups will be made of each file)" & @CRLF & @CRLF & "Click (YES) to copy." & @CRLF & "Click (NO) or (CANCEL) to cancel."
$tMB = MsgBox($MB_YESNOCANCEL, $aUtilName, $aMsg, 30)
If $tMB = 6 Or $tMB = 7 Then
LogWrite(" [Util] " & $tFileName & " content copied to SELECT LOCAL grids")
$tSplash = _Splash("Backing up " & $tFileName & @CRLF & "for Grid")
Local $tTxt = GUICtrlRead($G_T8_E_Edit)
_BackupFile($tFileSource, $tTxt, False)
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $i) Then
ControlSetText($tSplash, "", "Static1", "Processing " & $tFileName & @CRLF & "for Grid " & _ServerNamingScheme($i, $aNamingScheme))
SetStatusBusy("Copying Files", "Processing Grid " & _ServerNamingScheme($i, $aNamingScheme))
$tFileTemp = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\Engine.ini"
_BackupFile($tFileTemp, "", False)
FileCopy($tFileSource, $tFileTemp, $FC_OVERWRITE)
EndIf
Next
ControlSetText($tSplash, "", "Static1", "Copying complete.")
ElseIf $tMB = 2 Or $tMB = -1 Then
EndIf
$tG_T8_EditClicked = False
SetStatusBusy("Copying Files", "Copying complete.")
Sleep(1500)
SetStatusIdle()
SplashOff()
Else
_Splash("No Grids selected in main window.", 2000)
EndIf
EndFunc
Func _AnySelParam()
For $_ti = 0 To ($gParamTFMax - 1)
If $gParamTFActiveTF[$_ti] Then
Return True
EndIf
Next
For $_ti = 0 To ($gParamNumMax - 1)
If $gParamNumActiveTF[$_ti] Then
Return True
EndIf
Next
Return False
EndFunc
Func _AnySelGrid()
For $_ti = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$_ti] = "yes" And _GUICtrlListView_GetItemChecked($wMainListViewWindow, $_ti) Then
Return True
EndIf
Next
Return False
EndFunc
Func _ReplaceServerGrid($tParamter, $tTxtToReplace, $tTxtToReplaceWith, $tGridX = -1, $tGridY = -1, $tFileLoad = -1, $tQuotesTF = -1, $tSplashTF = True)
If $tGridX = -1 Then $tGridX = $xServergridx[$tGridActive]
If $tGridY = -1 Then $tGridY = $xServergridy[$tGridActive]
If $tFileLoad = -1 Then $tFileLoad = $aConfigFull
If $tQuotesTF = -1 Then $tQuotesTF = True
Local $tXFound = False, $tYFound = False, $tReturn = 0
Local $xfile, $tXFound = False, $tYFound = False, $tReturn = 0
Local $tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
Local $tFileSave = StringTrimRight($tFileLoad, 4) & $tTime & ".json"
_FileReadToArray($tFileLoad, $xfile, 0)
Local $tTxtGridX = "      ""gridX"": " & $tGridX & ","
Local $tTxtGridY = "      ""gridY"": " & $tGridY & ","
If $tQuotesTF Then
Local $tTxtToFind = "      """ & $tParamter & """: """ & $tTxtToReplace & ""","
Else
Local $tTxtToFind = "      """ & $tParamter & """: " & $tTxtToReplace & ","
EndIf
For $i = 0 To (UBound($xfile) - 1)
If $xfile[$i] = $tTxtGridX Then $tXFound = True
If $tXFound And $xfile[$i] = $tTxtGridY Then $tYFound = True
If $tXFound And $tYFound And $xfile[$i] = $tTxtToFind Then ExitLoop
Next
If $i > (UBound($xfile) - 5) Then
$tReturn = -1
Else
$tReturn = $i
$xfile[$i] = StringReplace($xfile[$i], $tTxtToReplace, $tTxtToReplaceWith)
_BackupFile($tFileLoad, $xfile, $tSplashTF, True)
EndIf
Return $tReturn
EndFunc
Func _ReplaceCommandLine($tGrid, $tCMD, $tAddTF)
Local $tCntTot = 0, $tCntChanged = 0, $tReturn[2]
If $tAddTF = True Then
$tCntTot += 1
If StringInStr($xServerGridExtraCMD[$tGrid], $tCMD) = 0 Then
$xServerGridExtraCMD[$tGrid] &= " -" & $tCMD
GUICtrlSetData($G_T1_I_CommandlineThisGrid, $xServerGridExtraCMD[$tGrid])
G_T1_I_CommandlineThisGrid()
$tCntChanged += 1
Else
EndIf
Else
$tCntTot += 1
If StringInStr($xServerGridExtraCMD[$tGrid], $tCMD) = 0 Then
Else
$tCMD1 = "-" & $tCMD
$xServerGridExtraCMD[$tGrid] = StringRegExpReplace($xServerGridExtraCMD[$tGrid], $tCMD1, "")
$xServerGridExtraCMD[$tGrid] = StringRegExpReplace($xServerGridExtraCMD[$tGrid], "  ", " ")
GUICtrlSetData($G_T1_I_CommandlineThisGrid, $xServerGridExtraCMD[$tGrid])
G_T1_I_CommandlineThisGrid()
$tCntChanged += 1
EndIf
EndIf
$tReturn[0] = $tCntTot
$tReturn[1] = $tCntChanged
Return $tReturn
EndFunc
Func _BackupFile($tFile, $tNewTxt = "", $tSplashTF = True, $tIsArrayTF = False)
Local $tTxt, $tPos, $tExt, $tNoExt, $tTime, $tFileSave, $tFolderOnly, $tFileOnly
For $tC = 1 To StringLen($tFile)
$tTxt = StringRight($tFile, $tC)
If StringInStr($tTxt, ".") = 0 Then
Else
$tNoExt = StringTrimRight($tFile, $tC)
$tExt = StringTrimLeft($tTxt, 1)
ExitLoop
EndIf
Next
If StringLen($tFile) = $tC Then Return "ERROR-No . found"
For $tC = 1 To StringLen($tFile)
$tTxt = StringRight($tFile, $tC)
If StringInStr($tTxt, "\") = 0 Then
Else
$tFolderOnly = StringTrimRight($tFile, $tC)
$tFileOnly = StringTrimLeft($tTxt, 1)
ExitLoop
EndIf
Next
If StringLen($tFile) = $tC Then Return "ERROR-No \ found"
$tTime = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "-" & @MIN
$tFileSave = $tFile & "_" & $tTime & ".bak"
If Not FileExists($tFile) Then _FileCreate($tFile)
If $tNewTxt <> "" Then
FileMove($tFile, $tFileSave, 1)
If $tIsArrayTF = False Then
FileWrite($tFile, $tNewTxt)
Else
_FileWriteFromArray($tFile, $tNewTxt)
EndIf
Else
FileCopy($tFile, $tFileSave)
EndIf
LogWrite("", " [FILE] " & $tFileOnly & " updated. Backup created:" & $tFileOnly & "." & $tExt & "_" & $tTime & ".bak")
If $tSplashTF Then _Splash($tFileOnly & " updated." & @CRLF & @CRLF & "Backup created:" & @CRLF & $tFileOnly & "." & $tExt & "_" & $tTime & ".bak", 1500)
Return $tFileSave
EndFunc
Func _ReplaceStringFile($tFile, $tTxtToReplace, $tTxtToReplaceWith, $tParamNum = -1, $tTForNum = "TF", $tSplashTF = True)
Local $tTxt, $tPos = -1, $tExt, $tNoExt, $tTime, $tFileSave, $tFolderOnly, $tFileOnly
Local $xfile, $tXFound = False, $tYFound = False, $tReturn = 0, $tFoundTF = False
For $tC = 1 To StringLen($tTxtToReplace)
$tTxt = StringRight($tTxtToReplace, $tC)
If StringInStr($tTxt, "=") = 0 Then
Else
$tParameter = StringTrimRight($tTxtToReplace, $tC)
ExitLoop
EndIf
Next
_FileReadToArray($tFile, $xfile, 0)
If UBound($xfile) = 0 Then Local $xfile[1]
For $i = 0 To (UBound($xfile) - 1)
If StringInStr($xfile[$i], $tParameter & "=") = 0 Then
Else
$tPos = $i
ExitLoop
EndIf
Next
If $tPos = -1 Then
If $tParameter = "RCONPort" Or $tParameter = "ServerPVE" Then
For $i = 0 To (UBound($xfile) - 1)
If StringInStr($xfile[$i], "[ServerSettings]") = 0 Then
Else
$tPos = $i + 1
$tFoundTF = True
ExitLoop
EndIf
Next
If $tFoundTF = False Then
$tPos = 2
If $tParameter = "RCONPort" Then _ArrayInsert($xfile, 0, "RCONEnabled=True")
_ArrayInsert($xfile, 0, "[ServerSettings]")
_ArrayInsert($xfile, $tPos)
Else
_ArrayInsert($xfile, $tPos)
EndIf
Else
If $tTForNum = "TF" Then
For $i = 0 To (UBound($xfile) - 1)
If StringInStr($xfile[$i], $gParamTFHeading[$tParamNum]) = 0 Then
Else
$tPos = $i + 1
ExitLoop
EndIf
Next
If $tPos > -1 Then
_ArrayInsert($xfile, $tPos, $tParameter & "=" & $gParamTFValue[$tParamNum])
Else
_ArrayInsert($xfile, 0)
_ArrayInsert($xfile, 0, $tParameter & "=" & $gParamTFValue[$tParamNum])
_ArrayInsert($xfile, 0, $gParamTFHeading[$tParamNum])
EndIf
Else
For $i = 0 To (UBound($xfile) - 1)
If StringInStr($xfile[$i], $gParamNumHeading[$tParamNum]) = 0 Then
Else
$tPos = $i + 1
ExitLoop
EndIf
Next
If $tPos > -1 Then
_ArrayInsert($xfile, $tPos, $tParameter & "=" & $gParamNumValue[$tParamNum])
Else
_ArrayInsert($xfile, 0)
_ArrayInsert($xfile, 0, $tParameter & "=" & $gParamNumValue[$tParamNum])
_ArrayInsert($xfile, 0, $gParamNumHeading[$tParamNum])
EndIf
EndIf
EndIf
Else
EndIf
For $tC = 1 To StringLen($tFile)
$tTxt = StringRight($tFile, $tC)
If StringInStr($tTxt, "\") = 0 Then
Else
$tFolderOnly = StringTrimRight($tFile, $tC)
$tFileOnly = StringTrimLeft($tTxt, 1)
ExitLoop
EndIf
Next
LogWrite("", " [Param] Changed Parameter in Server " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " [" & $tFileOnly & "] From:" & $tTxtToReplace & " to " & $tParameter & "=" & $tTxtToReplaceWith)
If $tPos > -1 Then $xfile[$tPos] = $tParameter & "=" & $tTxtToReplaceWith
_BackupFile($tFile, $xfile, $tSplashTF, True)
EndFunc
Func _Update_GUS_File($tFile, $tGrid)
_GUS_R_RCON($tGrid)
EndFunc
Func _GUS_R_RCON($tGrid)
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGrid] & "\Config\WindowsServer\GameUserSettings.ini"
Local $tBefore = "RCONPort=0"
Local $tRCON = $xServerRCONPort[$tGrid + 1]
_ReplaceStringFile($aFile, $tBefore, $tRCON, -1, "RCON", False)
EndFunc
Func _ParamClicked($tX, $aTForNum = "TF", $aNumOldValue = "")
If $aTForNum = "TF" Then
If $gParamTFValue[$tX] = True Then
Local $aTxtOld = $gParamTFName[$tX] & "=False"
Local $aValueOld = False
Else
Local $aTxtOld = $gParamTFName[$tX] & "=True"
Local $aValueOld = True
EndIf
If $gParamTFFile[$tX] = 0 Then
Local $tTxt = $gParamTFName[$tX]
Local $tAddorRemove = $gParamTFValue[$tX]
_ReplaceCommandLine($tGridActive, $tTxt, $tAddorRemove)
ElseIf $gParamTFFile[$tX] = 1 Then
Local $aTxtNew = $gParamTFValue[$tX]
Local $tParam = $gParamTFName[$tX]
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, False, False)
If $tLine = -1 Then
$gParamTFValue[$tX] = $aValueOld
_Splash("ERROR! " & $gParamTFName[$tX] & " value not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
ElseIf $gParamTFFile[$tX] = 2 Then
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\GameUserSettings.ini"
Local $aTxtNew = $gParamTFValue[$tX]
_ReplaceStringFile($aFile, $aTxtOld, $aTxtNew, $tX, "TF", False)
ElseIf $gParamTFFile[$tX] = 3 Then
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\Game.ini"
Local $aTxtNew = $gParamTFValue[$tX]
_ReplaceStringFile($aFile, $aTxtOld, $aTxtNew, $tX, "TF", False)
ElseIf $gParamTFFile[$tX] = 4 Then
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\Engine.ini"
Local $aTxtNew = $gParamTFValue[$tX]
_ReplaceStringFile($aFile, $aTxtOld, $aTxtNew, $tX, "TF", False)
EndIf
Else
Local $aTxtOld = $gParamNumName[$tX] & "=" & $aNumOldValue
If $gParamNumFile[$tX] = 0 Then
Local $tTxt = $gParamNumName[$tX]
Local $tAddorRemove = $gParamNumValue[$tX]
_ReplaceCommandLine($tGridActive, $tTxt, $tAddorRemove)
ElseIf $gParamNumFile[$tX] = 1 Then
Local $aTxtNew = $gParamNumValue[$tX]
Local $tParam = $gParamNumName[$tX]
Local $tLine = _ReplaceServerGrid($tParam, $aTxtOld, $aTxtNew, $xServergridx[$tGridActive], $xServergridy[$tGridActive], $aConfigFull, False, False)
If $tLine = -1 Then
$gParamNumValue[$tX] = $aNumOldValue
_Splash("ERROR! " & $gParamNumName[$tX] & " value not saved!" & @CRLF & @CRLF & "(Check if ServerGrid.json file is read-only)", 5000)
EndIf
ElseIf $gParamNumFile[$tX] = 2 Then
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\GameUserSettings.ini"
Local $aTxtNew = $gParamNumValue[$tX]
_ReplaceStringFile($aFile, $aTxtOld, $aTxtNew, $tX, "Num", False)
ElseIf $gParamNumFile[$tX] = 3 Then
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\Game.ini"
Local $aTxtNew = $gParamNumValue[$tX]
_ReplaceStringFile($aFile, $aTxtOld, $aTxtNew, $tX, "Num", False)
ElseIf $gParamNumFile[$tX] = 4 Then
Local $aFile = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\Engine.ini"
Local $aTxtNew = $gParamNumValue[$tX]
_ReplaceStringFile($aFile, $aTxtOld, $aTxtNew, $tX, "Num", False)
EndIf
EndIf
EndFunc
Func _ParamFileImport($tParamToImport = "")
Local $xfileLoad
Local $tFail = _FileReadToArray($aParametersFile, $xfileLoad, 0)
If $tFail = 0 Then
_ParamFileDefault()
_FileReadToArray($aParametersFile, $xfileLoad, 0)
EndIf
Local $xfile = ResizeArray($xfileLoad)
Local $tFileTotal = UBound($xfile)
For $i = 0 To ($tFileTotal - 1)
If StringInStr($xfile[$i], "[Begin Parameters]") Then
Global $gParamTotal = ($tFileTotal - $i - 1)
Local $gParamBegin = $i + 1
ExitLoop
Else
Global $gParamTotal = ($tFileTotal - 1)
EndIf
Next
Local $tTF = 0, $tNum = 0
For $i = $gParamBegin To ($tFileTotal - 1)
Local $tTxt = StringSplit($xfile[$i], ",", 2)
If $tTxt[2] = "True" Or $tTxt[2] = "False" Then
$tTF += 1
Else
$tNum += 1
EndIf
Next
If $tParamToImport = "" Then
Global $gParamTFMax = $tTF
Global $gParamTFActiveTF[$gParamTFMax]
Global $gParamTFActiveDefaultTF[$gParamTFMax]
Global $gParamTFName[$gParamTFMax]
Global $gParamTFValue[$gParamTFMax]
Global $gParamTFDefaultValue[$gParamTFMax]
Global $gParamTFFile[$gParamTFMax]
Global $gParamTFHeading[$gParamTFMax]
Global $gParamTFToolTip[$gParamTFMax]
Global $gParamTFValExistTF[$gParamTFMax]
Global $gParamNumMax = $tNum
Global $gParamNumActiveTF[$gParamNumMax]
Global $gParamNumActiveDefaultTF[$gParamNumMax]
Global $gParamNumName[$gParamNumMax]
Global $gParamNumValue[$gParamNumMax]
Global $gParamNumDefaultValue[$gParamNumMax]
Global $gParamNumFile[$gParamNumMax]
Global $gParamNumHeading[$gParamNumMax]
Global $gParamNumToolTip[$gParamNumMax]
Global $gParamNumValExistTF[$gParamNumMax]
Local $x = 0, $tTF = 0, $tNum = 0
For $i = $gParamBegin To ($tFileTotal - 1)
Local $tTxt = StringSplit($xfile[$i], ",", 2)
If $tTxt[2] = "True" Or $tTxt[2] = "False" Then
If $tTxt[0] = "True" Then
$gParamTFActiveTF[$tTF] = True
Else
$gParamTFActiveTF[$tTF] = False
EndIf
$gParamTFActiveDefaultTF[$tTF] = $gParamTFActiveTF[$tTF]
$gParamTFName[$tTF] = $tTxt[1]
If $tTxt[2] = "True" Then
$gParamTFValue[$tTF] = True
Else
$gParamTFValue[$tTF] = False
EndIf
$gParamTFDefaultValue[$tTF] = $gParamTFValue[$tTF]
$gParamTFFile[$tTF] = $tTxt[3]
$gParamTFHeading[$tTF] = $tTxt[4]
$gParamTFToolTip[$tTF] = $tTxt[5]
$tTF += 1
Else
If $tTxt[0] = "True" Then
$gParamNumActiveTF[$tNum] = True
Else
$gParamNumActiveTF[$tNum] = False
EndIf
$gParamNumActiveDefaultTF[$tNum] = $gParamNumActiveTF[$tNum]
$gParamNumName[$tNum] = $tTxt[1]
$gParamNumValue[$tNum] = $tTxt[2]
$gParamNumDefaultValue[$tNum] = $gParamNumValue[$tNum]
$gParamNumFile[$tNum] = $tTxt[3]
$gParamNumHeading[$tNum] = $tTxt[4]
$gParamNumToolTip[$tNum] = $tTxt[5]
$tNum += 1
EndIf
$x += 1
Next
If $tTF > $tNum Then
Global $tParamTypeMax = $tTF
Else
Global $tParamTypeMax = $tNum
EndIf
Else
Local $x = 0, $tTF = 0, $tNum = 0
For $i = $gParamBegin To ($tFileTotal - 1)
Local $tTxt = StringSplit($xfile[$i], ",", 2)
If $tTxt[2] = "True" Or $tTxt[2] = "False" Then
If $tParamToImport = "Highlight" Then
If $tTxt[0] = "True" Then
$gParamTFActiveTF[$tTF] = True
Else
$gParamTFActiveTF[$tTF] = False
EndIf
$gParamTFActiveDefaultTF[$tTF] = $gParamTFActiveTF[$tTF]
EndIf
If $tParamToImport = "Value" Then
If $gParamTFActiveTF[$tTF] Then
If $tTxt[2] = "True" Then
$gParamTFValue[$tTF] = True
Else
$gParamTFValue[$tTF] = False
EndIf
$gParamTFDefaultValue[$tTF] = $gParamTFValue[$tTF]
EndIf
EndIf
$tTF += 1
Else
If $tParamToImport = "Highlight" Then
If $tTxt[0] = "True" Then
$gParamNumActiveTF[$tNum] = True
Else
$gParamNumActiveTF[$tNum] = False
EndIf
$gParamNumActiveDefaultTF[$tNum] = $gParamNumActiveTF[$tNum]
EndIf
If $tParamToImport = "Value" Then
If $gParamNumActiveTF[$tNum] Then
$gParamNumValue[$tNum] = $tTxt[2]
$gParamNumDefaultValue[$tNum] = $gParamNumValue[$tNum]
EndIf
EndIf
$tNum += 1
EndIf
$x += 1
Next
EndIf
EndFunc
Func _ParamFileWrite($tParam = "na", $tPar = 0)
Local $xfileRead, $tCount = 0
Local $tFail = _FileReadToArray($aParametersFile, $xfileRead, 0)
Local $xfile = ResizeArray($xfileRead)
If $tFail = 0 Then
_ParamFileDefault()
_FileReadToArray($aParametersFile, $xfile, 0)
_Splash("Error loading parameter file. Default values set and new parameter change written.", 5000)
LogWrite("", " [Param] Error loading parameter file. Default values set and new parameter change written. Error Code:" & @error)
Else
If $tParam = "na" Then
Local $tFileTotal = UBound($xfile)
For $i = 0 To ($tFileTotal - 1)
Local $tTxt = StringSplit($xfile[$i], ",", 2)
If UBound($tTxt) > 1 Then
If $tTxt[1] = $tParam Then
If $tTxt[2] = "True" Or $tTxt[2] = "False" Then
$tCount += 1
Local $xfileBefore = $xfile[$i]
$xfile[$i] = $gParamTFActiveDefaultTF[$tPar] & "," & $gParamTFName[$tPar] & "," & $gParamTFDefaultValue[$tPar] & "," & $gParamTFFile[$tPar] & "," & $gParamTFHeading[$tPar] & "," & $gParamTFToolTip[$tPar]
LogWrite("", " [Param] Line " & $i & " changed from [" & $xfileBefore & "] to [" & $xfile[$i] & "]")
Else
$tCount += 1
Local $xfileBefore = $xfile[$i]
$xfile[$i] = $gParamNumActiveDefaultTF[$tPar] & "," & $gParamNumName[$tPar] & "," & $gParamNumDefaultValue[$tPar] & "," & $gParamNumFile[$tPar] & "," & $gParamNumHeading[$tPar] & "," & $gParamNumToolTip[$tPar]
LogWrite("", " [Param] Line " & $i & " changed from [" & $xfileBefore & "] to [" & $xfile[$i] & "]")
EndIf
ExitLoop
Else
EndIf
EndIf
Next
FileDelete($aParametersFile)
Local $tFail = _FileWriteFromArray($aParametersFile, $xfile)
If $tFail = 0 Then
_Splash("Error updating parameter file." & @CRLF & "Please ensure program is not opened in another program (Excel)", 2000)
LogWrite("", " [Param] Error writing parameter file. Code:" & @error)
EndIf
ElseIf $tParam = "Param" Then
Local $tFileTotal = UBound($xfile)
For $x = 0 To ($gParamTFMax - 1)
If $gParamTFActiveTF[$x] Then
For $i = 0 To ($tFileTotal - 1)
Local $tTxt = StringSplit($xfile[$i], ",", 2)
If UBound($tTxt) > 1 Then
If $tTxt[1] = $gParamTFName[$x] Then
$tCount += 1
Local $xfileBefore = $xfile[$i]
$xfile[$i] = $gParamTFActiveDefaultTF[$x] & "," & $gParamTFName[$x] & "," & $gParamTFDefaultValue[$x] & "," & $gParamTFFile[$x] & "," & $gParamTFHeading[$x] & "," & $gParamTFToolTip[$x]
LogWrite("", " [Param] Parameter changed from [" & $xfileBefore & "] to [" & $xfile[$i] & "]")
ExitLoop
EndIf
EndIf
Next
EndIf
Next
For $x = 0 To ($gParamNumMax - 1)
If $gParamNumActiveTF[$x] Then
For $i = 0 To ($tFileTotal - 1)
Local $tTxt = StringSplit($xfile[$i], ",", 2)
If UBound($tTxt) > 1 Then
If $tTxt[1] = $gParamNumName[$x] Then
$tCount += 1
Local $xfileBefore = $xfile[$i]
$xfile[$i] = $gParamNumActiveDefaultTF[$x] & "," & $gParamNumName[$x] & "," & $gParamNumDefaultValue[$x] & "," & $gParamNumFile[$x] & "," & $gParamNumHeading[$x] & "," & $gParamNumToolTip[$x]
LogWrite("", " [Param] Parameter changed from [" & $xfileBefore & "] to [" & $xfile[$i] & "]")
ExitLoop
EndIf
EndIf
Next
EndIf
Next
FileDelete($aParametersFile)
Local $tFail = _FileWriteFromArray($aParametersFile, $xfile)
If $tFail = 0 Then
_Splash("Error updating parameter file." & @CRLF & "Please ensure program is not opened in another program (Excel)", 2000)
LogWrite("", " [Param] Error writing parameter file. Code:" & @error)
EndIf
ElseIf $tParam = "Highlight" Then
Local $tFileTotal = UBound($xfile)
For $x = 0 To ($gParamTFMax - 1)
For $i = 0 To ($tFileTotal - 1)
Local $tTxt = StringSplit($xfile[$i], ",", 2)
If UBound($tTxt) > 1 Then
If $tTxt[1] = $gParamTFName[$x] Then
$tCount += 1
$xfile[$i] = $gParamTFActiveTF[$x] & "," & $tTxt[1] & "," & $tTxt[2] & "," & $tTxt[3] & "," & $tTxt[4] & "," & $tTxt[5]
ExitLoop
EndIf
EndIf
Next
Next
For $x = 0 To ($gParamNumMax - 1)
For $i = 0 To ($tFileTotal - 1)
Local $tTxt = StringSplit($xfile[$i], ",", 2)
If UBound($tTxt) > 1 Then
If $tTxt[1] = $gParamNumName[$x] Then
$tCount += 1
$xfile[$i] = $gParamNumActiveTF[$x] & "," & $tTxt[1] & "," & $tTxt[2] & "," & $tTxt[3] & "," & $tTxt[4] & "," & $tTxt[5]
ExitLoop
EndIf
EndIf
Next
Next
FileDelete($aParametersFile)
Local $tFail = _FileWriteFromArray($aParametersFile, $xfile)
If $tFail = 0 Then
_Splash("Error updating parameter file." & @CRLF & "Please ensure program is not opened in another program (Excel)", 2000)
LogWrite("", " [Param] Error writing parameter file. Code:" & @error)
EndIf
EndIf
EndIf
Return $tCount
EndFunc
Func _ParamFileDefault()
Local $tTxt = "------------------------------------------" & @CRLF & " AtlasServerUpdateUtility Grid Parameters" & @CRLF & "------------------------------------------" & @CRLF & "[Highlight/Active] [ParamName] [Value] [File] [HeadingInFile] [Description]" & @CRLF & "    [ParamName] Name of Parameter" & @CRLF & "        [Value] Value assigned to parameter" & @CRLF & "         [File] (0) Command line entry  (1) ServerGrid  (2) GameUserSettings.ini  (3) Game.ini  (4) Engine.ini" & @CRLF & "[HeadingInFile] The heading the parameter is under / follows" & @CRLF & "  [Description] Description displayed when hovering mouse over parameter name" & @CRLF & "- ! WARNING ! - NO COMMAS allowed in any part of any parameter.  It will cause glitches." & @CRLF & "------------------------------------------" & @CRLF & "[Begin Parameters]" & @CRLF & "True,NoBattlEye,True,0,n/a,Run server without BattleEye" & @CRLF & "True,NoCrashDialog,True,0,n/a,Prevents the big white error windows and allows the utility to restart crashed servers." & @CRLF & "True,ServerGameLog,True,0,n/a,Enable Server Admin Logs (including RCON support) use RCON command ?getgamelog? to print 100 entries at a time also outputs to dated file in in ?\Logs? adjust max length of RCON buffer with commandline: ??RCONServerGameLogBuffer=600?" & @CRLF & "True,bClampHomeServerXP,True,3,[/Script/ShooterGame.ShooterGameMode],Remove Level cap on Freeport / Home servers" & @CRLF & "True,ClampHomeServerXPLevel,8,3,[/Script/ShooterGame.ShooterGameMode],Level cap on Freeport / Home servers" & @CRLF & "False,XPMultiplier,1,2,[ServerSettings],No description." & @CRLF & "False,HarvestAmountMultiplier,1,2,[ServerSettings],Specifies the scaling factor for yields from all harvesting activities (chopping down trees picking berries carving carcasses mining rocks etc.). Higher values increase the amount of materials harvested with each strike." & @CRLF & "False,AllowAnyoneBabyImprintCuddle,False,2,[ServerSettings],""Use this if you want ANYONE to be able to """"take care"""" of a Baby Dino (cuddle etc.) not just whomever Imprinted on it.""" & @CRLF & "False,AllowHideDamageSourceFromLogs,False,2,[ServerSettings],Allows the hiding of damage sources in tribe logs." & @CRLF & "False,AllowHitMarkers,True,2,[ServerSettings],Use this to disable optional hitmarkers for ranged attacks" & @CRLF & "False,AllowThirdPersonPlayer,True,2,[ServerSettings],Enables 3rd Person view" & @CRLF & "True,Message,Welcome to your favorite Atlas server!,3,[MessageOfTheDay],Set message of the day (MOTD)" & @CRLF & "False,AutoSavePeriodMinutes,10,2,[ServerSettings],Set interval for automatic saves" & @CRLF & "False,bAllowUnlimitedRespecs,False,3,[/Script/ShooterGame.ShooterGameMode],Set to true to allow more than one usage of Mindwipe Tonic per level" & @CRLF & "False,bDisableFogOfWar,False,3,[/Script/ShooterGame.ShooterGameMode],No description." & @CRLF & "False,bDisableStructurePlacementCollision,False,3,[/Script/ShooterGame.ShooterGameMode],If 'true' allows for structures to clip into the terrain." & @CRLF & "False,bDontUseClaimFlags,False,3,[/Script/ShooterGame.ShooterGameMode],Turning off Claim Flags will turn your Server Lawless and Structures will decay." & @CRLF & "False,bHomeServerDontReplicateLoggedOutPlayers,True,3,[/Script/ShooterGame.ShooterGameMode],No description." & @CRLF & "False,bPvEDontReplicateLoggedOutPlayers,True,3,[/Script/ShooterGame.ShooterGameMode],Enables non-replicating logged off/sleeping players on all PvE servers" & @CRLF & "False,bUseStaticCharacterAge,False,3,[/Script/ShooterGame.ShooterGameMode],Supposed to freeze your current age. You need to die if you want the setting to take effect." & @CRLF & "False,CraftXPMultiplier,1,3,[/Script/ShooterGame.ShooterGameMode],A multiplier to scale the amount of XP earned for crafting" & @CRLF & "False,EnableHealthbars,True,2,[ServerSettings],No description." & @CRLF & "False,EnablePvPGamma,True,2,[ServerSettings],""Allow use of console command """"gamma"""" in PvP mode""" & @CRLF & _
"False,ForceAllStructureLocking,False,2,[ServerSettings],Enabling this will default lock all structures" & @CRLF & "False,GenericXPMultiplier,1,3,[/Script/ShooterGame.ShooterGameMode],A multiplier to scale the amount of XP earned for generic XP (automatic over time)" & @CRLF & "False,HarvestHealthMultiplier,1,2,[ServerSettings],""Specifies the scaling factor for the health"""" of items that can be harvested (trees rocks carcasses etc.). Higher values increase the amount of damage (i.e. """"number of strikes"""") such objects can withstand before being destroyed which results in higher overall harvest yields.""""""" & @CRLF & "False,KickIdlePlayersPeriod,3600,2,[ServerSettings],Time after which characters that have not moved or interacted will be kicked (if -EnableIdlePlayerKick as command line parameter is set)." & @CRLF & "False,KillXPMultiplier,1,3,[/Script/ShooterGame.ShooterGameMode],A multiplier to scale the amount of XP earned for a kill" & @CRLF & "False,ListenServerTetherDistanceMultiplier,1,2,[ServerSettings],No description." & @CRLF & "False,MaxTamedDinos,5000,2,[ServerSettings],Sets the maximum number of tamed Dinos on a Server this is a global cap." & @CRLF & "False,NoClaimFlagDecayPeriodMultiplier,0,3,[/Script/ShooterGame.ShooterGameMode],Decay rate to be for structures. 0.0 will be no decay" & @CRLF & "False,OxygenSwimSpeedStatMultiplier,1,2,[ServerSettings],Use this to set how swim speed is multiplied by level spent in oxygen. " & @CRLF & "False,PerPlatformMaxStructuresMultiplier,1,2,[ServerSettings],Higher number increases (on a percentage scale) max number of items place-able on saddles and raft" & @CRLF & "False,PlayerCharacterHealthRecoveryMultiplier,1,2,[ServerSettings],Specifies the scaling factor for player characters' health recovery. Higher values increase the recovery rate (player characters heal faster)" & @CRLF & "False,PlayerDefaultNoDiscoveriesMaxLevelUps,8,3,[/Script/ShooterGame.ShooterGameMode],No description." & @CRLF & "False,PreventOfflinePvP,False,2,[ServerSettings],Use this to enable the offline raiding prevention option." & @CRLF & "False,PreventOfflinePvPInterval,14400,2,[ServerSettings],That would be a 15 min wait before a tribe/players dinos/structures become invulnerable/inactive after they log off. (if Tribe requires ALL Tribe members logged off!)" & @CRLF & "False,PvEDinoDecayPeriodMultiplier,1,2,[ServerSettings],Dino PvE Auto-Claim time multiplier" & @CRLF & "False,PvPStructureDecay,True,2,[ServerSettings],Set to true to prevent structure from decaying while the Offline Raiding Prevention is active." & @CRLF & "False,RaidDinoCharacterFoodDrainMultiplier,1,2,[ServerSettings],No description." & @CRLF & "False,RCONServerGameLogBuffer,600,2,[ServerSettings],Determines how many lines of gamelogs are send over RCON" & @CRLF & "False,ServerCrosshair,True,2,[ServerSettings],Use this to disable the Crosshair on your Server" & @CRLF & "False,ShowFloatingDamageText,True,2,[ServerSettings],Use this to enable RPG-style popup text stat mode." & @CRLF & "False,ShowMapPlayerLocation,True,2,[ServerSettings],Show each player their own precise position when they view their map" & @CRLF & "False,SpecialXPMultiplier,1,3,[/Script/ShooterGame.ShooterGameMode],A multiplier to scale the amount of XP earned for SpecialEvents" & @CRLF & "False,StructurePreventResourceRadiusMultiplier,1,2,[ServerSettings],How close or far things respawn from a structure " & @CRLF & "False,TamingSpeedMultiplier,1,2,[ServerSettings],Specifies the scaling factor for dinosaur taming speed. Higher values make taming faster." & @CRLF & "False,TheMaxStructuresInRange,10500,2,[ServerSettings],Specifies the maximum number of structures that can be constructed within a certain (currently hard-coded) range." & @CRLF & "False,TribeJoinInterval,10,2,[ServerSettings],No description." & @CRLF & "FALSE,TribeNameChangeCooldown,300,2,[ServerSettings],Cooldown in minutes in between tribe name changes"
_BackupFile($aParametersFile, $tTxt, False)
EndFunc
Func _ParamsSave($tAllorSel = "all", $tWhichFileToUse = "all", $tGrid = $tGridActive)
Local $tFile[5], $tFileRead[5], $tFileName[5], $tSplit, $tFound, $tPar, $tBound[5], $tArray, $tCountTotal = 0, $tCountReplaced = 0, $tRead[2]
$tFileName[0] = "Command Line"
$tFileName[1] = "ServerGrid.json"
$tFileName[2] = "GameUserSettings.ini"
$tFileName[3] = "Game.ini"
$tFileName[4] = "Engine.ini"
If $tWhichFileToUse = "all" Then $tSelectFile = -1
If $tWhichFileToUse = "CommandLine" Then $tSelectFile = 0
If $tWhichFileToUse = "ServerGrid" Then $tSelectFile = 1
If $tWhichFileToUse = "GameUserSettings" Then $tSelectFile = 2
If $tWhichFileToUse = "Game" Then $tSelectFile = 3
If $tWhichFileToUse = "Engine" Then $tSelectFile = 4
$tFile[0] = -1
$tFile[1] = $aConfigFull
$tFile[2] = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGrid] & "\Config\WindowsServer\GameUserSettings.ini"
$tFile[3] = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGrid] & "\Config\WindowsServer\Game.ini"
$tFile[4] = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGrid] & "\Config\WindowsServer\Engine.ini"
For $i = 2 To 4
If Not FileExists($tFile[$i]) Then _FileCreate($tFile[$i])
_FileReadToArray($tFile[$i], $tFileRead[$i], 0)
Next
For $i = 0 To 4
$tBound[$i] = UBound($tFileRead[$i])
If $tBound[$i] = 0 Then
_ArrayAdd($tFileRead[$i], " ")
EndIf
Next
For $i = 0 To ($gParamTFMax - 1)
$tFileNum = $gParamTFFile[$i]
If $tFileNum = 0 Then
Local $tTxt = $gParamTFName[$i]
Local $tAddorRemove = $gParamTFValue[$i]
$tRead = _ReplaceCommandLine($tGrid, $tTxt, $tAddorRemove)
$tCountTotal += $tRead[0]
$tCountReplaced += $tRead[1]
Else
If $tSelectFile < 0 Or $tSelectFile = $tFileNum Then
$tArray = $tFileRead[$tFileNum]
$tParam = $gParamTFName[$i] & "=" & $gParamTFValue[$i]
If $tAllorSel = "sel" Then
If $gParamTFActiveTF[$i] Then
$tFileRead[$tFileNum] = _ReplaceParamInArray($tArray, $tParam, $i, "TF", $tFileName[$tFileNum])
$tCountReplaced += $_ReplaceParamInArrayCount
$tCountTotal += 1
EndIf
EndIf
EndIf
EndIf
Next
For $i = 0 To ($gParamNumMax - 1)
$tFileNum = $gParamNumFile[$i]
If $tSelectFile < 0 Or $tSelectFile = $tFileNum Then
$tArray = $tFileRead[$tFileNum]
$tParam = $gParamNumName[$i] & "=" & $gParamNumValue[$i]
If $tAllorSel = "sel" Then
If $gParamNumActiveTF[$i] Then
$tFileRead[$tFileNum] = _ReplaceParamInArray($tArray, $tParam, $i, "Num", $tFileName[$tFileNum])
$tCountReplaced += $_ReplaceParamInArrayCount
$tCountTotal += 1
EndIf
EndIf
EndIf
Next
For $i = 2 To 4
_BackupFile($tFile[$i], $tFileRead[$i], False, True)
Next
Local $tCount[2]
$tCount[0] = $tCountTotal
$tCount[1] = $tCountReplaced
Return $tCount
EndFunc
Func _ParamsRead($tAllorSel = "all")
Local $tFile[5], $tFileRead[5], $tSplit, $tFound, $tPar, $tBound[5], $tArray
$tFile[0] = -1
$tFile[1] = $aConfigFull
$tFile[2] = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\GameUserSettings.ini"
$tFile[3] = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\Game.ini"
$tFile[4] = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$tGridActive] & "\Config\WindowsServer\Engine.ini"
For $i = 2 To 4
If Not FileExists($tFile[$i]) Then _FileCreate($tFile[$i])
_FileReadToArray($tFile[$i], $tFileRead[$i], 0)
Next
For $i = 0 To 4
$tBound[$i] = UBound($tFileRead[$i])
If $tBound[$i] = 0 Then
_ArrayAdd($tFileRead[$i], " ")
EndIf
Next
For $i = 0 To ($gParamTFMax - 1)
$tPar = $gParamTFFile[$i]
$gParamTFValExistTF[$i] = False
If $tPar = 0 Then
$gParamTFValExistTF[$i] = True
If StringInStr($xServerGridExtraCMD[$tGridActive], $gParamTFName[$i]) = 0 Then
$gParamTFValue[$i] = False
Else
$gParamTFValue[$i] = True
EndIf
Else
$tArray = $tFileRead[$tPar]
For $x = 0 To (UBound($tArray) - 1)
If StringInStr($tArray[$x], $gParamTFName[$i] & "=") = 0 Then
Else
$tSplit = StringSplit($tArray[$x], "=", 2)
If $tSplit[1] = "true" Then
$gParamTFValue[$i] = True
Else
$gParamTFValue[$i] = False
EndIf
$gParamTFValExistTF[$i] = True
$tFound = True
ExitLoop
EndIf
If $tFound = False Then $gParamTFValue[$i] = $gParamTFDefaultValue[$i]
Next
EndIf
Next
For $i = 0 To ($gParamNumMax - 1)
$tPar = $gParamNumFile[$i]
$tArray = $tFileRead[$tPar]
$gParamNumValExistTF[$i] = False
For $x = 0 To (UBound($tArray) - 1)
If StringInStr($tArray[$x], $gParamNumName[$i] & "=") = 0 Then
Else
$tSplit = StringSplit($tArray[$x], "=", 2)
$gParamNumValue[$i] = $tSplit[1]
$gParamNumValExistTF[$i] = True
$tFound = True
ExitLoop
EndIf
If $tFound = False Then $gParamNumValue[$i] = $gParamNumDefaultValue[$i]
Next
Next
EndFunc
Func _ReplaceParamInArray($t_Array1, $t_Param, $t_ParamNum = -1, $t_TForNum = "TF", $t_File = "GameUserSettings.ini")
If UBound($t_Array1) = 0 Then
Local $t_Array[1]
$t_Array[0] = "AtlasServerUpdateUtility12345=True"
Else
Local $t_Array = $t_Array1
EndIf
Local $t_Parameter, $t_Ext, $t_Txt, $t_Pos = -1, $tNoExt, $tTime, $t_OldParam = "None"
Local $t_XFound = False, $t_YFound = False, $t_Return = 0
For $tC = 1 To StringLen($t_Param)
$t_Txt = StringRight($t_Param, $tC)
If StringInStr($t_Txt, "=") = 0 Then
Else
$t_Parameter = StringTrimRight($t_Param, $tC)
$t_Ext = StringTrimLeft($t_Txt, 1)
ExitLoop
EndIf
Next
For $t_i = 0 To (UBound($t_Array) - 1)
If StringInStr($t_Array[$t_i], $t_Parameter & "=") = 0 Then
$t_OldParam = "None"
Else
$t_OldParam = $t_Array[$t_i]
$t_Pos = $t_i
ExitLoop
EndIf
Next
If $t_Pos = -1 Then
If $t_Parameter = "RCONPort" Or $t_Parameter = "ServerPVE" Then
For $t_i = 0 To (UBound($t_Array) - 1)
If StringInStr($t_Array[$t_i], "[ServerSettings]") = 0 Then
Else
$t_Pos = $t_i + 1
_ArrayInsert($t_Array, $t_Pos)
ExitLoop
EndIf
Next
Else
If $t_TForNum = "TF" Then
For $t_i = 0 To (UBound($t_Array) - 1)
If StringInStr($t_Array[$t_i], $gParamTFHeading[$t_ParamNum]) = 0 Then
Else
$t_Pos = $t_i + 1
ExitLoop
EndIf
Next
If $t_Pos > -1 Then
_ArrayInsert($t_Array, $t_Pos, $t_Parameter & "=" & $gParamTFValue[$t_ParamNum])
Else
_ArrayInsert($t_Array, 0)
_ArrayInsert($t_Array, 0, $t_Parameter & "=" & $gParamTFValue[$t_ParamNum])
_ArrayInsert($t_Array, 0, $gParamTFHeading[$t_ParamNum])
EndIf
Else
For $t_i = 0 To (UBound($t_Array) - 1)
If StringInStr($t_Array[$t_i], $gParamNumHeading[$t_ParamNum]) = 0 Then
Else
$t_Pos = $t_i + 1
ExitLoop
EndIf
Next
If $t_Pos > -1 Then
_ArrayInsert($t_Array, $t_Pos, $t_Parameter & "=" & $gParamNumValue[$t_ParamNum])
Else
_ArrayInsert($t_Array, 0)
_ArrayInsert($t_Array, 0, $t_Parameter & "=" & $gParamNumValue[$t_ParamNum])
_ArrayInsert($t_Array, 0, $gParamNumHeading[$t_ParamNum])
EndIf
EndIf
EndIf
For $t_i = 0 To (UBound($t_Array) - 1)
If $t_Array[$t_i] = "AtlasServerUpdateUtility12345=True" Then
_ArrayDelete($t_Array, $t_i)
ExitLoop
EndIf
Next
Else
EndIf
If $t_Pos > -1 Then $t_Array[$t_Pos] = $t_Param
If $t_OldParam <> $t_Param Then
LogWrite("", " [Param] Changed Parameter in Server " & _ServerNamingScheme($tGridActive, $aNamingScheme) & " [" & $t_File & "] From:" & $t_OldParam & " to " & $t_Param)
Global $_ReplaceParamInArrayCount = 1
Else
Global $_ReplaceParamInArrayCount = 0
EndIf
Return $t_Array
EndFunc
Func PurgeParamBackups($aKeep)
Local $tTxt = "Creating " & $aUtilName & "_PurgeParamBackups.bat file."
Local $tSplash = _Splash($tTxt, 0, 750)
Local $tFile0, $tFile1, $tFile2, $tFile3, $tFile4, $tFolder, $tFile[5]
Local $aPurgeBackups = $aFolderTemp & $aUtilName & "_PurgeParamBackups.bat"
Local $sFileExists = FileExists($aPurgeBackups)
If $sFileExists = 1 Then
FileDelete($aPurgeBackups)
EndIf
For $i = 0 To ($aServerGridTotal - 1)
If $xLocalGrid[$i] = "yes" Then
$tFolder = $aServerDirLocal & "\ShooterGame\Saved\" & $xServerAltSaveDir[$i] & "\Config\WindowsServer\"
$tFile[2] = "GameUserSettings.ini"
$tFile[3] = "Game.ini"
$tFile[4] = "Engine.ini"
For $x = 2 To 4
FileWriteLine($aPurgeBackups, "for /f ""tokens=* skip=" & $aKeep & """ %%F in " & Chr(40) & "'dir """ & $tFolder & $tFile[$x] & "_*.bak"" /o-d /tc /b'" & Chr(41) & " do del """ & $tFolder & "%%F""")
Next
EndIf
Next
$tFolder = $aServerDirLocal & "\ShooterGame\"
$tFile = $aConfigFile
FileWriteLine($aPurgeBackups, "for /f ""tokens=* skip=" & $aKeep & """ %%F in " & Chr(40) & "'dir """ & $tFolder & $tFile & "_*.bak"" /o-d /tc /b'" & Chr(41) & " do del """ & $tFolder & "%%F""")
$tFolder = $aServerDirLocal & "\ShooterGame\Config\"
$tFile = "DefaultGame.ini"
FileWriteLine($aPurgeBackups, "for /f ""tokens=* skip=" & $aKeep & """ %%F in " & Chr(40) & "'dir """ & $tFolder & $tFile & "_*.bak"" /o-d /tc /b'" & Chr(41) & " do del """ & $tFolder & "%%F""")
$tFile = "DefaultGameUserSettings.ini"
FileWriteLine($aPurgeBackups, "for /f ""tokens=* skip=" & $aKeep & """ %%F in " & Chr(40) & "'dir """ & $tFolder & $tFile & "_*.bak"" /o-d /tc /b'" & Chr(41) & " do del """ & $tFolder & "%%F""")
$tFile = "DefaultEngine.ini"
FileWriteLine($aPurgeBackups, "for /f ""tokens=* skip=" & $aKeep & """ %%F in " & Chr(40) & "'dir """ & $tFolder & $tFile & "_*.bak"" /o-d /tc /b'" & Chr(41) & " do del """ & $tFolder & "%%F""")
$tTxt &= " [DONE]" & @CRLF & "Deleting Backups > " & $aKeep & @CRLF & "(ServerGrid.json_.bak, GameUserSettings, Game, Engine, DefaultGUS, DefaultGame, DefaultEngine)"
ControlSetText($tSplash, "", "Static1", $tTxt)
LogWrite("", " [Param] Deleting Backups > " & $aKeep & ". Files include: ServerGrid.json_[date].bak, GameUserSettings.ini, Game, Engine, DefaultGUS, DefaultGame, DefaultEngine.")
Run($aPurgeBackups, "", @SW_HIDE)
For $i = 0 To 8
$tTxt1 = $tTxt & @CRLF & "--==  PURGE PARAMETER BACKUPS COMPLETED ==--"
ControlSetText($tSplash, "", "Static1", $tTxt1)
Sleep(750)
ControlSetText($tSplash, "", "Static1", $tTxt)
Sleep(250)
Next
SplashOff()
EndFunc
Func _GetMemArrayRawAvg($Pid)
Local $tMem[UBound($Pid)], $wbemFlagReturnImmediately = 0x10, $wbemFlagForwardOnly = 0x20
$objWMIService = ObjGet("winmgmts:\\localhost\root\CIMV2")
If @error Then Return 0
$colItems = $objWMIService.ExecQuery("SELECT * FROM Win32_PerfRawData_PerfProc_Process", "WQL", $wbemFlagReturnImmediately + $wbemFlagForwardOnly)
If IsObj($colItems) Then
For $objItem In $colItems
For $x = 0 To (UBound($Pid) - 1)
If $Pid[$x] = $objItem.IDProcess Then $tMem[$x] = ($objItem.WorkingSetPrivate)
If @error Then Return 0
Next
Next
Return $tMem
EndIf
Return 0
EndFunc
Func _CurrentCPU($init = 0)
Global $liOldIdleTime = 0
Global $liOldSystemTime = 0
Local $SYS_BASIC_INFO = 0
Local $SYS_PERFORMANCE_INFO = 2
Local $SYS_TIME_INFO = 3
$SYSTEM_BASIC_INFORMATION = DllStructCreate("int;uint;uint;uint;uint;uint;uint;ptr;ptr;uint;byte;byte;short")
$status = DllCall("ntdll.dll", "int", "NtQuerySystemInformation", "int", $SYS_BASIC_INFO, "ptr", DllStructGetPtr($SYSTEM_BASIC_INFORMATION), "int", DllStructGetSize($SYSTEM_BASIC_INFORMATION), "int", 0)
If $status[0] Then Return -1
While 1
$SYSTEM_PERFORMANCE_INFORMATION = DllStructCreate("int64;int[76]")
$SYSTEM_TIME_INFORMATION = DllStructCreate("int64;int64;int64;uint;int")
$status = DllCall("ntdll.dll", "int", "NtQuerySystemInformation", "int", $SYS_TIME_INFO, "ptr", DllStructGetPtr($SYSTEM_TIME_INFORMATION), "int", DllStructGetSize($SYSTEM_TIME_INFORMATION), "int", 0)
If $status[0] Then Return -2
$status = DllCall("ntdll.dll", "int", "NtQuerySystemInformation", "int", $SYS_PERFORMANCE_INFO, "ptr", DllStructGetPtr($SYSTEM_PERFORMANCE_INFORMATION), "int", DllStructGetSize($SYSTEM_PERFORMANCE_INFORMATION), "int", 0)
If $status[0] Then Return -3
If $init = 1 Or $liOldIdleTime = 0 Then
$liOldIdleTime = DllStructGetData($SYSTEM_PERFORMANCE_INFORMATION, 1)
$liOldSystemTime = DllStructGetData($SYSTEM_TIME_INFORMATION, 2)
Sleep(1000)
If $init = 1 Then Return -99
Else
$dbIdleTime = DllStructGetData($SYSTEM_PERFORMANCE_INFORMATION, 1) - $liOldIdleTime
$dbSystemTime = DllStructGetData($SYSTEM_TIME_INFORMATION, 2) - $liOldSystemTime
$liOldIdleTime = DllStructGetData($SYSTEM_PERFORMANCE_INFORMATION, 1)
$liOldSystemTime = DllStructGetData($SYSTEM_TIME_INFORMATION, 2)
$dbIdleTime = $dbIdleTime / $dbSystemTime
$dbIdleTime = 100.0 - $dbIdleTime * 100.0 / DllStructGetData($SYSTEM_BASIC_INFORMATION, 11) + 0.5
Return $dbIdleTime
EndIf
$SYSTEM_PERFORMANCE_INFORMATION = 0
$SYSTEM_TIME_INFORMATION = 0
WEnd
EndFunc
Func _CPUGetTotalProcessorTimes()
Local $aRet, $aTimes
$aRet = DllCall("kernel32.dll", "bool", "GetSystemTimes", "uint64*", 0, "uint64*", 0, "uint64*", 0)
If @error Then Return SetError(2, @error, "")
If Not $aRet[0] Then Return SetError(3, 0, "")
Dim $aTimes[3] = [$aRet[1], $aRet[2], $aRet[3]]
Return $aTimes
EndFunc
Func _ProcessUsageTracker_Destroy(ByRef $aProcUsage)
If Not IsArray($aProcUsage) Or UBound($aProcUsage) < 2 Then Return SetError(1, 0, False)
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $aProcUsage[1][2])
$aProcUsage = ""
Return True
EndFunc
Func _ProcessUsageTracker_Create($sProcess, $nPID = 0)
Local $aRet, $iAccess, $hProcess, $aProcUsage[2][6]
If Not $nPID Then
$nPID = ProcessExists($sProcess)
EndIf
If StringRegExp(@OSVersion, "_(XP|200(0|3))") Then
$iAccess = 0x0400
Else
$iAccess = 0x1000
EndIf
$iAccess += 0x00100000
$aRet = _CPUGetTotalProcessorTimes()
If @error Then Return SetError(@error, @extended, "")
$aProcUsage[0][1] = $aRet[1] + $aRet[2]
$hProcess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", False, "dword", $nPID)
If @error Then Return SetError(2, @error, "")
$hProcess = $hProcess[0]
If $hProcess = 0 Then
Local $nLastError = DllCall("kernel32.dll", "dword", "GetLastError")
If @error Then Return SetError(2, @error, "")
$nLastError = $nLastError[0]
If $nLastError = 5 Then
$iAccess -= 0x00100000
$hProcess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", False, "dword", $nPID)
If @error Then Return SetError(2, @error, False)
$hProcess = $hProcess[0]
If $hProcess = 0 Then Return SetError(3, 0, "")
Else
Return SetError(3, $nLastError, "")
EndIf
EndIf
$aProcUsage[0][0] = 1
$aProcUsage[1][0] = $sProcess
$aProcUsage[1][1] = $nPID
$aProcUsage[1][2] = $hProcess
$aProcUsage[1][3] = $iAccess
$aRet = DllCall("kernel32.dll", "bool", "GetProcessTimes", "handle", $hProcess, "uint64*", 0, "uint64*", 0, "uint64*", 0, "uint64*", 0)
If @error Or Not $aRet[0] Then
Local $iErr = @error
_ProcessUsageTracker_Destroy($aProcUsage)
Return SetError(-1, $iErr, "")
EndIf
$aProcUsage[1][4] = $aRet[4]
$aProcUsage[1][5] = $aRet[5]
Return $aProcUsage
EndFunc
Func _ProcessUsageTracker_GetUsage(ByRef $aProcUsage)
If Not IsArray($aProcUsage) Or UBound($aProcUsage) < 2 Then Return SetError(1, 0, 0)
Local $fUsage, $nCPUTotal, $aRet
$aRet = _CPUGetTotalProcessorTimes()
If @error Then Return SetError(@error, @extended, 0)
$nCPUTotal = $aRet[1] + $aRet[2]
$aRet = DllCall("kernel32.dll", "bool", "GetProcessTimes", "handle", $aProcUsage[1][2], "uint64*", 0, "uint64*", 0, "uint64*", 0, "uint64*", 0)
If @error Or Not $aRet[0] Then
Local $iErr = @error
_ProcessUsageTracker_Destroy($aProcUsage)
Return SetError(-1, $iErr, 0)
EndIf
If $aRet[3] > $aRet[2] Then
If BitAND($aProcUsage[1][3], 0x00100000) Then
$aRet = DllCall("kernel32.dll", "dword", "WaitForSingleObject", "handle", $aProcUsage[1][2], "dword", 0)
If Not @error And $aRet[0] = 0 Then
_ProcessUsageTracker_Destroy($aProcUsage)
Return SetError(-1, 0, 0)
EndIf
Else
$aRet = DllCall("kernel32.dll", "bool", "GetExitCodeProcess", "handle", $aProcUsage[1][2], "dword*", 0)
If Not @error And $aRet[0] And $aRet[2] <> 259 Then
_ProcessUsageTracker_Destroy($aProcUsage)
Return SetError(-1, 0, 0)
EndIf
EndIf
Return 0
EndIf
$fUsage = Round((($aRet[4] - $aProcUsage[1][4]) + ($aRet[5] - $aProcUsage[1][5])) * 100 / ($nCPUTotal - $aProcUsage[0][1]), 1)
$aProcUsage[0][1] = $nCPUTotal
$aProcUsage[1][4] = $aRet[4]
$aProcUsage[1][5] = $aRet[5]
Return $fUsage
EndFunc
Func _CPUOverallUsageTracker_Create()
Local $aCPUTimes, $aCPUsUsage[2]
$aCPUTimes = _CPUGetTotalProcessorTimes()
If @error Then Return SetError(@error, @extended, "")
$aCPUsUsage[0] = $aCPUTimes[1] + $aCPUTimes[2]
$aCPUsUsage[1] = $aCPUTimes[1] + $aCPUTimes[2] - $aCPUTimes[0]
Return $aCPUsUsage
EndFunc
Func _CPUOverallUsageTracker_GetUsage(ByRef $aCPUsUsage)
If Not IsArray($aCPUsUsage) Or UBound($aCPUsUsage) < 2 Then Return SetError(1, 0, "")
Local $aCPUsCurInfo, $fUsage, $nTotalActive, $nTotal
$aCPUsCurInfo = _CPUOverallUsageTracker_Create()
If @error Then Return SetError(@error, @extended, 0)
$nTotal = $aCPUsCurInfo[0] - $aCPUsUsage[0]
$nTotalActive = $aCPUsCurInfo[1] - $aCPUsUsage[1]
$aCPUsUsage = $aCPUsCurInfo
Return Round($nTotalActive * 100 / $nTotal, 1)
EndFunc
Func _NetworkConnectionsViewer()
Run(@ScriptDir & "\NetworkConnectionsViewer.exe")
EndFunc
Func _GUIListViewEx_Globals()
Global $aGLVEx_Data[1][26] = [[0, 0, -1, "", -1, -1, -1, -1, _WinAPI_GetSystemMetrics(2), False, -1, -1, False, "", 0, True, 0, -1, -1, 0, 0, 0, 0, "08"]]
Global $hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVEx_SrcIndex, $aGLVEx_SrcArray, $aGLVEx_SrcColArray
Global $hGLVEx_TgtHandle, $cGLVEx_TgtID, $iGLVEx_TgtIndex, $aGLVEx_TgtArray, $aGLVEx_TgtColArray
Global $iGLVEx_Dragging = 0, $iGLVEx_DraggedIndex, $hGLVEx_DraggedImage = 0, $sGLVEx_DragEvent
Global $iGLVEx_InsertIndex = -1, $iGLVEx_LastY, $fGLVEx_BarUnder
Global $hGLVEx_Editing, $cGLVEx_EditID = 9999, $fGLVEx_EditClickFlag = 0, $fGLVEx_HeaderEdit = False
Global $fGLVEx_SelChangeFlag = 0, $fGLVEx_UserSelFlag = 0
Global $aGLVEx_DefColours[4] = ["0x000000", "0xFEFEFE", "0xFFFFFF", "0xCC6600"]
EndFunc
Func _GUIListViewEx_Init($hLV, $aArray = "", $iStart = 0, $iColour = 0, $fImage = False, $iAdded = 0)
Local $iLV_Index = 0
For $i = 1 To $aGLVEx_Data[0][0]
If $aGLVEx_Data[$i][0] = 0 Then
$iLV_Index = $i
ExitLoop
EndIf
Next
If $iLV_Index = 0 Then
$aGLVEx_Data[0][0] += 1
ReDim $aGLVEx_Data[$aGLVEx_Data[0][0] + 1][UBound($aGLVEx_Data, 2)]
$iLV_Index = $aGLVEx_Data[0][0]
EndIf
If IsHWnd($hLV) Then
$aGLVEx_Data[$iLV_Index][0] = $hLV
$aGLVEx_Data[$iLV_Index][1] = 0
Else
$aGLVEx_Data[$iLV_Index][0] = GUICtrlGetHandle($hLV)
$aGLVEx_Data[$iLV_Index][1] = $hLV
EndIf
$aGLVEx_Data[0][24] = Opt("GUIDataSeparatorChar")
$aGLVEx_Data[$iLV_Index][2] = _GUIListViewEx_ReadToArray($hLV, 1)
$aGLVEx_Data[$iLV_Index][20] = -1
$aGLVEx_Data[$iLV_Index][21] = -1
$aGLVEx_Data[$iLV_Index][3] = $iStart
If IsArray($aArray) Then
If UBound($aArray, 0) = 2 Then $aGLVEx_Data[$iLV_Index][3] += 2
EndIf
Local $aEditable[4][UBound($aGLVEx_Data[$iLV_Index][2], 2)]
$aGLVEx_Data[$iLV_Index][7] = $aEditable
_GUICtrlListView_SetInsertMarkColor($hLV, BitOR(BitShift(BitAND($iColour, 0x000000FF), -16), BitAND($iColour, 0x0000FF00), BitShift(BitAND($iColour, 0x00FF0000), 16)))
If $fImage Then
$aGLVEx_Data[$iLV_Index][5] = 1
EndIf
If BitAND($iAdded, 1) Then
Local $aLVSortState[_GUICtrlListView_GetColumnCount($hLV)]
$aGLVEx_Data[$iLV_Index][4] = $aLVSortState
Else
$aGLVEx_Data[$iLV_Index][4] = 0
EndIf
If BitAND($iAdded, 2) Then
$aGLVEx_Data[$iLV_Index][11] = 1
EndIf
If BitAND($iAdded, 4) Then
$aGLVEx_Data[$iLV_Index][9] = 1
EndIf
If BitAND($iAdded, 8) Then
$aGLVEx_Data[$iLV_Index][8] = 1
EndIf
Local $iCols = _GUICtrlListView_GetColumnCount($hLV)
Local $aHdrData[4][$iCols], $aRet
If BitAND($iAdded, 16) Then
Local $hHeader = _GUICtrlListView_GetHeader($hLV)
$aGLVEx_Data[$iLV_Index][24] = $hHeader
For $i = 0 To $iCols - 1
$aRet = _GUICtrlListView_GetColumn($hLV, $i)
$aHdrData[0][$i] = $aRet[5]
Next
EndIf
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
$aGLVEx_Data[$iLV_Index][23] = $aGLVEx_DefColours
If BitAND($iAdded, 32) Then
Local $aColArray = $aGLVEx_Data[$iLV_Index][2]
For $i = 1 To UBound($aColArray, 1) - 1
For $j = 0 To UBound($aColArray, 2) - 1
$aColArray[$i][$j] = ";"
Next
Next
$aGLVEx_Data[$iLV_Index][18] = $aColArray
$aGLVEx_Data[$iLV_Index][19] = 1
EndIf
If BitAND($iAdded, 64) Then
$aGLVEx_Data[$iLV_Index][12] = 1
EndIf
If BitAND($iAdded, 128) Then
$aGLVEx_Data[$iLV_Index][12] += 2
EndIf
If BitAND($iAdded, 256) Then
$aGLVEx_Data[$iLV_Index][12] += 4
EndIf
If BitAND($iAdded, 512) Then
$aGLVEx_Data[$iLV_Index][12] += 8 + 2
EndIf
If BitAND($iAdded, 1024) Then
Local $iStyle = _WinAPI_GetWindowLong($aGLVEx_Data[$iLV_Index][0], $GWL_STYLE)
_WinAPI_SetWindowLong($aGLVEx_Data[$iLV_Index][0], $GWL_STYLE, BitOR($iStyle, $LVS_SINGLESEL))
$aGLVEx_Data[$iLV_Index][22] = 1
$aGLVEx_Data[$iLV_Index][23] = $aGLVEx_DefColours
EndIf
If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hLV), 4) Then
$aGLVEx_Data[$iLV_Index][6] = 1
EndIf
If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hLV), 0x00000010) Then
$aGLVEx_Data[$iLV_Index][13] = 1
EndIf
Local $aRect = _GUICtrlListView_GetItemRect($aGLVEx_Data[$iLV_Index][0], 0)
$aGLVEx_Data[$iLV_Index][10] = $aRect[3] - $aRect[1]
Local $iListView_Count = 0
For $i = 1 To $iLV_Index
If $aGLVEx_Data[$i][0] Then $iListView_Count += 1
Next
If $iListView_Count = 1 Then _GUIListViewEx_SetActive($iLV_Index)
Return $iLV_Index
EndFunc
Func _GUIListViewEx_Close($iLV_Index = 0)
Local $iEditKeyCode
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
If $iLV_Index = 0 Then
$iEditKeyCode = $aGLVEx_Data[0][23]
Global $aGLVEx_Data[1][UBound($aGLVEx_Data, 2)] = [[0, 0, -1, "", -1, -1, -1, -1, _WinAPI_GetSystemMetrics(2), False, -1, -1, False, "", 0, True, 0, -1, -1, 0, 0, 0, 0, $iEditKeyCode]]
Else
For $i = 0 To UBound($aGLVEx_Data, 2) - 1
$aGLVEx_Data[$iLV_Index][$i] = 0
Next
If $aGLVEx_Data[0][1] = $iLV_Index Then
$aGLVEx_Data[0][1] = 0
EndIf
EndIf
Return 1
EndFunc
Func _GUIListViewEx_SetActive($iLV_Index)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, -1)
Local $iCurr_Index = $aGLVEx_Data[0][1]
If $iLV_Index Then
$aGLVEx_Data[0][1] = $iLV_Index
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Else
$aGLVEx_Data[0][1] = 0
$hGLVEx_SrcHandle = 0
$cGLVEx_SrcID = 0
EndIf
Return $iCurr_Index
EndFunc
Func _GUIListViewEx_GetActive()
Return $aGLVEx_Data[0][1]
EndFunc
Func _GUIListViewEx_ReadToArray($hLV, $iStart = 0)
Local $aLVArray = "", $aRow
If Not IsHWnd($hLV) Then
$hLV = GUICtrlGetHandle($hLV)
If Not IsHWnd($hLV) Then
Return SetError(1, 0, "")
EndIf
EndIf
Local $iRows = _GUICtrlListView_GetItemCount($hLV)
Local $iCols = _GUICtrlListView_GetColumnCount($hLV)
If ($iRows + $iStart <> 0) And $iCols <> 0 Then
Local $aLVArray[$iRows + $iStart][$iCols] = [[$iRows]]
For $i = 0 To $iRows - 1
$aRow = _GUICtrlListView_GetItemTextArray($hLV, $i)
For $j = 1 To $aRow[0]
$aLVArray[$i + $iStart][$j - 1] = $aRow[$j]
Next
Next
Else
Local $aLVArray[1][1] = [[0]]
EndIf
Return $aLVArray
EndFunc
Func _GUIListViewEx_ReturnArray($iLV_Index, $iMode = 0)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
Local $hLV = $aGLVEx_Data[$iLV_Index][0]
Local $aColOrder = StringSplit(_GUICtrlListView_GetColumnOrder($hLV), $aGLVEx_Data[0][24])
Local $aData_Colour = $aGLVEx_Data[$iLV_Index][2]
Local $iDim_1 = UBound($aData_Colour, 1), $iDim_2 = UBound($aData_Colour, 2)
Local $aCheck[$iDim_1], $aHeader[$iDim_2], $aHdrData
Switch $iMode
Case 0, 3
Case 1
If $aGLVEx_Data[$iLV_Index][6] Then
For $i = 1 To $iDim_1 - 1
$aCheck[$i] = _GUICtrlListView_GetItemChecked($hLV, $i - 1)
Next
If BitAND($aGLVEx_Data[$iLV_Index][3], 1) = 0 Then
__GUIListViewEx_Array_Delete($aCheck, 0)
EndIf
Return $aCheck
Else
Return SetError(3, 0, "")
EndIf
Case 2
If $aGLVEx_Data[$iLV_Index][19] Then
$aData_Colour = $aGLVEx_Data[$iLV_Index][18]
For $i = 0 To UBound($aData_Colour, 1) - 1
For $j = 0 To UBound($aData_Colour, 2) - 1
$aData_Colour[$i][$j] = StringRegExpReplace($aData_Colour[$i][$j], "0x(.{2})(.{2})(.{2})", "0x$3$2$1")
Next
Next
$aData_Colour[0][0] = $iDim_1 - 1
Else
Return SetError(4, 0, "")
EndIf
Case 4
If $aGLVEx_Data[$iLV_Index][24] Then
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
For $i = 0 To $iDim_2 - 1
$aHeader[$i] = $aHdrData[0][$i]
Next
Else
Local $aRet
For $i = 0 To $iDim_2 - 1
$aRet = _GUICtrlListView_GetColumn($hLV, $i)
$aHeader[$i] = $aRet[5]
Next
EndIf
Case 5
If $aGLVEx_Data[$iLV_Index][24] Then
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
For $i = 0 To $iDim_2 - 1
$aHeader[$i] = $aHdrData[1][$i]
Next
Else
Return SetError(5, 0, "")
EndIf
Case Else
Return SetError(6, 0, "")
EndSwitch
If $aGLVEx_Data[$iLV_Index][13] Then
Switch $iMode
Case 0, 2, 3
Local $aData_Colour_Ordered[$iDim_1][$iDim_2]
$aData_Colour_Ordered[0][0] = $aData_Colour[0][0]
For $i = 1 To $iDim_1 - 1
For $j = 0 To $iDim_2 - 1
$aData_Colour_Ordered[$i][$j] = $aData_Colour[$i][$aColOrder[$j + 1]]
Next
Next
$aData_Colour = $aData_Colour_Ordered
$aData_Colour_Ordered = ""
Case 4, 5
Local $aHeader_Ordered[$iDim_2]
For $i = 0 To $iDim_2 - 1
$aHeader_Ordered[$i] = $aHeader[$aColOrder[$i + 1]]
Next
Return $aHeader_Ordered
EndSwitch
Else
If $iMode = 4 Then
Return $aHeader
EndIf
EndIf
Local $iCount = 1
If BitAND($aGLVEx_Data[$iLV_Index][3], 1) = 0 Or $iMode = 2 Then
$iCount = 0
__GUIListViewEx_Array_Delete($aData_Colour, 0, True)
EndIf
If BitAND($aGLVEx_Data[$iLV_Index][3], 2) = 0 And $iMode < 2 Then
If UBound($aData_Colour, 1) = 0 Then
Local $aData_Colour[0]
Else
Local $iCols = UBound($aData_Colour, 2)
Local $aData_Colour_1D[UBound($aData_Colour)] = [$aData_Colour[0][0]]
For $i = $iCount To UBound($aData_Colour_1D) - 1
Local $aLine = ""
For $j = 0 To $iCols - 1
$aLine &= $aData_Colour[$i][$j] & $aGLVEx_Data[0][24]
Next
$aData_Colour_1D[$i] = StringTrimRight($aLine, 1)
Next
$aData_Colour = $aData_Colour_1D
EndIf
EndIf
Return $aData_Colour
EndFunc
Func _GUIListViewEx_SaveListView($iLV_Index, $sFileName)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
Local $hLV_Handle = $aGLVEx_Data[$iLV_Index][0]
Local $iStart = BitAND($aGLVEx_Data[$iLV_Index][3], 1)
Local $sHeader = "", $aRet
If $aGLVEx_Data[$iLV_Index][24] Then
Local $aHdrData = $aGLVEx_Data[$iLV_Index][25]
For $i = 0 To _GUICtrlListView_GetColumnCount($hLV_Handle) - 1
$aRet = _GUICtrlListView_GetColumn($hLV_Handle, $i)
$sHeader &= $aHdrData[0][$i] & @CR & $aRet[4] & @CR & $aHdrData[1][$i] & @CR & $aHdrData[2][$i] & @CR & $aHdrData[3][$i] & @LF
Next
Else
For $i = 0 To _GUICtrlListView_GetColumnCount($hLV_Handle) - 1
$aRet = _GUICtrlListView_GetColumn($hLV_Handle, $i)
$sHeader &= $aRet[5] & @CR & $aRet[4] & @CR & @CR & @CR & @LF
Next
EndIf
$sHeader = StringTrimRight($sHeader, 1)
Local $aData = _GUIListViewEx_ReturnArray($iLV_Index, 3)
If $iStart Then
_ArrayDelete($aData, 0)
EndIf
Local $aCheck = _GUIListViewEx_ReturnArray($iLV_Index, 1)
If $iStart Then
_ArrayDelete($aCheck, 0)
EndIf
Local $aColour = _GUIListViewEx_ReturnArray($iLV_Index, 2)
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Local $aSortable = $aGLVEx_Data[$iLV_Index][4]
Local $sData = "", $sCheck = "", $sColour = "", $sEditable = "", $sSortable = ""
If IsArray($aData) Then
$sData = __GUIListViewEx_MakeString($aData)
EndIf
If IsArray($aCheck) Then
$sCheck = __GUIListViewEx_MakeString($aCheck)
EndIf
If IsArray($aColour) Then
$sColour = __GUIListViewEx_MakeString($aColour)
EndIf
If IsArray($aEditable) Then
$sEditable = __GUIListViewEx_MakeString($aEditable)
EndIf
If IsArray($aSortable) Then
$sSortable = __GUIListViewEx_MakeString($aSortable)
EndIf
Local $iError = 0
Local $hFile = FileOpen($sFileName, $FO_OVERWRITE)
If @error Then
$iError = 1
Else
FileWrite($hFile, $sHeader & ChrW(0xEF0F) & $sData & ChrW(0xEF0F) & $sCheck & ChrW(0xEF0F) & $sColour & ChrW(0xEF0F) & $sEditable & ChrW(0xEF0F) & $sSortable)
If @error Then
$iError = 2
EndIf
EndIf
FileClose($hFile)
If $iError Then Return SetError(2, $iError, 0)
Return 1
EndFunc
Func _GUIListViewEx_LoadListView($iLV_Index, $sFileName, $iDims = 2)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
Switch $iDims
Case 1, 2
Case Else
Return SetError(2, 0, 0)
EndSwitch
Local $hLV_Handle = $aGLVEx_Data[$iLV_Index][0]
Local $cLV_CID = $aGLVEx_Data[$iLV_Index][1]
Local $iStart = BitAND($aGLVEx_Data[$iLV_Index][3], 1)
Local $sContent = FileRead($sFileName)
If @error Then Return SetError(3, 0, 0)
Local $aSplit = StringSplit($sContent, ChrW(0xEF0F), $STR_ENTIRESPLIT)
If $aSplit[1] = "" Then Return SetError(4, 0, 0)
Local $aHeader = __GUIListViewEx_MakeArray($aSplit[1])
Local $aData = __GUIListViewEx_MakeArray($aSplit[2])
Local $aCheck = __GUIListViewEx_MakeArray($aSplit[3])
Local $aColour = __GUIListViewEx_MakeArray($aSplit[4])
Local $aEditable = __GUIListViewEx_MakeArray($aSplit[5])
Local $aSortable = __GUIListViewEx_MakeArray($aSplit[6])
If UBound($aData, 0) = 1 Then
Local $aTempData[UBound($aData)][1]
Local $aTempCol[UBound($aData)][1]
For $i = 0 To UBound($aData) - 1
$aTempData[$i][0] = $aData[$i]
$aTempCol[$i][0] = $aColour[$i]
Next
$aData = $aTempData
$aColour = $aTempCol
EndIf
If $aGLVEx_Data[$iLV_Index][24] Then
Local $aHdrData[4][UBound($aHeader, 2)]
For $i = 0 To UBound($aHeader) - 1
$aHdrData[0][$i] = $aHeader[$i][0]
$aHdrData[1][$i] = $aHeader[$i][2]
$aHdrData[2][$i] = $aHeader[$i][3]
$aHdrData[3][$i] = $aHeader[$i][4]
Next
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
EndIf
$aGLVEx_Data[0][12] = 1
$aGLVEx_Data[0][15] = False
_GUICtrlListView_BeginUpdate($hLV_Handle)
_GUICtrlListView_DeleteAllItems($hLV_Handle)
Local $iCol_Count = _GUICtrlListView_GetColumnCount($hLV_Handle)
If $iCol_Count < UBound($aHeader) Then
For $i = $iCol_Count To UBound($aHeader) - 1
_GUICtrlListView_AddColumn($hLV_Handle, "", 100)
Next
EndIf
If $iCol_Count > UBound($aHeader) Then
For $i = $iCol_Count To UBound($aHeader) Step -1
_GUICtrlListView_DeleteColumn($hLV_Handle, $i)
Next
EndIf
For $i = 0 To UBound($aHeader) - 1
_GUICtrlListView_SetColumn($hLV_Handle, $i, $aHeader[$i][0], $aHeader[$i][1])
Next
If $cLV_CID Then
Local $sLine, $iLastCol = UBound($aData, 2) - 1
For $i = 0 To UBound($aData) - 1
$sLine = ""
For $j = 0 To $iLastCol
$sLine &= $aData[$i][$j] & "|"
Next
GUICtrlCreateListViewItem(StringTrimRight($sLine, 1), $cLV_CID)
Next
Else
_GUICtrlListView_AddArray($hLV_Handle, $aData)
EndIf
_GUICtrlListView_EndUpdate($hLV_Handle)
_ArrayInsert($aData, 0, UBound($aData))
$aGLVEx_Data[$iLV_Index][2] = $aData
$aGLVEx_Data[$iLV_Index][7] = $aEditable
$aGLVEx_Data[$iLV_Index][4] = $aSortable
$aGLVEx_Data[$iLV_Index][3] = $iStart + (($iDims = 2) ? (2) : (0))
If IsArray($aCheck) Then
For $i = 0 To UBound($aCheck) - 1
If $aCheck[$i] = "True" Then
_GUICtrlListView_SetItemChecked($hLV_Handle, $i, True)
EndIf
Next
EndIf
$aGLVEx_Data[0][12] = 0
$aGLVEx_Data[0][15] = True
If $aGLVEx_Data[$iLV_Index][19] Then
If IsArray($aColour) Then
_GUIListViewEx_LoadColour($iLV_Index, $aColour)
Else
$aColour = $aData
For $i = 0 To UBound($aData) - 1
For $j = 0 To UBound($aData, 2) - 1
$aColour[$i][$j] = ";"
Next
Next
$aGLVEx_Data[$iLV_Index][18] = $aColour
EndIf
EndIf
__GUIListViewEx_RedrawWindow($iLV_Index)
$aGLVEx_Data[0][1] = $iLV_Index
Return 1
EndFunc
Func _GUIListViewEx_Up()
Local $iGLVExMove_Index, $iGLVEx_Moving = 0
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, 0)
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
Local $iIndex
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
If $iIndex == "" Then
Return SetError(2, 0, "")
EndIf
Local $aIndex = StringSplit($iIndex, "|")
$iGLVExMove_Index = $aIndex[1]
If $aIndex[0] > 1 Then
For $i = 1 To $aIndex[0] - 1
If $aIndex[$i + 1] = $aIndex[1] + $i Then
$iGLVEx_Moving += 1
Else
ExitLoop
EndIf
Next
Else
$iGLVExMove_Index = $aIndex[1]
EndIf
If $iGLVExMove_Index < 1 Then
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, 0)
Return SetError(3, 0, "")
EndIf
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, -1, False)
$aGLVEx_Data[0][12] = True
For $iIndex = $iGLVExMove_Index To $iGLVExMove_Index + $iGLVEx_Moving
__GUIListViewEx_Array_Swap($aGLVEx_SrcArray, $iIndex, $iIndex + 1)
__GUIListViewEx_Array_Swap($aCheck_Array, $iIndex, $iIndex + 1)
__GUIListViewEx_Array_Swap($aGLVEx_SrcColArray, $iIndex, $iIndex + 1)
Next
$aGLVEx_Data[$iLV_Index][20] -= 1
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
For $i = 0 To $iGLVEx_Moving
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVExMove_Index + $i - 1)
Next
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_Down()
Local $iGLVExMove_Index, $iGLVEx_Moving = 0
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, 0)
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
Local $iIndex
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
If $iIndex == "" Then
Return SetError(2, 0, "")
EndIf
Local $aIndex = StringSplit($iIndex, "|")
If $aIndex[0] > 1 Then
$iGLVExMove_Index = $aIndex[$aIndex[0]]
For $i = 1 To $aIndex[0] - 1
If $aIndex[$aIndex[0] - $i] = $aIndex[$aIndex[0]] - $i Then
$iGLVEx_Moving += 1
Else
ExitLoop
EndIf
Next
Else
$iGLVExMove_Index = $aIndex[1]
EndIf
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, -1, False)
If $iGLVExMove_Index = _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle) - 1 Then
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iIndex)
Return SetError(3, 0, "")
EndIf
$aGLVEx_Data[0][12] = True
For $iIndex = $iGLVExMove_Index To $iGLVExMove_Index - $iGLVEx_Moving Step -1
__GUIListViewEx_Array_Swap($aGLVEx_SrcArray, $iIndex + 1, $iIndex + 2)
__GUIListViewEx_Array_Swap($aCheck_Array, $iIndex + 1, $iIndex + 2)
__GUIListViewEx_Array_Swap($aGLVEx_SrcColArray, $iIndex + 1, $iIndex + 2)
Next
$aGLVEx_Data[$iLV_Index][20] += 1
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
For $i = 0 To $iGLVEx_Moving
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVExMove_Index - $iGLVEx_Moving + $i + 1)
Next
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_Insert($vData, $fMultiRow = False, $fRetainWidth = False)
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Local $iIndex
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
Local $iInsert_Index = $iIndex
If $iIndex == "" Then $iInsert_Index = -1
If StringInStr($iIndex, "|") Then
Local $aIndex = StringSplit($iIndex, "|")
$iIndex = $aIndex[1]
For $i = 2 To $aIndex[0]
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, $aIndex[$i], False)
Next
EndIf
Local $vRet = _GUIListViewEx_InsertSpec($iLV_Index, $iInsert_Index + 1, $vData, $fMultiRow, $fRetainWidth)
Return SetError(@error, 0, $vRet)
EndFunc
Func _GUIListViewEx_InsertSpec($iLV_Index, $iRow, $vData, $fMultiRow = False, $fRetainWidth = False)
Local $vInsert
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
If $aGLVEx_SrcArray[0][0] = 0 Then $iRow = 0
If IsArray($vData) Then
$vInsert = $vData
Else
Local $aData = StringSplit($vData, $aGLVEx_Data[0][24])
Switch $aData[0]
Case 1
$vInsert = $aData[1]
Case Else
Local $vInsert[$aData[0]]
For $i = 0 To $aData[0] - 1
$vInsert[$i] = $aData[$i + 1]
Next
EndSwitch
EndIf
$aGLVEx_Data[0][12] = True
If $iRow = -1 Then
__GUIListViewEx_Array_Add($aGLVEx_SrcArray, $vInsert, $fMultiRow)
__GUIListViewEx_Array_Add($aCheck_Array, $vInsert, $fMultiRow)
__GUIListViewEx_Array_Add($aGLVEx_SrcColArray, ";", $fMultiRow)
Else
__GUIListViewEx_Array_Insert($aGLVEx_SrcArray, $iRow + 1, $vInsert, $fMultiRow)
__GUIListViewEx_Array_Insert($aCheck_Array, $iRow + 1, $vInsert, $fMultiRow)
__GUIListViewEx_Array_Insert($aGLVEx_SrcColArray, $iRow + 1, ";", $fMultiRow)
EndIf
If $aGLVEx_Data[0][15] Then
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox, $fRetainWidth)
EndIf
If $iRow = -1 Then
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle) - 1)
Else
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iRow)
EndIf
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_Delete($vRange = "")
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Local $vRet = _GUIListViewEx_DeleteSpec($iLV_Index, $vRange)
Return SetError(@error, 0, $vRet)
EndFunc
Func _GUIListViewEx_DeleteSpec($iLV_Index, $vRange = "")
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
If UBound($hGLVEx_SrcHandle) = 1 Then Return SetError(3, 0, "")
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
If $vRange = "-1" Then
$vRange = UBound($aGLVEx_SrcArray) - 2
EndIf
Local $iIndex, $aIndex
If String($vRange) <> "" Then
$aIndex = __GUIListViewEx_ExpandRange($vRange, $iLV_Index, 0)
If @error Then Return SetError(4, 0, 0)
Else
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
If $iIndex == "" Then
Return SetError(2, 0, "")
EndIf
$aIndex = StringSplit($iIndex, $aGLVEx_Data[0][24])
EndIf
For $i = 1 To $aIndex[0]
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, $i, False)
Next
$aGLVEx_Data[0][12] = True
For $i = $aIndex[0] To 1 Step -1
If $aIndex[$i] <= UBound($aGLVEx_SrcArray) - 2 Then
__GUIListViewEx_Array_Delete($aGLVEx_SrcArray, $aIndex[$i] + 1)
__GUIListViewEx_Array_Delete($aCheck_Array, $aIndex[$i] + 1)
__GUIListViewEx_Array_Delete($aGLVEx_SrcColArray, $aIndex[$i] + 1)
EndIf
Next
If $aGLVEx_Data[0][15] Then
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
If $aIndex[1] = 0 Then
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, 0)
Else
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $aIndex[1] - 1)
EndIf
EndIf
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_InsertCol($sTitle = "", $iWidth = 50)
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Local $vRet = _GUIListViewEx_InsertColSpec($iLV_Index, $aGLVEx_Data[0][2] + 1, $sTitle, $iWidth)
Return SetError(@error, 0, $vRet)
EndFunc
Func _GUIListViewEx_InsertColSpec($iLV_Index, $iCol = -1, $sTitle = "", $iWidth = 75)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
Local $fColourEnabled = $aGLVEx_Data[$iLV_Index][19]
Local $fHdrColourEnabled = $aGLVEx_Data[$iLV_Index][24], $aHdrData
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
If $fColourEnabled Then
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Local $aHdrData[4][UBound($aGLVEx_SrcArray, 2)]
If $fHdrColourEnabled Then
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
EndIf
Local $iMax_Col = UBound($aGLVEx_SrcArray, 2) - 1
If $iCol = -1 Then $iCol = $iMax_Col + 1
If $iCol < 0 Or $iCol > $iMax_Col + 1 Then Return SetError(2, 0, "")
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
$aGLVEx_Data[0][12] = True
ReDim $aGLVEx_SrcArray[UBound($aGLVEx_SrcArray)][UBound($aGLVEx_SrcArray, 2) + 1]
If $fColourEnabled Then
ReDim $aGLVEx_SrcColArray[UBound($aGLVEx_SrcColArray)][UBound($aGLVEx_SrcColArray, 2) + 1]
EndIf
For $i = 0 To UBound($aGLVEx_SrcArray) - 1
For $j = UBound($aGLVEx_SrcArray, 2) - 2 To $iCol Step -1
$aGLVEx_SrcArray[$i][$j + 1] = $aGLVEx_SrcArray[$i][$j]
If $fColourEnabled Then
$aGLVEx_SrcColArray[$i][$j + 1] = $aGLVEx_SrcColArray[$i][$j]
EndIf
Next
$aGLVEx_SrcArray[$i][$iCol] = ""
If $fColourEnabled Then
$aGLVEx_SrcColArray[$i][$iCol] = ";"
EndIf
Next
ReDim $aEditable[4][UBound($aEditable, 2) + 1]
ReDim $aHdrData[4][UBound($aHdrData, 2) + 1]
For $i = 0 To 3
For $j = UBound($aEditable, 2) - 2 To $iCol Step -1
$aEditable[$i][$j + 1] = $aEditable[$i][$j]
$aHdrData[$i][$j + 1] = $aHdrData[$i][$j]
Next
$aEditable[$i][$iCol] = ""
Next
$aHdrData[0][$iCol] = $sTitle
$aHdrData[1][$iCol] = ";"
$aHdrData[2][$iCol] = ""
$aHdrData[3][$iCol] = 0
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
If $fColourEnabled Then
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
EndIf
$aGLVEx_Data[$iLV_Index][7] = $aEditable
If $fHdrColourEnabled Then
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
EndIf
_GUICtrlListView_InsertColumn($hGLVEx_SrcHandle, $iCol, $sTitle, $iWidth)
If $aGLVEx_Data[0][15] Then
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
EndIf
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
Local $aLVSortState[_GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)]
$aGLVEx_Data[$iLV_Index][4] = $aLVSortState
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_DeleteCol()
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Local $vRet = _GUIListViewEx_DeleteColSpec($iLV_Index, $aGLVEx_Data[0][2])
Return SetError(@error, 0, $vRet)
EndFunc
Func _GUIListViewEx_DeleteColSpec($iLV_Index, $iCol = -1)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
Local $fColourEnabled = $aGLVEx_Data[$iLV_Index][19]
Local $fHdrColourEnabled = $aGLVEx_Data[$iLV_Index][24]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
If $fColourEnabled Then
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Local $aHdrData[4][UBound($aGLVEx_SrcArray, 2)]
If $fHdrColourEnabled Then
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
EndIf
Local $iMax_Col = UBound($aGLVEx_SrcArray, 2) - 1
If $iCol = -1 Then $iCol = $iMax_Col
If $iCol < 0 Or $iCol > $iMax_Col Then Return SetError(2, 0, "")
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
$aGLVEx_Data[0][12] = True
For $i = 0 To UBound($aGLVEx_SrcArray) - 1
For $j = $iCol To UBound($aGLVEx_SrcArray, 2) - 2
$aGLVEx_SrcArray[$i][$j] = $aGLVEx_SrcArray[$i][$j + 1]
If $fColourEnabled Then
$aGLVEx_SrcColArray[$i][$j] = $aGLVEx_SrcColArray[$i][$j + 1]
EndIf
Next
Next
ReDim $aGLVEx_SrcArray[UBound($aGLVEx_SrcArray)][UBound($aGLVEx_SrcArray, 2) - 1]
If $fColourEnabled Then
ReDim $aGLVEx_SrcColArray[UBound($aGLVEx_SrcColArray)][UBound($aGLVEx_SrcColArray, 2) - 1]
EndIf
For $i = 0 To 3
For $j = $iCol To UBound($aEditable, 2) - 2
$aEditable[$i][$j] = $aEditable[$i][$j + 1]
$aHdrData[$i][$j] = $aHdrData[$i][$j + 1]
Next
Next
ReDim $aEditable[4][UBound($aEditable, 2) - 1]
ReDim $aHdrData[4][UBound($aHdrData, 2) - 1]
_GUICtrlListView_DeleteColumn($hGLVEx_SrcHandle, $iCol)
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
If $fColourEnabled Then
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
EndIf
$aGLVEx_Data[$iLV_Index][7] = $aEditable
If $fHdrColourEnabled Then
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
EndIf
If $aGLVEx_Data[0][15] Then
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
EndIf
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
Local $aLVSortState[_GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)]
$aGLVEx_Data[$iLV_Index][4] = $aLVSortState
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_SortCol($iLV_Index, $iCol = -1)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
Local $aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
Local $iMax_Col = UBound($aGLVEx_SrcArray, 2) - 1
If $iCol = -1 Then
$iCol = $aGLVEx_Data[$iLV_Index][21]
EndIf
If $iCol < 0 Or $iCol > $iMax_Col Then Return SetError(2, 0, 0)
Local $aLVSortState = $aGLVEx_Data[$iLV_Index][4]
__GUIListViewEx_ColSort($aGLVEx_Data[$iLV_Index][0], $iLV_Index, $aLVSortState, $iCol)
Return 1
EndFunc
Func _GUIListViewEx_SetEditStatus($iLV_Index, $vCol, $iMode = 1, $vParam1 = Default, $vParam2 = Default)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then
Return SetError(1, 0, 0)
EndIf
Local $aRange = __GUIListViewEx_ExpandRange($vCol, $iLV_Index)
If @error Then Return SetError(2, 0, 0)
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Switch $iMode
Case 0, 1
If $vParam1 = Default Then $vParam1 = 0
If $vParam2 = Default Then $vParam2 = ""
Switch $vParam1
Case 0
If $vParam2 Then
Return SetError(4, 12, 0)
EndIf
Case 1
If $vParam2 And Not StringRegExp($vParam2, "^\d+\|\d+\|(0|1)$") Then
Return SetError(4, 12, 0)
EndIf
Case Else
Return SetError(4, 11, 0)
EndSwitch
For $i = 1 To $aRange[0]
$aEditable[0][$aRange[$i]] = $iMode
$aEditable[1][$aRange[$i]] = $vParam1
$aEditable[2][$aRange[$i]] = $vParam2
Next
Case 2
If Not (IsArray($vParam1) Or IsString($vParam1)) Then
Return SetError(4, 21, 0)
EndIf
If $vParam2 = Default Then $vParam2 = 0
Switch $vParam2
Case 0 To 3
Case Else
Return SetError(4, 22, 0)
EndSwitch
For $i = 1 To $aRange[0]
$aEditable[0][$aRange[$i]] = 2
$aEditable[1][$aRange[$i]] = $vParam1
$aEditable[2][$aRange[$i]] = $vParam2
Next
Case 3
If $vParam1 = Default Then
$vParam1 = ""
EndIf
If Not StringRegExp($vParam1, "^(\d{4}\/\d{2}\/\d{2})?#?$") Then
Return SetError(4, 31, 0)
EndIf
If $vParam2 = Default Then
$vParam2 = ""
EndIf
For $i = 1 To $aRange[0]
$aEditable[0][$aRange[$i]] = 3
$aEditable[1][$aRange[$i]] = $vParam1
$aEditable[2][$aRange[$i]] = $vParam2
Next
Case 9
If Not IsFunc($vParam1) Then
Return SetError(4, 91, 0)
EndIf
For $i = 1 To $aRange[0]
$aEditable[0][$aRange[$i]] = 9
$aEditable[1][$aRange[$i]] = $vParam1
Next
Case Else
Return SetError(3, 0, 0)
EndSwitch
$aGLVEx_Data[$iLV_Index][7] = $aEditable
Return 1
EndFunc
Func _GUIListViewEx_SetEditKey($sKey = Default)
If $sKey = Default Then
$aGLVEx_Data[0][23] = "08"
Return 1
EndIf
If Not StringRegExp($sKey, "(?i)^([!^]){0,2}([0-9a-f]{2})$") Then
Return SetError(1, 0, 0)
EndIf
$aGLVEx_Data[0][23] = StringReplace(StringReplace($sKey, "^", "11;"), "!", "12;")
Return 1
EndFunc
Func _GUIListViewEx_EditItem($iLV_Index, $iRow, $iCol, $iEditMode = 0, $iDelta_X = 0, $iDelta_Y = 0)
_GUIListViewEx_SetActive($iLV_Index)
If @error Then
Return SetError(1, 0, "")
EndIf
Local $iMax = _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle)
If $iRow < 0 Or $iRow > $iMax - 1 Then
Return SetError(3, 0, "")
EndIf
$iMax = _GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)
If $iCol < 0 Or $iCol > $iMax - 1 Then
Return SetError(4, 0, "")
EndIf
Switch Abs($iEditMode)
Case 0, 11, 12, 13, 21, 22, 23, 31, 32, 33
Case Else
Return SetError(5, 0, "")
EndSwitch
Local $aLocation[2] = [$iRow, $iCol]
Local $aEdited = __GUIListViewEx_EditProcess($iLV_Index, $aLocation, $iDelta_X, $iDelta_Y, $iEditMode, True)
If $aEdited[0][0] = 0 Then
$aEdited = ""
EndIf
Local $iKeyCode = @extended
_WinAPI_GetAsyncKeyState($iKeyCode)
While _WinAPI_GetAsyncKeyState($iKeyCode)
Sleep(10)
WEnd
_GUICtrlListView_SetItemSelected($aGLVEx_Data[$iLV_Index][0], -1, False)
SetExtended(($iKeyCode = 0x0D) ? (True) : (False))
Return $aEdited
EndFunc
Func _GUIListViewEx_EditWidth($iLV_Index, $aWidth)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then
Return SetError(1, 0, 0)
EndIf
If (Not IsArray($aWidth)) Or (UBound($aWidth, 0) <> 1) Then Return SetError(2, 0, 0)
ReDim $aWidth[_GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0])]
$aGLVEx_Data[$iLV_Index][14] = $aWidth
EndFunc
Func _GUIListViewEx_ChangeItem($iLV_Index, $iRow, $iCol, $vValue)
_GUIListViewEx_SetActive($iLV_Index)
If @error Then
Return SetError(1, 0, "")
EndIf
Local $iMax = _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle)
If $iRow < 0 Or $iRow > $iMax - 1 Then
Return SetError(3, 0, "")
EndIf
$iMax = _GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)
If $iCol < 0 Or $iCol > $iMax - 1 Then
Return SetError(4, 0, "")
EndIf
Local $aData_Array = $aGLVEx_Data[$iLV_Index][2]
_GUICtrlListView_SetItemText($hGLVEx_SrcHandle, $iRow, $vValue, $iCol)
$aData_Array[$iRow + 1][$iCol] = $vValue
$aGLVEx_Data[$iLV_Index][2] = $aData_Array
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_LoadHdrData($iLV_Index, $aHdrData)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
If UBound($aHdrData, 0) <> 2 Then
Return SetError(2, 0, 0)
EndIf
If UBound($aHdrData) <> 4 Then
Return SetError(2, 1, 0)
EndIf
If UBound($aHdrData, 2) <> UBound($aGLVEx_Data[$iLV_Index][2], 2) Then
Return SetError(2, 2, 0)
EndIf
Local $sColSet, $aColSplit
For $i = 0 To UBound($aHdrData, 2) - 1
If $aHdrData[0][$i] = Default Then
$aHdrData[0][$i] = ""
EndIf
$sColSet = $aHdrData[1][$i]
If $sColSet = "" Or $sColSet = Default Then
$sColSet = ";"
EndIf
If Not StringRegExp($sColSet, "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$") Then
Return SetError(4, 0, 0)
EndIf
$aColSplit = StringSplit($sColSet, ";")
For $j = 1 To 2
If $aColSplit[$j] And Not $aGLVEx_Data[$iLV_Index][24] Then
Return SetError(3, 0, 0)
Else
$aColSplit[$j] = StringRegExpReplace($aColSplit[$j], "0x(.{2})(.{2})(.{2})", "0x$3$2$1")
EndIf
Next
$aHdrData[1][$i] = $aColSplit[1] & ";" & $aColSplit[2]
If $aHdrData[2][$i] = Default Then
$aHdrData[2][$i] = ""
EndIf
If $aHdrData[3][$i] = Default Then
$aHdrData[3][$i] = _GUICtrlListView_GetColumnWidth($aGLVEx_Data[$iLV_Index][0], $i)
Else
$aHdrData[3][$i] = Abs(Number($aHdrData[3][$i]))
EndIf
Next
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
__GUIListViewEx_RedrawWindow($iLV_Index, True)
Return 1
EndFunc
Func _GUIListViewEx_EditHeader($iLV_Index = Default, $iCol = Default, $iDelta_X = 0, $iDelta_Y = 0)
Local $aRet = ""
If $iLV_Index = Default Then
$iLV_Index = $aGLVEx_Data[0][1]
EndIf
_GUIListViewEx_SetActive($iLV_Index)
If @error Then
Return SetError(1, 0, $aRet)
EndIf
Local $hLV_Handle = $aGLVEx_Data[$iLV_Index][0]
Local $cLV_CID = $aGLVEx_Data[$iLV_Index][1]
If $aGLVEx_Data[$iLV_Index][8] = "" Then
Return SetError(2, 0, $aRet)
EndIf
If $iCol = Default Then
$iCol = $aGLVEx_Data[0][2]
EndIf
Local $iMax = _GUICtrlListView_GetColumnCount($hLV_Handle)
If $iCol < 0 Or $iCol > $iMax - 1 Then
Return SetError(3, 0, $aRet)
EndIf
Local $tLVPos = DllStructCreate("struct;long X;long Y;endstruct")
__GUIListViewEx_GetLVCoords($hLV_Handle, $tLVPos)
Local $aLVClient = WinGetClientSize($hLV_Handle)
Local $aLV_FontDetails = __GUIListViewEx_GetLVFont($hLV_Handle)
WinSetState($hLV_Handle, "", @SW_DISABLE)
Local $aHdrData = $aGLVEx_Data[$iLV_Index][25]
Local $aColData, $sHeaderOrgText
If $aGLVEx_Data[$iLV_Index][24] Then
$sHeaderOrgText = $aHdrData[0][$iCol]
Else
$aColData = _GUICtrlListView_GetColumn($hLV_Handle, $iCol)
$sHeaderOrgText = $aColData[5]
EndIf
Local $aLocation[2] = [0, $iCol]
Local $aEdit_Coords = __GUIListViewEx_EditCoords($hLV_Handle, $cLV_CID, $aLocation, $tLVPos, $aLVClient[0] - 5, $iDelta_X, $iDelta_Y)
Local $hHeader = _GUICtrlListView_GetHeader($hLV_Handle)
Local $aHeader_Pos = WinGetPos($hHeader)
$aEdit_Coords[0] -= 2
$aEdit_Coords[1] -= $aHeader_Pos[3]
$aEdit_Coords[3] = $aHeader_Pos[3]
Local $hCombo, $hTemp_Edit, $hTemp_List, $hTemp_Combo, $sCombo_Data
If $aHdrData[2][$iCol] Then
$sCombo_Data = $aHdrData[2][$iCol]
If StringLeft($sCombo_Data, 1) = @TAB Then
$cGLVEx_EditID = GUICtrlCreateCombo("", $aEdit_Coords[0], $aEdit_Coords[1], $aEdit_Coords[2], $aEdit_Coords[3], 0x00200043)
$sCombo_Data = StringTrimLeft($sCombo_Data, 1)
Else
$cGLVEx_EditID = GUICtrlCreateCombo("", $aEdit_Coords[0], $aEdit_Coords[1], $aEdit_Coords[2], $aEdit_Coords[3], 0x00200042)
EndIf
GUICtrlSetData($cGLVEx_EditID, $sCombo_Data)
$hCombo = GUICtrlGetHandle($cGLVEx_EditID)
Local $tInfo = DllStructCreate("dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" & "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList")
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
_SendMessage($hCombo, 0x164, 0, $tInfo, 0, "wparam", "struct*")
$hTemp_Edit = DllStructGetData($tInfo, "hEdit")
$hTemp_List = DllStructGetData($tInfo, "hList")
$hTemp_Combo = DllStructGetData($tInfo, "hCombo")
Else
$cGLVEx_EditID = GUICtrlCreateEdit($sHeaderOrgText, $aEdit_Coords[0], $aEdit_Coords[1], $aEdit_Coords[2], $aEdit_Coords[3], 0)
$hTemp_Edit = GUICtrlGetHandle($cGLVEx_EditID)
EndIf
GUICtrlSetFont($cGLVEx_EditID, $aLV_FontDetails[0], Default, Default, $aLV_FontDetails[1])
_WinAPI_SetFocus($hTemp_Edit)
If Not $aGLVEx_Data[$iLV_Index][11] Then
GUICtrlSendMsg($cGLVEx_EditID, 0xB1, 0, -1)
EndIf
Local $tMouseClick = DllStructCreate($tagPOINT)
Local $aKeys[2] = [0x0D, 0x1B]
Local $iKey_Code = 0
Local $fCombo_State = False
Local $iOldESC = Opt("GUICloseOnESC", 0)
While 1
If $aGLVEx_Data[0][9] Then
$aGLVEx_Data[0][9] = False
ExitLoop
EndIf
For $i = 0 To 1
_WinAPI_GetAsyncKeyState($aKeys[$i])
If _WinAPI_GetAsyncKeyState($aKeys[$i]) Then
$iKey_Code = $aKeys[$i]
ExitLoop 2
EndIf
Next
If _WinAPI_GetFocus() <> $hTemp_Edit Then
ExitLoop
EndIf
_WinAPI_GetAsyncKeyState(0x01)
If _WinAPI_GetAsyncKeyState(0x01) Then
DllStructSetData($tMouseClick, "x", MouseGetPos(0))
DllStructSetData($tMouseClick, "y", MouseGetPos(1))
Switch _WinAPI_WindowFromPoint($tMouseClick)
Case $hTemp_Combo, $hTemp_Edit, $hTemp_List
Case Else
ExitLoop
EndSwitch
_WinAPI_GetAsyncKeyState(0x01)
While _WinAPI_GetAsyncKeyState(0x01)
Sleep(10)
WEnd
EndIf
If $hCombo Then
Switch _SendMessage($hCombo, 0x157)
Case 0
If $fCombo_State = True Then
If GUICtrlRead($cGLVEx_EditID) = "" Then
$fCombo_State = False
Else
$iKey_Code = 0x0D
ExitLoop
EndIf
EndIf
Case 1
If Not $fCombo_State Then
$fCombo_State = True
EndIf
EndSwitch
EndIf
Sleep(10)
WEnd
Switch $iKey_Code
Case 0x0D
Local $sHeaderNewText = GUICtrlRead($cGLVEx_EditID)
If $sHeaderNewText <> $sHeaderOrgText Then
If $aGLVEx_Data[$iLV_Index][24] Then
$aHdrData[0][$iCol] = $sHeaderNewText
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
Else
_GUICtrlListView_SetColumn($hLV_Handle, $iCol, $sHeaderNewText)
EndIf
Local $aRet[1][3] = [[$iCol, $sHeaderOrgText, $sHeaderNewText]]
EndIf
Case Else
$aRet = ""
EndSwitch
_WinAPI_GetAsyncKeyState($iKey_Code)
While _WinAPI_GetAsyncKeyState($iKey_Code)
Sleep(10)
WEnd
Opt("GUICloseOnESC", $iOldESC)
GUICtrlDelete($cGLVEx_EditID)
WinSetState($hLV_Handle, "", @SW_ENABLE)
Return $aRet
EndFunc
Func _GUIListViewEx_LoadColour($iLV_Index, $aColArray)
Local $sColSet
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
If Not $aGLVEx_Data[$iLV_Index][19] Then
Return SetError(2, 0, 0)
EndIf
If UBound($aColArray, 0) <> 2 Then
Return SetError(3, 0, 0)
EndIf
_ArrayInsert($aColArray, 0)
If (UBound($aColArray) <> UBound($aGLVEx_Data[$iLV_Index][2])) Or (UBound($aColArray, 2) <> UBound($aGLVEx_Data[$iLV_Index][2], 2)) Then
Return SetError(3, 1, 0)
EndIf
For $i = 1 To UBound($aColArray, 1) - 1
For $j = 0 To UBound($aColArray, 2) - 1
$sColSet = $aColArray[$i][$j]
If $sColSet = "" Then
$sColSet = ";"
$aColArray[$i][$j] = ";"
EndIf
If Not StringRegExp($sColSet, "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$") Then
Return SetError(4, 0, 0)
EndIf
$aColArray[$i][$j] = StringRegExpReplace($sColSet, "0x(.{2})(.{2})(.{2})", "0x$3$2$1")
Next
Next
$aGLVEx_Data[$iLV_Index][18] = $aColArray
Return 1
EndFunc
Func _GUIListViewEx_SetDefColours($iLV_Index, $aDefCols)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
If Not ($aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22]) Then Return SetError(2, 0, 0)
If Not IsArray($aDefCols) Or UBound($aDefCols) <> 4 Or UBound($aDefCols, 0) <> 1 Then Return SetError(3, 0, 0)
Local $aCurCols = $aGLVEx_Data[$iLV_Index][23]
Local $sCol
For $i = 0 To 3
If $aDefCols[$i] = Default Then
$aDefCols[$i] = $aGLVEx_DefColours[$i]
ElseIf $aDefCols[$i] = "" Then
$aDefCols[$i] = $aCurCols[$i]
Else
Switch Number($aDefCols[$i])
Case 0 To 0xFFFFFF
$sCol = '0x' & StringMid($aDefCols[$i], 7, 2) & StringMid($aDefCols[$i], 5, 2) & StringMid($aDefCols[$i], 3, 2)
$aDefCols[$i] = $sCol
Case Else
Return SetError(4, 0, 0)
EndSwitch
EndIf
Next
$aGLVEx_Data[$iLV_Index][23] = $aDefCols
__GUIListViewEx_RedrawWindow($iLV_Index, True)
Return 1
EndFunc
Func _GUIListViewEx_SetColour($iLV_Index, $sColSet, $iRow, $iCol)
_GUIListViewEx_SetActive($iLV_Index)
If @error Then
Return SetError(1, 0, 0)
EndIf
If Not $aGLVEx_Data[$iLV_Index][19] Then
Return SetError(2, 0, 0)
EndIf
If $sColSet = "" Then
$sColSet = ";"
EndIf
Local $fDefCol = (($sColSet = ";") ? (True) : (False))
If Not StringRegExp($sColSet, "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$") Then
Return SetError(3, 0, 0)
EndIf
Local $aColArray = $aGLVEx_Data[$iLV_Index][18]
If $iRow < 0 Or $iCol < 0 Or $iRow > UBound($aColArray) - 2 Or $iCol > UBound($aColArray, 2) - 1 Then
Return SetError(4, 0, 0)
EndIf
Local $aCurrSplit = StringSplit($aColArray[$iRow + 1][$iCol], ";")
Local $aNewSplit = StringSplit($sColSet, ";")
For $i = 1 To 2
If $aNewSplit[$i] Then
$aCurrSplit[$i] = '0x' & StringMid($aNewSplit[$i], 7, 2) & StringMid($aNewSplit[$i], 5, 2) & StringMid($aNewSplit[$i], 3, 2)
EndIf
If $fDefCol Then
$aCurrSplit[$i] = ""
EndIf
Next
$aColArray[$iRow + 1][$iCol] = $aCurrSplit[1] & ";" & $aCurrSplit[2]
$aGLVEx_Data[$iLV_Index][18] = $aColArray
$aGLVEx_Data[0][14] = 0
_GUICtrlListView_RedrawItems($aGLVEx_Data[$iLV_Index][0], $iRow, $iRow)
Return 1
EndFunc
Func _GUIListViewEx_BlockReDraw($iLV_Index, $bMode)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then
Return SetError(1, 0, 0)
EndIf
Switch $bMode
Case True
$aGLVEx_Data[0][15] = False
Case False
$aGLVEx_Data[0][15] = True
Local $aData_Array = $aGLVEx_Data[$iLV_Index][2]
Local $aCheck_Array[UBound($aData_Array)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
__GUIListViewEx_ReWriteLV($aGLVEx_Data[$iLV_Index][0], $aData_Array, $aCheck_Array, $iLV_Index, $aGLVEx_Data[$iLV_Index][6])
Case Else
Return SetError(2, 0, 0)
EndSwitch
Return 1
EndFunc
Func _GUIListViewEx_UserSort($iLV_Index, $vCol, $hFunc = -1)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then
Return SetError(1, 0, 0)
EndIf
If Not (IsArray($aGLVEx_Data[$iLV_Index][4])) Then
Return SetError(2, 0, 0)
EndIf
Local $aRange = __GUIListViewEx_ExpandRange($vCol, $iLV_Index)
If @error Then Return SetError(3, 0, 0)
If Not ($hFunc = -1) And Not (IsFunc($hFunc)) Then
Return SetError(4, 0, 0)
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
For $i = 1 To $aRange[0]
$aEditable[3][$aRange[$i]] = $hFunc
Next
$aGLVEx_Data[$iLV_Index][7] = $aEditable
Return 1
EndFunc
Func _GUIListViewEx_GetLastSelItem($iLV_Index = 0)
Switch $iLV_Index
Case 1 To $aGLVEx_Data[0][0]
Case 0, Default
$iLV_Index = _GUIListViewEx_GetActive()
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Case Else
Return SetError(2, 0, "")
EndSwitch
Local $iRow = $aGLVEx_Data[$iLV_Index][20]
Local $iCol = $aGLVEx_Data[$iLV_Index][21]
If $iRow = -1 Or $iCol = -1 Then Return SetError(3, 0, "")
Return $iLV_Index & "|" & $iRow & "|" & $iCol
EndFunc
Func _GUIListViewEx_ContextPos()
Local $aPos[3] = [$aGLVEx_Data[0][1], $aGLVEx_Data[0][10], $aGLVEx_Data[0][11]]
Return $aPos
EndFunc
Func _GUIListViewEx_ToolTipInit($iLV_Index, $vRange, $iTime = 1000, $iMode = 1)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
Local $aRange = __GUIListViewEx_ExpandRange($vRange, $iLV_Index)
If @error Then Return SetError(2, 0, 0)
If Not IsInt($iTime) Then Return SetError(3, 0, 0)
$aGLVEx_Data[$iLV_Index][15] = $aRange
$aGLVEx_Data[$iLV_Index][16] = $iTime
$aGLVEx_Data[$iLV_Index][17] = $iMode
Return 1
EndFunc
Func _GUIListViewEx_EventMonitor($iEditMode = 0, $iDelta_X = 0, $iDelta_Y = 0)
Local $aRet, $vRet, $iLV_Index, $iError
If $fGLVEx_EditClickFlag <> 0 Then
$iLV_Index = $fGLVEx_EditClickFlag
$aGLVEx_Data[0][1] = $iLV_Index
$fGLVEx_EditClickFlag = 0
Switch Abs($iEditMode)
Case 0, 01, 02, 03, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33
Case Else
Return SetError(1, 0, "")
EndSwitch
Local $aLocation[2] = [$aGLVEx_Data[0][17], $aGLVEx_Data[0][18]]
If $aLocation[0] = -1 Then
Return SetError(2, 0, "")
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
If $aLocation[1] = -1 Then
For $i = 0 To UBound($aEditable, 2) - 1
If $aEditable[0][$i] <> 0 Then
$aLocation[1] = $i
$aGLVEx_Data[0][18] = $i
ExitLoop
EndIf
Next
EndIf
Switch $aEditable[0][$aLocation[1]]
Case 0
Return SetError(3, 0, "")
Case 9
Local $hUserFunction = $aEditable[1][$aLocation[1]]
$vRet = $hUserFunction($hGLVEx_SrcHandle, $iLV_Index, $aLocation[0], $aLocation[1])
Return SetError(@error, @extended, $vRet)
Case Else
$aRet = __GUIListViewEx_EditProcess($iLV_Index, $aLocation, $iDelta_X, $iDelta_Y, $iEditMode)
$iError = @error
If IsArray($aRet) And $aRet[0][0] Then
Return SetError($iError, 1, $aRet)
Else
Return SetError($iError, 1, "")
EndIf
EndSwitch
EndIf
If $fGLVEx_HeaderEdit Then
$fGLVEx_HeaderEdit = False
_WinAPI_GetAsyncKeyState(0x01)
While _WinAPI_GetAsyncKeyState(0x01) Or _WinAPI_GetAsyncKeyState(0x11)
Sleep(10)
WEnd
$aRet = _GUIListViewEx_EditHeader()
$iError = @error
If IsArray($aRet) Then
Return SetError($iError, 2, $aRet)
Else
Return SetError($iError, 2, "")
EndIf
EndIf
If $aGLVEx_Data[0][19] Then
$vRet = $aGLVEx_Data[0][19]
$aGLVEx_Data[0][19] = ""
If $aGLVEx_Data[0][22] = 1 Then
__GUIListViewEx_RedrawWindow($vRet, True)
$aGLVEx_Data[0][22] = 0
EndIf
Return SetError(0, 3, $vRet)
EndIf
If $sGLVEx_DragEvent Then
$vRet = $sGLVEx_DragEvent
$sGLVEx_DragEvent = ""
If $aGLVEx_Data[0][22] Then
Local $aIndex = StringSplit($vRet, ":")
__GUIListViewEx_RedrawWindow($aIndex[1], True)
If $aIndex[2] <> $aIndex[1] Then
__GUIListViewEx_RedrawWindow($aIndex[2], True)
EndIf
$aGLVEx_Data[0][22] = 0
EndIf
Return SetError(0, 4, $vRet)
EndIf
Local $iMode = $aGLVEx_Data[$aGLVEx_Data[0][1]][17]
If $iMode Then
$iLV_Index = $aGLVEx_Data[0][1]
Local $fToolTipCol = False
If $aGLVEx_Data[$iLV_Index][21] Then
$aGLVEx_Data[0][4] = $aGLVEx_Data[0][17]
$aGLVEx_Data[0][5] = $aGLVEx_Data[0][18]
EndIf
If $aGLVEx_Data[0][4] <> $aGLVEx_Data[0][6] Or $aGLVEx_Data[0][5] <> $aGLVEx_Data[0][7] Then
If $aGLVEx_Data[$iLV_Index][15] = "*" Then
$fToolTipCol = True
Else
If IsArray($aGLVEx_Data[$iLV_Index][15]) Then
Local $vRange = $aGLVEx_Data[$iLV_Index][15]
For $i = 1 To $vRange[0]
If $aGLVEx_Data[0][2] = $vRange[$i] Then
$fToolTipCol = True
ExitLoop
EndIf
Next
EndIf
EndIf
EndIf
If $fToolTipCol Then
Local $aItemText = _GUICtrlListView_GetItemTextArray($aGLVEx_Data[$iLV_Index][0], $aGLVEx_Data[0][4])
If Not @error Then
Local $sText
Switch $iMode
Case 1
$sText = $aItemText[$aGLVEx_Data[0][5] + 1]
Case 2
$sText = $aItemText[1]
EndSwitch
ToolTip($sText)
AdlibRegister("__GUIListViewEx_ToolTipHide", $aGLVEx_Data[$iLV_Index][16])
$aGLVEx_Data[0][6] = $aGLVEx_Data[0][4]
$aGLVEx_Data[0][7] = $aGLVEx_Data[0][5]
EndIf
EndIf
EndIf
If $fGLVEx_SelChangeFlag Then
Local $aRetArray[3] = [$fGLVEx_SelChangeFlag, $aGLVEx_Data[0][17], $aGLVEx_Data[0][18]]
$fGLVEx_SelChangeFlag = 0
If $fGLVEx_UserSelFlag Then
$fGLVEx_UserSelFlag = 0
Return SetError(0, 9, $aRetArray)
EndIf
EndIf
Return SetError(0, 0, "")
EndFunc
Func _GUIListViewEx_MsgRegister($fNOTIFY = True, $fMOUSEMOVE = True, $fLBUTTONUP = True, $fSYSCOMMAND = True)
If $fNOTIFY Then GUIRegisterMsg(0x004E, "_GUIListViewEx_WM_NOTIFY_Handler")
If $fMOUSEMOVE Then GUIRegisterMsg(0x0200, "_GUIListViewEx_WM_MOUSEMOVE_Handler")
If $fLBUTTONUP Then GUIRegisterMsg(0x0202, "_GUIListViewEx_WM_LBUTTONUP_Handler")
If $fSYSCOMMAND Then GUIRegisterMsg(0x0112, "_GUIListViewEx_WM_SYSCOMMAND_Handler")
EndFunc
Func _GUIListViewEx_WM_NOTIFY_Handler($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam
Local $dwDrawStage, $iCol, $aHdrData
Local $tStruct = DllStructCreate("hwnd;uint_ptr;int_ptr;int;int", $lParam)
If @error Then Return
Local $hLV = DllStructGetData($tStruct, 1)
Local $iItem = DllStructGetData($tStruct, 4)
Local $iCode = BitAND(DllStructGetData($tStruct, 3), 0xFFFFFFFF)
If $iCode = -12 Then
If $aGLVEx_Data[0][12] Then Return
For $iLV_Index = 1 To $aGLVEx_Data[0][0]
If $aGLVEx_Data[$iLV_Index][0] = DllStructGetData($tStruct, 1) Then
ExitLoop
EndIf
Next
If $iLV_Index <= $aGLVEx_Data[0][0] Then
Local Static $aDefCols = $aGLVEx_DefColours
If $aGLVEx_Data[0][14] <> DllStructGetData($tStruct, 1) Then
$aGLVEx_Data[0][14] = DllStructGetData($tStruct, 1)
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$aGLVEx_Data[0][13] = $aGLVEx_Data[$iLV_Index][18]
$aDefCols = $aGLVEx_Data[$iLV_Index][23]
EndIf
EndIf
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
Local $tNMLVCUSTOMDRAW = DllStructCreate($tagNMLVCUSTOMDRAW, $lParam)
$dwDrawStage = DllStructGetData($tNMLVCUSTOMDRAW, "dwDrawStage")
Switch $dwDrawStage
Case 1
Return 32
Case 65537
Return 32
Case 196609
$iItem = DllStructGetData($tNMLVCUSTOMDRAW, "dwItemSpec")
Local $iSubItem = DllStructGetData($tNMLVCUSTOMDRAW, "iSubItem")
Local $bSelColour = False
If $iItem = $aGLVEx_Data[$iLV_Index][20] Then
If $aGLVEx_Data[$iLV_Index][22] Then
If $iSubItem = $aGLVEx_Data[$iLV_Index][21] Then
$bSelColour = True
EndIf
Else
$bSelColour = True
EndIf
EndIf
Local $iTextColour = $aDefCols[0]
Local $iBackColour = $aDefCols[1]
If $bSelColour Then
$iTextColour = $aDefCols[2]
$iBackColour = $aDefCols[3]
Else
If $aGLVEx_Data[$iLV_Index][19] Then
If StringInStr(($aGLVEx_Data[0][13])[$iItem + 1][$iSubItem], ";") Then
Local $aSplitColour = StringSplit(($aGLVEx_Data[0][13])[$iItem + 1][$iSubItem], ";")
If $aSplitColour[1] Then $iTextColour = $aSplitColour[1]
If $aSplitColour[2] Then $iBackColour = $aSplitColour[2]
EndIf
EndIf
EndIf
DllStructSetData($tNMLVCUSTOMDRAW, "ClrText", $iTextColour)
DllStructSetData($tNMLVCUSTOMDRAW, "ClrTextBk", $iBackColour)
Return 2
EndSwitch
EndIf
Else
For $iLV_Index = 1 To $aGLVEx_Data[0][0]
If DllStructGetData($tStruct, 1) = $aGLVEx_Data[$iLV_Index][24] Then
ExitLoop
EndIf
Next
If $iLV_Index <= $aGLVEx_Data[0][0] Then
Local $tNMCustomDraw = DllStructCreate($tagNMLVCUSTOMDRAW, $lParam)
Local $hDC = DllStructGetData($tNMCustomDraw, "hdc")
If $aGLVEx_Data[0][20] <> DllStructGetData($tStruct, 1) Then
$aGLVEx_Data[0][20] = DllStructGetData($tStruct, 1)
Local $hFont = _SendMessage(DllStructGetData($tStruct, 1), 0x0031)
Local $hObject = _WinAPI_SelectObject($hDC, $hFont)
Local $tLogFont = DllStructCreate($tagLOGFONT)
_WinAPI_GetObject($hFont, DllStructGetSize($tLogFont), DllStructGetPtr($tLogFont))
_WinAPI_SelectObject($hDC, $hObject)
_WinAPI_ReleaseDC(DllStructGetData($tStruct, 1), $hDC)
DllStructSetData($tLogFont, "Weight", 600)
$aGLVEx_Data[0][21] = _WinAPI_CreateFontIndirect($tLogFont)
EndIf
$dwDrawStage = DllStructGetData($tNMCustomDraw, "dwDrawStage")
Switch $dwDrawStage
Case 1
Return 32
Case 65537
Return 0x00000010
Case 0x00010002
Local $iColumnIndex = DllStructGetData($tNMCustomDraw, "dwItemSpec")
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
Local $aColSplit = StringSplit($aHdrData[1][$iColumnIndex], ";")
Local $aHdrDefCols = $aGLVEx_Data[$iLV_Index][23]
Local $iHdrTextColour, $iHdrBackColour
If $aColSplit[1] == "" Then
$iHdrTextColour = $aHdrDefCols[0]
Else
$iHdrTextColour = $aColSplit[1]
EndIf
If $aColSplit[2] == "" Then
$iHdrBackColour = $aHdrDefCols[1]
Else
$iHdrBackColour = $aColSplit[2]
EndIf
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, DllStructGetData($tNMCustomDraw, 6) + 1)
DllStructSetData($tRECT, 2, DllStructGetData($tNMCustomDraw, 7) + 1)
DllStructSetData($tRECT, 3, DllStructGetData($tNMCustomDraw, 8) - 2)
DllStructSetData($tRECT, 4, DllStructGetData($tNMCustomDraw, 9) - 2)
_WinAPI_SetBkMode($hDC, 1)
_WinAPI_SelectObject($hDC, $aGLVEx_Data[0][21])
_WinAPI_SetTextColor($hDC, $iHdrTextColour)
Local $hBrush = _WinAPI_CreateSolidBrush($iHdrBackColour)
_WinAPI_FillRect($hDC, $tRECT, $hBrush)
If $iColumnIndex < _GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0]) Then
Local $aRet = _GUICtrlListView_GetColumn($aGLVEx_Data[$iLV_Index][0], $iColumnIndex)
Local $iColAlign = 2 * $aRet[0]
_WinAPI_DrawText($hDC, $aHdrData[0][$iColumnIndex], $tRECT, $iColAlign)
EndIf
Return 2
EndSwitch
EndIf
EndIf
Else
Local $fEditHotKey = False
For $iLV_Index = 1 To $aGLVEx_Data[0][0]
If $aGLVEx_Data[$iLV_Index][0] = DllStructGetData($tStruct, 1) Then
ExitLoop
EndIf
Next
Local $iRow
If $iLV_Index <= $aGLVEx_Data[0][0] Then
If $iLV_Index <> $aGLVEx_Data[0][1] Then
$aGLVEx_Data[0][1] = $iLV_Index
$aGLVEx_Data[0][17] = $aGLVEx_Data[$iLV_Index][20]
$aGLVEx_Data[0][18] = $aGLVEx_Data[$iLV_Index][21]
EndIf
Switch $iCode
Case $LVN_BEGINSCROLL
If $cGLVEx_EditID <> 9999 Then
GUICtrlDelete($cGLVEx_EditID)
$cGLVEx_EditID = 9999
WinSetState($hGLVEx_Editing, "", @SW_ENABLE)
EndIf
Case $LVN_BEGINDRAG
If Not BitAND($aGLVEx_Data[$iLV_Index][12], 8) Then
$aGLVEx_Data[0][1] = $iLV_Index
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
$iGLVEx_SrcIndex = $iLV_Index
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$hGLVEx_TgtHandle = $hGLVEx_SrcHandle
$cGLVEx_TgtID = $cGLVEx_SrcID
$iGLVEx_TgtIndex = $iGLVEx_SrcIndex
$aGLVEx_TgtArray = $aGLVEx_SrcArray
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
Local $fImage = $aGLVEx_Data[$iLV_Index][5]
If $cGLVEx_SrcID Then
GUICtrlSetState($cGLVEx_SrcID, 256)
Else
_WinAPI_SetFocus($hGLVEx_SrcHandle)
EndIf
$iGLVEx_DraggedIndex = DllStructGetData($tStruct, 4)
$iGLVEx_Dragging = 1
Local $iIndex
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
If StringInStr($iIndex, $iGLVEx_DraggedIndex) And StringInStr($iIndex, "|") Then
Local $aIndex = StringSplit($iIndex, "|")
For $i = 1 To $aIndex[0]
If $aIndex[$i] = $iGLVEx_DraggedIndex Then ExitLoop
Next
If $i <> 1 Then
For $j = $i - 1 To 1 Step -1
If $aIndex[$j] <> $aIndex[$j + 1] - 1 Then ExitLoop
$iGLVEx_DraggedIndex -= 1
$iGLVEx_Dragging += 1
Next
EndIf
If $i <> $aIndex[0] Then
For $j = $i + 1 To $aIndex[0]
If $aIndex[$j] <> $aIndex[$j - 1] + 1 Then ExitLoop
$iGLVEx_Dragging += 1
Next
EndIf
Else
$iGLVEx_Dragging = 1
EndIf
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, -1, False)
If $fImage Then
Local $aImageData = _GUICtrlListView_CreateDragImage($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex)
$hGLVEx_DraggedImage = $aImageData[0]
_GUIImageList_BeginDrag($hGLVEx_DraggedImage, 0, 0, 0)
EndIf
EndIf
Case $LVN_COLUMNCLICK, -2
$aGLVEx_Data[0][1] = $iLV_Index
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
$iRow = DllStructGetData($tStruct, 4)
$aGLVEx_Data[0][4] = $iRow
$aGLVEx_Data[0][17] = $iRow
$aGLVEx_Data[$iLV_Index][20] = $iRow
$iCol = DllStructGetData($tStruct, 5)
$aGLVEx_Data[0][2] = $iCol
$aGLVEx_Data[0][5] = $iCol
$aGLVEx_Data[0][18] = $iCol
$aGLVEx_Data[$iLV_Index][21] = $iCol
If $iCode = $LVN_COLUMNCLICK Then
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Local $aRect = _GUICtrlListView_GetSubItemRect($hGLVEx_SrcHandle, 0, $iCol)
Local $aLV_Pos = WinGetPos($hGLVEx_SrcHandle)
If $aRect[0] < 0 Or $aRect[2] > $aLV_Pos[2] - $aGLVEx_Data[0][8] Then
_GUICtrlListView_Scroll($hGLVEx_SrcHandle, $aRect[0], 0)
EndIf
_WinAPI_GetAsyncKeyState(0x11)
If _WinAPI_GetAsyncKeyState(0x11) Then
If $aEditable[0][$iCol] Then
$fGLVEx_HeaderEdit = True
EndIf
Else
If IsArray($aGLVEx_Data[$iLV_Index][4]) Then
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
Local $aLVSortState = $aGLVEx_Data[$iLV_Index][4]
__GUIListViewEx_ColSort($hGLVEx_SrcHandle, $iLV_Index, $aLVSortState, $iCol, $aEditable[3][$iCol])
$aGLVEx_Data[$iLV_Index][4] = $aLVSortState
Local $iDim2 = UBound($aGLVEx_SrcArray, 2) - 1
For $j = 1 To $aGLVEx_SrcArray[0][0]
For $k = 0 To $iDim2
$aGLVEx_SrcArray[$j][$k] = _GUICtrlListView_GetItemText($hGLVEx_SrcHandle, $j - 1, $k)
Next
Next
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_SrcArray = 0
EndIf
EndIf
Else
$fGLVEx_UserSelFlag = 1
EndIf
Case $LVN_KEYDOWN
Local $tKey = DllStructCreate($tagNMHDR & ";WORD KeyCode", $lParam)
$aGLVEx_Data[0][16] = DllStructGetData($tKey, "KeyCode")
If __GUIListViewEx_CheckUserEditKey() Then
$fEditHotKey = True
ContinueCase
EndIf
If $aGLVEx_Data[$iLV_Index][22] Then
_GUICtrlListView_SetItemSelected($hLV, $aGLVEx_Data[0][17], False)
Switch $aGLVEx_Data[0][16]
Case 37
If $aGLVEx_Data[0][18] > 0 Then $aGLVEx_Data[0][18] -= 1
$aGLVEx_Data[$iLV_Index][21] = $aGLVEx_Data[0][18]
_GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
$fGLVEx_UserSelFlag = 1
$fGLVEx_SelChangeFlag = $iLV_Index
Case 39
If $aGLVEx_Data[0][18] < _GUICtrlListView_GetColumnCount($hLV) - 1 Then $aGLVEx_Data[0][18] += 1
$aGLVEx_Data[$iLV_Index][21] = $aGLVEx_Data[0][18]
_GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
$fGLVEx_UserSelFlag = 1
$fGLVEx_SelChangeFlag = $iLV_Index
EndSwitch
EndIf
Case -3
$aGLVEx_Data[0][1] = $iLV_Index
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
If Not $fEditHotKey Then
$iRow = DllStructGetData($tStruct, 4)
$aGLVEx_Data[0][17] = $iRow
$aGLVEx_Data[$iLV_Index][20] = $iRow
$iCol = DllStructGetData($tStruct, 5)
$aGLVEx_Data[0][18] = $iCol
$aGLVEx_Data[$iLV_Index][21] = $iCol
EndIf
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$fGLVEx_EditClickFlag = $iLV_Index
Case $LVN_ITEMCHANGED
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
_GUICtrlListView_SetItemSelected($hLV, $iItem, False)
EndIf
If $aGLVEx_Data[0][16] <> 0 Then
Switch $aGLVEx_Data[0][16]
Case 38
If $aGLVEx_Data[0][17] > 0 Then $aGLVEx_Data[0][17] -= 1
$aGLVEx_Data[$iLV_Index][20] = $aGLVEx_Data[0][17]
$fGLVEx_UserSelFlag = 1
Case 40
If $aGLVEx_Data[0][17] < _GUICtrlListView_GetItemCount($hLV) - 1 Then $aGLVEx_Data[0][17] += 1
$aGLVEx_Data[$iLV_Index][20] = $aGLVEx_Data[0][17]
$fGLVEx_UserSelFlag = 1
EndSwitch
$aGLVEx_Data[0][16] = 0
Else
_WinAPI_GetAsyncKeyState(0x01)
If _WinAPI_GetAsyncKeyState(0x01) Then
Local $aMPos = MouseGetPos()
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", $aMPos[0])
DllStructSetData($tPoint, "Y", $aMPos[1])
_WinAPI_ScreenToClient($hLV, $tPoint)
Local $aCurPos[2] = [DllStructGetData($tPoint, "X"), DllStructGetData($tPoint, "Y")]
Local $aHitTest = _GUICtrlListView_SubItemHitTest($hLV, $aCurPos[0], $aCurPos[1])
If $aHitTest[0] > -1 And $aHitTest[1] > -1 And $aHitTest[0] = $iItem Then
If $aGLVEx_Data[0][17] <> $iItem Then _GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
$aGLVEx_Data[0][17] = $aHitTest[0]
$aGLVEx_Data[0][18] = $aHitTest[1]
$aGLVEx_Data[$iLV_Index][20] = $aGLVEx_Data[0][17]
$aGLVEx_Data[$iLV_Index][21] = $aGLVEx_Data[0][18]
_GUICtrlListView_RedrawItems($hLV, $iItem, $iItem)
EndIf
$fGLVEx_UserSelFlag = 1
EndIf
EndIf
$fGLVEx_SelChangeFlag = $iLV_Index
Case -5
$aGLVEx_Data[0][1] = $iLV_Index
$aGLVEx_Data[0][10] = DllStructGetData($tStruct, 4)
$aGLVEx_Data[0][11] = DllStructGetData($tStruct, 5)
_GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
$aGLVEx_Data[0][17] = DllStructGetData($tStruct, 4)
$aGLVEx_Data[0][18] = DllStructGetData($tStruct, 5)
$aGLVEx_Data[$iLV_Index][20] = $aGLVEx_Data[0][17]
$aGLVEx_Data[$iLV_Index][21] = $aGLVEx_Data[0][18]
_GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
EndSwitch
Else
For $iLV_Index = 1 To $aGLVEx_Data[0][0]
If DllStructGetData($tStruct, 1) = _GUICtrlListView_GetHeader($aGLVEx_Data[$iLV_Index][0]) Then
ExitLoop
EndIf
Next
If $iLV_Index <= $aGLVEx_Data[0][0] Then
Local $tNMHEADER = DllStructCreate($tagNMHEADER, $lParam)
$iCol = DllStructGetData($tNMHEADER, "Item")
Switch $iCol
Case 0 To _GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0]) - 1
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
If IsArray($aHdrData) And UBound($aHdrData, 2) Then
Local $iHdrResize = $aHdrData[3][$iCol]
Switch $iCode
Case -306, -326
If $iHdrResize Then
Return True
Else
Return False
EndIf
Case -305, -325
If $iHdrResize Then
_GUICtrlListView_SetColumnWidth($aGLVEx_Data[$iLV_Index][0], $iCol, $iHdrResize)
_WinAPI_RedrawWindow(DllStructGetData($tStruct, 1))
EndIf
EndSwitch
EndIf
EndSwitch
EndIf
EndIf
EndIf
EndFunc
Func _GUIListViewEx_WM_MOUSEMOVE_Handler($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam
Local $iVertScroll
If $iGLVEx_Dragging = 0 Then
Return "GUI_RUNDEFMSG"
EndIf
If $aGLVEx_Data[$aGLVEx_Data[0][1]][10] Then
$iVertScroll = $aGLVEx_Data[$aGLVEx_Data[0][1]][10]
Else
Local $aRect = _GUICtrlListView_GetItemRect($hGLVEx_SrcHandle, 0)
$iVertScroll = $aRect[3] - $aRect[1]
EndIf
Local $hCurrent_Wnd = __GUIListViewEx_GetCursorWnd()
If $hCurrent_Wnd <> $hGLVEx_TgtHandle Then
If BitAND($aGLVEx_Data[$iGLVEx_TgtIndex][12], 1) Then
Return "GUI_RUNDEFMSG"
EndIf
For $i = 1 To $aGLVEx_Data[0][0]
If $aGLVEx_Data[$i][0] = $hCurrent_Wnd Then
If BitAND($aGLVEx_Data[$i][12], 2) Then
Return "GUI_RUNDEFMSG"
EndIf
If _GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle) = _GUICtrlListView_GetColumnCount($hCurrent_Wnd) Then
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, -1, True)
$hGLVEx_TgtHandle = $hCurrent_Wnd
$cGLVEx_TgtID = $aGLVEx_Data[$i][1]
$iGLVEx_TgtIndex = $i
$aGLVEx_TgtArray = $aGLVEx_Data[$i][2]
$aGLVEx_Data[0][3] = $aGLVEx_Data[$i][10]
ExitLoop
EndIf
EndIf
Next
EndIf
Local $iCurr_Y = BitShift($lParam, 16)
If $iGLVEx_InsertIndex <> -1 Then
If $iGLVEx_LastY = $iCurr_Y Then
Return "GUI_RUNDEFMSG"
ElseIf $iGLVEx_LastY > $iCurr_Y Then
$fGLVEx_BarUnder = False
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, $iGLVEx_InsertIndex, False)
Else
$fGLVEx_BarUnder = True
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, $iGLVEx_InsertIndex, True)
EndIf
EndIf
$iGLVEx_LastY = $iCurr_Y
Local $aLVHit = _GUICtrlListView_HitTest($hGLVEx_TgtHandle)
Local $iCurr_Index = $aLVHit[0]
If $iCurr_Index = -1 Then
If $fGLVEx_BarUnder Then
_GUICtrlListView_Scroll($hGLVEx_TgtHandle, 0, $iVertScroll)
Else
_GUICtrlListView_Scroll($hGLVEx_TgtHandle, 0, -$iVertScroll)
EndIf
Sleep(10)
EndIf
If $iGLVEx_InsertIndex <> $iCurr_Index Then
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, $iCurr_Index, $fGLVEx_BarUnder)
$iGLVEx_InsertIndex = $iCurr_Index
EndIf
Return "GUI_RUNDEFMSG"
EndFunc
Func _GUIListViewEx_WM_LBUTTONUP_Handler($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam, $lParam
If Not $iGLVEx_Dragging Then
Return "GUI_RUNDEFMSG"
EndIf
Local $iMultipleItems = $iGLVEx_Dragging - 1
$iGLVEx_Dragging = 0
If $iGLVEx_InsertIndex = -1 Then
$iGLVEx_InsertIndex = _GUICtrlListView_GetItemCount($hGLVEx_TgtHandle) - 1
EndIf
Local $hCurrent_Wnd = __GUIListViewEx_GetCursorWnd()
If $hCurrent_Wnd <> $hGLVEx_TgtHandle Then
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, -1, True)
For $i = 0 To $iMultipleItems
__GUIListViewEx_HighLight($hGLVEx_TgtHandle, $cGLVEx_TgtID, $iGLVEx_DraggedIndex + $i)
Next
$aGLVEx_SrcArray = 0
$aGLVEx_TgtArray = 0
Return
EndIf
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, -1, True)
If $hGLVEx_DraggedImage Then
_GUIImageList_DragLeave($hGLVEx_SrcHandle)
_GUIImageList_EndDrag()
_GUIImageList_Destroy($hGLVEx_DraggedImage)
$hGLVEx_DraggedImage = 0
EndIf
If $hGLVEx_SrcHandle = $hGLVEx_TgtHandle Then
If $fGLVEx_BarUnder Then
If $iGLVEx_DraggedIndex > $iGLVEx_InsertIndex Then $iGLVEx_InsertIndex += 1
Else
If $iGLVEx_DraggedIndex < $iGLVEx_InsertIndex Then $iGLVEx_InsertIndex -= 1
EndIf
Switch $iGLVEx_InsertIndex
Case $iGLVEx_DraggedIndex To $iGLVEx_DraggedIndex + $iMultipleItems
For $i = 0 To $iMultipleItems
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVEx_DraggedIndex + $i)
Next
$aGLVEx_SrcArray = 0
$aGLVEx_TgtArray = 0
Return
EndSwitch
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
Local $aCheckDrag_Array[$iMultipleItems + 1]
$aGLVEx_SrcColArray = $aGLVEx_Data[$iGLVEx_SrcIndex][18]
Local $bUserCol = ((IsArray($aGLVEx_SrcColArray)) ? (True) : (False))
If $iMultipleItems Then
Local $aInsertData[$iMultipleItems + 1]
Local $aColData[$iMultipleItems + 1]
Local $aItemData[UBound($aGLVEx_SrcArray, 2)]
For $i = 0 To $iMultipleItems
For $j = 0 To UBound($aGLVEx_SrcArray, 2) - 1
$aItemData[$j] = $aGLVEx_SrcArray[$iGLVEx_DraggedIndex + 1 + $i][$j]
Next
$aInsertData[$i] = $aItemData
If $bUserCol Then
For $j = 0 To UBound($aGLVEx_SrcColArray, 2) - 1
$aItemData[$j] = $aGLVEx_SrcColArray[$iGLVEx_DraggedIndex + 1 + $i][$j]
Next
$aColData[$i] = $aItemData
EndIf
$aCheckDrag_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex + $i)
Next
Else
Local $aInsertData[1]
Local $aColData[1]
Local $aItemData[UBound($aGLVEx_SrcArray, 2)]
For $i = 0 To UBound($aGLVEx_SrcArray, 2) - 1
$aItemData[$i] = $aGLVEx_SrcArray[$iGLVEx_DraggedIndex + 1][$i]
Next
$aInsertData[0] = $aItemData
If $bUserCol Then
For $i = 0 To UBound($aGLVEx_SrcColArray, 2) - 1
$aItemData[$i] = $aGLVEx_SrcColArray[$iGLVEx_DraggedIndex + 1][$i]
Next
$aColData[0] = $aItemData
EndIf
$aCheckDrag_Array[0] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex)
EndIf
$aGLVEx_Data[0][12] = True
For $i = 0 To $iMultipleItems
__GUIListViewEx_Array_Delete($aGLVEx_SrcArray, $iGLVEx_DraggedIndex + 1)
__GUIListViewEx_Array_Delete($aCheck_Array, $iGLVEx_DraggedIndex + 1)
If $bUserCol Then __GUIListViewEx_Array_Delete($aGLVEx_SrcColArray, $iGLVEx_DraggedIndex + 1)
Next
If $iGLVEx_DraggedIndex < $iGLVEx_InsertIndex Then
$iGLVEx_InsertIndex -= $iMultipleItems
EndIf
For $i = $iMultipleItems To 0 Step -1
__GUIListViewEx_Array_Insert($aGLVEx_SrcArray, $iGLVEx_InsertIndex + 1, $aInsertData[$i])
__GUIListViewEx_Array_Insert($aCheck_Array, $iGLVEx_InsertIndex + 1, $aCheckDrag_Array[$i])
If $bUserCol Then __GUIListViewEx_Array_Insert($aGLVEx_SrcColArray, $iGLVEx_InsertIndex + 1, $aColData[$i], False, False)
Next
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iGLVEx_SrcIndex)
For $i = 0 To $iMultipleItems
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVEx_InsertIndex + $i)
Next
$aGLVEx_Data[$aGLVEx_Data[0][1]][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iGLVEx_SrcIndex][18] = $aGLVEx_SrcColArray
Else
Local $bCheckbox = (($aGLVEx_Data[$iGLVEx_SrcIndex][6] And $aGLVEx_Data[$iGLVEx_TgtIndex][6]) ? (True) : (False))
If $fGLVEx_BarUnder Then
$iGLVEx_InsertIndex += 1
EndIf
$aGLVEx_SrcColArray = $aGLVEx_Data[$iGLVEx_SrcIndex][18]
Local $bUserColSrc = ((IsArray($aGLVEx_SrcColArray)) ? (True) : (False))
$aGLVEx_TgtColArray = $aGLVEx_Data[$iGLVEx_TgtIndex][18]
Local $bUserColTgt = ((IsArray($aGLVEx_TgtColArray)) ? (True) : (False))
Local $aCheck_SrcArray[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_SrcArray) - 1
$aCheck_SrcArray[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
Local $aCheck_TgtArray[UBound($aGLVEx_TgtArray)]
For $i = 1 To UBound($aCheck_TgtArray) - 1
$aCheck_TgtArray[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_TgtHandle, $i - 1)
Next
Local $aCheckDrag_Array[$iMultipleItems + 1]
If $iMultipleItems Then
Local $aInsertData[$iMultipleItems + 1]
Local $aColData[$iMultipleItems + 1]
Local $aItemData[UBound($aGLVEx_SrcArray, 2)]
For $i = 0 To $iMultipleItems
For $j = 0 To UBound($aGLVEx_SrcArray, 2) - 1
$aItemData[$j] = $aGLVEx_SrcArray[$iGLVEx_DraggedIndex + 1 + $i][$j]
Next
$aInsertData[$i] = $aItemData
If $bUserColTgt Then
For $j = 0 To UBound($aGLVEx_SrcArray, 2) - 1
If $bUserColSrc Then
$aItemData[$j] = $aGLVEx_SrcColArray[$iGLVEx_DraggedIndex + 1 + $i][$j]
Else
$aItemData[$j] = ";"
EndIf
Next
$aColData[$i] = $aItemData
EndIf
$aCheckDrag_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex + $i)
Next
Else
Local $aInsertData[1]
Local $aColData[1]
Local $aItemData[UBound($aGLVEx_SrcArray, 2)]
For $i = 0 To UBound($aGLVEx_SrcArray, 2) - 1
$aItemData[$i] = $aGLVEx_SrcArray[$iGLVEx_DraggedIndex + 1][$i]
Next
$aInsertData[0] = $aItemData
If $bUserColTgt Then
For $i = 0 To UBound($aGLVEx_SrcArray, 2) - 1
If $bUserColSrc Then
$aItemData[$i] = $aGLVEx_SrcColArray[$iGLVEx_DraggedIndex + 1][$i]
Else
$aItemData[$i] = ";"
EndIf
Next
$aColData[0] = $aItemData
EndIf
$aCheckDrag_Array[0] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex)
EndIf
$aGLVEx_Data[0][12] = True
If Not BitAND($aGLVEx_Data[$iGLVEx_SrcIndex][12], 4) Then
For $i = 0 To $iMultipleItems
__GUIListViewEx_Array_Delete($aGLVEx_SrcArray, $iGLVEx_DraggedIndex + 1)
__GUIListViewEx_Array_Delete($aCheck_SrcArray, $iGLVEx_DraggedIndex + 1, $aCheckDrag_Array[$i])
If $bUserColSrc Then __GUIListViewEx_Array_Delete($aGLVEx_SrcColArray, $iGLVEx_DraggedIndex + 1)
Next
EndIf
If $iGLVEx_InsertIndex < 0 Then
$iGLVEx_InsertIndex = _GUICtrlListView_GetItemCount($hGLVEx_TgtHandle)
EndIf
For $i = $iMultipleItems To 0 Step -1
__GUIListViewEx_Array_Insert($aGLVEx_TgtArray, $iGLVEx_InsertIndex + 1, $aInsertData[$i])
__GUIListViewEx_Array_Insert($aCheck_TgtArray, $iGLVEx_InsertIndex + 1, $aCheckDrag_Array[$i])
If $bUserColTgt Then __GUIListViewEx_Array_Insert($aGLVEx_TgtColArray, $iGLVEx_InsertIndex + 1, $aColData[$i], False, False)
Next
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_SrcArray, $iGLVEx_SrcIndex, $bCheckbox)
__GUIListViewEx_ReWriteLV($hGLVEx_TgtHandle, $aGLVEx_TgtArray, $aCheck_TgtArray, $iGLVEx_TgtIndex, $bCheckbox)
_GUIListViewEx_SetActive($iGLVEx_TgtIndex)
For $i = 0 To $iMultipleItems
__GUIListViewEx_HighLight($hGLVEx_TgtHandle, $cGLVEx_TgtID, $iGLVEx_InsertIndex + $i)
Next
$aGLVEx_Data[$iGLVEx_SrcIndex][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iGLVEx_SrcIndex][18] = $aGLVEx_SrcColArray
$aGLVEx_Data[$iGLVEx_TgtIndex][2] = $aGLVEx_TgtArray
$aGLVEx_Data[$iGLVEx_TgtIndex][18] = $aGLVEx_TgtColArray
EndIf
$aGLVEx_SrcArray = 0
$aGLVEx_TgtArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_TgtColArray = 0
$sGLVEx_DragEvent = $iGLVEx_SrcIndex & ":" & $iGLVEx_TgtIndex
$aGLVEx_Data[0][22] = 1
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iGLVEx_SrcIndex)
If $hGLVEx_TgtHandle <> $hGLVEx_SrcHandle Then
__GUIListViewEx_RedrawWindow($iGLVEx_TgtIndex)
EndIf
EndFunc
Func _GUIListViewEx_WM_SYSCOMMAND_Handler($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $lParam, $lParam
If $hWnd = _WinAPI_GetParent($hGLVEx_SrcHandle) And $wParam = 0xF060 Then
$aGLVEx_Data[0][9] = True
EndIf
EndFunc
Func __GUIListViewEx_ExpandRange($vRange, $iLV_Index, $iMode = 1)
If StringRegExp($vRange, "[^*0-9-;]") <> 0 Then
Return SetError(1, 0, 0)
EndIf
Local $iCount
If $iMode = 1 Then
$iCount = _GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0])
Else
$iCount = _GUICtrlListView_GetItemCount($aGLVEx_Data[$iLV_Index][0])
EndIf
Local $aRet[$iCount + 1]
$vRange = StringStripWS($vRange, 8)
If $vRange = "*" Then
$aRet[0] = $iCount
For $i = 1 To $iCount
$aRet[$i] = $i - 1
Next
Else
If StringInStr($vRange, "-") Then
Local $aSplit_1, $aSplit_2, $iNumber
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
$vRange &= $aSplit_2[1] & ";"
If ($aSplit_2[0]) > 1 Then
If (Number($aSplit_2[2]) > Number($aSplit_2[1])) Then
$iNumber = $aSplit_2[1]
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
Else
Return SetError(1, 0, 0)
EndIf
EndIf
Next
EndIf
Local $aSplit = StringSplit($vRange, ";")
For $i = 1 To $aSplit[0]
If $aSplit[$i] Then
$aRet[0] += 1
$aRet[$aRet[0]] = $aSplit[$i]
EndIf
Next
ReDim $aRet[$aRet[0] + 1]
EndIf
Return $aRet
EndFunc
Func __GUIListViewEx_HighLight($hLVHandle, $cLV_CID, $iIndexA, $iIndexB = -1)
If $cLV_CID Then
GUICtrlSetState($cLV_CID, 256)
Else
_WinAPI_SetFocus($hLVHandle)
EndIf
If $iIndexB <> -1 Then _GUICtrlListView_SetItemSelected($hLVHandle, $iIndexB, False)
_GUICtrlListView_SetItemState($hLVHandle, $iIndexA, $LVIS_SELECTED, $LVIS_SELECTED)
_GUICtrlListView_EnsureVisible($hLVHandle, $iIndexA)
EndFunc
Func __GUIListViewEx_GetLVFont($hLVHandle)
Local $iError = 0, $aFontDetails[2] = [Default, Default]
If Not IsHWnd($hLVHandle) Then
$hLVHandle = GUICtrlGetHandle($hLVHandle)
EndIf
If Not IsHWnd($hLVHandle) Then
$iError = 1
Else
Local $hFont = _SendMessage($hLVHandle, 0x0031)
If Not $hFont Then
$iError = 2
Else
Local $hDC = _WinAPI_GetDC($hLVHandle)
Local $hObjOrg = _WinAPI_SelectObject($hDC, $hFont)
Local $tFONT = DllStructCreate($tagLOGFONT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObjectW', 'ptr', $hFont, 'int', DllStructGetSize($tFONT), 'ptr', DllStructGetPtr($tFONT))
If @error Or $aRet[0] = 0 Then
$iError = 3
Else
$aFontDetails[0] = Round((-1 * DllStructGetData($tFONT, 'Height')) * 72 / _WinAPI_GetDeviceCaps($hDC, 90), 1)
$aRet = DllCall("gdi32.dll", "int", "GetTextFaceW", "handle", $hDC, "int", 0, "ptr", 0)
Local $iCount = $aRet[0]
Local $tBuffer = DllStructCreate("wchar[" & $iCount & "]")
Local $pBuffer = DllStructGetPtr($tBuffer)
$aRet = DllCall("Gdi32.dll", "int", "GetTextFaceW", "handle", $hDC, "int", $iCount, "ptr", $pBuffer)
If @error Then
$iError = 4
Else
$aFontDetails[1] = DllStructGetData($tBuffer, 1)
EndIf
EndIf
_WinAPI_SelectObject($hDC, $hObjOrg)
_WinAPI_ReleaseDC($hLVHandle, $hDC)
EndIf
EndIf
Return SetError($iError, 0, $aFontDetails)
EndFunc
Func __GUIListViewEx_EditProcess($iLV_Index, $aLocation, $iDelta_X, $iDelta_Y, $iEditMode, $iForce = False)
Local $hTemp_Combo = 9999, $hTemp_Edit = 9999, $hTemp_List = 9999, $iKey_Code, $fCombo_State, $aSplit, $sInsert
Local $iEditType, $fEdit, $fCombo, $fRead_Only, $fAuto_Drop, $fDTP, $fClick_Move = False, $cUpDown, $hUpDown
Local $hPrevCurrGUI = GUISwitch(_WinAPI_GetParent($hGLVEx_SrcHandle))
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, $aLocation[0], False)
Local $aEdited[1][4] = [[0]]
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
$hGLVEx_Editing = $hGLVEx_SrcHandle
Local $cEditingID = $cGLVEx_SrcID
Local $aKeys[7] = [0x09, 0x0D, 0x1B, 0x25, 0x27, 0x26, 0x28]
Local $fReset_Edits = False
If $iEditMode < 0 Then
$fReset_Edits = True
$iEditMode = Abs($iEditMode)
EndIf
Local $iEditRow = 0, $iEditCol = 0
If $iEditMode Then
$aSplit = StringSplit(StringFormat("%02s", $iEditMode), "")
$iEditRow = $aSplit[1]
$iEditCol = $aSplit[2]
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
If $aGLVEx_Data[$iLV_Index][9] Then
$fClick_Move = True
EndIf
Local $tLVPos = DllStructCreate("struct;long X;long Y;endstruct")
__GUIListViewEx_GetLVCoords($hGLVEx_Editing, $tLVPos)
Local $aLVClient = WinGetClientSize($hGLVEx_Editing)
Local $aLV_FontDetails = __GUIListViewEx_GetLVFont($hGLVEx_Editing)
WinSetState($hGLVEx_Editing, "", @SW_DISABLE)
Local $aWidth = ($aGLVEx_Data[$iLV_Index][14])
If Not IsArray($aWidth) Then Local $aWidth[_GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0])]
Local $iWidth, $fExitLoop, $tMouseClick = DllStructCreate($tagPOINT)
Local $iOldMouseOpt = Opt("MouseCoordMode", 1)
Local $iOldESC = Opt("GUICloseOnESC", 0)
_WinAPI_GetAsyncKeyState(0x01)
While _WinAPI_GetAsyncKeyState(0x01)
Sleep(10)
WEnd
While 1
$fEdit = False
$fCombo = False
$fRead_Only = False
$fAuto_Drop = False
$fDTP = False
$iEditType = $aEditable[0][$aLocation[1]]
Switch $iEditType
Case 0, 1
$fEdit = True
If $iForce Then
$iEditType = 1
EndIf
Case 2
$fCombo = True
Local $sCombo_Data = $aEditable[1][$aLocation[1]]
$fRead_Only = (BitAND($aEditable[2][$aLocation[1]], 1) = 1)
$fAuto_Drop = (BitAND($aEditable[2][$aLocation[1]], 2) = 2)
Case 3
$fDTP = True
Local $sDTP_Default = $aEditable[1][$aLocation[1]]
If StringRight($sDTP_Default, 1) = "#" Then
$sDTP_Default = StringTrimRight($sDTP_Default, 1)
$fAuto_Drop = True
EndIf
If $sDTP_Default = Default Then
$sDTP_Default = @YEAR & "/" & @MON & "/" & @MDAY
EndIf
Local $sDTP_Format = $aEditable[2][$aLocation[1]]
If $sDTP_Format = Default Then
$sDTP_Format = ""
EndIf
EndSwitch
Local $sItemOrgText = _GUICtrlListView_GetItemText($hGLVEx_Editing, $aLocation[0], $aLocation[1])
Local $aEdit_Pos = __GUIListViewEx_EditCoords($hGLVEx_Editing, $cEditingID, $aLocation, $tLVPos, $aLVClient[0] - 5, $iDelta_X, $iDelta_Y)
$iWidth = Number($aWidth[$aLocation[1]])
If $iWidth > $aEdit_Pos[2] Then
If $fRead_Only Then
If $iWidth < 0 Then
$aEdit_Pos[2] = Abs($iWidth)
EndIf
Else
$aEdit_Pos[2] = Abs($iWidth)
EndIf
EndIf
Switch $iEditType
Case 1
$cGLVEx_EditID = GUICtrlCreateInput($sItemOrgText, $aEdit_Pos[0], $aEdit_Pos[1], $aEdit_Pos[2], $aEdit_Pos[3], 128)
$hTemp_Edit = GUICtrlGetHandle($cGLVEx_EditID)
If $aEditable[1][$aLocation[1]] = 1 Then
Local $iWrap = -1
If $aEditable[2][$aLocation[1]] Then
$aSplit = StringSplit($aEditable[2][$aLocation[1]], "|")
If UBound($aSplit) = 4 Then
$iWrap = (($aSplit[3] = 1) ? (0x05) : (-1))
EndIf
EndIf
$cUpDown = GUICtrlCreateUpdown($cGLVEx_EditID, $iWrap)
$hUpDown = GUICtrlGetHandle($cUpDown)
If UBound($aSplit) = 4 Then
GUICtrlSetLimit($cUpDown, $aSplit[2], $aSplit[1])
EndIf
_WinAPI_RedrawWindow($hUpDown)
EndIf
Case 2
If $fRead_Only Then
$cGLVEx_EditID = GUICtrlCreateCombo("", $aEdit_Pos[0], $aEdit_Pos[1], $aEdit_Pos[2], $aEdit_Pos[3], 0x00200043)
GUICtrlSetData($cGLVEx_EditID, $sCombo_Data, $sItemOrgText)
Else
$cGLVEx_EditID = GUICtrlCreateCombo("", $aEdit_Pos[0], $aEdit_Pos[1], $aEdit_Pos[2], $aEdit_Pos[3], 0x00200042)
GUICtrlSetData($cGLVEx_EditID, $sCombo_Data)
EndIf
Local $tInfo = DllStructCreate("dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" & "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList")
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
Local $hCombo = GUICtrlGetHandle($cGLVEx_EditID)
If $fRead_Only And Abs($iWidth) > $aEdit_Pos[2] Then
_SendMessage($hCombo, 0x160, Abs($iWidth))
EndIf
_SendMessage($hCombo, 0x164, 0, $tInfo, 0, "wparam", "struct*")
$hTemp_Edit = DllStructGetData($tInfo, "hEdit")
$hTemp_List = DllStructGetData($tInfo, "hList")
$hTemp_Combo = DllStructGetData($tInfo, "hCombo")
Case 3
$cGLVEx_EditID = GUICtrlCreateDate($sDTP_Default, $aEdit_Pos[0], $aEdit_Pos[1], $aEdit_Pos[2], $aEdit_Pos[3])
$hTemp_Edit = GUICtrlGetHandle($cGLVEx_EditID)
If $sDTP_Format Then
GUICtrlSendMsg($cGLVEx_EditID, 0x1032, 0, $sDTP_Format)
EndIf
EndSwitch
GUICtrlSetFont($cGLVEx_EditID, $aLV_FontDetails[0], Default, Default, $aLV_FontDetails[1])
_WinAPI_SetFocus($hTemp_Edit)
If Not $aGLVEx_Data[$iLV_Index][11] Then
GUICtrlSendMsg($cGLVEx_EditID, 0xB1, 0, -1)
EndIf
If $fAuto_Drop Then
Switch $iEditType
Case 2
_SendMessage($hCombo, 0x14F, True)
Case 3
_SendMessage($hTemp_Edit, 0x0201, 1, $aEdit_Pos[2] - 10)
EndSwitch
EndIf
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$iKey_Code = 0
$fCombo_State = (($fAuto_Drop) ? (True) : (False))
While 1
$fExitLoop = False
If $aGLVEx_Data[0][9] Then
$fExitLoop = True
$aGLVEx_Data[0][9] = False
EndIf
_WinAPI_GetAsyncKeyState(0x01)
If _WinAPI_GetAsyncKeyState(0x01) Then
DllStructSetData($tMouseClick, "x", MouseGetPos(0))
DllStructSetData($tMouseClick, "y", MouseGetPos(1))
Switch _WinAPI_WindowFromPoint($tMouseClick)
Case $hTemp_Combo, $hTemp_Edit, $hTemp_List, $hUpDown
Case Else
If Not $fDTP Then
$fExitLoop = True
EndIf
EndSwitch
_WinAPI_GetAsyncKeyState(0x01)
While _WinAPI_GetAsyncKeyState(0x01)
Sleep(10)
WEnd
EndIf
If $fExitLoop Then
If $fEdit Then
If $fClick_Move Then
$iKey_Code = 0x02
Else
$iKey_Code = 0x01
EndIf
EndIf
ExitLoop
EndIf
If $fCombo Then
Switch _SendMessage($hCombo, 0x157)
Case 0
If $fCombo_State = True Then
If GUICtrlRead($cGLVEx_EditID) = "" Then
$fCombo_State = False
Else
$iKey_Code = 0x0D
ExitLoop
EndIf
EndIf
Case 1
If Not $fCombo_State Then
$fCombo_State = True
EndIf
EndSwitch
EndIf
For $i = 0 To 2
_WinAPI_GetAsyncKeyState($aKeys[$i])
If _WinAPI_GetAsyncKeyState($aKeys[$i]) Then
$iKey_Code = $aKeys[$i]
ExitLoop 2
EndIf
Next
For $i = 3 To 6
_WinAPI_GetAsyncKeyState($aKeys[$i])
If _WinAPI_GetAsyncKeyState($aKeys[$i]) And _WinAPI_GetAsyncKeyState(0x11) Then
$iKey_Code = $aKeys[$i]
ExitLoop 2
EndIf
Next
If _WinAPI_GetFocus() <> $hTemp_Edit Then
ExitLoop
EndIf
Sleep(10)
WEnd
Switch $iKey_Code
Case 0x25, 0x26, 0x27, 0x28
If $fEdit Then
ContinueCase
EndIf
Case 0x02, 0x09, 0x0D
Local $sItemNewText = GUICtrlRead($cGLVEx_EditID)
If $sItemNewText <> $sItemOrgText Then
_GUICtrlListView_SetItemText($hGLVEx_Editing, $aLocation[0], $sItemNewText, $aLocation[1])
$aGLVEx_SrcArray[$aLocation[0] + 1][$aLocation[1]] = $sItemNewText
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aEdited[0][0] += 1
ReDim $aEdited[$aEdited[0][0] + 1][4]
$aEdited[$aEdited[0][0]][0] = $aLocation[0]
$aEdited[$aEdited[0][0]][1] = $aLocation[1]
$aEdited[$aEdited[0][0]][2] = $sItemOrgText
$aEdited[$aEdited[0][0]][3] = $sItemNewText
EndIf
EndSwitch
GUICtrlDelete($cGLVEx_EditID)
GUICtrlDelete($cUpDown)
$cGLVEx_EditID = 9999
Opt("MouseCoordMode", $iOldMouseOpt)
If $iEditMode = 0 Then
ExitLoop
Else
Switch $iKey_Code
Case 0x02
$iKey_Code = 0x01
ContinueCase
Case 0x00, 0x01, 0x0D
_WinAPI_GetAsyncKeyState($iKey_Code)
While _WinAPI_GetAsyncKeyState($iKey_Code)
Sleep(10)
WEnd
ExitLoop
Case 0x1B
If $fReset_Edits Then
For $i = $aEdited[0][0] To 1 Step -1
_GUICtrlListView_SetItemText($hGLVEx_Editing, $aEdited[$i][0], $aEdited[$i][2], $aEdited[$i][1])
Switch UBound($aGLVEx_SrcArray, 0)
Case 1
$aSplit = StringSplit($aGLVEx_SrcArray[$aEdited[$i][0] + 1], $aGLVEx_Data[0][24])
$aSplit[$aEdited[$i][1] + 1] = $aEdited[$i][2]
$sInsert = ""
For $j = 1 To $aSplit[0]
$sInsert &= $aSplit[$j] & $aGLVEx_Data[0][24]
Next
$aGLVEx_SrcArray[$aEdited[$i][0] + 1] = StringTrimRight($sInsert, 1)
Case 2
$aGLVEx_SrcArray[$aEdited[$i][0] + 1][$aEdited[$i][1]] = $aEdited[$i][2]
EndSwitch
Next
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
Local $aEdited[1][4] = [[0]]
EndIf
_WinAPI_GetAsyncKeyState(0x1B)
While _WinAPI_GetAsyncKeyState(0x1B)
Sleep(10)
WEnd
ExitLoop
Case 0x09, 0x27
While 1
If $iEditCol <> 0 Then
$aLocation[1] += 1
If $aLocation[1] = _GUICtrlListView_GetColumnCount($hGLVEx_Editing) Then
Switch $iEditCol
Case 1
ExitLoop 2
Case 2
$aLocation[1] -= 1
ExitLoop
Case 3
$aLocation[1] = 0
EndSwitch
EndIf
If $aEditable[0][$aLocation[1]] <> 0 Then
ExitLoop
Else
ExitLoop 2
EndIf
Else
ExitLoop 2
EndIf
WEnd
Case 0x25
While 1
If $iEditCol <> 0 Then
$aLocation[1] -= 1
If $aLocation[1] < 0 Then
Switch $iEditCol
Case 1
ExitLoop 2
Case 2
$aLocation[1] += 1
ExitLoop
Case 3
$aLocation[1] = _GUICtrlListView_GetColumnCount($hGLVEx_Editing) - 1
EndSwitch
EndIf
If $aEditable[0][$aLocation[1]] <> 0 Then
ExitLoop
Else
ExitLoop 2
EndIf
Else
ExitLoop 2
EndIf
WEnd
Case 0x28
While 1
If $iEditRow <> 0 Then
$aLocation[0] += 1
If $aLocation[0] = _GUICtrlListView_GetItemCount($hGLVEx_Editing) Then
Switch $iEditRow
Case 1
ExitLoop 2
Case 2
$aLocation[0] -= 1
ExitLoop
Case 3
$aLocation[0] = -1
EndSwitch
Else
ExitLoop
EndIf
Else
ExitLoop 2
EndIf
WEnd
Case 0x26
While 1
If $iEditRow <> 0 Then
$aLocation[0] -= 1
If $aLocation[0] < 0 Then
Switch $iEditRow
Case 1
ExitLoop 2
Case 2
$aLocation[0] += 1
ExitLoop
Case 3
$aLocation[0] = _GUICtrlListView_GetItemCount($hGLVEx_Editing)
EndSwitch
Else
ExitLoop
EndIf
Else
ExitLoop 2
EndIf
WEnd
EndSwitch
_WinAPI_GetAsyncKeyState($iKey_Code)
While _WinAPI_GetAsyncKeyState($iKey_Code)
Sleep(10)
WEnd
EndIf
WEnd
$aGLVEx_SrcArray = 0
WinSetState($hGLVEx_Editing, "", @SW_ENABLE)
_GUICtrlListView_SetItemState($hGLVEx_Editing, $aLocation[0], $LVIS_SELECTED, $LVIS_SELECTED)
SetExtended($iKey_Code)
Opt("GUICloseOnESC", $iOldESC)
GUISwitch($hPrevCurrGUI)
_WinAPI_SetFocus($hGLVEx_Editing)
Return $aEdited
EndFunc
Func __GUIListViewEx_EditCoords($hLV_Handle, $cLV_CID, $aLocation, $tLVPos, $iLVWidth, $iDelta_X, $iDelta_Y)
Local $aEdit_Data[4]
_GUICtrlListView_EnsureVisible($hLV_Handle, $aLocation[0])
Local $aRect = _GUICtrlListView_GetSubItemRect($hLV_Handle, $aLocation[0], $aLocation[1])
$aEdit_Data[3] = $aRect[3] - $aRect[1] + 1
$aEdit_Data[2] = _GUICtrlListView_GetColumnWidth($hLV_Handle, $aLocation[1])
If $aRect[0] < 0 Or $aRect[2] > $iLVWidth Then
_GUICtrlListView_Scroll($hLV_Handle, $aRect[0], 0)
$aRect = _GUICtrlListView_GetSubItemRect($hLV_Handle, $aLocation[0], $aLocation[1])
If $aRect[0] + $aEdit_Data[2] > $iLVWidth Then
$aEdit_Data[2] = $iLVWidth - $aRect[0]
EndIf
EndIf
If $cLV_CID Then
$iDelta_Y += 1
EndIf
$aEdit_Data[0] = DllStructGetData($tLVPos, "X") + $aRect[0] + $iDelta_X + 2
$aEdit_Data[1] = DllStructGetData($tLVPos, "Y") + $aRect[1] + $iDelta_Y
Return $aEdit_Data
EndFunc
Func __GUIListViewEx_ReWriteLV($hLVHandle, ByRef $aLV_Array, ByRef $aCheck_Array, $iLV_Index, $fCheckBox = True, $fRetainWidth = True)
Local $iVertScroll, $iColCount
Local $iLV_CID = $aGLVEx_Data[$iLV_Index][1]
If $aGLVEx_Data[$iLV_Index][10] Then
$iVertScroll = $aGLVEx_Data[$iLV_Index][10]
Else
Local $aRect = _GUICtrlListView_GetItemRect($hLVHandle, 0)
$aGLVEx_Data[$iLV_Index][10] = $aRect[3] - $aRect[1]
If $iVertScroll = 0 Then
$iVertScroll = 20
EndIf
EndIf
Local $iTopIndex_Org = _GUICtrlListView_GetTopIndex($hLVHandle)
If $fRetainWidth And $iLV_CID Then
$iColCount = _GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)
Local $aCol_Width[$iColCount]
For $i = 1 To $iColCount - 1
$aCol_Width[$i] = _GUICtrlListView_GetColumnWidth($hGLVEx_SrcHandle, $i)
Next
EndIf
_GUICtrlListView_BeginUpdate($hLVHandle)
_GUICtrlListView_DeleteAllItems($hLVHandle)
If UBound($aLV_Array, 2) Then
Local $aArray = $aLV_Array
_ArrayDelete($aArray, 0)
Local $cLV_CID = $aGLVEx_Data[$iLV_Index][1]
If $cLV_CID Then
Local $sLine, $iLastCol = UBound($aArray, 2) - 1
For $i = 0 To UBound($aArray) - 1
$sLine = ""
For $j = 0 To $iLastCol
$sLine &= $aArray[$i][$j] & "|"
Next
GUICtrlCreateListViewItem(StringTrimRight($sLine, 1), $cLV_CID)
Next
Else
_GUICtrlListView_AddArray($hLVHandle, $aArray)
EndIf
For $i = 1 To $aLV_Array[0][0]
If $fCheckBox And $aCheck_Array[$i] Then
_GUICtrlListView_SetItemChecked($hLVHandle, $i - 1)
EndIf
Next
Local $iTopIndex_Curr = _GUICtrlListView_GetTopIndex($hLVHandle)
While $iTopIndex_Curr < $iTopIndex_Org
_GUICtrlListView_Scroll($hLVHandle, 0, $iVertScroll)
If _GUICtrlListView_GetTopIndex($hLVHandle) = $iTopIndex_Curr Then
ExitLoop
Else
$iTopIndex_Curr = _GUICtrlListView_GetTopIndex($hLVHandle)
EndIf
WEnd
EndIf
If $fRetainWidth And $iLV_CID Then
For $i = 1 To $iColCount - 1
$aCol_Width[$i] = _GUICtrlListView_SetColumnWidth($hGLVEx_SrcHandle, $i, $aCol_Width[$i])
Next
EndIf
_GUICtrlListView_EndUpdate($hLVHandle)
EndFunc
Func __GUIListViewEx_GetLVCoords($hLV_Handle, ByRef $tLVPos)
Local $aWnd = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hLV_Handle)
Local $hWnd = $aWnd[0]
Local $aLVPos = WinGetPos($hLV_Handle)
DllStructSetData($tLVPos, "X", $aLVPos[0])
DllStructSetData($tLVPos, "Y", $aLVPos[1])
_WinAPI_ScreenToClient($hWnd, $tLVPos)
EndFunc
Func __GUIListViewEx_GetCursorWnd()
Local $iOldMouseOpt = Opt("MouseCoordMode", 1)
Local $tMPos = DllStructCreate("struct;long X;long Y;endstruct")
DllStructSetData($tMPos, "X", MouseGetPos(0))
DllStructSetData($tMPos, "Y", MouseGetPos(1))
Opt("MouseCoordMode", $iOldMouseOpt)
Return _WinAPI_WindowFromPoint($tMPos)
EndFunc
Func __GUIListViewEx_Array_Add(ByRef $avArray, $vAdd, $fMultiRow = False, $bCount = True)
Local $iIndex_Max = UBound($avArray)
Local $iAdd_Dim
Switch UBound($avArray, 0)
Case 1
If UBound($vAdd, 0) = 2 Or $fMultiRow Then
$iAdd_Dim = UBound($vAdd, 1)
ReDim $avArray[$iIndex_Max + $iAdd_Dim]
Else
ReDim $avArray[$iIndex_Max + 1]
EndIf
Case 2
Local $iDim2 = UBound($avArray, 2)
If UBound($vAdd, 0) = 2 Then
$iAdd_Dim = UBound($vAdd, 1)
ReDim $avArray[$iIndex_Max + $iAdd_Dim][$iDim2]
$avArray[0][0] += $iAdd_Dim
Local $iAdd_Max = UBound($vAdd, 2)
For $i = 0 To $iAdd_Dim - 1
For $j = 0 To $iDim2 - 1
If $j > $iAdd_Max - 1 Then
$avArray[$iIndex_Max + $i][$j] = ""
Else
$avArray[$iIndex_Max + $i][$j] = $vAdd[$i][$j]
EndIf
Next
Next
ElseIf $fMultiRow Then
$iAdd_Dim = UBound($vAdd, 1)
ReDim $avArray[$iIndex_Max + $iAdd_Dim][$iDim2]
$avArray[0][0] += $iAdd_Dim
For $i = 0 To $iAdd_Dim - 1
$avArray[$iIndex_Max + $i][0] = $vAdd[$i]
Next
Else
ReDim $avArray[$iIndex_Max + 1][$iDim2]
If $bCount Then
$avArray[0][0] += 1
EndIf
If IsArray($vAdd) Then
Local $vAdd_Max = UBound($vAdd)
For $j = 0 To $iDim2 - 1
If $j > $vAdd_Max - 1 Then
$avArray[$iIndex_Max][$j] = ""
Else
$avArray[$iIndex_Max][$j] = $vAdd[$j]
EndIf
Next
Else
For $j = 0 To $iDim2 - 1
$avArray[$iIndex_Max][$j] = $vAdd
Next
EndIf
EndIf
EndSwitch
EndFunc
Func __GUIListViewEx_Array_Insert(ByRef $avArray, $iIndex, $vInsert, $fMultiRow = False, $bCount = True)
Local $iIndex_Max = UBound($avArray)
Local $iInsert_Dim = UBound($vInsert, 1)
Switch UBound($avArray, 0)
Case 1
If UBound($vInsert, 0) = 2 Or $fMultiRow Then
ReDim $avArray[$iIndex_Max + $iInsert_Dim]
For $i = $iIndex_Max + $iInsert_Dim - 1 To $iIndex + 1 Step -1
$avArray[$i] = $avArray[$i - 1]
Next
Else
ReDim $avArray[$iIndex_Max + 1]
For $i = $iIndex_Max To $iIndex + 1 Step -1
$avArray[$i] = $avArray[$i - 1]
Next
$avArray[$iIndex] = $vInsert
EndIf
Case 2
If $iIndex > $iIndex_Max - 1 Then
__GUIListViewEx_Array_Add($avArray, $vInsert, $fMultiRow, $bCount)
Return
EndIf
Local $iDim2 = UBound($avArray, 2)
If UBound($vInsert, 0) = 2 Then
$iInsert_Dim = UBound($vInsert, 1)
ReDim $avArray[$iIndex_Max + $iInsert_Dim][$iDim2]
If $bCount Then
$avArray[0][0] += $iInsert_Dim
EndIf
For $i = $iIndex_Max + $iInsert_Dim - 1 To $iIndex + $iInsert_Dim Step -1
For $j = 0 To $iDim2 - 1
$avArray[$i][$j] = $avArray[$i - $iInsert_Dim][$j]
Next
Next
Local $iInsert_Max = UBound($vInsert, 2)
For $i = 0 To $iInsert_Dim - 1
For $j = 0 To $iDim2 - 1
If $j > $iInsert_Max - 1 Then
$avArray[$iIndex + $i][$j] = ""
Else
$avArray[$iIndex + $i][$j] = $vInsert[$i][$j]
EndIf
Next
Next
ElseIf $fMultiRow Then
$iInsert_Dim = UBound($vInsert, 1)
ReDim $avArray[$iIndex_Max + $iInsert_Dim][$iDim2]
$avArray[0][0] += $iInsert_Dim
For $i = $iIndex_Max + $iInsert_Dim - 1 To $iIndex + $iInsert_Dim Step -1
For $j = 0 To $iDim2 - 1
$avArray[$i][$j] = $avArray[$i - $iInsert_Dim][$j]
Next
Next
For $i = 0 To $iInsert_Dim - 1
$avArray[$iIndex + $i][0] = $vInsert[$i]
Next
Else
ReDim $avArray[$iIndex_Max + 1][$iDim2]
$avArray[0][0] += 1
For $i = $iIndex_Max To $iIndex + 1 Step -1
For $j = 0 To $iDim2 - 1
$avArray[$i][$j] = $avArray[$i - 1][$j]
Next
Next
If IsArray($vInsert) Then
Local $vInsert_Max = UBound($vInsert)
For $j = 0 To $iDim2 - 1
If $j > $vInsert_Max - 1 Then
$avArray[$iIndex][$j] = ""
Else
$avArray[$iIndex][$j] = $vInsert[$j]
EndIf
Next
Else
For $j = 0 To $iDim2 - 1
$avArray[$iIndex][$j] = $vInsert
Next
EndIf
EndIf
EndSwitch
EndFunc
Func __GUIListViewEx_Array_Delete(ByRef $avArray, $iIndex, $bDelCount = False)
Local $iIndex_Max = UBound($avArray)
If $iIndex_Max = 0 Then Return
Switch UBound($avArray, 0)
Case 1
For $i = $iIndex To $iIndex_Max - 2
$avArray[$i] = $avArray[$i + 1]
Next
ReDim $avArray[$iIndex_Max - 1]
Case 2
Local $iDim2 = UBound($avArray, 2)
For $i = $iIndex To $iIndex_Max - 2
For $j = 0 To $iDim2 - 1
$avArray[$i][$j] = $avArray[$i + 1][$j]
Next
Next
ReDim $avArray[$iIndex_Max - 1][$iDim2]
If Not $bDelCount Then
$avArray[0][0] -= 1
EndIf
EndSwitch
EndFunc
Func __GUIListViewEx_Array_Swap(ByRef $avArray, $iIndex1, $iIndex2)
Local $vTemp
Switch UBound($avArray, 0)
Case 1
$vTemp = $avArray[$iIndex1]
$avArray[$iIndex1] = $avArray[$iIndex2]
$avArray[$iIndex2] = $vTemp
Case 2
Local $iDim2 = UBound($avArray, 2)
For $i = 0 To $iDim2 - 1
$vTemp = $avArray[$iIndex1][$i]
$avArray[$iIndex1][$i] = $avArray[$iIndex2][$i]
$avArray[$iIndex2][$i] = $vTemp
Next
EndSwitch
Return 0
EndFunc
Func __GUIListViewEx_ToolTipHide()
AdlibUnRegister("__GUIListViewEx_ToolTipHide")
ToolTip("")
EndFunc
Func __GUIListViewEx_MakeString($aArray)
If Not IsArray($aArray) Then Return SetError(1, 0, "")
Local $sRet = ""
Local $sDelim_Col = @CR
Local $sDelim_Row = @LF
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 0 To UBound($aArray, $UBOUND_ROWS) - 1
$sRet &= $aArray[$i] & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
For $i = 0 To UBound($aArray, $UBOUND_ROWS) - 1
For $j = 0 To UBound($aArray, $UBOUND_COLUMNS) - 1
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, StringLen($sDelim_Col)) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, "")
EndSwitch
EndFunc
Func __GUIListViewEx_MakeArray($sString)
If $sString = "" Then Return SetError(1, 0, "")
Local $aRetArray, $aRows, $aItems
Local $sRowDelimiter = @LF
Local $sColDelimiter = @CR
If StringInStr($sString, $sColDelimiter) Then
$aRows = StringSplit($sString, $sRowDelimiter)
StringReplace($aRows[1], $sColDelimiter, "")
Local $aRetArray[$aRows[0]][@extended + 1]
For $i = 1 To $aRows[0]
$aItems = StringSplit($aRows[$i], $sColDelimiter)
For $j = 1 To $aItems[0]
$aRetArray[$i - 1][$j - 1] = $aItems[$j]
Next
Next
Else
$aRetArray = StringSplit($sString, $sRowDelimiter, $STR_NOCOUNT)
EndIf
Return $aRetArray
EndFunc
Func __GUIListViewEx_ColSort($hLV, $iLV_Index, ByRef $vSortSense, $iCol, $hUserSortFunction = 0, $bToggleSense = True)
Local $aListViewContent = $aGLVEx_Data[$iLV_Index][2]
Local $aColourSettings = $aGLVEx_Data[$iLV_Index][18]
Local $iItemCount = $aListViewContent[0][0]
If $iItemCount Then
Local $iDescending = 0
If UBound($vSortSense) Then
$iDescending = $vSortSense[$iCol]
Else
$iDescending = $vSortSense
EndIf
Local $iColumnCount = UBound($aListViewContent, 2)
Local $fColourEnabled = ((IsArray($aGLVEx_Data[$iLV_Index][18])) ? (True) : (False))
If $fColourEnabled Then
ReDim $aListViewContent[UBound($aListViewContent)][($iColumnCount * 2) + 2]
For $i = 1 To $iItemCount
For $j = 0 To $iColumnCount - 1
$aListViewContent[$i][$iColumnCount + $j + 2] = $aColourSettings[$i][$j]
Next
Next
Else
ReDim $aListViewContent[UBound($aListViewContent)][$iColumnCount + 2]
EndIf
Local Enum $iIndexValue = $iColumnCount, $iItemParam
Local $sSelectedItems = _GUICtrlListView_GetSelectedIndices($hLV)
Local $aSelectedItems
If $sSelectedItems = "" Then
Local $aSelectedItems[2] = [1, $aGLVEx_Data[0][17]]
Else
$aSelectedItems = StringSplit($sSelectedItems, Opt('GUIDataSeparatorChar'))
EndIf
Local $aCheckedItems[$iItemCount + 1] = [0]
For $i = 0 To $iItemCount - 1
If _GUICtrlListView_GetItemChecked($hLV, $i) Then
$aCheckedItems[0] += 1
$aCheckedItems[$aCheckedItems[0]] = $i
EndIf
Next
ReDim $aCheckedItems[$aCheckedItems[0] + 1]
Local $iFocused = -1
For $i = 0 To $iItemCount - 1
If $iFocused = -1 Then
If _GUICtrlListView_GetItemFocused($hLV, $i) Then $iFocused = $i
EndIf
_GUICtrlListView_SetItemSelected($hLV, $i, False)
_GUICtrlListView_SetItemChecked($hLV, $i, False)
$aListViewContent[$i + 1][$iIndexValue] = $i
$aListViewContent[$i + 1][$iItemParam] = _GUICtrlListView_GetItemParam($hLV, $i)
Next
If IsFunc($hUserSortFunction) Then
$hUserSortFunction($aListViewContent, $iDescending, 1, 0, $iCol)
ElseIf $hUserSortFunction = -1 Then
Else
_ArraySort($aListViewContent, $iDescending, 1, 0, $iCol)
EndIf
For $i = 1 To $iItemCount
For $j = 0 To $iColumnCount - 1
_GUICtrlListView_SetItemText($hLV, $i - 1, $aListViewContent[$i][$j], $j)
If $fColourEnabled Then
$aColourSettings[$i][$j] = $aListViewContent[$i][$iColumnCount + $j + 2]
EndIf
Next
_GUICtrlListView_SetItemParam($hLV, $i - 1, $aListViewContent[$i][$iItemParam])
For $j = 1 To $aSelectedItems[0]
If $aListViewContent[$i][$iIndexValue] = $aSelectedItems[$j] Then
$aGLVEx_Data[0][17] = $i - 1
$aGLVEx_Data[$iLV_Index][20] = $i - 1
If Not ($aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22]) Then
If $aListViewContent[$i - 1][$iIndexValue] = $iFocused Then
_GUICtrlListView_SetItemSelected($hLV, $i - 1, True, True)
Else
_GUICtrlListView_SetItemSelected($hLV, $i - 1, True)
EndIf
ExitLoop
EndIf
EndIf
Next
For $j = 1 To $aCheckedItems[0]
If $aListViewContent[$i][$iIndexValue] = $aCheckedItems[$j] Then
_GUICtrlListView_SetItemChecked($hLV, $i - 1, True)
ExitLoop
EndIf
Next
Next
If $bToggleSense Then
If UBound($vSortSense) Then
$vSortSense[$iCol] = Not $iDescending
Else
$vSortSense = Not $iDescending
EndIf
EndIf
ReDim $aListViewContent[UBound($aListViewContent)][$iColumnCount]
$aGLVEx_Data[$iLV_Index][2] = $aListViewContent
$aGLVEx_Data[$iLV_Index][18] = $aColourSettings
$aGLVEx_Data[0][19] = $iLV_Index
$aGLVEx_Data[0][22] = 1
EndIf
EndFunc
Func __GUIListViewEx_RedrawWindow($iLV_Index, $fForce = False)
If $fForce Or $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$aGLVEx_Data[0][14] = 0
If $aGLVEx_Data[0][15] Then
_WinAPI_RedrawWindow($aGLVEx_Data[$iLV_Index][0])
EndIf
EndIf
EndFunc
Func __GUIListViewEx_CheckUserEditKey()
Local $aKey = StringSplit($aGLVEx_Data[0][23], ";"), $iKeyValue
Local $fCheck = True
For $i = 1 To $aKey[0]
$iKeyValue = Dec($aKey[$i])
If Not _WinAPI_GetAsyncKeyState($iKeyValue) Then
$fCheck = False
ExitLoop
EndIf
Next
Return $fCheck
EndFunc
Func _GUIScrollBars_Globals()
Global $__g_aSB_WindowInfo[1][10] = [[0, 0, 0, 0, -1]]
$__g_aSB_WindowInfo[0][5] = _WinAPI_GetSystemMetrics(2)
$__g_aSB_WindowInfo[0][6] = _WinAPI_GetSystemMetrics(3)
Global $__g_aSB_WindowInfoEx[1][9]
EndFunc
Func _GUIScrollbars_Generate($hWnd, $iH_Scroll = 0, $iV_Scroll = 0, $iH_Tight = 0, $iV_Tight = 0, $fBefore = False, $iRepeat = 0, $bRegisterMsg = True)
Local $iIndex
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
For $iIndex = 1 To $__g_aSB_WindowInfo[0][0]
If $hWnd = $__g_aSB_WindowInfo[$iIndex][0] Then
ExitLoop
EndIf
Next
If $iIndex > $__g_aSB_WindowInfo[0][0] Then
$__g_aSB_WindowInfo[0][0] += 1
ReDim $__g_aSB_WindowInfo[$iIndex + 1][UBound($__g_aSB_WindowInfo, 2)]
ReDim $__g_aSB_WindowInfoEx[$iIndex + 1][UBound($__g_aSB_WindowInfoEx, 2)]
EndIf
If $iH_Scroll = 0 And $iV_Scroll = 0 Then Return SetError(2, 0, 0)
If $iH_Tight <> 0 Then $iH_Tight = 1
If $iV_Tight <> 0 Then $iV_Tight = 1
If Not IsInt($iRepeat) Then $iRepeat = 0
Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
Local $tSCROLLINFO = DllStructCreate($tagSCROLLINFO)
DllStructSetData($tSCROLLINFO, "cbSize", DllStructGetSize($tSCROLLINFO))
Local $iError, $iExtended
$__g_aSB_WindowInfo[$iIndex][0] = $hWnd
Local $hDC = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If Not @error Then
$hDC = $hDC[0]
DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hDC, "ptr", DllStructGetPtr($tTEXTMETRIC))
If @error Then
$iError = @error
$iExtended = @extended
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
Return SetError($iError, $iExtended, -2)
EndIf
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
Else
Return SetError(@error, @extended, -1)
EndIf
$__g_aSB_WindowInfo[$iIndex][2] = DllStructGetData($tTEXTMETRIC, "tmAveCharWidth")
$__g_aSB_WindowInfo[$iIndex][3] = DllStructGetData($tTEXTMETRIC, "tmHeight") + DllStructGetData($tTEXTMETRIC, "tmExternalLeading")
Local $aClientSize = WinGetClientSize($hWnd)
Local $iX_Client_Full = $aClientSize[0]
Local $iY_Client_Full = $aClientSize[1]
$__g_aSB_WindowInfo[$iIndex][4] = $iX_Client_Full
$__g_aSB_WindowInfo[$iIndex][5] = $iY_Client_Full
If $iX_Client_Full > $iH_Scroll Then $iH_Scroll = 0
If $iY_Client_Full > $iV_Scroll Then $iV_Scroll = 0
_GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, False)
If $iH_Scroll Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ)
If $bRegisterMsg Then
GUIRegisterMsg($WM_HSCROLL, "_Scrollbars_WM_HSCROLL")
GUIRegisterMsg($WM_MOUSEHWHEEL, '_Scrollbars_WM_MOUSEHWHEEL')
EndIf
EndIf
If $iV_Scroll Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT)
If $bRegisterMsg Then
GUIRegisterMsg($WM_VSCROLL, "_Scrollbars_WM_VSCROLL")
GUIRegisterMsg($WM_MOUSEWHEEL, "_Scrollbars_WM_MOUSEWHEEL")
EndIf
EndIf
If $iRepeat And $bRegisterMsg Then
GUIRegisterMsg($WM_KEYUP, "_Scrollbars_WM_KEYUP")
EndIf
$aClientSize = WinGetClientSize($hWnd)
Local $iX_Client_Bar = $aClientSize[0]
Local $iY_Client_Bar = $aClientSize[1]
Local $iH_FullPage
If $iH_Scroll Then
If $fBefore Then
$__g_aSB_WindowInfo[$iIndex][4] = $iX_Client_Bar
$iH_FullPage = Floor($__g_aSB_WindowInfo[$iIndex][4] / $__g_aSB_WindowInfo[$iIndex][2])
$__g_aSB_WindowInfo[$iIndex][6] = Floor($iH_Scroll / $__g_aSB_WindowInfo[$iIndex][2]) - $iH_Tight
Else
If $iV_Scroll Then $__g_aSB_WindowInfo[$iIndex][4] = $iX_Client_Bar
$iH_FullPage = Floor($__g_aSB_WindowInfo[$iIndex][4] / $__g_aSB_WindowInfo[$iIndex][2])
$__g_aSB_WindowInfo[$iIndex][6] = Floor($iH_Scroll / $__g_aSB_WindowInfo[$iIndex][2] * $__g_aSB_WindowInfo[$iIndex][4] / $iX_Client_Full) - $iH_Tight
EndIf
Else
$__g_aSB_WindowInfo[$iIndex][6] = 0
EndIf
Local $iV_FullPage
If $iV_Scroll Then
If $fBefore Then
$__g_aSB_WindowInfo[$iIndex][5] = $iY_Client_Bar
$iV_FullPage = Floor($__g_aSB_WindowInfo[$iIndex][5] / $__g_aSB_WindowInfo[$iIndex][3])
$__g_aSB_WindowInfo[$iIndex][7] = Floor($iV_Scroll / $__g_aSB_WindowInfo[$iIndex][3]) - $iV_Tight
Else
If $iH_Scroll Then $__g_aSB_WindowInfo[$iIndex][5] = $iY_Client_Bar
$iV_FullPage = Floor($__g_aSB_WindowInfo[$iIndex][5] / $__g_aSB_WindowInfo[$iIndex][3])
$__g_aSB_WindowInfo[$iIndex][7] = Floor($iV_Scroll / $__g_aSB_WindowInfo[$iIndex][3] * $__g_aSB_WindowInfo[$iIndex][5] / $iY_Client_Full) - $iV_Tight
EndIf
Else
$__g_aSB_WindowInfo[$iIndex][7] = 0
EndIf
Local $aRet[4]
If $iV_Scroll Then
$aRet[0] = $iX_Client_Bar
Else
$aRet[0] = $iX_Client_Full
EndIf
If $iH_Scroll Then
$aRet[1] = $iY_Client_Bar
Else
$aRet[1] = $iY_Client_Full
EndIf
$aRet[2] = $iX_Client_Bar / $iX_Client_Full
$aRet[3] = $iY_Client_Bar / $iY_Client_Full
$__g_aSB_WindowInfoEx[$iIndex][0] = $iH_Scroll
$__g_aSB_WindowInfoEx[$iIndex][1] = $iV_Scroll
$__g_aSB_WindowInfoEx[$iIndex][2] = $aRet[2]
$__g_aSB_WindowInfoEx[$iIndex][3] = $aRet[3]
$__g_aSB_WindowInfoEx[$iIndex][4] = $fBefore
$__g_aSB_WindowInfoEx[$iIndex][5] = $iRepeat
$__g_aSB_WindowInfoEx[$iIndex][6] = (($iRepeat) ? ($iRepeat) : (7))
Local $fSuccess = True
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, False) = False Then $fSuccess = False
If $iH_Scroll Then
If _GUIScrollBars_SetScrollInfoMax($hWnd, $SB_HORZ, $__g_aSB_WindowInfo[$iIndex][6]) = False Then $fSuccess = False
_GUIScrollBars_SetScrollInfoPage($hWnd, $SB_HORZ, $iH_FullPage)
If @error Then $fSuccess = False
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ, True) = False Then $fSuccess = False
Else
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ, False) = False Then $fSuccess = False
EndIf
If $iV_Scroll Then
If _GUIScrollBars_SetScrollInfoMax($hWnd, $SB_VERT, $__g_aSB_WindowInfo[$iIndex][7]) = False Then $fSuccess = False
_GUIScrollBars_SetScrollInfoPage($hWnd, $SB_VERT, $iV_FullPage)
If @error Then $fSuccess = False
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT, True) = False Then $fSuccess = False
Else
If _GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT, False) = False Then $fSuccess = False
EndIf
If $fSuccess Then Return $aRet
Return SetError(3, 0, 0)
EndFunc
Func _GUIScrollbars_ReSizer($hWnd, $iH_Max, $iV_Max, $bFullClient = False, $bRegisterMsg = True)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
For $iIndex = 1 To $__g_aSB_WindowInfo[0][0]
If $hWnd = $__g_aSB_WindowInfo[$iIndex][0] Then
ExitLoop
EndIf
Next
If $iIndex > $__g_aSB_WindowInfo[0][0] Then Return SetError(2, 0, 0)
If Not BitAND(_WinAPI_GetWindowLong($hWnd, $GWL_STYLE), 0x00040000) Then Return SetError(3, 0, 0)
$__g_aSB_WindowInfoEx[$iIndex][7] = $iH_Max
$__g_aSB_WindowInfoEx[$iIndex][8] = $iV_Max
Local $aPos = WinGetPos($hWnd)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, False)
Local $aClientSize = WinGetClientSize($hWnd)
Local $aMaxSize[2] = [$aPos[2] + $__g_aSB_WindowInfoEx[$iIndex][7] - $aClientSize[0], $aPos[3] + $__g_aSB_WindowInfoEx[$iIndex][8] - $aClientSize[1]]
WinMove($hWnd, "", Default, Default, $aMaxSize[0], $aMaxSize[1])
If Not $bFullClient Then
$__g_aSB_WindowInfo[0][1] = 0
$__g_aSB_WindowInfo[0][2] = 0
WinMove($hWnd, "", Default, Default, $aPos[2], $aPos[3])
$__g_aSB_WindowInfo[0][3] = $hWnd
$__g_aSB_WindowInfo[0][4] = $iIndex
_Scrollbars_WM_EXITSIZEMOVE($hWnd, 0, 0, 0)
EndIf
If $bRegisterMsg Then
GUIRegisterMsg($WM_EXITSIZEMOVE, "_Scrollbars_WM_EXITSIZEMOVE")
GUIRegisterMsg($WM_ENTERSIZEMOVE, "_Scrollbars_WM_ENTERSIZEMOVE")
EndIf
Return $aMaxSize
EndFunc
Func _GUIScrollbars_Locate_Ctrl($hWnd, $iX, $iY)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex = -1 Then Return SetError(3, 0, 0)
If $iX < 0 Or $iX > $__g_aSB_WindowInfoEx[$iIndex][0] Then Return SetError(2, 0, 0)
If $iY < 0 Or $iY > $__g_aSB_WindowInfoEx[$iIndex][1] Then Return SetError(2, 0, 0)
If Not $__g_aSB_WindowInfoEx[$iIndex][4] Then
$iX *= $__g_aSB_WindowInfoEx[$iIndex][2]
$iY *= $__g_aSB_WindowInfoEx[$iIndex][3]
EndIf
$iX -= _GUIScrollBars_GetScrollInfoPos($hWnd, $SB_HORZ) * $__g_aSB_WindowInfo[$iIndex][2]
$iY -= _GUIScrollBars_GetScrollInfoPos($hWnd, $SB_VERT) * $__g_aSB_WindowInfo[$iIndex][3]
Local $aRet[2] = [$iX, $iY]
Return $aRet
EndFunc
Func _GUIScrollbars_Scroll_Page($hWnd, $iH_Scroll_Pos = 0, $iV_Scroll_Pos = 0)
Local $iPos
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not (IsInt($iH_Scroll_Pos) And IsInt($iV_Scroll_Pos)) Then Return SetError(3, 0, 0)
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex = -1 Then Return SetError(2, 0, 0)
Local $iH_Page = Floor($__g_aSB_WindowInfo[$iIndex][4] / $__g_aSB_WindowInfo[$iIndex][2])
Local $iV_Page = Floor($__g_aSB_WindowInfo[$iIndex][5] / $__g_aSB_WindowInfo[$iIndex][3])
If $iH_Scroll_Pos > 0 Then
$iPos = ($iH_Scroll_Pos - 1) * $iH_Page
If $iPos > $__g_aSB_WindowInfo[$iIndex][6] Then $iPos = $__g_aSB_WindowInfo[$iIndex][6]
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, $iPos)
EndIf
If $iV_Scroll_Pos > 0 Then
$iPos = ($iV_Scroll_Pos - 1) * $iV_Page
If $iPos > $__g_aSB_WindowInfo[$iIndex][7] Then $iPos = $__g_aSB_WindowInfo[$iIndex][7]
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, $iPos)
EndIf
EndFunc
Func _GUIScrollbars_Minimize($hWnd)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex = -1 Then Return SetError(1, 0, 0)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, True)
$__g_aSB_WindowInfo[$iIndex][8] = _GUIScrollBars_GetScrollPos($hWnd, $SB_VERT)
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, 0)
$__g_aSB_WindowInfo[$iIndex][9] = _GUIScrollBars_GetScrollPos($hWnd, $SB_HORZ)
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, 0)
EndFunc
Func _GUIScrollbars_Restore($hWnd, $fVert = True, $fHorz = True)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex = -1 Then Return SetError(2, 0, 0)
If Not $fVert Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_VERT, False)
EndIf
If Not $fHorz Then
_GUIScrollBars_ShowScrollBar($hWnd, $SB_HORZ, False)
EndIf
If $fVert Then
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, $__g_aSB_WindowInfo[$iIndex][8])
EndIf
If $fHorz Then
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, $__g_aSB_WindowInfo[$iIndex][9])
EndIf
EndFunc
Func _Scrollbars_WM_VSCROLL($hWnd, $iMsg, $wParam, $lParam)
#forceref $iMsg, $wParam, $lParam
Local $nScrollCode = BitAND($wParam, 0x0000FFFF)
Local $iIndex = -1, $yChar, $yPos
Local $Min, $Max, $Page, $Pos, $TrackPos
For $x = 0 To UBound($__g_aSB_WindowInfo) - 1
If $__g_aSB_WindowInfo[$x][0] = $hWnd Then
$iIndex = $x
$yChar = $__g_aSB_WindowInfo[$iIndex][3]
ExitLoop
EndIf
Next
If $iIndex = -1 Then Return $GUI_RUNDEFMSG
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $SB_VERT)
$Min = DllStructGetData($tSCROLLINFO, "nMin")
$Max = DllStructGetData($tSCROLLINFO, "nMax")
$Page = DllStructGetData($tSCROLLINFO, "nPage")
$yPos = DllStructGetData($tSCROLLINFO, "nPos")
$Pos = $yPos
$TrackPos = DllStructGetData($tSCROLLINFO, "nTrackPos")
Switch $nScrollCode
Case $SB_TOP
DllStructSetData($tSCROLLINFO, "nPos", $Min)
Case $SB_BOTTOM
DllStructSetData($tSCROLLINFO, "nPos", $Max)
Case $SB_LINEUP
DllStructSetData($tSCROLLINFO, "nPos", $Pos - 1)
Case $SB_LINEDOWN
DllStructSetData($tSCROLLINFO, "nPos", $Pos + 1)
Case $SB_PAGEUP
DllStructSetData($tSCROLLINFO, "nPos", $Pos - $Page)
Case $SB_PAGEDOWN
DllStructSetData($tSCROLLINFO, "nPos", $Pos + $Page)
Case $SB_THUMBTRACK
DllStructSetData($tSCROLLINFO, "nPos", $TrackPos)
EndSwitch
DllStructSetData($tSCROLLINFO, "fMask", $SIF_POS)
_GUIScrollBars_SetScrollInfo($hWnd, $SB_VERT, $tSCROLLINFO)
_GUIScrollBars_GetScrollInfo($hWnd, $SB_VERT, $tSCROLLINFO)
$Pos = DllStructGetData($tSCROLLINFO, "nPos")
If ($Pos <> $yPos) Then
_GUIScrollBars_ScrollWindow($hWnd, 0, $yChar * ($yPos - $Pos))
$yPos = $Pos
EndIf
Return 0
EndFunc
Func _Scrollbars_WM_HSCROLL($hWnd, $iMsg, $wParam, $lParam)
#forceref $iMsg, $lParam
Local $nScrollCode = BitAND($wParam, 0x0000FFFF)
Local $iIndex = -1, $xChar, $xPos
Local $Page, $Pos, $TrackPos
For $x = 0 To UBound($__g_aSB_WindowInfo) - 1
If $__g_aSB_WindowInfo[$x][0] = $hWnd Then
$iIndex = $x
$xChar = $__g_aSB_WindowInfo[$iIndex][2]
ExitLoop
EndIf
Next
If $iIndex = -1 Then Return $GUI_RUNDEFMSG
Local $tSCROLLINFO = _GUIScrollBars_GetScrollInfoEx($hWnd, $SB_HORZ)
$Page = DllStructGetData($tSCROLLINFO, "nPage")
$xPos = DllStructGetData($tSCROLLINFO, "nPos")
$Pos = $xPos
$TrackPos = DllStructGetData($tSCROLLINFO, "nTrackPos")
Switch $nScrollCode
Case $SB_LINELEFT
DllStructSetData($tSCROLLINFO, "nPos", $Pos - 1)
Case $SB_LINERIGHT
DllStructSetData($tSCROLLINFO, "nPos", $Pos + 1)
Case $SB_PAGELEFT
DllStructSetData($tSCROLLINFO, "nPos", $Pos - $Page)
Case $SB_PAGERIGHT
DllStructSetData($tSCROLLINFO, "nPos", $Pos + $Page)
Case $SB_THUMBTRACK
DllStructSetData($tSCROLLINFO, "nPos", $TrackPos)
EndSwitch
DllStructSetData($tSCROLLINFO, "fMask", $SIF_POS)
_GUIScrollBars_SetScrollInfo($hWnd, $SB_HORZ, $tSCROLLINFO)
_GUIScrollBars_GetScrollInfo($hWnd, $SB_HORZ, $tSCROLLINFO)
$Pos = DllStructGetData($tSCROLLINFO, "nPos")
If ($Pos <> $xPos) Then _GUIScrollBars_ScrollWindow($hWnd, $xChar * ($xPos - $Pos), 0)
Return 0
EndFunc
Func _Scrollbars_WM_MOUSEWHEEL($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $lParam
Local $iDirn, $iDelta = BitShift($wParam, 16)
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex <> -1 Then
If BitAND($wParam, 0x0000FFFF) Then
$iDirn = $SB_LINERIGHT
If $iDelta > 0 Then $iDirn = $SB_LINELEFT
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][6]
_SendMessage($hWnd, $WM_HSCROLL, $iDirn)
Next
Else
$iDirn = $SB_LINEDOWN
If $iDelta > 0 Then $iDirn = $SB_LINEUP
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][6]
_SendMessage($hWnd, $WM_VSCROLL, $iDirn)
Next
EndIf
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func _Scrollbars_WM_MOUSEHWHEEL($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $lParam
Local $iDirn = $SB_LINERIGHT
If BitShift($wParam, 16) > 0 Then $iDirn = $SB_LINELEFT
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex <> -1 Then
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_HSCROLL, $iDirn)
Next
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func _Scrollbars_WM_KEYUP($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $lParam
Local $aRet_Ctrl
Local $iIndex = -1
For $i = 0 To UBound($__g_aSB_WindowInfo) - 1
If $hWnd = $__g_aSB_WindowInfo[$i][0] Then $iIndex = $i
Next
If $iIndex <> -1 Then
Local $bCtrl = False
$aRet_Ctrl = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", "0x11")
If $aRet_Ctrl[0] Then $bCtrl = True
Switch $wParam
Case 0x21
If $bCtrl Then
_SendMessage($hWnd, $WM_HSCROLL, $SB_PAGELEFT)
Else
_SendMessage($hWnd, $WM_VSCROLL, $SB_PAGEUP)
EndIf
Case 0x22
If $bCtrl Then
_SendMessage($hWnd, $WM_HSCROLL, $SB_PAGERIGHT)
Else
_SendMessage($hWnd, $WM_VSCROLL, $SB_PAGEDOWN)
EndIf
Case 0x23
If $bCtrl Then
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, $__g_aSB_WindowInfo[$iIndex][6])
Else
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, $__g_aSB_WindowInfo[$iIndex][7])
EndIf
Case 0x24
If $bCtrl Then
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, 0)
Else
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, 0)
EndIf
Case 0x25
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_HSCROLL, $SB_LINELEFT)
Next
Case 0x26
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_VSCROLL, $SB_LINEUP)
Next
Case 0x27
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_HSCROLL, $SB_LINERIGHT)
Next
Case 0x28
For $i = 1 To $__g_aSB_WindowInfoEx[$iIndex][5]
_SendMessage($hWnd, $WM_VSCROLL, $SB_LINEDOWN)
Next
EndSwitch
EndIf
Return $GUI_RUNDEFMSG
EndFunc
Func _Scrollbars_WM_ENTERSIZEMOVE($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam, $lParam
For $iIndex = 1 To $__g_aSB_WindowInfo[0][0]
If $hWnd = $__g_aSB_WindowInfo[$iIndex][0] Then
$__g_aSB_WindowInfo[0][1] = _GUIScrollBars_GetScrollInfoPos($hWnd, $SB_HORZ)
$__g_aSB_WindowInfo[0][2] = _GUIScrollBars_GetScrollInfoPos($hWnd, $SB_VERT)
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, 0)
_GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, 0)
_GUIScrollBars_ShowScrollBar($hWnd, $SB_BOTH, False)
$__g_aSB_WindowInfo[0][3] = $hWnd
$__g_aSB_WindowInfo[0][4] = $iIndex
ExitLoop
EndIf
Next
EndFunc
Func _Scrollbars_WM_EXITSIZEMOVE($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam, $lParam
If $hWnd = $__g_aSB_WindowInfo[0][3] And $__g_aSB_WindowInfo[0][4] <> -1 Then
Local $iIndex = $__g_aSB_WindowInfo[0][4]
Local $aClientSize = WinGetClientSize($hWnd)
Local $iH_Aperture = 0, $iV_Aperture = 0, $iH_Reduction = 0, $iV_Reduction = 0
For $i = 1 To 2
If $aClientSize[0] < $__g_aSB_WindowInfoEx[$iIndex][7] + $iH_Reduction Then
$iH_Aperture = $__g_aSB_WindowInfoEx[$iIndex][7] + $iH_Reduction
$iV_Reduction = $__g_aSB_WindowInfo[0][6]
EndIf
If $aClientSize[1] < $__g_aSB_WindowInfoEx[$iIndex][8] + $iV_Reduction Then
$iV_Aperture = $__g_aSB_WindowInfoEx[$iIndex][8] + $iV_Reduction
$iH_Reduction = $__g_aSB_WindowInfo[0][5]
EndIf
Next
_GUIScrollbars_Generate($hWnd, $iH_Aperture, $iV_Aperture)
If $iH_Aperture Then _GUIScrollBars_SetScrollInfoPos($hWnd, $SB_HORZ, $__g_aSB_WindowInfo[0][1])
If $iV_Aperture Then _GUIScrollBars_SetScrollInfoPos($hWnd, $SB_VERT, $__g_aSB_WindowInfo[0][2])
$__g_aSB_WindowInfo[0][1] = 0
$__g_aSB_WindowInfo[0][4] = -1
EndIf
EndFunc
